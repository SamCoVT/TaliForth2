; Dictionary Headers for Tali Forth 2
; Scot W. Stevenson <scot.stevenson@gmail.com>
; Updated by Sam Colwell
; First version: 05. Dec 2016 (Liara Forth)
; This version: 01. Jan 2023

; Dictionary headers are kept separately from the code, which allows various
; tricks in the code. We roughly follow the Gforth terminology: The Execution
; Token (xt) is the address of the first byte of a word's code that can be, uh,
; executed; the Name Token (nt) is a pointer to the beginning of the word's
; header in the Dictionary. There the link to the next word in the Dictionary
; is always one cell down from the current word's own nt. In the code itself,
; we use "nt_<WORD>" for the nt and "xt_<WORD>" for the xt.

; This gives us the following header structure:

;              8 bit     8 bit
;               LSB       MSB
; nt_word ->  +--------+--------+
;          +0 | Length | Status |
;             +--------+--------+
;          +2 | Next Header     | -> nt_next_word
;             +-----------------+
;          +4 | Start of Code   | -> xt_word
;             +-----------------+
;          +6 | End of Code     | -> z_word
;             +--------+--------+
;          +8 | Name   |        |
;             +--------+--------+
;             |        |        |
;             +--------+--------+
;             |        |  ...   | (name string does not end with a zero)
;          +n +--------+--------+

; The Status Byte is created by adding the flags defined in definitions.asm,
; which are:

;       CO - Compile Only
;       IM - Immediate Word
;       NN - Never Native Compile (must always be called by JSR)
;       AN - Always Native Compile (may not be called by JSR)
;       UF - Contains underflow check
;       HC - Has CFA (words created by CREATE and DOES> only)
;       ST - Uses stack manipulation stripped for native compile (R>, >R etc)

; Note there is currently one bit unused.

; By default, all existing words can be natively compiled (compiled inline) or
; as a subroutine jump target; the system decides which variant to use based on
; a threshold the user can set. By default, all user-created words are flagged
; never-native. The user can override this by using the always-native word
; just after defining their new word.  The NN flag forbids native compiling,
; the AN flag forces it.

; The last word (top word in code) is always BYE. It is marked as the last word
; by its value of 0000 in its Next Header field. The words are sorted with the
; more common ones first (further down in code) so they are found earlier.
; Anything to do with output comes later (further up) because things will
; always be slow if there is a human involved.

; The initial skeleton of this list was automatically generated by a script
; in the tools folder and then sorted by hand.

; The dhdr macro is used to generate the chain of dictionary entries.
; Most words use the convention that word NAME is implemented by code between
; xt_name and z_name. These dictionary entries are simply `#def_nt name`,
; adding optional flags like `#def_nt name, UF`.  Special names like M*/ can be
; defined using the optional third argument `#def_nt name, flags, "m*/"`.
; The final dictionary entry in each wordlist should specify last=true.

def_nt .macro label, flags=0, name="", last=false
    _s := \name ? \name : str(.\label)

;TODO    .cwarn z_\label - xt_\label > 255, format("%s len %d", str(.\label), z_\label - xt_\label)
    .byte len(_s), \flags
    .word \last ? 0 : +, xt_\label, z_\label
    .text _s
.if !\last
+
.endif
.endmacro


; FORTH-WORDLIST

dictionary_start:

#def_nt drop,           UF              ; DROP is always the first native word in the Dictionary
#def_nt dup,            UF
#def_nt swap,           UF
#def_nt store,          UF, "!"
#def_nt fetch,          UF, "@"
#def_nt over,           UF
#def_nt to_r,           CO+UF+ST, ">r"
#def_nt r_from,         CO+ST, "r>"
#def_nt r_fetch,        CO+ST, "r@"
#def_nt nip,            UF
#def_nt rot,            UF
#def_nt not_rot,        UF, "-rot"
#def_nt tuck,           UF
#def_nt comma,          UF, ","
#def_nt c_fetch,        UF, "c@"
#def_nt c_store,        UF, "c!"
#def_nt plus_store,     UF, "+!"
#def_nt zero,           , "0"
#def_nt one,            , "1"
#def_nt two,            , "2"
#def_nt execute,        UF
#def_nt emit,           NN+UF
#def_nt type,           UF
#def_nt dot,            UF, "."
#def_nt u_dot,          UF, "u."
#def_nt u_dot_r,        UF, "u.r"
#def_nt dot_r,          UF, ".r"
#def_nt d_dot,          UF, "d."
#def_nt d_dot_r,        UF, "d.r"
#def_nt m_star_slash,   UF, "m*/"
#def_nt ud_dot,         UF, "ud."
#def_nt ud_dot_r,       UF, "ud.r"
#def_nt question,       UF, "?"
#def_nt false,          , "false"
#def_nt true,           , "true"
#def_nt space
#def_nt two_dup,        UF, "2dup"
#def_nt question_dup,   UF, "?dup"
#def_nt plus,           UF, "+"
#def_nt minus,          UF, "-"
#def_nt one_minus,      UF, "1-"
#def_nt one_plus,       UF, "1+"
#def_nt two_star,       UF, "2*"
#def_nt two_slash,      UF, "2/"
#def_nt abs,            UF
#def_nt dabs,           UF
#def_nt and,            UF
#def_nt or,             UF
#def_nt xor,            UF
#def_nt rshift,         UF
#def_nt lshift,         UF
#def_nt pick                            ; underflow check is complicated, leave off here
#def_nt char
#def_nt bracket_char,   CO+IM, "[char]"
#def_nt char_plus,      , "char+"
#def_nt chars,          UF              ; becomes no-op when underflow stripped
#def_nt cells                           ; same as 2*
#def_nt cell_plus,      UF, "cell+"
#def_nt here
#def_nt equal,          UF, "="
#def_nt not_equals,     UF, "<>"
#def_nt less_than,      UF, "<"
#def_nt u_less_than,    UF, "u<"
#def_nt u_greater_than, UF, "u>"
#def_nt greater_than,   UF, ">"
#def_nt zero_equal,     UF, "0="
#def_nt zero_unequal,   UF, "0<>"
#def_nt zero_greater,   UF, "0>"
#def_nt zero_less,      UF, "0<"
#def_nt min,            UF
#def_nt max,            UF
#def_nt two_drop,       UF, "2drop"
#def_nt two_swap,       UF, "2swap"
#def_nt two_over,       UF, "2over"
#def_nt two_store,      UF, "2!"
#def_nt two_fetch,      UF, "2@"
#def_nt two_variable,   , "2variable"
#def_nt two_constant,   UF, "2constant"
#def_nt two_literal,    UF+IM, "2literal"
#def_nt two_r_fetch,    CO+NN+ST, "2r@"
#def_nt two_r_from,     CO+ST, "2r>"
#def_nt two_to_r,       CO+UF+ST, "2>r"
#def_nt invert,         UF
#def_nt negate,         UF
#def_nt dnegate,        UF
#def_nt c_comma,        UF, "c,"
#def_nt bounds,         UF
#def_nt spaces,         UF
#def_nt bl
#def_nt minus_trailing, UF, "-trailing"
#def_nt minus_leading,  UF, "-leading"
#def_nt slash_string,   UF, "/string"
#def_nt refill
#def_nt accept,         UF+NN
#def_nt input_to_r,     NN, "input>r"
#def_nt r_to_input,     NN, "r>input"
#def_nt unused
#def_nt depth
#def_nt key
#def_nt keyq,           , "key?"
#def_nt allot,          UF
#def_nt create
#def_nt does,           CO+IM, "does>"
#def_nt variable
#def_nt constant,       UF
#def_nt value,          UF              ; same code as CONSTANT
#def_nt to,             NN+IM
#def_nt s_to_d,         UF, "s>d"
#def_nt d_to_s,         UF, "d>s"
#def_nt d_minus,        UF, "d-"
#def_nt d_plus,         UF, "d+"
#def_nt erase,          UF
#def_nt blank,          UF
#def_nt fill,           UF
#def_nt find_name,      UF, "find-name"
#def_nt tick,           , "'"
#def_nt bracket_tick,   CO+IM, "[']"
#def_nt name_to_int,    UF, "name>int"
#def_nt int_to_name,    UF, "int>name"
#def_nt name_to_string, UF, "name>string"
#def_nt to_body,        UF, ">body"
#def_nt defer
#def_nt latestxt
#def_nt latestnt
#def_nt parse_name,     NN, "parse-name"
#def_nt parse,          UF
#def_nt execute_parsing, UF, "execute-parsing"
#def_nt source
#def_nt source_id,      , "source-id"
#def_nt colon,          , ":"
#def_nt semicolon,      CO+IM, ";"
#def_nt colon_noname,   , ":noname"
#def_nt compile_comma,  UF+NN, "compile,"
#def_nt left_bracket,   IM+CO, "["
#def_nt right_bracket,  IM, "]"
#def_nt literal,        IM+CO+UF, "literal"
#def_nt sliteral,       CO+IM+UF, "sliteral"
#def_nt dot_quote,      CO+IM, '."'
#def_nt s_quote,        IM+NN, 's"'
#def_nt s_backslash_quote, IM, 's\"'
#def_nt postpone,       IM+CO, "postpone"
#def_nt immediate
#def_nt compile_only,   , "compile-only"
#def_nt never_native,   , "never-native"
#def_nt always_native,  , "always-native"
#def_nt allow_native,   , "allow-native"
#def_nt nc_limit,       NN, "nc-limit"
#def_nt strip_underflow, NN, "strip-underflow"
#def_nt abort
#def_nt abort_quote,    CO+IM+NN, 'abort"'
#def_nt do,             CO+IM+NN
#def_nt question_do,    CO+IM+NN, "?do"
#def_nt i,              CO
#def_nt j,              CO
#def_nt loop,           CO+IM
#def_nt plus_loop,      CO+IM, "+loop"
#def_nt exit,           AN+CO
#def_nt unloop,         CO
#def_nt leave,          CO+IM
#def_nt recurse,        CO+IM+NN
#def_nt quit
#def_nt begin,          CO+IM
#def_nt again,          CO+IM+UF
#def_nt state
#def_nt evaluate,       UF
#def_nt base
#def_nt digit_question, UF, "digit?"
#def_nt number,         UF
#def_nt to_number,      UF, ">number"
#def_nt hex
#def_nt decimal
#def_nt count,          UF
#def_nt m_star,         UF, "m*"
#def_nt um_star,        UF, "um*"
#def_nt star,           UF, "*"
#def_nt um_slash_mod,   UF, "um/mod"
#def_nt sm_slash_rem,   UF, "sm/rem"
#def_nt fm_slash_mod,   UF, "fm/mod"
#def_nt slash,          UF, "/"
#def_nt slash_mod,      UF, "/mod"
#def_nt mod,            UF
#def_nt star_slash_mod, UF, "*/mod"
#def_nt star_slash,     UF, "*/"
#def_nt backslash,      IM, "\"
#def_nt move,           NN+UF
#def_nt cmove_up,       UF, "cmove>"
#def_nt cmove,          UF
#def_nt pad
#def_nt cleave,         UF
#def_nt hexstore,       UF
#def_nt within,         UF
#def_nt to_in,          , ">in"
#def_nt less_number_sign, , "<#"
#def_nt number_sign,    UF, "#"
#def_nt number_sign_s,  UF, "#s"
#def_nt number_sign_greater, UF, "#>"
#def_nt hold,           UF
#def_nt sign,           UF
#def_nt output
#def_nt input
#def_nt havekey
#def_nt cr
#def_nt page
#def_nt at_xy,          UF, "at-xy"
#def_nt marker,         IM
#def_nt words
#def_nt wordsize,       UF
#def_nt aligned                           ; same code as ALIGN
#def_nt align
#def_nt bell
#def_nt dump,           UF
#def_nt dot_s,          , ".s"

.if "disassembler" in TALI_OPTIONAL_WORDS
#def_nt disasm,         UF
.endif

#def_nt compare,        UF
#def_nt search,         UF+NN

.if "environment?" in TALI_OPTIONAL_WORDS
#def_nt environment_q,  UF, "environment?"
.endif

#def_nt find,           UF
#def_nt word,           UF
#def_nt paren,          IM, "("
#def_nt dot_paren,      IM, ".("
#def_nt if,             IM+CO+NN
#def_nt then,           UF+IM+CO+NN
#def_nt else,           UF+IM+CO+NN
#def_nt repeat,         UF+IM+CO+NN
#def_nt until,          UF+IM+CO+NN
#def_nt while,          UF+IM+CO+NN
#def_nt case,           IM+CO+NN        ; shares code with ZERO
#def_nt of,             IM+CO+NN
#def_nt endof,          UF+IM+CO+NN
#def_nt endcase,        UF+IM+CO+NN
#def_nt defer_fetch,    UF, "defer@"
#def_nt defer_store,    UF, "defer!"
#def_nt is,             IM
#def_nt action_of,      IM, "action-of"
#def_nt useraddr,       , "useraddr"
#def_nt buffer_colon,   UF, "buffer:"

.if "block" in TALI_OPTIONAL_WORDS
#def_nt buffstatus
#def_nt buffblocknum
#def_nt blkbuffer
#def_nt scr,            NN
#def_nt blk,            NN
;TODO these mention HC but don't have the flag?
#def_nt block_write,    UF+NN, "block-write"    ; Deferred words need the HC (Code Field) flag.
#def_nt block_write_vector, NN, "block-write-vector" ; Deferred words need the HC (Code Field) flag.
#def_nt block_read,     UF+HC+NN, "block-read"  ; Deferred words need the HC (Code Field) flag.
#def_nt block_read_vector, HC+NN, "block-read-vector" ; Deferred words need the HC (Code Field) flag.
#def_nt save_buffers,   , "save-buffers"
#def_nt block,          UF
#def_nt update
#def_nt buffer,         UF
#def_nt empty_buffers,  , "empty-buffers"
#def_nt flush
#def_nt load,           UF
#def_nt thru,           UF

.if "editor" in TALI_OPTIONAL_WORDS
#def_nt list,           UF
#def_nt block_c65_init, , "block-c65-init"
.endif

.endif

.if "block" in TALI_OPTIONAL_WORDS && "ramdrive" in TALI_OPTIONAL_WORDS
#def_nt block_ramdrive_init, UF, "block-ramdrive-init"
.endif

.if "wordlist" in TALI_OPTIONAL_WORDS
#def_nt definitions
#def_nt wordlist
#def_nt search_wordlist, UF, "search-wordlist"
#def_nt set_current,    UF, "set-current"
#def_nt get_current,    , "get-current"
#def_nt set_order,      , "set-order"
#def_nt get_order,      , "get-order"
#def_nt root_wordlist,  , "root-wordlist"
.endif

.if "assembler" in TALI_OPTIONAL_WORDS && "wordlist" in TALI_OPTIONAL_WORDS
#def_nt assembler_wordlist, , "assembler-wordlist"
.endif

.if "editor" in TALI_OPTIONAL_WORDS && "wordlist" in TALI_OPTIONAL_WORDS
#def_nt editor_wordlist, , "editor-wordlist"
.endif

.if "wordlist" in TALI_OPTIONAL_WORDS
#def_nt forth_wordlist, , "forth-wordlist"
#def_nt only
#def_nt also
#def_nt previous
#def_nt to_order,       UF, ">order"
#def_nt order
#def_nt forth
.endif

#def_nt see,            NN

.if "ed" in TALI_OPTIONAL_WORDS
#def_nt ed,             NN, "ed:"       ; ed6502
.endif

#def_nt cold
#def_nt bye,            , , true        ; true flags last word in the wordlist

; END of FORTH-WORDLIST


; ROOT-WORDLIST
        ; This is a short wordlist that has just the words needed to
        ; set the wordlists. These words are also included in the
        ; FORTH-WORDLIST as well.

root_dictionary_start:
.if "wordlist" in TALI_OPTIONAL_WORDS
#def_nt set_order,      , "set-order"
#def_nt forth
#def_nt forth_wordlist, , "forth-wordlist"   ; shares code with ZERO
#def_nt words,          , , true
.endif
; END of ROOT-WORDLIST


; EDITOR-WORDLIST

editor_dictionary_start:
.if "editor" in TALI_OPTIONAL_WORDS && "block" in TALI_OPTIONAL_WORDS
#def_nt editor_o,       UF, "o"
#def_nt editor_line,    UF, "line"
#def_nt editor_l,       , "l"
#def_nt editor_el,      , "el"
#def_nt editor_erase_screen, , "erase-screen"
#def_nt editor_enter_screen, , "enter-screen", true
.endif
; END of EDITOR-WORDLIST


; ASSEMBLER-WORDLIST

; Labels for the opcodes have the format "nt_asm_<OPC>" where a futher
; underscore replaces any dot present in the SAN mnemonic. The hash sign for
; immediate addressing is replaced by an "h" (for example, the label code for
; "lda.#" is "xt_adm_lda_h"). All opcodes are immediate.
assembler_dictionary_start:
.if "assembler" in TALI_OPTIONAL_WORDS
#def_nt asm_adc_h,      IM+NN, "adc.#"
#def_nt asm_adc_x,      IM+NN, "adc.x"
#def_nt asm_adc_y,      IM+NN, "adc.y"
#def_nt asm_adc_z,      IM+NN, "adc.z"
#def_nt asm_adc_zi,     IM+NN, "adc.zi"
#def_nt asm_adc_ziy,    IM+NN, "adc.ziy"
#def_nt asm_adc_zx,     IM+NN, "adc.zx"
#def_nt asm_adc_zxi,    IM+NN, "adc.zxi"
#def_nt asm_and,        IM+NN, "and."   ; not "and" because of conflicts with Forth word
#def_nt asm_and_h,      IM+NN, "and.#"
#def_nt asm_and_x,      IM+NN, "and.x"
#def_nt asm_and_y,      IM+NN, "and.y"
#def_nt asm_and_z,      IM+NN, "and.z"
#def_nt asm_and_zi,     IM+NN, "and.zi"
#def_nt asm_and_ziy,    IM+NN, "and.ziy"
#def_nt asm_and_zx,     IM+NN, "and.zx"
#def_nt asm_and_zxi,    IM+NN, "and.zxi"
#def_nt asm_asl,        IM+NN, "asl"
#def_nt asm_asl_a,      IM+NN, "asl.a"
#def_nt asm_asl_x,      IM+NN, "asl.x"
#def_nt asm_asl_z,      IM+NN, "asl.z"
#def_nt asm_asl_zx,     IM+NN, "asl.zx"
#def_nt asm_bcc,        IM+NN, "bcc"
#def_nt asm_bcs,        IM+NN, "bcs"
#def_nt asm_beq,        IM+NN, "beq"
#def_nt asm_bit,        IM+NN, "bit"
#def_nt asm_bit_h,      IM+NN, "bit.#"
#def_nt asm_bit_x,      IM+NN, "bit.x"
#def_nt asm_bit_z,      IM+NN, "bit.z"
#def_nt asm_bit_zx,     IM+NN, "bit.zx"
#def_nt asm_bmi,        IM+NN, "bmi"
#def_nt asm_bne,        IM+NN, "bne"
#def_nt asm_bpl,        IM+NN, "bpl"
#def_nt asm_bra,        IM+NN, "bra"
#def_nt asm_brk,        IM+NN, "brk"
#def_nt asm_bvc,        IM+NN, "bvc"
#def_nt asm_bvs,        IM+NN, "bvs"
#def_nt asm_clc,        IM+NN, "clc"
#def_nt asm_cld,        IM+NN, "cld"
#def_nt asm_cli,        IM+NN, "cli"
#def_nt asm_clv,        IM+NN, "clv"
#def_nt asm_cmp,        IM+NN, "cmp"
#def_nt asm_cmp_h,      IM+NN, "cmp.#"
#def_nt asm_cmp_x,      IM+NN, "cmp.x"
#def_nt asm_cmp_y,      IM+NN, "cmp.y"
#def_nt asm_cmp_z,      IM+NN, "cmp.z"
#def_nt asm_cmp_zi,     IM+NN, "cmp.zi"
#def_nt asm_cmp_ziy,    IM+NN, "cmp.ziy"
#def_nt asm_cmp_zx,     IM+NN, "cmp.zx"
#def_nt asm_cmp_zxi,    IM+NN, "cmp.zxi"
#def_nt asm_cpx,        IM+NN, "cpx"
#def_nt asm_cpx_h,      IM+NN, "cpx.#"
#def_nt asm_cpx_z,      IM+NN, "cpx.z"
#def_nt asm_cpy,        IM+NN, "cpy"
#def_nt asm_cpy_h,      IM+NN, "cpy.#"
#def_nt asm_cpy_z,      IM+NN, "cpy.z"
#def_nt asm_dec,        IM+NN, "dec"
#def_nt asm_dec_a,      IM+NN, "dec.a"
#def_nt asm_dec_x,      IM+NN, "dec.x"
#def_nt asm_dec_z,      IM+NN, "dec.z"
#def_nt asm_dec_zx,     IM+NN, "dec.zx"
#def_nt asm_dex,        IM+NN, "dex"
#def_nt asm_dey,        IM+NN, "dey"
#def_nt asm_eor,        IM+NN, "eor"
#def_nt asm_eor_h,      IM+NN, "eor.#"
#def_nt asm_eor_x,      IM+NN, "eor.x"
#def_nt asm_eor_y,      IM+NN, "eor.y"
#def_nt asm_eor_z,      IM+NN, "eor.z"
#def_nt asm_eor_zi,     IM+NN, "eor.zi"
#def_nt asm_eor_ziy,    IM+NN, "eor.ziy"
#def_nt asm_eor_zx,     IM+NN, "eor.zx"
#def_nt asm_eor_zxi,    IM+NN, "eor.zxi"
#def_nt asm_inc,        IM+NN, "inc"
#def_nt asm_inc_a,      IM+NN, "inc.a"
#def_nt asm_inc_x,      IM+NN, "inc.x"
#def_nt asm_inc_z,      IM+NN, "inc.z"
#def_nt asm_inc_zx,     IM+NN, "inc.zx"
#def_nt asm_inx,        IM+NN, "inx"
#def_nt asm_iny,        IM+NN, "iny"
#def_nt asm_jmp,        IM+NN, "jmp"
#def_nt asm_jmp_i,      IM+NN, "jmp.i"
#def_nt asm_jmp_xi,     IM+NN, "jmp.xi"
#def_nt asm_jsr,        IM+NN, "jsr"
#def_nt asm_lda,        IM+NN, "lda"
#def_nt asm_lda_h,      IM+NN, "lda.#"
#def_nt asm_lda_x,      IM+NN, "lda.x"
#def_nt asm_lda_y,      IM+NN, "lda.y"
#def_nt asm_lda_z,      IM+NN, "lda.z"
#def_nt asm_lda_zi,     IM+NN, "lda.zi"
#def_nt asm_lda_ziy,    IM+NN, "lda.ziy"
#def_nt asm_lda_zx,     IM+NN, "lda.zx"
#def_nt asm_lda_zxi,    IM+NN, "lda.zxi"
#def_nt asm_ldx,        IM+NN, "ldx"
#def_nt asm_ldx_h,      IM+NN, "ldx.#"
#def_nt asm_ldx_y,      IM+NN, "ldx.y"
#def_nt asm_ldx_z,      IM+NN, "ldx.z"
#def_nt asm_ldx_zy,     IM+NN, "ldx.zy"
#def_nt asm_ldy,        IM+NN, "ldy"
#def_nt asm_ldy_h,      IM+NN, "ldy.#"
#def_nt asm_ldy_x,      IM+NN, "ldy.x"
#def_nt asm_ldy_z,      IM+NN, "ldy.z"
#def_nt asm_ldy_zx,     IM+NN, "ldy.zx"
#def_nt asm_lsr,        IM+NN, "lsr"
#def_nt asm_lsr_a,      IM+NN, "lsr.a"
#def_nt asm_lsr_x,      IM+NN, "lsr.x"
#def_nt asm_lsr_z,      IM+NN, "lsr.z"
#def_nt asm_lsr_zx,     IM+NN, "lsr.zx"
#def_nt asm_nop,        IM+NN, "nop"
#def_nt asm_ora,        IM+NN, "ora"
#def_nt asm_ora_h,      IM+NN, "ora.#"
#def_nt asm_ora_x,      IM+NN, "ora.x"
#def_nt asm_ora_y,      IM+NN, "ora.y"
#def_nt asm_ora_z,      IM+NN, "ora.z"
#def_nt asm_ora_zi,     IM+NN, "ora.zi"
#def_nt asm_ora_ziy,    IM+NN, "ora.ziy"
#def_nt asm_ora_zx,     IM+NN, "ora.zx"
#def_nt asm_ora_zxi,    IM+NN, "ora.zxi"
#def_nt asm_pha,        IM+NN, "pha"
#def_nt asm_php,        IM+NN, "php"
#def_nt asm_phx,        IM+NN, "phx"
#def_nt asm_phy,        IM+NN, "phy"
#def_nt asm_pla,        IM+NN, "pla"
#def_nt asm_plp,        IM+NN, "plp"
#def_nt asm_plx,        IM+NN, "plx"
#def_nt asm_ply,        IM+NN, "ply"
#def_nt asm_rol,        IM+NN, "rol"
#def_nt asm_rol_a,      IM+NN, "rol.a"
#def_nt asm_rol_x,      IM+NN, "rol.x"
#def_nt asm_rol_z,      IM+NN, "rol.z"
#def_nt asm_rol_zx,     IM+NN, "rol.zx"
#def_nt asm_ror,        IM+NN, "ror"
#def_nt asm_ror_a,      IM+NN, "ror.a"
#def_nt asm_ror_x,      IM+NN, "ror.x"
#def_nt asm_ror_z,      IM+NN, "ror.z"
#def_nt asm_ror_zx,     IM+NN, "ror.zx"
#def_nt asm_rti,        IM+NN, "rti"
#def_nt asm_rts,        IM+NN, "rts"
#def_nt asm_sbc,        IM+NN, "sbc"
#def_nt asm_sbc_h,      IM+NN, "sbc.#"
#def_nt asm_sbc_x,      IM+NN, "sbc.x"
#def_nt asm_sbc_y,      IM+NN, "sbc.y"
#def_nt asm_sbc_z,      IM+NN, "sbc.z"
#def_nt asm_sbc_zi,     IM+NN, "sbc.zi"
#def_nt asm_sbc_ziy,    IM+NN, "sbc.ziy"
#def_nt asm_sbc_zx,     IM+NN, "sbc.zx"
#def_nt asm_sbc_zxi,    IM+NN, "sbc.zxi"
#def_nt asm_sec,        IM+NN, "sec"
#def_nt asm_sed,        IM+NN, "sed"
#def_nt asm_sei,        IM+NN, "sei"
#def_nt asm_sta,        IM+NN, "sta"
#def_nt asm_sta_x,      IM+NN, "sta.x"
#def_nt asm_sta_y,      IM+NN, "sta.y"
#def_nt asm_sta_z,      IM+NN, "sta.z"
#def_nt asm_sta_zi,     IM+NN, "sta.zi"
#def_nt asm_sta_ziy,    IM+NN, "sta.ziy"
#def_nt asm_sta_zx,     IM+NN, "sta.zx"
#def_nt asm_sta_zxi,    IM+NN, "sta.zxi"
#def_nt asm_stx,        IM+NN, "stx"
#def_nt asm_stx_z,      IM+NN, "stx.z"
#def_nt asm_stx_zy,     IM+NN, "stx.zy"
#def_nt asm_sty,        IM+NN,"sty"
#def_nt asm_sty_z,      IM+NN, "sty.z"
#def_nt asm_sty_zx,     IM+NN, "sty.zx"
#def_nt asm_stz,        IM+NN, "stz"
#def_nt asm_stz_x,      IM+NN, "stz.x"
#def_nt asm_stz_z,      IM+NN, "stz.z"
#def_nt asm_stz_zx,     IM+NN, "stz.zx"
#def_nt asm_tax,        IM+NN, "tax"
#def_nt asm_tay,        IM+NN, "tay"
#def_nt asm_trb,        IM+NN, "trb"
#def_nt asm_trb_z,      IM+NN, "trb.z"
#def_nt asm_tsb,        IM+NN, "tsb"
#def_nt asm_tsb_z,      IM+NN, "tsb.z"
#def_nt asm_tsx,        IM+NN, "tsx"
#def_nt asm_txa,        IM+NN, "txa"
#def_nt asm_txs,        IM+NN, "txs"
#def_nt asm_tya,        IM+NN, "tya"

; Assembler pseudo-instructions, directives and macros

#def_nt asm_arrow,      IM, "-->"       ; uses same code as HERE, but immediate
#def_nt asm_back_jump,  IM, "<j"        ; syntactic sugar, does nothing
#def_nt asm_back_branch, IM, "<b"
#def_nt asm_push_a,     IM+NN, "push-a", true

.endif
; END of ASSEMBLER-WORDLIST

; END
