; Dictionary Headers for Tali Forth 2
; Scot W. Stevenson <scot.stevenson@gmail.com>
; Updated by Sam Colwell
; First version: 05. Dec 2016 (Liara Forth)
; This version: 01. Jan 2023

; Dictionary headers are kept separately from the code, which allows various
; tricks in the code. We roughly follow the Gforth terminology: The Execution
; Token (xt) is the address of the first byte of a word's code that can be, uh,
; executed; the Name Token (nt) is a pointer to the beginning of the word's
; header in the Dictionary. There the link to the next word in the Dictionary
; is always one cell down from the current word's own nt. In the code itself,
; we use "nt_<WORD>" for the nt and "xt_<WORD>" for the xt.

; This gives us the following header structure:

;              8 bit     8 bit
;               LSB       MSB
; nt_word ->  +--------+--------+
;          +0 | Length | Status |
;             +--------+--------+
;          +2 | Next Header     | -> nt_next_word
;             +-----------------+
;          +4 | Start of Code   | -> xt_word
;             +-----------------+
;          +6 | End of Code     | -> z_word
;             +--------+--------+
;          +8 | Name   |        |
;             +--------+--------+
;             |        |        |
;             +--------+--------+
;             |        |  ...   | (name string does not end with a zero)
;          +n +--------+--------+

; The Status Byte is created by adding the flags defined in definitions.asm,
; which are:

;       CO - Compile Only
;       IM - Immediate Word
;       NN - Never Native Compile (must always be called by JSR)
;       AN - Always Native Compile (may not be called by JSR)
;       UF - Contains underflow check
;       HC - Has CFA (words created by CREATE and DOES> only)

; Note there are currently two bits unused.

; By default, all existing words can be natively compiled (compiled inline) or
; as a subroutine jump target; the system decides which variant to use based on
; a threshold the user can set. By default, all user-created words are flagged
; never-native. The user can override this by using the always-native word
; just after defining their new word.  The NN flag forbids native compiling,
; the AN flag forces it.

; The last word (top word in code) is always BYE. It is marked as the last word
; by its value of 0000 in its Next Header field. The words are sorted with the
; more common ones first (further down in code) so they are found earlier.
; Anything to do with output comes later (further up) because things will
; always be slow if there is a human involved.

; The initial skeleton of this list was automatically generated by a script
; in the tools folder and then sorted by hand.

; The dhdr macro is used to generate the chain of dictionary entries.
; Most words use the convention that word NAME is implemented by code between
; xt_name and z_name. These dictionary entries are simply `#dhdr name`,
; adding optional flags like `#dhdr name, UF`.  Special names like M*/ can be
; defined using the optional third argument `#dhdr name, flags, "m*/"`.
; The final dictionary entry in each wordlist should specify last=true.

dhdr .macro label, flags=0, name="", last=false
    _s := \name ? \name : str(.\label)

    .byte len(_s), \flags
    .word \last ? 0 : +, xt_\label, z_\label
    .text _s
.if !\last
+
.endif
.endmacro


; FORTH-WORDLIST

; DROP is always the first native word in the Dictionary
dictionary_start:

#dhdr drop,     UF
#dhdr dup,      UF
#dhdr swap,     UF
#dhdr store,    UF, "!"
#dhdr fetch,    UF, "@"
#dhdr over,     UF
#dhdr to_r,     CO+UF, ">r"     ; see strip_table
#dhdr r_from,   CO, "r>"        ; see strip_table
#dhdr r_fetch,  CO, "r@"        ; see strip_table
#dhdr nip,      UF
#dhdr rot,      UF
#dhdr not_rote, UF, "-rot"
#dhdr tuck,     UF
#dhdr comma,    UF, ","
#dhdr c_fetch,  UF, "c@"
#dhdr c_store,  UF, "c!"
#dhdr plus_store, UF, "+!"
#dhdr zero,     , "0"
#dhdr one,      , "1"
#dhdr two,      , "2"
#dhdr execute,  UF
#dhdr emit,     NN+UF
#dhdr type,     UF
#dhdr dot,      UF, "."
#dhdr u_dot,    UF, "u."
#dhdr u_dot_r,  UF, "u.r"
#dhdr dot_r,    UF, ".r"
#dhdr d_dot,    UF, "d."
#dhdr d_dot_r,  UF, "d.r"
#dhdr ud_dot,   UF, "ud."
#dhdr ud_dot_r, UF, "ud.r"
#dhdr question, , "?"
#dhdr false,    , "false"
#dhdr true,     , "true"
#dhdr space
#dhdr two_dup,  UF, "2dup"
#dhdr question_dup, UF, "?dup"
#dhdr plus,     UF, "+"
#dhdr minus,    UF, "-"
#dhdr one_minus, UF, "1-"
#dhdr one_plus, UF, "1+"
#dhdr two_star, UF, "2*"
#dhdr two_slash, UF, "2/"
#dhdr abs,      UF
#dhdr dabs,     UF
#dhdr and,      UF
#dhdr or,       UF
#dhdr xor,      UF
#dhdr rshift,   UF
#dhdr lshift,   UF
#dhdr pick                      ; underflow check is complicated, leave off here
#dhdr char
#dhdr bracket_char, CO+IM, "[char]"
#dhdr char_plus, , "char+"
#dhdr chars,    UF              ; becomes no-op when underflow stripped
#dhdr cells                     ; same as 2*
#dhdr cell_plus, UF, "cell+"
#dhdr here
#dhdr equal,            UF, "="
#dhdr not_equals,       UF, "<>"
#dhdr less_than,        UF, "<"
#dhdr u_less_than,      UF, "u<"
#dhdr u_greater_than,   UF, "u>"
#dhdr greater_than,     UF, ">"
#dhdr zero_equal,       UF, "0="
#dhdr zero_unequal,     UF, "0<>"
#dhdr zero_greater,     UF, "0>"
#dhdr zero_less,        UF, "0<"
#dhdr min,      UF
#dhdr max,      UF
#dhdr two_drop, UF, "2drop"
#dhdr two_swap, UF, "2swap"
#dhdr two_over, UF, "2over"
#dhdr two_store, UF, "2!"
#dhdr two_fetch, UF, "2@"
#dhdr two_variable, , "2variable"
#dhdr two_constant, UF, "2constant"
#dhdr two_literal, UF+IM, "2literal"
#dhdr two_r_fetch, CO+NN, "2r@"         ; see strip_table, leave NN for now
#dhdr two_r_from, CO, "2r>"             ; see strip_table
#dhdr two_to_r, CO+UF, "2>r"            ; see strip_table
#dhdr invert,   UF
#dhdr negate,   UF
#dhdr dnegate,  UF
#dhdr c_comma,  UF, "c,"
#dhdr bounds,   UF
#dhdr spaces,   UF
#dhdr bl
#dhdr minus_trailing, UF, "-trailing"
#dhdr minus_leading, UF, "-leading"
#dhdr slash_string, UF, "/string"
#dhdr refill
#dhdr accept,   UF+NN
#dhdr input_to_r, NN, "input>r"
#dhdr r_to_input, NN, "r>input"
#dhdr unused
#dhdr depth
#dhdr key
#dhdr allot,    UF
#dhdr create
#dhdr does,     CO+IM, "does>"
#dhdr variable
#dhdr constant, UF
#dhdr value,    UF                      ; same code as CONSTANT
#dhdr to,       NN+IM
#dhdr s_to_d,   UF, "s>d"
#dhdr d_to_s,   UF, "d>s"
#dhdr d_minus,  UF, "d-"
#dhdr d_plus,   UF, "d+"
#dhdr erase                             ; underflow checked by FILL
#dhdr blank                             ; underflow checked by FILL
#dhdr fill,     UF
#dhdr find_name, UF, "find-name"
#dhdr tick,     , "'"
#dhdr bracket_tick, CO+IM, "[']"

nt_name_to_int:
        .byte 8, UF
        .word nt_int_to_name, xt_name_to_int, z_name_to_int
        .text "name>int"

nt_int_to_name:
        .byte 8, UF
        .word nt_name_to_string, xt_int_to_name, z_int_to_name
        .text "int>name"

nt_name_to_string:
        .byte 11, UF
        .word nt_to_body, xt_name_to_string, z_name_to_string
        .text "name>string"

nt_to_body:
        .byte 5, UF
        .word nt_defer, xt_to_body, z_to_body
        .text ">body"

nt_defer:
        .byte 5, 0
        .word nt_latestxt, xt_defer, z_defer
        .text "defer"

nt_latestxt:
        .byte 8, 0
        .word nt_latestnt, xt_latestxt, z_latestxt
        .text "latestxt"

nt_latestnt:
        .byte 8, 0
        .word nt_parse_name, xt_latestnt, z_latestnt
        .text "latestnt"

nt_parse_name:
        .byte 10, NN
        .word nt_parse, xt_parse_name, z_parse_name
        .text "parse-name"

nt_parse:
        .byte 5, UF
        .word nt_execute_parsing, xt_parse, z_parse
        .text "parse"

nt_execute_parsing:
        .byte 15, UF
        .word nt_source, xt_execute_parsing, z_execute_parsing
        .text "execute-parsing"

nt_source:
        .byte 6, 0
        .word nt_source_id, xt_source, z_source
        .text "source"

nt_source_id:
        .byte 9, 0
        .word nt_colon, xt_source_id, z_source_id
        .text "source-id"

nt_colon:
        .byte 1, 0
        .word nt_semicolon, xt_colon, z_colon
        .text ":"

nt_semicolon:
        .byte 1, CO+IM
        .word nt_colon_noname, xt_semicolon, z_semicolon
        .text ";"

nt_colon_noname:
        .byte 7, 0
        .word nt_compile_comma, xt_colon_noname, z_colon_noname
        .text ":noname"

nt_compile_comma:
        .byte 8, UF+NN
        .word nt_left_bracket, xt_compile_comma, z_compile_comma
        .text "compile,"

nt_left_bracket:
        .byte 1, IM+CO
        .word nt_right_bracket, xt_left_bracket, z_left_bracket
        .text "["

nt_right_bracket:
        .byte 1, IM
        .word nt_literal, xt_right_bracket, z_right_bracket
        .text "]"

nt_literal:
        .byte 7, IM+CO+UF
        .word nt_sliteral, xt_literal, z_literal
        .text "literal"

nt_sliteral:
        .byte 8, CO+IM+UF
        .word nt_dot_quote, xt_sliteral, z_sliteral
        .text "sliteral"

nt_dot_quote:
        .byte 2, CO+IM
        .word nt_s_quote, xt_dot_quote, z_dot_quote
        .text ".", $22

nt_s_quote:
        .byte 2, IM+NN
        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
        .text "s", $22

nt_s_backslash_quote:
        .byte 3, IM
        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
        .text "s", $5C, $22

nt_postpone:
        .byte 8, IM+CO
        .word nt_immediate, xt_postpone, z_postpone
        .text "postpone"

nt_immediate:
        .byte 9, 0
        .word nt_compile_only, xt_immediate, z_immediate
        .text "immediate"

nt_compile_only:
        .byte 12, 0
        .word nt_never_native, xt_compile_only, z_compile_only
        .text "compile-only"

nt_never_native:
        .byte 12, 0
        .word nt_always_native, xt_never_native, z_never_native
        .text "never-native"

nt_always_native:
        .byte 13, 0
        .word nt_allow_native, xt_always_native, z_always_native
        .text "always-native"

nt_allow_native:
        .byte 12, 0
        .word nt_nc_limit, xt_allow_native, z_allow_native
        .text "allow-native"

nt_nc_limit:
        .byte 8, NN
        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
        .text "nc-limit"

nt_strip_underflow:
        .byte 15, NN
        .word nt_abort, xt_strip_underflow, z_strip_underflow
        .text "strip-underflow"

nt_abort:
        .byte 5, 0
        .word nt_abort_quote, xt_abort, z_abort
        .text "abort"

nt_abort_quote:
        .byte 6, CO+IM+NN
        .word nt_do, xt_abort_quote, z_abort_quote
        .text "abort", $22

nt_do:
        .byte 2, CO+IM+NN
        .word nt_question_do, xt_do, z_do
        .text "do"

nt_question_do:
        .byte 3, CO+IM+NN
        .word nt_i, xt_question_do, z_question_do
        .text "?do"

nt_i:
        .byte 1, CO
        .word nt_j, xt_i, z_i
        .text "i"

nt_j:
        .byte 1, CO
        .word nt_loop, xt_j, z_j
        .text "j"

nt_loop:
        .byte 4, CO+IM
        .word nt_plus_loop, xt_loop, z_loop
        .text "loop"

nt_plus_loop:
        .byte 5, CO+IM
        .word nt_exit, xt_plus_loop, z_plus_loop
        .text "+loop"

nt_exit:
        .byte 4, AN+CO
        .word nt_unloop, xt_exit, z_exit
        .text "exit"

nt_unloop:
        .byte 6, CO
        .word nt_leave, xt_unloop, z_unloop
        .text "unloop"

nt_leave:
        .byte 5, CO+IM
        .word nt_recurse, xt_leave, z_leave
        .text "leave"

nt_recurse:
        .byte 7, CO+IM+NN
        .word nt_quit, xt_recurse, z_recurse
        .text "recurse"

nt_quit:
        .byte 4, 0
        .word nt_begin, xt_quit, z_quit
        .text "quit"

nt_begin:
        .byte 5, CO+IM
        .word nt_again, xt_begin, z_begin
        .text "begin"

nt_again:
        .byte 5, CO+IM+UF
        .word nt_state, xt_again, z_again
        .text "again"

nt_state:
        .byte 5, 0
        .word nt_evaluate, xt_state, z_state
        .text "state"

nt_evaluate:
        .byte 8, UF
        .word nt_base, xt_evaluate, z_evaluate
        .text "evaluate"

nt_base:
        .byte 4, 0
        .word nt_digit_question, xt_base, z_base
        .text "base"

nt_digit_question:
        .byte 6, UF
        .word nt_number, xt_digit_question, z_digit_question
        .text "digit?"

nt_number:
        .byte 6, UF
        .word nt_to_number, xt_number, z_number
        .text "number"

nt_to_number:
        .byte 7, UF
        .word nt_hex, xt_to_number, z_to_number
        .text ">number"

nt_hex:
        .byte 3, 0
        .word nt_decimal, xt_hex, z_hex
        .text "hex"

nt_decimal:
        .byte 7, 0
        .word nt_count, xt_decimal, z_decimal
        .text "decimal"

nt_count:
        .byte 5, UF
        .word nt_m_star, xt_count, z_count
        .text "count"

nt_m_star:
        .byte 2, UF
        .word nt_um_star, xt_m_star, z_m_star
        .text "m*"

nt_um_star:
        .byte 3, UF
        .word nt_star, xt_um_star, z_um_star
        .text "um*"

nt_star:
        .byte 1, UF
        .word nt_um_slash_mod, xt_star, z_star
        .text "*"

nt_um_slash_mod:
        .byte 6, UF
        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
        .text "um/mod"

nt_sm_slash_rem:
        .byte 6, UF
        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
        .text "sm/rem"

nt_fm_slash_mod:
        .byte 6, UF
        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
        .text "fm/mod"

nt_slash:
        .byte 1, UF
        .word nt_slash_mod, xt_slash, z_slash
        .text "/"

nt_slash_mod:
        .byte 4, UF
        .word nt_mod, xt_slash_mod, z_slash_mod
        .text "/mod"

nt_mod:
        .byte 3, UF
        .word nt_star_slash_mod, xt_mod, z_mod
        .text "mod"

nt_star_slash_mod:
        .byte 5, UF
        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
        .text "*/mod"

nt_star_slash:
        .byte 2, UF
        .word nt_backslash, xt_star_slash, z_star_slash
        .text "*/"

nt_backslash:
        .byte 1, IM
        .word nt_move, xt_backslash, z_backslash
        .byte '\'

nt_move:
        .byte 4, NN+UF
        .word nt_cmove_up, xt_move, z_move
        .text "move"

nt_cmove_up:
        .byte 6, UF
        .word nt_cmove, xt_cmove_up, z_cmove_up
        .text "cmove>"

nt_cmove:
        .byte 5, UF
        .word nt_pad, xt_cmove, z_cmove
        .text "cmove"

nt_pad:
        .byte 3, 0
        .word nt_cleave, xt_pad, z_pad
        .text "pad"

nt_cleave:
        .byte 6, UF
        .word nt_hexstore, xt_cleave, z_cleave
        .text "cleave"

nt_hexstore:
        .byte 8, UF
        .word nt_within, xt_hexstore, z_hexstore
        .text "hexstore"

nt_within:
        .byte 6, UF
        .word nt_to_in, xt_within, z_within
        .text "within"

nt_to_in:
        .byte 3, 0
        .word nt_less_number_sign, xt_to_in, z_to_in
        .text ">in"

nt_less_number_sign:
        .byte 2, 0
        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
        .text "<#"

nt_number_sign:
        .byte 1, UF
        .word nt_number_sign_s, xt_number_sign, z_number_sign
        .text "#"

nt_number_sign_s:
        .byte 2, UF
        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
        .text "#s"

nt_number_sign_greater:
        .byte 2, UF
        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
        .text "#>"

nt_hold:
        .byte 4, UF
        .word nt_sign, xt_hold, z_hold
        .text "hold"

nt_sign:
        .byte 4, UF
        .word nt_output, xt_sign, z_sign
        .text "sign"

nt_output:
        .byte 6, 0
        .word nt_input, xt_output, z_output
        .text "output"

nt_input:
        .byte 5, 0
        .word nt_cr, xt_input, z_input
        .text "input"

nt_cr:
        .byte 2, 0
        .word nt_page, xt_cr, z_cr
        .text "cr"

nt_page:
        .byte 4, 0
        .word nt_at_xy, xt_page, z_page
        .text "page"

nt_at_xy:
        .byte 5, UF
        .word nt_marker, xt_at_xy, z_at_xy
        .text "at-xy"

nt_marker:
        .byte 6, IM
        .word nt_words, xt_marker, z_marker
        .text "marker"

nt_words:
        .byte 5, 0
        .word nt_wordsize, xt_words, z_words
        .text "words"

nt_wordsize:
        .byte 8, UF
        .word nt_aligned, xt_wordsize, z_wordsize
        .text "wordsize"

nt_aligned:
        .byte 7, 0
        .word nt_align, xt_aligned, z_aligned   ; same code as ALIGN
        .text "aligned"

nt_align:
        .byte 5, 0
        .word nt_bell, xt_align, z_align
        .text "align"

nt_bell:
        .byte 4, 0
        .word nt_dump, xt_bell, z_bell
        .text "bell"

nt_dump:
        .byte 4, UF
        .word nt_dot_s, xt_dump, z_dump
        .text "dump"

nt_dot_s:
        .byte 2, 0
        .word +, xt_dot_s, z_dot_s
        .text ".s"
+

.if "disassembler" in TALI_OPTIONAL_WORDS
nt_disasm:
        .byte 6, UF
        .word +, xt_disasm, z_disasm
        .text "disasm"
+
.endif

nt_compare:
        .byte 7, UF
        .word nt_search, xt_compare, z_compare
        .text "compare"

nt_search:
        .byte 6, UF+NN
        .word +, xt_search, z_search
        .text "search"
+
.if "environment?" in TALI_OPTIONAL_WORDS
nt_environment_q:
        .byte 12, UF
        .word +, xt_environment_q, z_environment_q
        .text "environment?"
+
.endif
nt_find:
        .byte 4, UF
        .word nt_word, xt_find, z_find
        .text "find"

nt_word:
        .byte 4, UF
        .word nt_paren, xt_word, z_word
        .text "word"

nt_paren:
        .byte 1, IM
        .word nt_dot_paren, xt_paren, z_paren
        .text "("

nt_dot_paren:
        .byte 2, IM
        .word nt_if, xt_dot_paren, z_dot_paren
        .text ".("

nt_if:
        .byte 2, IM+CO+NN
        .word nt_then, xt_if, z_if
        .text "if"

nt_then:
        .byte 4, IM+CO+NN
        .word nt_else, xt_then, z_then
        .text "then"

nt_else:
        .byte 4, IM+CO+NN
        .word nt_repeat, xt_else, z_else
        .text "else"

nt_repeat:
        .byte 6, IM+CO+NN
        .word nt_until, xt_repeat, z_repeat
        .text "repeat"

nt_until:
        .byte 5, IM+CO+NN
        .word nt_while, xt_until, z_until
        .text "until"

nt_while:
        .byte 5, IM+CO+NN
        .word nt_case, xt_while, z_while
        .text "while"

nt_case:
        .byte 4, IM+CO+NN
        .word nt_of, xt_case, z_case    ; shares code with ZERO
        .text "case"

nt_of:
        .byte 2, IM+CO+NN
        .word nt_endof, xt_of, z_of
        .text "of"

nt_endof:
        .byte 5, IM+CO+NN
        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
        .text "endof"

nt_endcase:
        .byte 7, IM+CO+NN
        .word nt_defer_fetch, xt_endcase, z_endcase
        .text "endcase"

nt_defer_fetch:
        .byte 6, 0
        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
        .text "defer@"

nt_defer_store:
        .byte 6, 0
        .word nt_is, xt_defer_store, z_defer_store
        .text "defer!"

nt_is:
        .byte 2, IM
        .word nt_action_of, xt_is, z_is
        .text "is"

nt_action_of:
        .byte 9, IM
        .word nt_useraddr, xt_action_of, z_action_of
        .text "action-of"

nt_useraddr:
        .byte 8, 0
        .word nt_buffer_colon, xt_useraddr, z_useraddr
        .text "useraddr"

nt_buffer_colon:
        .byte 7, 0
        .word +, xt_buffer_colon, z_buffer_colon
        .text "buffer:"
+
.if "block" in TALI_OPTIONAL_WORDS
nt_buffstatus:
        .byte 10, 0
        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
        .text "buffstatus"

nt_buffblocknum:
        .byte 12, 0
        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
        .text "buffblocknum"

nt_blkbuffer:
        .byte 9, 0
        .word nt_scr, xt_blkbuffer, z_blkbuffer
        .text "blkbuffer"

nt_scr:
        .byte 3, NN
        .word nt_blk, xt_scr, z_scr
        .text "scr"

nt_blk:
        .byte 3, NN
        .word nt_block_write, xt_blk, z_blk
        .text "blk"

nt_block_write:
        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
        .word nt_block_write_vector, xt_block_write, z_block_write
        .text "block-write"

nt_block_write_vector:
        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
        .word nt_block_read, xt_block_write_vector, z_block_write_vector
        .text "block-write-vector"

nt_block_read:
        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
        .word nt_block_read_vector, xt_block_read, z_block_read
        .text "block-read"

nt_block_read_vector:
        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
        .text "block-read-vector"

nt_save_buffers:
        .byte 12, 0
        .word nt_block, xt_save_buffers, z_save_buffers
        .text "save-buffers"

nt_block:
        .byte 5, 0
        .word nt_update, xt_block, z_block
        .text "block"

nt_update:
        .byte 6, 0
        .word nt_buffer, xt_update, z_update
        .text "update"

nt_buffer:
        .byte 6, 0
        .word nt_empty_buffers, xt_buffer, z_buffer
        .text "buffer"

nt_empty_buffers:
        .byte 13, 0
        .word nt_flush, xt_empty_buffers, z_empty_buffers
        .text "empty-buffers"

nt_flush:
        .byte 5, 0
        .word nt_load, xt_flush, z_flush
        .text "flush"

nt_load:
        .byte 4, UF
        .word nt_thru, xt_load, z_load
        .text "load"

nt_thru:
        .byte 4, UF
        .word +, xt_thru, z_thru
        .text "thru"
+

.if "editor" in TALI_OPTIONAL_WORDS
nt_list:
        .byte 4, UF
        .word nt_block_c65_init, xt_list, z_list
        .text "list"

nt_block_c65_init:
        .byte 14, 0
        .word +, xt_block_c65_init, z_block_c65_init
        .text "block-c65-init"
+
.endif
.endif

.if "block" in TALI_OPTIONAL_WORDS && "ramdrive" in TALI_OPTIONAL_WORDS
nt_block_ramdrive_init:
        .byte 19, UF
        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
        .text "block-ramdrive-init"
+
.endif

.if "wordlist" in TALI_OPTIONAL_WORDS
nt_definitions:
        .byte 11, 0
        .word nt_wordlist, xt_definitions, z_definitions
        .text "definitions"

nt_wordlist:
        .byte 8, 0
        .word nt_search_wordlist, xt_wordlist, z_wordlist
        .text "wordlist"

nt_search_wordlist:
        .byte 15, UF
        .word nt_set_current, xt_search_wordlist, z_search_wordlist
        .text "search-wordlist"

nt_set_current:
        .byte 11, UF
        .word nt_get_current, xt_set_current, z_set_current
        .text "set-current"

nt_get_current:
        .byte 11, 0
        .word nt_set_order, xt_get_current, z_get_current
        .text "get-current"

nt_set_order:
        .byte 9, 0
        .word nt_get_order, xt_set_order, z_set_order
        .text "set-order"

nt_get_order:
        .byte 9, 0
        .word nt_root_wordlist, xt_get_order, z_get_order
        .text "get-order"

nt_root_wordlist:
        .byte 13, 0
        .word +, xt_root_wordlist, z_root_wordlist
        .text "root-wordlist"
+
.endif

.if "assembler" in TALI_OPTIONAL_WORDS && "wordlist" in TALI_OPTIONAL_WORDS
nt_assembler_wordlist:  ; shares code with TWO
        .byte 18, 0
        .word +, xt_assembler_wordlist, z_assembler_wordlist
        .text "assembler-wordlist"
+
.endif

.if "editor" in TALI_OPTIONAL_WORDS && "wordlist" in TALI_OPTIONAL_WORDS
nt_editor_wordlist:     ; shares code with ONE
        .byte 15, 0
        .word +, xt_editor_wordlist, z_editor_wordlist
        .text "editor-wordlist"
+
.endif

.if "wordlist" in TALI_OPTIONAL_WORDS
nt_forth_wordlist:      ; shares code with ZERO
        .byte 14, 0
        .word nt_only, xt_forth_wordlist, z_forth_wordlist
        .text "forth-wordlist"

nt_only:
        .byte 4, 0
        .word nt_also, xt_only, z_only
        .text "only"

nt_also:
        .byte 4, 0
        .word nt_previous, xt_also, z_also
        .text "also"

nt_previous:
        .byte 8, 0
        .word nt_to_order, xt_previous, z_previous
        .text "previous"

nt_to_order:
        .byte 6, 0
        .word nt_order, xt_to_order, z_to_order
        .text ">order"

nt_order:
        .byte 5, 0
        .word nt_forth, xt_order, z_order
        .text "order"

nt_forth:
        .byte 5, 0
        .word +, xt_forth, z_forth
        .text "forth"
+
.endif

nt_see: .byte 3, NN
        .word +, xt_see, z_see
        .text "see"
+

.if "ed" in TALI_OPTIONAL_WORDS
nt_ed:                  ; ed6502
        .byte 3, NN
        .word +, xt_ed, z_ed
        .text "ed:"
+
.endif

nt_cold:
        .byte 4, 0
        .word nt_bye, xt_cold, z_cold
        .text "cold"

nt_bye:
        .byte 3         ; length of word strings
        .byte 0         ; status byte
        .word 0000      ; next word in Dictionary, 0000 signals end
        .word xt_bye    ; start of code block (xt of this word)
        .word z_bye     ; end of code (RTS)
        .text "bye"     ; word name, always lower case, not zero-terminated

; END of FORTH-WORDLIST


; ROOT-WORDLIST
        ; This is a short wordlist that has just the words needed to
        ; set the wordlists. These words are also included in the
        ; FORTH-WORDLIST as well.

root_dictionary_start:
.if "wordlist" in TALI_OPTIONAL_WORDS
nt_root_set_order:
        .byte 9, 0
        .word nt_root_forth, xt_set_order, z_set_order
        .text "set-order"

nt_root_forth:
        .byte 5, 0
        .word nt_root_forth_wordlist, xt_forth, z_forth
        .text "forth"

nt_root_forth_wordlist: ; shares code with ZERO
        .byte 14, 0
        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
        .text "forth-wordlist"

nt_root_words:
        .byte 5, 0
        .word 0000, xt_words, z_words
        .text "words"
.endif
; END of ROOT-WORDLIST


; EDITOR-WORDLIST

editor_dictionary_start:
.if "editor" in TALI_OPTIONAL_WORDS && "block" in TALI_OPTIONAL_WORDS
nt_editor_o:
        .byte 1, 0
        .word nt_editor_line, xt_editor_o, z_editor_o
        .text "o"

nt_editor_line:
        .byte 4, UF
        .word nt_editor_l, xt_editor_line, z_editor_line
        .text "line"

nt_editor_l:
        .byte 1, 0
        .word nt_editor_el, xt_editor_l, z_editor_l
        .text "l"

nt_editor_el:
        .byte 2, 0
        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
        .text "el"

nt_editor_erase_screen:
        .byte 12, 0
        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
        .text "erase-screen"

nt_editor_enter_screen:
        .byte 12, 0
        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
        .text "enter-screen"
.endif
; END of EDITOR-WORDLIST


; ASSEMBLER-WORDLIST

; Labels for the opcodes have the format "nt_asm_<OPC>" where a futher
; underscore replaces any dot present in the SAN mnemonic. The hash sign for
; immediate addressing is replaced by an "h" (for example, the label code for
; "lda.#" is "xt_adm_lda_h"). All opcodes are immediate.
assembler_dictionary_start:
.if "assembler" in TALI_OPTIONAL_WORDS
nt_asm_adc_h:
		.byte 5, IM+NN
                .word nt_asm_adc_x
		.word xt_asm_adc_h, z_asm_adc_h
		.text "adc.#"

nt_asm_adc_x:
		.byte 5, IM+NN
                .word nt_asm_adc_y
		.word xt_asm_adc_x, z_asm_adc_x
		.text "adc.x"

nt_asm_adc_y:
		.byte 5, IM+NN
                .word nt_asm_adc_z
		.word xt_asm_adc_y, z_asm_adc_y
		.text "adc.y"

nt_asm_adc_z:
		.byte 5, IM+NN
                .word nt_asm_adc_zi
		.word xt_asm_adc_z, z_asm_adc_z
		.text "adc.z"

nt_asm_adc_zi:
		.byte 6, IM+NN
                .word nt_asm_adc_ziy
		.word xt_asm_adc_zi, z_asm_adc_zi
		.text "adc.zi"

nt_asm_adc_ziy:
		.byte 7, IM+NN
                .word nt_asm_adc_zx
		.word xt_asm_adc_ziy, z_asm_adc_ziy
		.text "adc.ziy"

nt_asm_adc_zx:
		.byte 6, IM+NN
                .word nt_asm_adc_zxi
		.word xt_asm_adc_zx, z_asm_adc_zx
		.text "adc.zx"

nt_asm_adc_zxi:
		.byte 7, IM+NN
                .word nt_asm_and
		.word xt_asm_adc_zxi, z_asm_adc_zxi
		.text "adc.zxi"

nt_asm_and:     ; not "and" because of conflicts with Forth word
		.byte 4, IM+NN
                .word nt_asm_and_h
		.word xt_asm_and, z_asm_and
		.text "and."

nt_asm_and_h:
		.byte 5, IM+NN
                .word nt_asm_and_x
		.word xt_asm_and_h, z_asm_and_h
		.text "and.#"

nt_asm_and_x:
		.byte 5, IM+NN
                .word nt_asm_and_y
		.word xt_asm_and_x, z_asm_and_x
		.text "and.x"

nt_asm_and_y:
		.byte 5, IM+NN
                .word nt_asm_and_z
		.word xt_asm_and_y, z_asm_and_y
		.text "and.y"

nt_asm_and_z:
		.byte 5, IM+NN
                .word nt_asm_and_zi
		.word xt_asm_and_z, z_asm_and_z
		.text "and.z"

nt_asm_and_zi:
		.byte 6, IM+NN
                .word nt_asm_and_ziy
		.word xt_asm_and_zi, z_asm_and_zi
		.text "and.zi"

nt_asm_and_ziy:
		.byte 7, IM+NN
                .word nt_asm_and_zx
		.word xt_asm_and_ziy, z_asm_and_ziy
		.text "and.ziy"

nt_asm_and_zx:
		.byte 6, IM+NN
                .word nt_asm_and_zxi
		.word xt_asm_and_zx, z_asm_and_zx
		.text "and.zx"

nt_asm_and_zxi:
		.byte 7, IM+NN
                .word nt_asm_asl
		.word xt_asm_and_zxi, z_asm_and_zxi
		.text "and.zxi"

nt_asm_asl:
		.byte 3, IM+NN
                .word nt_asm_asl_a
		.word xt_asm_asl, z_asm_asl
		.text "asl"

nt_asm_asl_a:
		.byte 5, IM+NN
                .word nt_asm_asl_x
		.word xt_asm_asl_a, z_asm_asl_a
		.text "asl.a"

nt_asm_asl_x:
		.byte 5, IM+NN
                .word nt_asm_asl_z
		.word xt_asm_asl_x, z_asm_asl_x
		.text "asl.x"

nt_asm_asl_z:
		.byte 5, IM+NN
                .word nt_asm_asl_zx
		.word xt_asm_asl_z, z_asm_asl_z
		.text "asl.z"

nt_asm_asl_zx:
		.byte 6, IM+NN
                .word nt_asm_bcc
		.word xt_asm_asl_zx, z_asm_asl_zx
		.text "asl.zx"

nt_asm_bcc:
		.byte 3, IM+NN
                .word nt_asm_bcs
		.word xt_asm_bcc, z_asm_bcc
		.text "bcc"

nt_asm_bcs:
		.byte 3, IM+NN
                .word nt_asm_beq
		.word xt_asm_bcs, z_asm_bcs
		.text "bcs"

nt_asm_beq:
		.byte 3, IM+NN
                .word nt_asm_bit
		.word xt_asm_beq, z_asm_beq
		.text "beq"

nt_asm_bit:
		.byte 3, IM+NN
                .word nt_asm_bit_h
		.word xt_asm_bit, z_asm_bit
		.text "bit"

nt_asm_bit_h:
		.byte 5, IM+NN
                .word nt_asm_bit_x
		.word xt_asm_bit_h, z_asm_bit_h
		.text "bit.#"

nt_asm_bit_x:
		.byte 5, IM+NN
                .word nt_asm_bit_z
		.word xt_asm_bit_x, z_asm_bit_x
		.text "bit.x"

nt_asm_bit_z:
		.byte 5, IM+NN
                .word nt_asm_bit_zx
		.word xt_asm_bit_z, z_asm_bit_z
		.text "bit.z"

nt_asm_bit_zx:
		.byte 6, IM+NN
                .word nt_asm_bmi
		.word xt_asm_bit_zx, z_asm_bit_zx
		.text "bit.zx"

nt_asm_bmi:
		.byte 3, IM+NN
                .word nt_asm_bne
		.word xt_asm_bmi, z_asm_bmi
		.text "bmi"

nt_asm_bne:
		.byte 3, IM+NN
                .word nt_asm_bpl
		.word xt_asm_bne, z_asm_bne
		.text "bne"

nt_asm_bpl:
		.byte 3, IM+NN
                .word nt_asm_bra
		.word xt_asm_bpl, z_asm_bpl
		.text "bpl"

nt_asm_bra:
		.byte 3, IM+NN
                .word nt_asm_brk
		.word xt_asm_bra, z_asm_bra
		.text "bra"

nt_asm_brk:
		.byte 3, IM+NN
                .word nt_asm_bvc
		.word xt_asm_brk, z_asm_brk
		.text "brk"

nt_asm_bvc:
		.byte 3, IM+NN
                .word nt_asm_bvs
		.word xt_asm_bvc, z_asm_bvc
		.text "bvc"

nt_asm_bvs:
		.byte 3, IM+NN
                .word nt_asm_clc
		.word xt_asm_bvs, z_asm_bvs
		.text "bvs"

nt_asm_clc:
		.byte 3, IM+NN
                .word nt_asm_cld
		.word xt_asm_clc, z_asm_clc
		.text "clc"

nt_asm_cld:
		.byte 3, IM+NN
                .word nt_asm_cli
		.word xt_asm_cld, z_asm_cld
		.text "cld"

nt_asm_cli:
		.byte 3, IM+NN
                .word nt_asm_clv
		.word xt_asm_cli, z_asm_cli
		.text "cli"

nt_asm_clv:
		.byte 3, IM+NN
                .word nt_asm_cmp
		.word xt_asm_clv, z_asm_clv
		.text "clv"

nt_asm_cmp:
		.byte 3, IM+NN
                .word nt_asm_cmp_h
		.word xt_asm_cmp, z_asm_cmp
		.text "cmp"

nt_asm_cmp_h:
		.byte 5, IM+NN
                .word nt_asm_cmp_x
		.word xt_asm_cmp_h, z_asm_cmp_h
		.text "cmp.#"

nt_asm_cmp_x:
		.byte 5, IM+NN
                .word nt_asm_cmp_y
		.word xt_asm_cmp_x, z_asm_cmp_x
		.text "cmp.x"

nt_asm_cmp_y:
		.byte 5, IM+NN
                .word nt_asm_cmp_z
		.word xt_asm_cmp_y, z_asm_cmp_y
		.text "cmp.y"

nt_asm_cmp_z:
		.byte 5, IM+NN
                .word nt_asm_cmp_zi
		.word xt_asm_cmp_z, z_asm_cmp_z
		.text "cmp.z"

nt_asm_cmp_zi:
		.byte 6, IM+NN
                .word nt_asm_cmp_ziy
		.word xt_asm_cmp_zi, z_asm_cmp_zi
		.text "cmp.zi"

nt_asm_cmp_ziy:
		.byte 7, IM+NN
                .word nt_asm_cmp_zx
		.word xt_asm_cmp_ziy, z_asm_cmp_ziy
		.text "cmp.ziy"

nt_asm_cmp_zx:
		.byte 6, IM+NN
                .word nt_asm_cmp_zxi
		.word xt_asm_cmp_zx, z_asm_cmp_zx
		.text "cmp.zx"

nt_asm_cmp_zxi:
		.byte 7, IM+NN
                .word nt_asm_cpx
		.word xt_asm_cmp_zxi, z_asm_cmp_zxi
		.text "cmp.zxi"

nt_asm_cpx:
		.byte 3, IM+NN
                .word nt_asm_cpx_h
		.word xt_asm_cpx, z_asm_cpx
		.text "cpx"

nt_asm_cpx_h:
		.byte 5, IM+NN
                .word nt_asm_cpx_z
		.word xt_asm_cpx_h, z_asm_cpx_h
		.text "cpx.#"

nt_asm_cpx_z:
		.byte 5, IM+NN
                .word nt_asm_cpy
		.word xt_asm_cpx_z, z_asm_cpx_z
		.text "cpx.z"

nt_asm_cpy:
		.byte 3, IM+NN
                .word nt_asm_cpy_h
		.word xt_asm_cpy, z_asm_cpy
		.text "cpy"

nt_asm_cpy_h:
		.byte 5, IM+NN
                .word nt_asm_cpy_z
		.word xt_asm_cpy_h, z_asm_cpy_h
		.text "cpy.#"

nt_asm_cpy_z:
		.byte 5, IM+NN
                .word nt_asm_dec
		.word xt_asm_cpy_z, z_asm_cpy_z
		.text "cpy.z"

nt_asm_dec:
		.byte 3, IM+NN
                .word nt_asm_dec_a
		.word xt_asm_dec, z_asm_dec
		.text "dec"

nt_asm_dec_a:
		.byte 5, IM+NN
                .word nt_asm_dec_x
		.word xt_asm_dec_a, z_asm_dec_a
		.text "dec.a"

nt_asm_dec_x:
		.byte 5, IM+NN
                .word nt_asm_dec_z
		.word xt_asm_dec_x, z_asm_dec_x
		.text "dec.x"

nt_asm_dec_z:
		.byte 5, IM+NN
                .word nt_asm_dec_zx
		.word xt_asm_dec_z, z_asm_dec_z
		.text "dec.z"

nt_asm_dec_zx:
		.byte 6, IM+NN
                .word nt_asm_dex
		.word xt_asm_dec_zx, z_asm_dec_zx
		.text "dec.zx"

nt_asm_dex:
		.byte 3, IM+NN
                .word nt_asm_dey
		.word xt_asm_dex, z_asm_dex
		.text "dex"

nt_asm_dey:
		.byte 3, IM+NN
                .word nt_asm_eor
		.word xt_asm_dey, z_asm_dey
		.text "dey"

nt_asm_eor:
		.byte 3, IM+NN
                .word nt_asm_eor_h
		.word xt_asm_eor, z_asm_eor
		.text "eor"

nt_asm_eor_h:
		.byte 5, IM+NN
                .word nt_asm_eor_x
		.word xt_asm_eor_h, z_asm_eor_h
		.text "eor.#"

nt_asm_eor_x:
		.byte 5, IM+NN
                .word nt_asm_eor_y
		.word xt_asm_eor_x, z_asm_eor_x
		.text "eor.x"

nt_asm_eor_y:
		.byte 5, IM+NN
                .word nt_asm_eor_z
		.word xt_asm_eor_y, z_asm_eor_y
		.text "eor.y"

nt_asm_eor_z:
		.byte 5, IM+NN
                .word nt_asm_eor_zi
		.word xt_asm_eor_z, z_asm_eor_z
		.text "eor.z"

nt_asm_eor_zi:
		.byte 6, IM+NN
                .word nt_asm_eor_ziy
		.word xt_asm_eor_zi, z_asm_eor_zi
		.text "eor.zi"

nt_asm_eor_ziy:
		.byte 7, IM+NN
                .word nt_asm_eor_zx
		.word xt_asm_eor_ziy, z_asm_eor_ziy
		.text "eor.ziy"

nt_asm_eor_zx:
		.byte 6, IM+NN
                .word nt_asm_eor_zxi
		.word xt_asm_eor_zx, z_asm_eor_zx
		.text "eor.zx"

nt_asm_eor_zxi:
		.byte 7, IM+NN
                .word nt_asm_inc
		.word xt_asm_eor_zxi, z_asm_eor_zxi
		.text "eor.zxi"

nt_asm_inc:
		.byte 3, IM+NN
                .word nt_asm_inc_a
		.word xt_asm_inc, z_asm_inc
		.text "inc"

nt_asm_inc_a:
		.byte 5, IM+NN
                .word nt_asm_inc_x
		.word xt_asm_inc_a, z_asm_inc_a
		.text "inc.a"

nt_asm_inc_x:
		.byte 5, IM+NN
                .word nt_asm_inc_z
		.word xt_asm_inc_x, z_asm_inc_x
		.text "inc.x"

nt_asm_inc_z:
		.byte 5, IM+NN
                .word nt_asm_inc_zx
		.word xt_asm_inc_z, z_asm_inc_z
		.text "inc.z"

nt_asm_inc_zx:
		.byte 6, IM+NN
                .word nt_asm_inx
		.word xt_asm_inc_zx, z_asm_inc_zx
		.text "inc.zx"

nt_asm_inx:
		.byte 3, IM+NN
                .word nt_asm_iny
		.word xt_asm_inx, z_asm_inx
		.text "inx"

nt_asm_iny:
		.byte 3, IM+NN
                .word nt_asm_jmp
		.word xt_asm_iny, z_asm_iny
		.text "iny"

nt_asm_jmp:
		.byte 3, IM+NN
                .word nt_asm_jmp_i
		.word xt_asm_jmp, z_asm_jmp
		.text "jmp"

nt_asm_jmp_i:
		.byte 5, IM+NN
                .word nt_asm_jmp_xi
		.word xt_asm_jmp_i, z_asm_jmp_i
		.text "jmp.i"

nt_asm_jmp_xi:
		.byte 6, IM+NN
                .word nt_asm_jsr
		.word xt_asm_jmp_xi, z_asm_jmp_xi
		.text "jmp.xi"

nt_asm_jsr:
		.byte 3, IM+NN
                .word nt_asm_lda
		.word xt_asm_jsr, z_asm_jsr
		.text "jsr"

nt_asm_lda:
		.byte 3, IM+NN
                .word nt_asm_lda_h
		.word xt_asm_lda, z_asm_lda
		.text "lda"

nt_asm_lda_h:
		.byte 5, IM+NN
                .word nt_asm_lda_x
		.word xt_asm_lda_h, z_asm_lda_h
		.text "lda.#"

nt_asm_lda_x:
		.byte 5, IM+NN
                .word nt_asm_lda_y
		.word xt_asm_lda_x, z_asm_lda_x
		.text "lda.x"

nt_asm_lda_y:
		.byte 5, IM+NN
                .word nt_asm_lda_z
		.word xt_asm_lda_y, z_asm_lda_y
		.text "lda.y"

nt_asm_lda_z:
		.byte 5, IM+NN
                .word nt_asm_lda_zi
		.word xt_asm_lda_z, z_asm_lda_z
		.text "lda.z"

nt_asm_lda_zi:
		.byte 6, IM+NN
                .word nt_asm_lda_ziy
		.word xt_asm_lda_zi, z_asm_lda_zi
		.text "lda.zi"

nt_asm_lda_ziy:
		.byte 7, IM+NN
                .word nt_asm_lda_zx
		.word xt_asm_lda_ziy, z_asm_lda_ziy
		.text "lda.ziy"

nt_asm_lda_zx:
		.byte 6, IM+NN
                .word nt_asm_lda_zxi
		.word xt_asm_lda_zx, z_asm_lda_zx
		.text "lda.zx"

nt_asm_lda_zxi:
		.byte 7, IM+NN
                .word nt_asm_ldx
		.word xt_asm_lda_zxi, z_asm_lda_zxi
		.text "lda.zxi"

nt_asm_ldx:
		.byte 3, IM+NN
                .word nt_asm_ldx_h
		.word xt_asm_ldx, z_asm_ldx
		.text "ldx"

nt_asm_ldx_h:
		.byte 5, IM+NN
                .word nt_asm_ldx_y
		.word xt_asm_ldx_h, z_asm_ldx_h
		.text "ldx.#"

nt_asm_ldx_y:
		.byte 5, IM+NN
                .word nt_asm_ldx_z
		.word xt_asm_ldx_y, z_asm_ldx_y
		.text "ldx.y"

nt_asm_ldx_z:
		.byte 5, IM+NN
                .word nt_asm_ldx_zy
		.word xt_asm_ldx_z, z_asm_ldx_z
		.text "ldx.z"

nt_asm_ldx_zy:
		.byte 6, IM+NN
                .word nt_asm_ldy
		.word xt_asm_ldx_zy, z_asm_ldx_zy
		.text "ldx.zy"

nt_asm_ldy:
		.byte 3, IM+NN
                .word nt_asm_ldy_h
		.word xt_asm_ldy, z_asm_ldy
		.text "ldy"

nt_asm_ldy_h:
		.byte 5, IM+NN
                .word nt_asm_ldy_x
		.word xt_asm_ldy_h, z_asm_ldy_h
		.text "ldy.#"

nt_asm_ldy_x:
		.byte 5, IM+NN
                .word nt_asm_ldy_z
		.word xt_asm_ldy_x, z_asm_ldy_x
		.text "ldy.x"

nt_asm_ldy_z:
		.byte 5, IM+NN
                .word nt_asm_ldy_zx
		.word xt_asm_ldy_z, z_asm_ldy_z
		.text "ldy.z"

nt_asm_ldy_zx:
		.byte 6, IM+NN
                .word nt_asm_lsr
		.word xt_asm_ldy_zx, z_asm_ldy_zx
		.text "ldy.zx"

nt_asm_lsr:
		.byte 3, IM+NN
                .word nt_asm_lsr_a
		.word xt_asm_lsr, z_asm_lsr
		.text "lsr"

nt_asm_lsr_a:
		.byte 5, IM+NN
                .word nt_asm_lsr_x
		.word xt_asm_lsr_a, z_asm_lsr_a
		.text "lsr.a"

nt_asm_lsr_x:
		.byte 5, IM+NN
                .word nt_asm_lsr_z
		.word xt_asm_lsr_x, z_asm_lsr_x
		.text "lsr.x"

nt_asm_lsr_z:
		.byte 5, IM+NN
                .word nt_asm_lsr_zx
		.word xt_asm_lsr_z, z_asm_lsr_z
		.text "lsr.z"

nt_asm_lsr_zx:
		.byte 6, IM+NN
                .word nt_asm_nop
		.word xt_asm_lsr_zx, z_asm_lsr_zx
		.text "lsr.zx"

nt_asm_nop:
		.byte 3, IM+NN
                .word nt_asm_ora
		.word xt_asm_nop, z_asm_nop
		.text "nop"

nt_asm_ora:
		.byte 3, IM+NN
                .word nt_asm_ora_h
		.word xt_asm_ora, z_asm_ora
		.text "ora"

nt_asm_ora_h:
		.byte 5, IM+NN
                .word nt_asm_ora_x
		.word xt_asm_ora_h, z_asm_ora_h
		.text "ora.#"

nt_asm_ora_x:
		.byte 5, IM+NN
                .word nt_asm_ora_y
		.word xt_asm_ora_x, z_asm_ora_x
		.text "ora.x"

nt_asm_ora_y:
		.byte 5, IM+NN
                .word nt_asm_ora_z
		.word xt_asm_ora_y, z_asm_ora_y
		.text "ora.y"

nt_asm_ora_z:
		.byte 5, IM+NN
                .word nt_asm_ora_zi
		.word xt_asm_ora_z, z_asm_ora_z
		.text "ora.z"

nt_asm_ora_zi:
		.byte 6, IM+NN
                .word nt_asm_ora_ziy
		.word xt_asm_ora_zi, z_asm_ora_zi
		.text "ora.zi"

nt_asm_ora_ziy:
		.byte 7, IM+NN
                .word nt_asm_ora_zx
		.word xt_asm_ora_ziy, z_asm_ora_ziy
		.text "ora.ziy"

nt_asm_ora_zx:
		.byte 6, IM+NN
                .word nt_asm_ora_zxi
		.word xt_asm_ora_zx, z_asm_ora_zx
		.text "ora.zx"

nt_asm_ora_zxi:
		.byte 7, IM+NN
                .word nt_asm_pha
		.word xt_asm_ora_zxi, z_asm_ora_zxi
		.text "ora.zxi"

nt_asm_pha:
		.byte 3, IM+NN
                .word nt_asm_php
		.word xt_asm_pha, z_asm_pha
		.text "pha"

nt_asm_php:
		.byte 3, IM+NN
                .word nt_asm_phx
		.word xt_asm_php, z_asm_php
		.text "php"

nt_asm_phx:
		.byte 3, IM+NN
                .word nt_asm_phy
		.word xt_asm_phx, z_asm_phx
		.text "phx"

nt_asm_phy:
		.byte 3, IM+NN
                .word nt_asm_pla
		.word xt_asm_phy, z_asm_phy
		.text "phy"

nt_asm_pla:
		.byte 3, IM+NN
                .word nt_asm_plp
		.word xt_asm_pla, z_asm_pla
		.text "pla"

nt_asm_plp:
		.byte 3, IM+NN
                .word nt_asm_plx
		.word xt_asm_plp, z_asm_plp
		.text "plp"

nt_asm_plx:
		.byte 3, IM+NN
                .word nt_asm_ply
		.word xt_asm_plx, z_asm_plx
		.text "plx"

nt_asm_ply:
		.byte 3, IM+NN
                .word nt_asm_rol
		.word xt_asm_ply, z_asm_ply
		.text "ply"

nt_asm_rol:
		.byte 3, IM+NN
                .word nt_asm_rol_a
		.word xt_asm_rol, z_asm_rol
		.text "rol"

nt_asm_rol_a:
		.byte 5, IM+NN
                .word nt_asm_rol_x
		.word xt_asm_rol_a, z_asm_rol_a
		.text "rol.a"

nt_asm_rol_x:
		.byte 5, IM+NN
                .word nt_asm_rol_z
		.word xt_asm_rol_x, z_asm_rol_x
		.text "rol.x"

nt_asm_rol_z:
		.byte 5, IM+NN
                .word nt_asm_rol_zx
		.word xt_asm_rol_z, z_asm_rol_z
		.text "rol.z"

nt_asm_rol_zx:
		.byte 6, IM+NN
                .word nt_asm_ror
		.word xt_asm_rol_zx, z_asm_rol_zx
		.text "rol.zx"

nt_asm_ror:
		.byte 3, IM+NN
                .word nt_asm_ror_a
		.word xt_asm_ror, z_asm_ror
		.text "ror"

nt_asm_ror_a:
		.byte 5, IM+NN
                .word nt_asm_ror_x
		.word xt_asm_ror_a, z_asm_ror_a
		.text "ror.a"

nt_asm_ror_x:
		.byte 5, IM+NN
                .word nt_asm_ror_z
		.word xt_asm_ror_x, z_asm_ror_x
		.text "ror.x"

nt_asm_ror_z:
		.byte 5, IM+NN
                .word nt_asm_ror_zx
		.word xt_asm_ror_z, z_asm_ror_z
		.text "ror.z"

nt_asm_ror_zx:
		.byte 6, IM+NN
                .word nt_asm_rti
		.word xt_asm_ror_zx, z_asm_ror_zx
		.text "ror.zx"

nt_asm_rti:
		.byte 3, IM+NN
                .word nt_asm_rts
		.word xt_asm_rti, z_asm_rti
		.text "rti"

nt_asm_rts:
		.byte 3, IM+NN
                .word nt_asm_sbc
		.word xt_asm_rts, z_asm_rts
		.text "rts"

nt_asm_sbc:
		.byte 3, IM+NN
                .word nt_asm_sbc_h
		.word xt_asm_sbc, z_asm_sbc
		.text "sbc"

nt_asm_sbc_h:
		.byte 5, IM+NN
                .word nt_asm_sbc_x
		.word xt_asm_sbc_h, z_asm_sbc_h
		.text "sbc.#"

nt_asm_sbc_x:
		.byte 5, IM+NN
                .word nt_asm_sbc_y
		.word xt_asm_sbc_x, z_asm_sbc_x
		.text "sbc.x"

nt_asm_sbc_y:
		.byte 5, IM+NN
                .word nt_asm_sbc_z
		.word xt_asm_sbc_y, z_asm_sbc_y
		.text "sbc.y"

nt_asm_sbc_z:
		.byte 5, IM+NN
                .word nt_asm_sbc_zi
		.word xt_asm_sbc_z, z_asm_sbc_z
		.text "sbc.z"

nt_asm_sbc_zi:
		.byte 6, IM+NN
                .word nt_asm_sbc_ziy
		.word xt_asm_sbc_zi, z_asm_sbc_zi
		.text "sbc.zi"

nt_asm_sbc_ziy:
		.byte 7, IM+NN
                .word nt_asm_sbc_zx
		.word xt_asm_sbc_ziy, z_asm_sbc_ziy
		.text "sbc.ziy"

nt_asm_sbc_zx:
		.byte 6, IM+NN
                .word nt_asm_sbc_zxi
		.word xt_asm_sbc_zx, z_asm_sbc_zx
		.text "sbc.zx"

nt_asm_sbc_zxi:
		.byte 7, IM+NN
                .word nt_asm_sec
		.word xt_asm_sbc_zxi, z_asm_sbc_zxi
		.text "sbc.zxi"

nt_asm_sec:
		.byte 3, IM+NN
                .word nt_asm_sed
		.word xt_asm_sec, z_asm_sec
		.text "sec"

nt_asm_sed:
		.byte 3, IM+NN
                .word nt_asm_sei
		.word xt_asm_sed, z_asm_sed
		.text "sed"

nt_asm_sei:
		.byte 3, IM+NN
                .word nt_asm_sta
		.word xt_asm_sei, z_asm_sei
		.text "sei"

nt_asm_sta:
		.byte 3, IM+NN
                .word nt_asm_sta_x
		.word xt_asm_sta, z_asm_sta
		.text "sta"

nt_asm_sta_x:
		.byte 5, IM+NN
                .word nt_asm_sta_y
		.word xt_asm_sta_x, z_asm_sta_x
		.text "sta.x"

nt_asm_sta_y:
		.byte 5, IM+NN
                .word nt_asm_sta_z
		.word xt_asm_sta_y, z_asm_sta_y
		.text "sta.y"

nt_asm_sta_z:
		.byte 5, IM+NN
                .word nt_asm_sta_zi
		.word xt_asm_sta_z, z_asm_sta_z
		.text "sta.z"

nt_asm_sta_zi:
		.byte 6, IM+NN
                .word nt_asm_sta_ziy
		.word xt_asm_sta_zi, z_asm_sta_zi
		.text "sta.zi"

nt_asm_sta_ziy:
		.byte 7, IM+NN
                .word nt_asm_sta_zx
		.word xt_asm_sta_ziy, z_asm_sta_ziy
		.text "sta.ziy"

nt_asm_sta_zx:
		.byte 6, IM+NN
                .word nt_asm_sta_zxi
		.word xt_asm_sta_zx, z_asm_sta_zx
		.text "sta.zx"

nt_asm_sta_zxi:
		.byte 7, IM+NN
                .word nt_asm_stx
		.word xt_asm_sta_zxi, z_asm_sta_zxi
		.text "sta.zxi"

nt_asm_stx:
		.byte 3, IM+NN
                .word nt_asm_stx_z
		.word xt_asm_stx, z_asm_stx
		.text "stx"

nt_asm_stx_z:
		.byte 5, IM+NN
                .word nt_asm_stx_zy
		.word xt_asm_stx_z, z_asm_stx_z
		.text "stx.z"

nt_asm_stx_zy:
		.byte 6, IM+NN
                .word nt_asm_sty
		.word xt_asm_stx_zy, z_asm_stx_zy
		.text "stx.zy"

nt_asm_sty:
		.byte 3, IM+NN
                .word nt_asm_sty_z
		.word xt_asm_sty, z_asm_sty
		.text "sty"

nt_asm_sty_z:
		.byte 5, IM+NN
                .word nt_asm_sty_zx
		.word xt_asm_sty_z, z_asm_sty_z
		.text "sty.z"

nt_asm_sty_zx:
		.byte 6, IM+NN
                .word nt_asm_stz
		.word xt_asm_sty_zx, z_asm_sty_zx
		.text "sty.zx"

nt_asm_stz:
		.byte 3, IM+NN
                .word nt_asm_stz_x
		.word xt_asm_stz, z_asm_stz
		.text "stz"

nt_asm_stz_x:
		.byte 5, IM+NN
                .word nt_asm_stz_z
		.word xt_asm_stz_x, z_asm_stz_x
		.text "stz.x"

nt_asm_stz_z:
		.byte 5, IM+NN
                .word nt_asm_stz_zx
		.word xt_asm_stz_z, z_asm_stz_z
		.text "stz.z"

nt_asm_stz_zx:
		.byte 6, IM+NN
                .word nt_asm_tax
		.word xt_asm_stz_zx, z_asm_stz_zx
		.text "stz.zx"

nt_asm_tax:
		.byte 3, IM+NN
                .word nt_asm_tay
		.word xt_asm_tax, z_asm_tax
		.text "tax"

nt_asm_tay:
		.byte 3, IM+NN
                .word nt_asm_trb
		.word xt_asm_tay, z_asm_tay
		.text "tay"

nt_asm_trb:
		.byte 3, IM+NN
                .word nt_asm_trb_z
		.word xt_asm_trb, z_asm_trb
		.text "trb"

nt_asm_trb_z:
		.byte 5, IM+NN
                .word nt_asm_tsb
		.word xt_asm_trb_z, z_asm_trb_z
		.text "trb.z"

nt_asm_tsb:
		.byte 3, IM+NN
                .word nt_asm_tsb_z
		.word xt_asm_tsb, z_asm_tsb
		.text "tsb"

nt_asm_tsb_z:
		.byte 5, IM+NN
                .word nt_asm_tsx
		.word xt_asm_tsb_z, z_asm_tsb_z
		.text "tsb.z"

nt_asm_tsx:
		.byte 3, IM+NN
                .word nt_asm_txa
		.word xt_asm_tsx, z_asm_tsx
		.text "tsx"

nt_asm_txa:
		.byte 3, IM+NN
                .word nt_asm_txs
		.word xt_asm_txa, z_asm_txa
		.text "txa"

nt_asm_txs:
		.byte 3, IM+NN
                .word nt_asm_tya
		.word xt_asm_txs, z_asm_txs
		.text "txs"

nt_asm_tya:
		.byte 3, IM+NN
                .word nt_asm_arrow
		.word xt_asm_tya, z_asm_tya
		.text "tya"

; Assembler pseudo-instructions, directives and macros

nt_asm_arrow:   ; uses same code as HERE, but immediate
                .byte 3, IM
                .word nt_asm_back_jump
                .word xt_asm_arrow, z_asm_arrow
                .text "-->"


nt_asm_back_jump:  ; syntactic sugar, does nothing
                .byte 2, IM
                .word nt_asm_back_branch
                .word xt_asm_back_jump, z_asm_back_jump
                .text "<j"

nt_asm_back_branch:
                .byte 2, IM
                .word nt_asm_push_a
                .word xt_asm_back_branch, z_asm_back_branch
                .text "<b"

nt_asm_push_a:
                .byte 6, IM+NN
                .word 0000
                .word xt_asm_push_a, z_asm_push_a
                .text "push-a"
.endif
; END of ASSEMBLER-WORDLIST

; END
