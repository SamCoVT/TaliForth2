Tali Forth is an excellent platform for playing directly with hardware.  Tali
lets you poke and prod hardware interactively.  Once you figure out how to use the
hardware directly, you can write new words to access the hardware.  These words
can be tested interactively and then be used to write an application that uses the
hardware.

This tutorial shows how to interface some LEDs and pushbutton switches on a Ben
Eater style 65C02 computer with a serial port (recommended for Tali) and the
switches and LEDs wires to PORTA of a 65C22 Versatile Interface Adapter (VIA).
For this example, the VIA will be memory mapped starting at address $6000 and
the LEDs and pushbutton switches will be wired as shown here.  If your hardware
is different, you can adjust the Forth source code accordingly.

=== The Hardware

image::pics/tutorial_hardware_buttons_and_LEDs.png[]

The LEDs are connected to Port A bits 0-3 and the pushbutton switches are
connected to Port A bits 4-7.  The LEDs are wired such that a "1" in a bit will
light up that LED, while a "0" will turn off that LED.  The switches are wired
in an "active low" configuration, such that pressing a switch will result in a
"0" on that bit, and releasing the switch will result in a "1" on that bit.
Although that may seem backwards, this is a standard method for wiring up
pushbuttons.  Our software will need to account for the fact that the switches
are active low.

=== The Software

The first step is to initialize Port A of the VIA so that bits 0-3 are outputs
(to the LEDs) and bits 4-7 are inputs (from the switches).  The datasheet for
the W65C22 will be our reference material (available directly from WDC at
https://www.westerndesigncenter.com/wdc/documentation/w65c22.pdf).

Referencing Table 2-1 and reading section 2.1 in the W65C22 VIA datasheet shows
that we will need to access the Data Direction Register A (register 3) to set
the direction of the pins as well as Input Register A and Output Register A
(both at register 1 - we'll just name this PA for "Port A" and use that for both
input and output).  To get started, we will make names for these two registers
in the VIA.


```
\ Name the starting address for the VIA.
\ The registers are memory mapped, so register 3 will be
\ 3 higher than the base address.  Change this address if
\ your VIA is in a different location.
$6000 constant via_base_address

\ Name the two registers we will use.
\ Calculate their addresses based on the base address.
via_base_address 1 +  constant PA    \ Port A data
via_base_address 3 +  constant DDRA  \ Port A data direction
```

Now we can make bits 0-3 outputs by writing a value to DDRA (Data Direction
Register A) that has 1s where we want output pins.  We'll use binary values in
this code (starts with % for binary and bit #0 is on the right side) to make it
easy to see the individual bits, but the values can be given in any base that
Forth supports.  We'll also turn on every other LED so it will be easy to see if
our code is working.  Because these registers are 8-bits wide, we will use C!
(Character Store), which stores a single byte at the given address (both given
on the stack).


```
\ Make bits 0-3 on Port A outputs.
%00001111 DDRA C!
\ Turn on every other LED.
%00001010 PA C!
```

That's it!  We are now able to directly control the LEDs from Forth just by
writing a new value to the PA memory location in Forth.  Let's make some helper
words to make working with the LEDs a bit easier.

```
: LED_Init ( -- )  \ Initialize the LED pins as outputs.
   %00001111 DDRA C! ;
: LED! ( c -- )  \ Send byte to LEDs (only bits 0-3 used).
   PA C! ;
```

When the hardware is first powered up, we will need to run LED_Init once (it
won't hurt if it is run again, but it should be run at least once).  After
that, we can just use LED! to send a new pattern to the LEDs.

```
: mydelay ( -- ) \ A simple delay - adjust first number to adjust speed.
   10000 0 do loop ;
: LED_Dance ( -- ) \ Make the LEDs dance
   10 0 do         \ Loop 10 times
      $1100 LED! mydelay
      $0110 LED! mydelay
      $0011 LED! mydelay
      $1001 LED! mydelay
   loop ;

\ Try it out.
LED_Dance
```

Now that we have control of the LEDs, lets move on to the switches.  These are
wired in an "active low" configuration, so they give a "0" when pressed and a
"1" when not pressed.  We'll start with SW1, which is wired to PA4 so it will be
in bit 4 when we read from Port A.  We will use the C@ (Character Fetch) word to
read an 8-bit value from PA.  Let's use C@ directly first, and then we will make
some helper words for determining if each switch is pressed or not.

```
\ Read the value on Port A and print it out.
PA C@ .
```

`PA` puts the address of Port A on the stack.  `C@` reads the value at that
address and leaves that on the stack.  Finally, `.` prints the value on the
stack.  This will print out the byte value from Port A, however it will contain
both the values of the switches as well as the bits for the LEDs.  By pressing
different switches while running this code, you can see that the value changes.
(Hint: You can press CTRL-P to bring up the previous line of Forth code if you
want to run it again - Tali remembers the last 8 lines.)

We will want to "mask" the bits that we are not interested in - in this case by
forcing them all to be zeroes.  We will use the AND instruction to do that, and
it needs a bitmask (a special value to indicate which bits we want) that has a 1
in the bit location we are interested in and zeroes in all other bits.  For SW1,
on bit 4, that might look like this:

```
PA C@  %00010000 AND  .
```

This code is only interested in the switch on bit 4 (SW1).  When that switch is
pressed, bit 4 will be read as a zero (because the switches are active low).
This code zeroes out all of the other bits, so the result of this code will be
zero when the switch is pressed.  Do note that you don't get "1" as the result
when the switch is not pressed, but rather 16 (assuming Tali is in decimal
mode).  That's because bit 4 has the decimal value of 16.  The value for any bit
can be determined by raising 2 to the bit number.

To check a different switch, just change the bitmask.

```
\ Check SW2 on bit 5.
PA C@  %00100000 AND  .
```

This code will print the current status of switch SW2 on bit 5.  It also prints
0 when the switch is pressed, but this prints 64 when the switch is released
because bit 5's value is twice that of bit 4.

What we want are some helper words for each button to tell if they are pressed
or not.  We can then use whether they are pressed or not as a true/false value
to control loops and IF statements.  Words that test for something and return a
true or false value usually end with a question mark in the name.


```
: SW1?  ( -- f ) \ Return TRUE if SW1 is pressed.
   PA C@  %00010000 AND  0= ;
```

Note that we are not printing the result here, but we are checking to see if it
is zero or not and leaving the true or false result from `0=` on the stack for
other code to use.  Our stack comment indicates that this word leaves a flag on
the stack after it is run.  Other words could be create for the other buttons by
changing the bitmask.

Finally, let's put this all together and have the LEDs dance until the SW1
switch is pressed.  Note that you may need to hold the button down for a bit, as
it's only checked at one point during the LED dance.

```
: LED_Dance2 ( -- ) \ Dance the LEDs until SW1 pressed.
   BEGIN
      $1100 LED! mydelay
      $0110 LED! mydelay
      $0011 LED! mydelay
      $1001 LED! mydelay
   SW1? UNTIL ;

\ Try it out.
LED_Dance2
```

////
This tutorial shows how to interface with an LCD on a Ben Eater style 65C02
computer with a serial port (recommended for Tali) and LCD wired to PORTB of a
65C22 as shown here: https://eater.net/schematics/6502-serial.png

The important details are that the 65C22 Versatile Interface Adapter (called the
VIA from here on) is memory mapped starting at address $6000, the LCD DB4-7
(data pins) are connected to VIA pins PB0-3, LCD RS (register select) is
connected to VIA PB4, LCD R/W* (read/write*) is connected to VIA PB5, and LCD E
(enable) is connected to VIA PB6.  Note that the LCD DB0-3 pins are not
connected, meaning we will need to run the LCD in 4-bit mode.  This is often
done with LCDs to reduce the number of I/O pins needed to run them - do note
that the earlier Ben Eater design (without serial port) had a different
connection scheme and used the LCD in 8-bit mode.

The reference materials to consult will be the W65C22 datasheet for the VIA and
the Hitachi HD44780U datasheet (your character LCD likely either has this
chipset or a clone of it - search for "ADE-207-272(Z)" to locate the exact
version used here).

Because the LCD is connected to the VIA, we will need to initialize the VIA
first, and then the LCD.  We need bits 0-6 of Port B on the VIA to be outputs.
Reading in the W65C22 VIA datasheet shows that we will need to access the Data
Direction Register B (register 2) to set the direction of the pins and Output
Register B (register 0) to send the data and commands to the LCD. To get
started, we will make names for these two registers in the VIA.

```
\ Name the starting address for the VIA.
\ The registers are memory mapped, so register 2 will be
\ 2 higher than the base address.  Change this address if
\ your VIA is in a different location.
$6000 constant via_base_address

\ Name the two registers we will use.
\ Calculate their addresses based on the base address.
via_base_address     constant PB    \ Port B data
via_base_address 2 + constant DDRB  \ Port B data direction
```

Now we can try making the pins outputs and make sure we can control them.
You can test the pins for HIGH and LOW using a multimeter or LED + resistor.
The VIA datasheet says putting a 1 into a bit in the Data Direction Register
makes the corresponding port bit an output, so we need to put 1s in bits 0
through 6.

When accessing 8-bit memory locations (and the hardware we are using is memory
mapped), the Forth words `C@` (character fetch) and `C!` (character store) can
be used to directly read and write those locations.  We'll use `C!` here to
directly control the VIA from Forth.  The % in front of the number tells Tali
that the number is given directly in binary (you can use $ instead if you prefer
hex)

```
\ Make PB0 through PB6 outputs.
%01111111 DDRB C!
```
Once we run this, the pins should be outputs and will stay that way until we
reset or power cycle the hardware.  Now we can write to the Port B data register
to control what is output on those pins and use a multimeter to verify it's
working and we have control of the VIA.  We'll use a value that has alternating
0s and 1s for testing.

```
\ Make every other bit a 1.
%01010101 PB C!
```

The pins should change immediately after running this code.  As you can see,
using C! lets you directly poke the hardware to ask it to do thing.  Once this
has been verified to be working, we'll make some helper words to make working
with the VIA easier.  (The part in parenthesis is a stack comment and it shows
what the word accepts from the stack and leaves on the stack.  It's OK to ignore
it for now if you are unfamiliar with stack comments.)

```
\ Initialize the VIA with Port B bits 0-6 set up as outputs.
: Init_VIA ( -- )   %01111111 DDRB C! ;
\ Write a value (given on the stack) to the Port B pins.
: PB! ( u -- )   PB C! ;
\ Get the current value of PB pins.
: PB@ ( -- u )   PB C@ ;
```

You'll note that the Init_VIA word contains exactly the same code we ran
directly earlier, while the PB! is missing the value.  That's because PB! is
expecting the value to already be on the stack, and you can use this word by
placing the value you want sent to Port B on the stack and then running PB! like
"%00001111 PB!".

Once these words are defined, we can use them to start talking to the LCD.  In
the HD44780U datasheet on page 33, it shows a timing diagram for writing to the
LCD using 4-bit mode.  Only DB7 (bit 7) of the data is shown, but you are
supposed to send the upper nybble (4-bits, or half a byte) first and then the
lower nybble using the same data lines.  Even though the LCD is using DB4-DB7,
those are connected to bits 0-3 of Port B on the VIA, so we will need to write
our commands to bits 0-3 of Port B on the VIA.

For each command sent to the LCD, the E (enable) line needs to be strobed, which
is simply bringing it high and then low.  The R/W* (read/write*) line tells the
LCD if we are reading or writing, with a 0 meaning we are writing.  Finally, the
RS (register select) line will be 0 for commands (like clear the screen or move
the cursor) and 1 of data (eg. the text to display). 

To send a command to the LCD, we need to make the RS bit a 0, R/W* a zero, E a
zero, and the nybble we want to send on the data lines.  Then we can strobe the
E line by making it high, and then low.  This transfers the nybble to the LCD.
To send another nybble (two need to be sent for each byte), you just change the
data a strobe the E line again.

The bad news is that LCDs start up in 8-bit mode and we need to do a special
dance to initialize them into 4-bit mode.  The good news is that the datasheet
tells us exactly the steps to this initialization dance on page 46 (not shown at
each step is a strobe of the E line).  This dance is complicated enough that we
will write some words to help us out.

```
\ Give names to the control lines.
%01000000 constant LCD_E    \ VIA PB6
%00100000 constant LCD_R/W* \ VIA PB5, valid forth name
%00010000 constant LCD_RS   \ VIA PB4

: LCD_strobe ( -- )     \ Bring the strobe light high then low.
  PB  @                 \ Get the current value of PB.
  DUP  LCD_E OR  PB!    \ Turn on just the E bit.
  LCD_E INVERT AND  PB! \ Turn off just the E bit.
  ;

: LCD_send_nybble ( u -- ) \ Send 4-bit value to LCD.
  %00001111 AND  \ Make sure only lower 4 bits used.
  PB@            \ Get current value on PB.
  %11110000 AND  \ zero out the lower 4 bits and
  OR DUP PB!     \ replace with nybble.
  LCD_strobe     \ Send the nybble to the LCD.
  ;

: LCD_send_byte ( u -- ) \ Send 8-bit value in two nybbles.
  \ Send the upper nybble first.
  DUP  4 rshift  LCD_send_nybble
  \ Send the lower nybble next.
  LCD_send_nybble
  ;

: LCD_command ( u -- ) \ Send command to LCD
  \ Make RS a zero.
  PB@  LCD_RS INVERT AND  PB!
  \ Send the command
  LCD_send_byte
  LCD_delay
  ;

: LCD_delay ( -- ) \ Simple delay to give LCD time to react.
  1000 0 do loop ;

: LCD_Init ( -- )
  0 PB! \ Zero out the LCD data and control lines to start.
  \ Force to 8-bit mode (even through we want 4-bit)
  %00000011 LCD_send_nybble LCD_delay
  %00000011 LCD_send_nybble LCD_delay
  %00000011 LCD_send_nybble LCD_delay
  \ Set to 4-bit mode
  %00000010 LCD_send_nybble LCD_delay
  \ Now we can send commands normally.
  %00100000 LCD_command \ 4-bit mode, 2 lines, 5x8 font
  %00010000 LCD_command \ move cursor after each char
  %00001110 LCD_command \ Display on, cursor on, no blinking
  %00000110 LCD_command \ cursor moves right
  %00000001 LCD_command \ Clear the screen
  ;

: LCD_char ( u -- ) \ Put a character on the screen.
  \ Make RS a one.
  PB@  LCD_RS OR  PB!
  \ Send the command
  LCD_send_byte
  LCD_delay
  ;
```

The three main words that will be used in applications are LCD_Init to
initialize the LCD into 4-bit mode, LCD_command to send commands to the LCD (see
pages 24-25 of the HD44780U datasheet for available commands), and LCD_char to
send text for the LCD to display.  Lets test these by printing a * on the
screen.

```
LCD_Init
42 LCD_char \ 42 is the ASCII value for *
```

If all is well, the LCD screen should have just a * on it, with a cursor in the
next location.  If anything isn't working, we can run the guts of a word
interactively and check the hardware pins to see where it goes wrong.  Once this
is working, we can print "Hi" next.

```
char H LCD_char
char i LCD_char
```

This is fine for very short messages, but it would be nice to be able to print
longer messages.  Next we will make a word that prints an entire string to the
LCD screen.

```
: LCD_type ( addr u -- ) \ Print a string to the LCD
 0 ?do \ Loop through all the characters
   dup i + c@  LCD_char \ Print the current letter to the LCD
 loop
 ;
```

Now we can print strings so the LCD.  Do note that S" needs a space before the
first letter of the string.

```
s" Hi there" LCD_type
```

We're making a bit of a mess on our LCD, so lets clear the screen.  That's
command 1 (%00000001) in the datasheet.

```
1 LCD_command
```

That seems handy enough we should make it into a word.

```
\ Clear the LCD screen.
: LCD_clear ( -- )   1 LCD_command ;
```

////