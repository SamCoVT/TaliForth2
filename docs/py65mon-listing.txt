
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Sun Jun  9 17:30:28 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../words/all.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 2d		lda #$2d	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd 37 b3	lda $b337,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad 37 b3	lda $b337	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f						_load_user_vars_loop:
.801f		b9 55 b3	lda $b355,y	                lda cold_user_table,y
.8022		91 08		sta ($08),y	                sta (up),y
.8024		88		dey		                dey
.8025		d0 f8		bne $801f	                bne _load_user_vars_loop
.8027		ad 55 b3	lda $b355	                lda cold_user_table
.802a		92 08		sta ($08)	                sta (up)
.802c		20 3a 84	jsr $843a	                jsr xt_cr
.802f		ca		dex		                dex
.8030		ca		dex		                dex
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		a9 38		lda #$38	                lda #<forth_words_start
.8035		95 02		sta $02,x	                sta 2,x
.8037		a9 ba		lda #$ba	                lda #>forth_words_start
.8039		95 03		sta $03,x	                sta 3,x
.803b		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803d		95 00		sta $00,x	                sta 0,x
.803f		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8041		95 01		sta $01,x	                sta 1,x
.8043		20 b2 88	jsr $88b2	                jsr xt_evaluate
.8046		9c 00 7c	stz $7c00	                stz hist_buff
.8049		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804c		9c 00 7d	stz $7d00	                stz hist_buff+$100
.804f		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8052		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8055		9c 80 7e	stz $7e80	                stz hist_buff+$280
.8058		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805b		9c 80 7f	stz $7f80	                stz hist_buff+$380
.805e						xt_abort:
.805e		a2 78		ldx #$78	                ldx #dsp0
.8060						xt_quit:
.8060		8a		txa		                txa             ; Save the DSP that we just defined
.8061		a2 ff		ldx #$ff	                ldx #rsp0
.8063		9a		txs		                txs
.8064		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8065		64 04		stz $04		                stz ip
.8067		64 05		stz $05		                stz ip+1
.8069		64 0a		stz $0a		                stz insrc
.806b		64 0b		stz $0b		                stz insrc+1
.806d		a9 00		lda #$00	                lda #0
.806f		a0 04		ldy #$04	                ldy #blk_offset
.8071		91 08		sta ($08),y	                sta (up),y
.8073		c8		iny		                iny
.8074		91 08		sta ($08),y	                sta (up),y
.8076		a9 fc		lda #$fc	                lda #(256-4)
.8078		85 1f		sta $1f		                sta loopctrl
.807a		64 1a		stz $1a		                stz state
.807c		64 1b		stz $1b		                stz state+1
.807e						_get_line:
.807e		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8080		85 0c		sta $0c		                sta cib
.8082		a9 02		lda #$02	                lda #>buffer0
.8084		85 0d		sta $0d		                sta cib+1
.8086		64 0e		stz $0e		                stz ciblen
.8088		64 0f		stz $0f		                stz ciblen+1
.808a		20 42 8f	jsr $8f42	                jsr xt_refill           ; ( -- f )
.808d		b5 00		lda $00,x	                lda 0,x
.808f		d0 05		bne $8096	                bne _success
.8091		a9 06		lda #$06	                lda #err_refill
.8093		4c 7e d7	jmp $d77e	                jmp error
.8096						_success:
.8096		e8		inx		                inx                     ; drop
.8097		e8		inx		                inx
.8098		20 e5 d6	jsr $d6e5	                jsr interpret
.809b		e0 78		cpx #$78	                cpx #dsp0
.809d		f0 05		beq $80a4	                beq _stack_ok
.809f		90 03		bcc $80a4	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a1		4c 7c d7	jmp $d77c	                jmp underflow_error
.80a4						_stack_ok:
.80a4		a5 1a		lda $1a		                lda state
.80a6		f0 02		beq $80aa	                beq _print
.80a8		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80aa						_print:
.80aa		20 cf d7	jsr $d7cf	                jsr print_string
.80ad		80 cf		bra $807e	                bra _get_line
.80af						z_cold:
.80af						z_abort:
.80af						z_quit:

;******  Processing file: platform/../words/core.asm

.80af						xt_abort_quote:
.80af		20 da 8f	jsr $8fda	                jsr xt_s_quote          ; S"
.80b2		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b4		a9 ba		lda #$ba	                lda #<abort_quote_runtime
.80b6		20 58 97	jsr $9758	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80b9		60		rts		z_abort_quote:  rts
.80ba						abort_quote_runtime:
.80ba		b5 04		lda $04,x	                lda 4,x
.80bc		15 05		ora $05,x	                ora 5,x
.80be		f0 09		beq $80c9	                beq _done       ; if FALSE, we're done
.80c0		20 b7 94	jsr $94b7	                jsr xt_type
.80c3		20 3a 84	jsr $843a	                jsr xt_cr
.80c6		4c 5e 80	jmp $805e	                jmp xt_abort    ; not JSR, so never come back
.80c9						_done:
.80c9		8a		txa		                txa
.80ca		18		clc		                clc
.80cb		69 06		adc #$06	                adc #6
.80cd		aa		tax		                tax
.80ce		60		rts		                rts
.80cf						xt_abs:
.80cf		20 68 d7	jsr $d768	                jsr underflow_1
.80d2		b5 01		lda $01,x	                lda 1,x
.80d4		10 0d		bpl $80e3	                bpl _done       ; positive number, easy money!
.80d6		38		sec		                sec
.80d7		a9 00		lda #$00	                lda #0
.80d9		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80db		95 00		sta $00,x	                sta 0,x
.80dd		a9 00		lda #$00	                lda #0          ; MSB
.80df		f5 01		sbc $01,x	                sbc 1,x
.80e1		95 01		sta $01,x	                sta 1,x
.80e3						_done:
.80e3		60		rts		z_abs:          rts
.80e4						xt_accept:
.80e4		20 6d d7	jsr $d76d	                jsr underflow_2
.80e7		b5 00		lda $00,x	                lda 0,x
.80e9		15 01		ora $01,x	                ora 1,x
.80eb		d0 09		bne $80f6	                bne _not_zero
.80ed		e8		inx		                inx
.80ee		e8		inx		                inx
.80ef		74 00		stz $00,x	                stz 0,x
.80f1		74 01		stz $01,x	                stz 1,x
.80f3		4c c2 81	jmp $81c2	                jmp accept_done
.80f6						_not_zero:
.80f6		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80f8		85 27		sta $27		                sta tmp2
.80fa		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fc		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.80fe		85 25		sta $25		                sta tmp1
.8100		b5 03		lda $03,x	                lda 3,x
.8102		85 26		sta $26		                sta tmp1+1
.8104		e8		inx		                inx
.8105		e8		inx		                inx
.8106		a0 00		ldy #$00	                ldy #0
.8108		a5 1c		lda $1c		                lda status
.810a		29 f7		and #$f7	                and #$F7
.810c		1a		inc a		                ina
.810d		09 08		ora #$08	                ora #%00001000
.810f		85 1c		sta $1c		                sta status
.8111						accept_loop:
.8111		20 b1 89	jsr $89b1	                jsr key_a
.8114		c9 0a		cmp #$0a	                cmp #AscLF
.8116		f0 20		beq $8138	                beq _eol
.8118		c9 0d		cmp #$0d	                cmp #AscCR
.811a		f0 1c		beq $8138	                beq _eol
.811c		c9 08		cmp #$08	                cmp #AscBS
.811e		f0 22		beq $8142	                beq _backspace
.8120		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8122		f0 1e		beq $8142	                beq _backspace
.8124		c9 10		cmp #$10	                cmp #AscCP
.8126		f0 36		beq $815e	                beq _ctrl_p
.8128		c9 0e		cmp #$0e	                cmp #AscCN
.812a		f0 44		beq $8170	                beq _ctrl_n
.812c		91 25		sta ($25),y	                sta (tmp1),y
.812e		c8		iny		                iny
.812f		20 c5 86	jsr $86c5	                jsr emit_a
.8132		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8134		d0 db		bne $8111	                bne accept_loop       ; fall through if buffer limit reached
.8136		80 03		bra $813b	                bra _buffer_full
.8138						_eol:
.8138		20 cb 91	jsr $91cb	                jsr xt_space    ; print final space
.813b						_buffer_full:
.813b		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813d		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.813f		4c c2 81	jmp $81c2	                jmp accept_done
.8142						_backspace:
.8142		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8144		d0 06		bne $814c	                bne +
.8146		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8148		20 c5 86	jsr $86c5	                jsr emit_a
.814b		c8		iny		                iny
.814c						+
.814c		88		dey		                dey
.814d		a9 08		lda #$08	                lda #AscBS      ; move back one
.814f		20 c5 86	jsr $86c5	                jsr emit_a
.8152		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8154		20 c5 86	jsr $86c5	                jsr emit_a
.8157		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8159		20 c5 86	jsr $86c5	                jsr emit_a
.815c		80 b3		bra $8111	                bra accept_loop
.815e						_ctrl_p:
.815e		a5 1c		lda $1c		                lda status
.8160		29 07		and #$07	                and #7
.8162		d0 08		bne $816c	                bne _ctrl_p_dec
.8164		a5 1c		lda $1c		                lda status
.8166		09 07		ora #$07	                ora #7
.8168		85 1c		sta $1c		                sta status
.816a		80 11		bra $817d	                bra _recall_history
.816c						_ctrl_p_dec:
.816c		c6 1c		dec $1c		                dec status
.816e		80 0d		bra $817d	                bra _recall_history
.8170						_ctrl_n:
.8170		a9 08		lda #$08	                lda #$8
.8172		24 1c		bit $1c		                bit status
.8174		d0 07		bne $817d	                bne _recall_history
.8176		a5 1c		lda $1c		                lda status
.8178		29 f7		and #$f7	                and #$F7
.817a		1a		inc a		               ina
.817b		85 1c		sta $1c		                sta status
.817d						_recall_history:
.817d		a9 08		lda #$08	                lda #%00001000
.817f		14 1c		trb $1c		                trb status
.8181		20 dd 81	jsr $81dd	                jsr accept_total_recall
.8184		a9 0d		lda #$0d	                lda #AscCR
.8186		20 c5 86	jsr $86c5	                jsr emit_a
.8189						input_clear:
.8189		c0 00		cpy #$00	                cpy #0
.818b		f0 08		beq $8195	                beq input_cleared
.818d		a9 20		lda #$20	                lda #AscSP
.818f		20 c5 86	jsr $86c5	                jsr emit_a
.8192		88		dey		                dey
.8193		80 f4		bra $8189	                bra input_clear
.8195						input_cleared:
.8195		a9 0d		lda #$0d	                lda #AscCR
.8197		20 c5 86	jsr $86c5	                jsr emit_a
.819a		b1 29		lda ($29),y	                lda (tmp3),y
.819c		85 1d		sta $1d		                sta status+1
.819e		e6 29		inc $29		                inc tmp3
.81a0		d0 02		bne $81a4	                bne +           ; Increment the upper byte on carry.
.81a2		e6 2a		inc $2a		                inc tmp3+1
.81a4						+
.81a4		a9 0d		lda #$0d	                lda #AscCR
.81a6		20 c5 86	jsr $86c5	                jsr emit_a
.81a9						_history_loop:
.81a9		c4 1d		cpy $1d		                cpy status+1
.81ab		d0 03		bne $81b0	                bne +
.81ad		4c 11 81	jmp $8111	                jmp accept_loop       ; Needs a long jump
.81b0						+
.81b0		c4 27		cpy $27		                cpy tmp2
.81b2		f0 0a		beq $81be	                beq _hist_filled_buffer
.81b4		b1 29		lda ($29),y	                lda (tmp3),y
.81b6		91 25		sta ($25),y	                sta (tmp1),y
.81b8		20 c5 86	jsr $86c5	                jsr emit_a
.81bb		c8		iny		                iny
.81bc		80 eb		bra $81a9	                bra _history_loop
.81be						_hist_filled_buffer:
.81be		88		dey		                dey
.81bf		4c 11 81	jmp $8111	                jmp accept_loop
.81c2						accept_done:
.81c2		20 dd 81	jsr $81dd	                jsr accept_total_recall
.81c5		85 1d		sta $1d		                sta status+1
.81c7		a0 00		ldy #$00	                ldy #0
.81c9		91 29		sta ($29),y	                sta (tmp3),y
.81cb		e6 29		inc $29		                inc tmp3
.81cd		d0 02		bne $81d1	                bne +           ; Increment the upper byte on carry.
.81cf		e6 2a		inc $2a		                inc tmp3+1
.81d1						+
.81d1						_save_history_loop:
.81d1		c4 1d		cpy $1d		                cpy status+1
.81d3		f0 07		beq $81dc	                beq _save_history_done
.81d5		b1 25		lda ($25),y	                lda (tmp1),y
.81d7		91 29		sta ($29),y	                sta (tmp3),y
.81d9		c8		iny		                iny
.81da		80 f5		bra $81d1	                bra _save_history_loop
.81dc						_save_history_done:
.81dc						z_accept:
.81dc		60		rts		                rts
.81dd						accept_total_recall:
.81dd		a9 00		lda #$00	                lda #<hist_buff
.81df		85 29		sta $29		                sta tmp3
.81e1		a9 7c		lda #$7c	                lda #>hist_buff
.81e3		85 2a		sta $2a		                sta tmp3+1
.81e5		a5 1c		lda $1c		                lda status
.81e7		6a		ror a		                ror
.81e8		29 03		and #$03	                and #3
.81ea		18		clc		                clc
.81eb		65 2a		adc $2a		                adc tmp3+1
.81ed		85 2a		sta $2a		                sta tmp3+1
.81ef		a5 1c		lda $1c		                lda status
.81f1		6a		ror a		                ror             ; Rotate through carry into msb.
.81f2		6a		ror a		                ror
.81f3		29 80		and #$80	                and #$80
.81f5		18		clc		                clc
.81f6		65 29		adc $29		                adc tmp3
.81f8		85 29		sta $29		                sta tmp3
.81fa		90 02		bcc $81fe	                bcc +           ; Increment the upper byte on carry.
.81fc		e6 2a		inc $2a		                inc tmp3+1
.81fe						+
.81fe		98		tya		                tya
.81ff		c9 80		cmp #$80	                cmp #$80
.8201		90 02		bcc $8205	                bcc +
.8203		a9 7f		lda #$7f	                lda #$7F
.8205						+
.8205		60		rts		                rts
.8206						xt_action_of:
.8206		a5 1a		lda $1a		                lda state
.8208		05 1b		ora $1b		                ora state+1
.820a		f0 0c		beq $8218	                beq _interpreting
.820c		20 14 83	jsr $8314	                jsr xt_bracket_tick
.820f		a0 85		ldy #$85	                ldy #>xt_defer_fetch
.8211		a9 44		lda #$44	                lda #<xt_defer_fetch
.8213		20 58 97	jsr $9758	                jsr cmpl_subroutine
.8216		80 06		bra $821e	                bra _done
.8218						_interpreting:
.8218		20 42 92	jsr $9242	                jsr xt_tick
.821b		20 44 85	jsr $8544	                jsr xt_defer_fetch
.821e						_done:
.821e		60		rts		z_action_of:           rts
.821f						xt_again:
.821f		20 68 d7	jsr $d768	                jsr underflow_1
.8222		20 71 97	jsr $9771	                jsr cmpl_jump_tos
.8225		60		rts		z_again:        rts
.8226						xt_align:
.8226						xt_aligned:
.8226						z_align:
.8226						z_aligned:
.8226		60		rts		                rts             ; stripped out during native compile
.8227						xt_allot:
.8227		20 68 d7	jsr $d768	                jsr underflow_1
.822a		b5 01		lda $01,x	                lda 1,x
.822c		30 22		bmi $8250	                bmi _release
.822e		18		clc		                clc
.822f		a5 00		lda $00		                lda cp
.8231		75 00		adc $00,x	                adc 0,x
.8233		85 00		sta $00		                sta cp
.8235		a5 01		lda $01		                lda cp+1
.8237		75 01		adc $01,x	                adc 1,x
.8239		85 01		sta $01		                sta cp+1
.823b		a0 00		ldy #$00	                ldy #<cp_end
.823d		c4 00		cpy $00		                cpy cp
.823f		a9 7c		lda #$7c	                lda #>cp_end
.8241		e5 01		sbc $01		                sbc cp+1
.8243		b0 48		bcs $828d	                bcs _done               ; we're fine.
.8245		84 00		sty $00		                sty cp                  ; still #<cp_end
.8247		a9 7c		lda #$7c	                lda #>cp_end
.8249		85 01		sta $01		                sta cp+1
.824b		a9 00		lda #$00	                lda #err_allot
.824d		4c 7e d7	jmp $d77e	                jmp error
.8250						_release:
.8250		ca		dex		                dex
.8251		ca		dex		                dex
.8252		a5 00		lda $00		                lda cp
.8254		95 00		sta $00,x	                sta 0,x
.8256		a5 01		lda $01		                lda cp+1
.8258		95 01		sta $01,x	                sta 1,x
.825a		20 53 8e	jsr $8e53	                jsr xt_plus                     ; new CP is now TOS
.825d		ca		dex		                dex
.825e		ca		dex		                dex                             ; new CP now NOS
.825f		a9 00		lda #$00	                lda #<cp0
.8261		95 00		sta $00,x	                sta 0,x
.8263		a9 03		lda #$03	                lda #>cp0
.8265		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8267		20 a6 d6	jsr $d6a6	                jsr compare_16bit               ; still ( CP CP0 )
.826a		f0 17		beq $8283	                beq _nega_done
.826c		30 15		bmi $8283	                bmi _nega_done
.826e		a9 00		lda #$00	                lda #<cp0
.8270		85 00		sta $00		                sta cp
.8272		a9 03		lda #$03	                lda #>cp0
.8274		85 01		sta $01		                sta cp+1
.8276		a9 1a		lda #$1a	                lda #<dictionary_start
.8278		85 02		sta $02		                sta dp
.827a		a9 bb		lda #$bb	                lda #>dictionary_start
.827c		85 03		sta $03		                sta dp+1
.827e		a9 0a		lda #$0a	                lda #err_negallot
.8280		4c 7e d7	jmp $d77e	                jmp error
.8283						_nega_done:
.8283		b5 02		lda $02,x	                lda 2,x
.8285		85 00		sta $00		                sta cp
.8287		b5 03		lda $03,x	                lda 3,x
.8289		85 01		sta $01		                sta cp+1
.828b		e8		inx		                inx
.828c		e8		inx		                inx                     ; drop through to _done
.828d						_done:
.828d		e8		inx		                inx
.828e		e8		inx		                inx
.828f						z_allot:
.828f		60		rts		                rts
.8290						xt_and:
.8290		20 6d d7	jsr $d76d	                jsr underflow_2
.8293		b5 00		lda $00,x	                lda 0,x
.8295		35 02		and $02,x	                and 2,x
.8297		95 02		sta $02,x	                sta 2,x
.8299		b5 01		lda $01,x	                lda 1,x
.829b		35 03		and $03,x	                and 3,x
.829d		95 03		sta $03,x	                sta 3,x
.829f		e8		inx		                inx
.82a0		e8		inx		                inx
.82a1		60		rts		z_and:          rts
.82a2						xt_at_xy:
.82a2		20 6d d7	jsr $d76d	                jsr underflow_2
.82a5		a5 18		lda $18		                lda base
.82a7		48		pha		                pha
.82a8		a9 0a		lda #$0a	                lda #10
.82aa		85 18		sta $18		                sta base
.82ac		a9 1b		lda #$1b	                lda #AscESC
.82ae		20 c5 86	jsr $86c5	                jsr emit_a
.82b1		a9 5b		lda #$5b	                lda #'['
.82b3		20 c5 86	jsr $86c5	                jsr emit_a
.82b6		20 e9 8c	jsr $8ce9	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82b9		20 d5 d7	jsr $d7d5	                jsr print_u
.82bc		a9 3b		lda #$3b	                lda #';'
.82be		20 c5 86	jsr $86c5	                jsr emit_a
.82c1		20 e9 8c	jsr $8ce9	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82c4		20 d5 d7	jsr $d7d5	                jsr print_u
.82c7		a9 48		lda #$48	                lda #'H'
.82c9		20 c5 86	jsr $86c5	                jsr emit_a
.82cc		68		pla		                pla
.82cd		85 18		sta $18		                sta base
.82cf		60		rts		z_at_xy:        rts
.82d0						xt_backslash:
.82d0		a0 04		ldy #$04	                ldy #blk_offset
.82d2		b1 08		lda ($08),y	                lda (up),y
.82d4		c8		iny		                iny
.82d5		11 08		ora ($08),y	                ora (up),y
.82d7		f0 19		beq $82f2	                beq backslash_not_block
.82d9		a5 10		lda $10		                lda toin
.82db		29 3f		and #$3f	                and #$3F
.82dd		f0 1b		beq $82fa	                beq z_backslash
.82df		c9 01		cmp #$01	                cmp #$1
.82e1		f0 17		beq $82fa	                beq z_backslash
.82e3		a5 10		lda $10		                lda toin
.82e5		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.82e7		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.82e8		69 40		adc #$40	                adc #$40
.82ea		85 10		sta $10		                sta toin
.82ec		90 0c		bcc $82fa	                bcc z_backslash
.82ee		e6 11		inc $11		                inc toin+1
.82f0		80 08		bra $82fa	                bra z_backslash
.82f2						backslash_not_block:
.82f2		a5 0e		lda $0e		                lda ciblen
.82f4		85 10		sta $10		                sta toin
.82f6		a5 0f		lda $0f		                lda ciblen+1
.82f8		85 11		sta $11		                sta toin+1
.82fa		60		rts		z_backslash:    rts
.82fb						xt_base:
.82fb		ca		dex		                dex
.82fc		ca		dex		                dex
.82fd		a9 18		lda #$18	                lda #<base
.82ff		95 00		sta $00,x	                sta 0,x         ; LSB
.8301		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8303		60		rts		z_base:         rts
.8304						xt_bl:
.8304		ca		dex		                dex
.8305		ca		dex		                dex
.8306		a9 20		lda #$20	                lda #AscSP
.8308		95 00		sta $00,x	                sta 0,x
.830a		74 01		stz $01,x	                stz 1,x
.830c		60		rts		z_bl:           rts
.830d						xt_bracket_char:
.830d		20 53 83	jsr $8353	                jsr xt_char
.8310		20 f2 89	jsr $89f2	                jsr xt_literal
.8313		60		rts		z_bracket_char: rts
.8314						xt_bracket_tick:
.8314		20 42 92	jsr $9242	                jsr xt_tick
.8317		20 f2 89	jsr $89f2	                jsr xt_literal
.831a		60		rts		z_bracket_tick: rts
.831b						xt_buffer_colon:
.831b		20 40 84	jsr $8440	                jsr xt_create
.831e		20 27 82	jsr $8227	                jsr xt_allot
.8321		60		rts		z_buffer_colon: rts
.8322						xt_c_comma:
.8322		20 68 d7	jsr $d768	                jsr underflow_1
.8325		b5 00		lda $00,x	                lda 0,x
.8327		20 68 97	jsr $9768	                jsr cmpl_a
.832a		e8		inx		                inx
.832b		e8		inx		                inx
.832c		60		rts		z_c_comma:      rts
.832d						xt_c_fetch:
.832d		20 68 d7	jsr $d768	                jsr underflow_1
.8330		a1 00		lda ($00,x)	                lda (0,x)
.8332		95 00		sta $00,x	                sta 0,x
.8334		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8336		60		rts		z_c_fetch:      rts
.8337						xt_c_store:
.8337		20 6d d7	jsr $d76d	                jsr underflow_2
.833a		b5 02		lda $02,x	                lda 2,x
.833c		81 00		sta ($00,x)	                sta (0,x)
.833e		e8		inx		                inx
.833f		e8		inx		                inx
.8340		e8		inx		                inx
.8341		e8		inx		                inx
.8342		60		rts		z_c_store:      rts
.8343						xt_cell_plus:
.8343		20 68 d7	jsr $d768	                jsr underflow_1
.8346		f6 00		inc $00,x	                inc 0,x
.8348		d0 02		bne $834c	                bne +
.834a		f6 01		inc $01,x	                inc 1,x
.834c						+
.834c		f6 00		inc $00,x	                inc 0,x
.834e		d0 02		bne $8352	                bne _done
.8350		f6 01		inc $01,x	                inc 1,x
.8352						_done:
.8352		60		rts		z_cell_plus:    rts
.8353						xt_char:
.8353		20 51 8d	jsr $8d51	                jsr xt_parse_name
.8356		b5 00		lda $00,x	                lda 0,x
.8358		15 01		ora $01,x	                ora 1,x
.835a		d0 05		bne $8361	                bne _not_empty
.835c		a9 05		lda #$05	                lda #err_noname
.835e		4c 7e d7	jmp $d77e	                jmp error
.8361						_not_empty:
.8361		e8		inx		                inx             ; drop number of characters, leave addr
.8362		e8		inx		                inx
.8363		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8365		95 00		sta $00,x	                sta 0,x
.8367		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8369		60		rts		z_char:         rts
.836a						xt_chars:
.836a		20 68 d7	jsr $d768	                jsr underflow_1
.836d		60		rts		z_chars:        rts
.836e						xt_colon:
.836e		a5 1a		lda $1a		                lda state
.8370		05 1b		ora $1b		                ora state+1
.8372		f0 05		beq $8379	                beq +
.8374		a9 07		lda #$07	                lda #err_state
.8376		4c 7e d7	jmp $d77e	                jmp error
.8379						+
.8379		c6 1a		dec $1a		                dec state
.837b		c6 1b		dec $1b		                dec state+1
.837d		a9 40		lda #$40	                lda #%01000000
.837f		04 1c		tsb $1c		                tsb status
.8381		20 bf d6	jsr $d6bf	                jsr current_to_dp
.8384		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8386		48		pha		                pha
.8387		a5 02		lda $02		                lda dp
.8389		48		pha		                pha
.838a		a9 80		lda #$80	                lda #%10000000
.838c		04 1c		tsb $1c		                tsb status
.838e		20 40 84	jsr $8440	                jsr xt_create
.8391		20 bf d6	jsr $d6bf	                jsr current_to_dp   ; This might be able to be omitted
.8394		a5 02		lda $02		                lda dp
.8396		85 06		sta $06		                sta workword
.8398		a5 03		lda $03		                lda dp+1
.839a		85 07		sta $07		                sta workword+1
.839c		68		pla		                pla
.839d		85 02		sta $02		                sta dp
.839f		68		pla		                pla
.83a0		85 03		sta $03		                sta dp+1
.83a2		20 d2 d6	jsr $d6d2	                jsr dp_to_current
.83a5		a5 00		lda $00		                lda cp
.83a7		38		sec		                sec
.83a8		e9 03		sbc #$03	                sbc #3
.83aa		85 00		sta $00		                sta cp
.83ac		b0 02		bcs $83b0	                bcs _done
.83ae		c6 01		dec $01		                dec cp+1
.83b0						_done:
.83b0		60		rts		z_colon:        rts
.83b1						xt_colon_noname:
.83b1		a5 1a		lda $1a		                lda state
.83b3		05 1b		ora $1b		                ora state+1
.83b5		f0 05		beq $83bc	                beq +
.83b7		a9 07		lda #$07	                lda #err_state
.83b9		4c 7e d7	jmp $d77e	                jmp error
.83bc						+
.83bc		c6 1a		dec $1a		                dec state
.83be		c6 1b		dec $1b		                dec state+1
.83c0		a9 40		lda #$40	                lda #%01000000
.83c2		14 1c		trb $1c		                trb status
.83c4		a5 00		lda $00		                lda cp
.83c6		85 06		sta $06		                sta workword
.83c8		a5 01		lda $01		                lda cp+1
.83ca		85 07		sta $07		                sta workword+1
.83cc		60		rts		z_colon_noname:        rts
.83cd						xt_comma:
.83cd		20 68 d7	jsr $d768	                jsr underflow_1
.83d0		a0 02		ldy #$02	                ldy #2
.83d2		b5 00		lda $00,x	_twice:         lda 0,x
.83d4		20 68 97	jsr $9768	                jsr cmpl_a
.83d7		e8		inx		                inx
.83d8		88		dey		                dey
.83d9		d0 f7		bne $83d2	                bne _twice
.83db		60		rts		z_comma:        rts
.83dc						xt_compile_only:
.83dc		20 bf d6	jsr $d6bf	                jsr current_to_dp
.83df		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.83e1		b1 02		lda ($02),y	                lda (dp),y
.83e3		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.83e5		91 02		sta ($02),y	                sta (dp),y
.83e7		60		rts		z_compile_only: rts
.83e8						xt_value:
.83e8						xt_constant:
.83e8		20 68 d7	jsr $d768	                jsr underflow_1
.83eb		20 40 84	jsr $8440	                jsr xt_create
.83ee		38		sec		                sec
.83ef		a5 00		lda $00		                lda cp
.83f1		e9 02		sbc #$02	                sbc #2
.83f3		85 25		sta $25		                sta tmp1
.83f5		a5 01		lda $01		                lda cp+1
.83f7		e9 00		sbc #$00	                sbc #0
.83f9		85 26		sta $26		                sta tmp1+1
.83fb		a9 d0		lda #$d0	                lda #<doconst           ; LSB of DOCONST
.83fd		92 25		sta ($25)	                sta (tmp1)
.83ff		a0 01		ldy #$01	                ldy #1
.8401		a9 d5		lda #$d5	                lda #>doconst           ; MSB of DOCONST
.8403		91 25		sta ($25),y	                sta (tmp1),y
.8405		20 cd 83	jsr $83cd	                jsr xt_comma            ; drop through to adjust_z
.8408						adjust_z:
.8408		20 f7 9b	jsr $9bf7	                jsr xt_latestnt         ; gives us ( -- nt )
.840b		b5 00		lda $00,x	                lda 0,x
.840d		85 25		sta $25		                sta tmp1
.840f		b5 01		lda $01,x	                lda 1,x
.8411		85 26		sta $26		                sta tmp1+1
.8413		a0 06		ldy #$06	                ldy #6
.8415		b1 25		lda ($25),y	                lda (tmp1),y
.8417		18		clc		                clc
.8418		69 02		adc #$02	                adc #2
.841a		91 25		sta ($25),y	                sta (tmp1),y
.841c		c8		iny		                iny
.841d		b1 25		lda ($25),y	                lda (tmp1),y
.841f		69 00		adc #$00	                adc #0                  ; only need carry
.8421		91 25		sta ($25),y	                sta (tmp1),y
.8423		e8		inx		                inx
.8424		e8		inx		                inx
.8425						z_value:
.8425		60		rts		z_constant:     rts
.8426						xt_count:
.8426		20 68 d7	jsr $d768	                jsr underflow_1
.8429		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.842b		a8		tay		                tay
.842c		f6 00		inc $00,x	                inc 0,x         ; LSB
.842e		d0 02		bne $8432	                bne +
.8430		f6 01		inc $01,x	                inc 1,x         ; MSB
.8432		98		tya		+               tya
.8433		ca		dex		                dex
.8434		ca		dex		                dex
.8435		95 00		sta $00,x	                sta 0,x         ; LSB
.8437		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8439		60		rts		z_count:        rts
.843a						xt_cr:
.843a		a9 0a		lda #$0a	                lda #AscLF
.843c		20 c5 86	jsr $86c5	                jsr emit_a
.843f		60		rts		z_cr:           rts
.8440						xt_create:
.8440		20 51 8d	jsr $8d51	                jsr xt_parse_name       ; ( addr u )
.8443		b5 00		lda $00,x	                lda 0,x
.8445		15 01		ora $01,x	                ora 1,x
.8447		d0 05		bne $844e	                bne _got_name
.8449		a9 05		lda #$05	                lda #err_noname
.844b		4c 7e d7	jmp $d77e	                jmp error
.844e						_got_name:
.844e		74 01		stz $01,x	                stz 1,x
.8450		20 af 93	jsr $93af	                jsr xt_two_dup          ; ( addr u addr u )
.8453		20 ce 9a	jsr $9ace	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8456		b5 00		lda $00,x	                lda 0,x
.8458		15 01		ora $01,x	                ora 1,x
.845a		f0 1e		beq $847a	                beq _new_name           ; We haven't seen this one before.
.845c		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.845d		e8		inx		                inx
.845e		24 1c		bit $1c		                bit status
.8460		10 08		bpl $846a	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8462		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8464		05 1c		ora $1c		                ora status
.8466		85 1c		sta $1c		                sta status
.8468		80 18		bra $8482	                bra _process_name
.846a						_redefined_name:
.846a		a9 02		lda #$02	                lda #str_redefined
.846c		20 a4 d7	jsr $d7a4	                jsr print_string_no_lf
.846f		20 af 93	jsr $93af	                jsr xt_two_dup           ; ( addr u addr u )
.8472		20 b7 94	jsr $94b7	                jsr xt_type
.8475		20 cb 91	jsr $91cb	                jsr xt_space
.8478		80 08		bra $8482	                bra _process_name
.847a						_new_name:
.847a		e8		inx		                inx                     ; Drop flag (0) from find-name.
.847b		e8		inx		                inx
.847c		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.847e		25 1c		and $1c		                and status
.8480		85 1c		sta $1c		                sta status
.8482						_process_name:
.8482		b5 00		lda $00,x	                lda 0,x
.8484		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.8486		a5 00		lda $00		                lda cp
.8488		85 25		sta $25		                sta tmp1
.848a		a5 01		lda $01		                lda cp+1
.848c		85 26		sta $26		                sta tmp1+1
.848e		b5 00		lda $00,x	                lda 0,x
.8490		18		clc		                clc
.8491		69 08		adc #$08	                adc #8
.8493		85 29		sta $29		                sta tmp3                ; total header length
.8495		95 00		sta $00,x	                sta 0,x
.8497		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.8499		20 27 82	jsr $8227	                jsr xt_allot    ; ( addr )
.849c		20 bf d6	jsr $d6bf	                jsr current_to_dp
.849f		a0 00		ldy #$00	                ldy #0
.84a1		a5 27		lda $27		                lda tmp2
.84a3		91 25		sta ($25),y	                sta (tmp1),y
.84a5		a9 08		lda #$08	                lda #NN
.84a7		09 20		ora #$20	                ora #HC
.84a9		c8		iny		                iny
.84aa		91 25		sta ($25),y	                sta (tmp1),y
.84ac		c8		iny		                iny
.84ad		a5 02		lda $02		                lda dp
.84af		91 25		sta ($25),y	                sta (tmp1),y
.84b1		c8		iny		                iny
.84b2		a5 03		lda $03		                lda dp+1
.84b4		91 25		sta ($25),y	                sta (tmp1),y
.84b6		c8		iny		                iny
.84b7		a5 26		lda $26		                lda tmp1+1
.84b9		85 03		sta $03		                sta dp+1
.84bb		a5 25		lda $25		                lda tmp1
.84bd		85 02		sta $02		                sta dp
.84bf		18		clc		                clc
.84c0		65 29		adc $29		                adc tmp3        ; add total header length
.84c2		91 25		sta ($25),y	                sta (tmp1),y
.84c4		48		pha		                pha             ; we need this in the next step
.84c5		c8		iny		                iny
.84c6		a5 26		lda $26		                lda tmp1+1
.84c8		69 00		adc #$00	                adc #0          ; only need the carry
.84ca		91 25		sta ($25),y	                sta (tmp1),y
.84cc		c8		iny		                iny
.84cd		68		pla		                pla             ; LSB of "z_" address
.84ce		18		clc		                clc
.84cf		69 03		adc #$03	                adc #3
.84d1		91 25		sta ($25),y	                sta (tmp1),y
.84d3		88		dey		                dey             ; get the MSB of xt back
.84d4		b1 25		lda ($25),y	                lda (tmp1),y
.84d6		69 00		adc #$00	                adc #0          ; only need the carry
.84d8		c8		iny		                iny
.84d9		c8		iny		                iny
.84da		91 25		sta ($25),y	                sta (tmp1),y
.84dc		c8		iny		                iny
.84dd		b5 00		lda $00,x	                lda 0,x
.84df		38		sec		                sec
.84e0		e9 08		sbc #$08	                sbc #8
.84e2		85 23		sta $23		                sta tmptos
.84e4		b5 01		lda $01,x	                lda 1,x
.84e6		e9 00		sbc #$00	                sbc #0          ; only need carry
.84e8		85 24		sta $24		                sta tmptos+1
.84ea						_name_loop:
.84ea		b1 23		lda ($23),y	                lda (tmptos),y
.84ec		c9 5b		cmp #$5b	                cmp #'Z'+1
.84ee		b0 06		bcs $84f6	                bcs _store_name
.84f0		c9 41		cmp #$41	                cmp #'A'
.84f2		90 02		bcc $84f6	                bcc _store_name
.84f4		09 20		ora #$20	                ora #$20
.84f6						_store_name:
.84f6		91 25		sta ($25),y	                sta (tmp1),y
.84f8		c8		iny		                iny
.84f9		c6 27		dec $27		                dec tmp2
.84fb		d0 ed		bne $84ea	                bne _name_loop
.84fd		a0 d6		ldy #$d6	                ldy #>dovar
.84ff		a9 16		lda #$16	                lda #<dovar
.8501		20 58 97	jsr $9758	                jsr cmpl_subroutine
.8504		20 d2 d6	jsr $d6d2	                jsr dp_to_current
.8507		e8		inx		                inx
.8508		e8		inx		                inx
.8509		60		rts		z_create:       rts
.850a						xt_decimal:
.850a		a9 0a		lda #$0a	                lda #10
.850c		85 18		sta $18		                sta base
.850e		64 19		stz $19		                stz base+1              ; paranoid
.8510		60		rts		z_decimal:      rts
.8511						xt_defer:
.8511		20 40 84	jsr $8440	                jsr xt_create
.8514		a5 00		lda $00		                lda cp          ; LSB
.8516		38		sec		                sec
.8517		e9 02		sbc #$02	                sbc #2
.8519		85 25		sta $25		                sta tmp1
.851b		a5 01		lda $01		                lda cp+1        ; MSB
.851d		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.851f		85 26		sta $26		                sta tmp1+1
.8521		a0 00		ldy #$00	                ldy #0
.8523		a9 e4		lda #$e4	                lda #<dodefer   ; LSB
.8525		91 25		sta ($25),y	                sta (tmp1),y
.8527		c8		iny		                iny
.8528		a9 d5		lda #$d5	                lda #>dodefer   ; MSB
.852a		91 25		sta ($25),y	                sta (tmp1),y
.852c		a9 f8		lda #$f8	                lda #<defer_error
.852e		92 00		sta ($00)	                sta (cp)
.8530		e6 00		inc $00		                inc cp
.8532		d0 02		bne $8536	                bne +
.8534		e6 01		inc $01		                inc cp+1
.8536						+
.8536		a9 d5		lda #$d5	                lda #>defer_error
.8538		92 00		sta ($00)	                sta (cp)
.853a		e6 00		inc $00		                inc cp
.853c		d0 02		bne $8540	                bne +
.853e		e6 01		inc $01		                inc cp+1
.8540						+
.8540		20 08 84	jsr $8408	                jsr adjust_z    ; adjust header to correct length
.8543		60		rts		z_defer:        rts
.8544						xt_defer_fetch:
.8544		20 9e 92	jsr $929e	                jsr xt_to_body
.8547		20 1a 88	jsr $881a	                jsr xt_fetch
.854a		60		rts		z_defer_fetch:  rts
.854b						xt_defer_store:
.854b		20 9e 92	jsr $929e	                jsr xt_to_body
.854e		20 18 92	jsr $9218	                jsr xt_store
.8551		60		rts		z_defer_store:  rts
.8552						xt_depth:
.8552		a9 78		lda #$78	                lda #dsp0
.8554		86 1e		stx $1e		                stx tmpdsp
.8556		38		sec		                sec
.8557		e5 1e		sbc $1e		                sbc tmpdsp
.8559		4a		lsr a		                lsr
.855a		ca		dex		                dex
.855b		ca		dex		                dex
.855c		95 00		sta $00,x	                sta 0,x
.855e		74 01		stz $01,x	                stz 1,x
.8560		60		rts		z_depth:        rts
.8561						xt_question_do:
.8561		ca		dex		                dex
.8562		ca		dex		                dex
.8563		a9 a4		lda #$a4	                lda #<question_do_runtime
.8565		95 00		sta $00,x	                sta 0,x
.8567		a9 85		lda #$85	                lda #>question_do_runtime
.8569		95 01		sta $01,x	                sta 1,x
.856b		20 a0 86	jsr $86a0	                jsr xt_dup              ; xt and xt' are the same
.856e		ca		dex		                dex
.856f		ca		dex		                dex
.8570		a9 10		lda #$10	                lda #question_do_runtime_size
.8572		95 00		sta $00,x	                sta 0,x
.8574		74 01		stz $01,x	                stz 1,x
.8576		20 26 97	jsr $9726	                jsr cmpl_by_limit
.8579		90 0b		bcc $8586	                bcc _native
.857b		20 1b 89	jsr $891b	                jsr xt_here
.857e		20 cf 9d	jsr $9dcf	                jsr xt_zero
.8581		20 cd 83	jsr $83cd	                jsr xt_comma
.8584		80 08		bra $858e	                bra do_common
.8586						_native:
.8586		20 79 97	jsr $9779	                jsr cmpl_jump_later
.8589		80 03		bra $858e	                bra do_common
.858b						xt_do:
.858b		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; push 0 TOS
.858e						do_common:
.858e		ca		dex		                dex
.858f		ca		dex		                dex
.8590		a5 21		lda $21		                lda loopleave
.8592		95 00		sta $00,x	                sta 0,x
.8594		a5 22		lda $22		                lda loopleave+1
.8596		95 01		sta $01,x	                sta 1,x
.8598		64 22		stz $22		                stz loopleave+1
.859a		a0 85		ldy #$85	                ldy #>do_runtime
.859c		a9 bc		lda #$bc	                lda #<do_runtime
.859e		20 58 97	jsr $9758	                jsr cmpl_subroutine
.85a1		4c 1b 89	jmp $891b	                jmp xt_here
.85a4						z_question_do:
.85a4						z_do:
.85a4						question_do_runtime:
.85a4		b5 00		lda $00,x	                lda 0,x
.85a6		d5 02		cmp $02,x	                cmp 2,x
.85a8		d0 0d		bne $85b7	                bne _begin
.85aa		b5 01		lda $01,x	                lda 1,x
.85ac		d5 03		cmp $03,x	                cmp 3,x
.85ae		d0 07		bne $85b7	                bne _begin
.85b0		e8		inx		                inx                     ; drop loop limits and skip
.85b1		e8		inx		                inx
.85b2		e8		inx		                inx
.85b3		e8		inx		                inx
=16						question_do_runtime_size = * - question_do_runtime
.85b4		a9 00		lda #$00	                lda #0
>85b6		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.85b7		a9 01		lda #$01	_begin:         lda #1
.85b9		4c 12 98	jmp $9812	                jmp zbranch_runtime
.85bc						do_runtime:
.85bc		a4 1f		ldy $1f		                ldy loopctrl
.85be		30 05		bmi $85c5	                bmi +                   ; is this the first LCB?
.85c0		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.85c2		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.85c5						+
.85c5		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.85c6		c8		iny		                iny
.85c7		c8		iny		                iny
.85c8		c8		iny		                iny
.85c9		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.85cb		38		sec		                sec
.85cc		a9 00		lda #$00	                lda #0
.85ce		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.85d0		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.85d3		a9 80		lda #$80	                lda #$80
.85d5		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.85d7		99 03 01	sta $0103,y	                sta loopfufa+1,y
.85da		18		clc		                clc
.85db		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.85dd		79 02 01	adc $0102,y	                adc loopfufa,y
.85e0		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.85e2		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.85e4		79 03 01	adc $0103,y	                adc loopfufa+1,y
.85e7		99 01 01	sta $0101,y	                sta loopindex+1,y
.85ea		e8		inx		                inx                 ; clean up the stack
.85eb		e8		inx		                inx
.85ec		e8		inx		                inx
.85ed		e8		inx		                inx
.85ee		60		rts		                rts
.85ef						xt_does:
.85ef		a0 85		ldy #$85	                ldy #>does_runtime
.85f1		a9 fe		lda #$fe	                lda #<does_runtime
.85f3		20 58 97	jsr $9758	                jsr cmpl_subroutine
.85f6		a0 d5		ldy #$d5	                ldy #>dodoes
.85f8		a9 fd		lda #$fd	                lda #<dodoes
.85fa		20 58 97	jsr $9758	                jsr cmpl_subroutine
.85fd		60		rts		z_does:         rts
.85fe						does_runtime:
.85fe		7a		ply		                ply             ; LSB
.85ff		68		pla		                pla             ; MSB
.8600		c8		iny		                iny
.8601		d0 01		bne $8604	                bne +
.8603		1a		inc a		                ina
.8604						+
.8604		84 25		sty $25		                sty tmp1
.8606		85 26		sta $26		                sta tmp1+1
.8608		20 bf d6	jsr $d6bf	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.860b		a5 02		lda $02		                lda dp
.860d		18		clc		                clc
.860e		69 04		adc #$04	                adc #4
.8610		85 27		sta $27		                sta tmp2
.8612		a5 03		lda $03		                lda dp+1
.8614		69 00		adc #$00	                adc #0          ; we only care about the carry
.8616		85 28		sta $28		                sta tmp2+1
.8618		b2 27		lda ($27)	                lda (tmp2)
.861a		18		clc		                clc
.861b		69 01		adc #$01	                adc #1
.861d		85 29		sta $29		                sta tmp3
.861f		a0 01		ldy #$01	                ldy #1
.8621		b1 27		lda ($27),y	                lda (tmp2),y
.8623		69 00		adc #$00	                adc #0          ; we only care about the carry
.8625		85 2a		sta $2a		                sta tmp3+1
.8627		a5 25		lda $25		                lda tmp1        ; LSB
.8629		92 29		sta ($29)	                sta (tmp3)
.862b		a5 26		lda $26		                lda tmp1+1
.862d		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.862f		60		rts		                rts
.8630						xt_dot:
.8630		20 68 d7	jsr $d768	                jsr underflow_1
.8633		20 a0 86	jsr $86a0	                jsr xt_dup                      ; ( n n )
.8636		20 cf 80	jsr $80cf	                jsr xt_abs                      ; ( n u )
.8639		20 cf 9d	jsr $9dcf	                jsr xt_zero                     ; ( n u 0 )
.863c		20 cf 89	jsr $89cf	                jsr xt_less_number_sign         ; ( n u 0 )
.863f		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s            ; ( n ud )
.8642		20 91 8f	jsr $8f91	                jsr xt_rot                      ; ( ud n )
.8645		20 50 91	jsr $9150	                jsr xt_sign                     ; ( ud )
.8648		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater      ; ( addr u )
.864b		20 b7 94	jsr $94b7	                jsr xt_type
.864e		20 cb 91	jsr $91cb	                jsr xt_space
.8651		60		rts		z_dot:          rts
.8652						xt_dot_paren:
.8652		ca		dex		                dex
.8653		ca		dex		                dex
.8654		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8656		95 00		sta $00,x	                sta 0,x
.8658		74 01		stz $01,x	                stz 1,x
.865a		20 ac 8d	jsr $8dac	                jsr xt_parse
.865d		20 b7 94	jsr $94b7	                jsr xt_type
.8660		60		rts		z_dot_paren:    rts
.8661						xt_dot_quote:
.8661		20 da 8f	jsr $8fda	                jsr xt_s_quote
.8664		a0 94		ldy #$94	                ldy #>xt_type
.8666		a9 b7		lda #$b7	                lda #<xt_type
.8668		20 58 97	jsr $9758	                jsr cmpl_subroutine
.866b		60		rts		z_dot_quote:    rts
.866c						xt_dot_r:
.866c		20 6d d7	jsr $d76d	                jsr underflow_2
.866f		20 6c 93	jsr $936c	                jsr xt_to_r
.8672		20 a0 86	jsr $86a0	                jsr xt_dup
.8675		20 cf 80	jsr $80cf	                jsr xt_abs
.8678		20 cf 9d	jsr $9dcf	                jsr xt_zero
.867b		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.867e		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.8681		20 91 8f	jsr $8f91	                jsr xt_rot
.8684		20 50 91	jsr $9150	                jsr xt_sign
.8687		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.868a		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.868d		20 05 8d	jsr $8d05	                jsr xt_over
.8690		20 e4 8b	jsr $8be4	                jsr xt_minus
.8693		20 d1 91	jsr $91d1	                jsr xt_spaces
.8696		20 b7 94	jsr $94b7	                jsr xt_type
.8699		60		rts		z_dot_r:        rts
.869a						xt_drop:
.869a		20 68 d7	jsr $d768	                jsr underflow_1
.869d		e8		inx		                inx
.869e		e8		inx		                inx
.869f		60		rts		z_drop:         rts
.86a0						xt_dup:
.86a0		20 68 d7	jsr $d768	                jsr underflow_1
.86a3		ca		dex		                dex
.86a4		ca		dex		                dex
.86a5		b5 02		lda $02,x	                lda 2,x         ; LSB
.86a7		95 00		sta $00,x	                sta 0,x
.86a9		b5 03		lda $03,x	                lda 3,x         ; MSB
.86ab		95 01		sta $01,x	                sta 1,x
.86ad		60		rts		z_dup:          rts
.86ae						xt_else:
.86ae						xt_endof:
.86ae		20 79 97	jsr $9779	                jsr cmpl_jump_later
.86b1		20 2e 92	jsr $922e	                jsr xt_swap         ; ( target orig )
.86b4						xt_then:
.86b4		20 1b 89	jsr $891b	                jsr xt_here
.86b7		20 2e 92	jsr $922e	                jsr xt_swap
.86ba		20 18 92	jsr $9218	                jsr xt_store
.86bd						z_else:
.86bd						z_endof:
.86bd		60		rts		z_then:         rts
.86be						xt_emit:
.86be		20 68 d7	jsr $d768	                jsr underflow_1
.86c1		b5 00		lda $00,x	                lda 0,x
.86c3		e8		inx		                inx
.86c4		e8		inx		                inx
.86c5						emit_a:
.86c5		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.86c8						z_emit:
.86c8						xt_endcase:
.86c8		a0 86		ldy #$86	                ldy #>xt_drop
.86ca		a9 9a		lda #$9a	                lda #<xt_drop
.86cc		20 58 97	jsr $9758	                jsr cmpl_subroutine
.86cf						_endcase_loop:
.86cf		b5 00		lda $00,x	                lda 0,x
.86d1		15 01		ora $01,x	                ora 1,x
.86d3		f0 05		beq $86da	                beq _done
.86d5		20 b4 86	jsr $86b4	                jsr xt_then
.86d8		80 f5		bra $86cf	                bra _endcase_loop
.86da						_done:
.86da		e8		inx		                inx
.86db		e8		inx		                inx
.86dc		60		rts		z_endcase:      rts
.86dd						xt_environment_q:
.86dd		20 68 d7	jsr $d768	                jsr underflow_1
.86e0		a0 00		ldy #$00	                ldy #00                 ; counter for table
.86e2		5a		phy		                phy
.86e3						_table_loop:
.86e3		20 af 93	jsr $93af	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.86e6		ca		dex		                dex
.86e7		ca		dex		                dex                     ; ( addr u addr u ? )
.86e8		b9 5a 87	lda $875a,y	                lda env_table_single,y
.86eb		95 00		sta $00,x	                sta 0,x
.86ed		c8		iny		                iny
.86ee		b9 5a 87	lda $875a,y	                lda env_table_single,y
.86f1		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.86f3		c8		iny		                iny
.86f4		15 00		ora $00,x	                ora 0,x
.86f6		f0 4d		beq $8745	                beq _table_done
.86f8		5a		phy		                phy                     ; save Y, which is used by COUNT
.86f9		20 26 84	jsr $8426	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.86fc		20 96 9f	jsr $9f96	                jsr xt_compare          ; ( addr u f )
.86ff		7a		ply		                ply
.8700		b5 00		lda $00,x	                lda 0,x
.8702		15 01		ora $01,x	                ora 1,x
.8704		f0 04		beq $870a	                beq _got_result
.8706		e8		inx		                inx                     ; DROP, now ( addr u )
.8707		e8		inx		                inx
.8708		80 d9		bra $86e3	                bra _table_loop
.870a						_got_result:
.870a		e8		inx		                inx                     ; drop flag, now ( addr u )
.870b		e8		inx		                inx
.870c		88		dey		                dey                     ; go back to index we had
.870d		88		dey		                dey
.870e		68		pla		                pla
.870f		d0 0d		bne $871e	                bne _double_result
.8711		b9 78 87	lda $8778,y	                lda env_results_single,y
.8714		95 02		sta $02,x	                sta 2,x
.8716		c8		iny		                iny
.8717		b9 78 87	lda $8778,y	                lda env_results_single,y
.871a		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.871c		80 1f		bra $873d	                bra _set_flag
.871e						_double_result:
.871e		ca		dex		                dex                     ; ( addr u ? )
.871f		ca		dex		                dex
.8720		98		tya		                tya
.8721		38		sec		                sec
.8722		e9 18		sbc #$18	                sbc #24
.8724		0a		asl a		                asl
.8725		a8		tay		                tay
.8726		b9 8e 87	lda $878e,y	                lda env_results_double,y
.8729		95 02		sta $02,x	                sta 2,x
.872b		c8		iny		                iny
.872c		b9 8e 87	lda $878e,y	                lda env_results_double,y
.872f		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8731		c8		iny		                iny
.8732		b9 8e 87	lda $878e,y	                lda env_results_double,y
.8735		95 04		sta $04,x	                sta 4,x
.8737		c8		iny		                iny
.8738		b9 8e 87	lda $878e,y	                lda env_results_double,y
.873b		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.873d						_set_flag:
.873d		a9 ff		lda #$ff	                lda #$FF
.873f		95 00		sta $00,x	                sta 0,x
.8741		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8743		80 14		bra $8759	                bra _done
.8745						_table_done:
.8745		68		pla		                pla
.8746		d0 09		bne $8751	                bne _no_match
.8748		1a		inc a		                ina
.8749		48		pha		                pha
.874a		8a		txa		                txa
.874b		18		clc		                clc
.874c		69 06		adc #$06	                adc #6                  ; skip six bytes
.874e		aa		tax		                tax                     ; ( addr u )
.874f		80 92		bra $86e3	                bra _table_loop
.8751						_no_match:
.8751		8a		txa		                txa
.8752		18		clc		                clc
.8753		69 0a		adc #$0a	                adc #10
.8755		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8756		20 cf 9d	jsr $9dcf	                jsr xt_false
.8759						_done:
.8759						z_environment_q:
.8759		60		rts		                rts
.875a						env_table_single:
>875a		50 d5 60 d5 66 d5 6b d5		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8762		7d d5
>8764		85 d5 8e d5 94 d5 9a d5		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>876c		ad d5 b9 d5 00 00		        .word envs_sc, envs_wl, 0000
.8772						env_table_double:
>8772		c3 d5 c9 d5 00 00		        .word envs_max_d, envs_max_ud, 0000
.8778						env_results_single:
>8778		ff 00				        .word $00FF     ; /COUNTED-STRING
>877a		ff 00				        .word $00FF     ; /HOLD
>877c		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>877e		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8780		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8782		ff 00				        .word $00FF     ; MAX-CHAR
>8784		ff 7f				        .word $7FFF     ; MAX-N
>8786		ff ff				        .word $FFFF     ; MAX-U
>8788		80 00				        .word $0080     ; RETURN-STACK-CELLS
>878a		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>878c		09 00				        .word $0009     ; WORDLISTS
.878e						env_results_double:
>878e		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8792		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8796						xt_equal:
.8796		20 6d d7	jsr $d76d	                jsr underflow_2
.8799		b5 00		lda $00,x	                lda 0,x                 ; LSB
.879b		d5 02		cmp $02,x	                cmp 2,x
.879d		d0 0a		bne $87a9	                bne _false
.879f		b5 01		lda $01,x	                lda 1,x                 ; MSB
.87a1		d5 03		cmp $03,x	                cmp 3,x
.87a3		d0 04		bne $87a9	                bne _false
.87a5		a9 ff		lda #$ff	                lda #$FF
.87a7		80 02		bra $87ab	                bra _done
.87a9		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.87ab		95 02		sta $02,x	_done:          sta 2,x
.87ad		95 03		sta $03,x	                sta 3,x
.87af		e8		inx		                inx
.87b0		e8		inx		                inx
.87b1		60		rts		z_equal:        rts
.87b2						xt_blank:
.87b2		ca		dex		                dex
.87b3		ca		dex		                dex
.87b4		a9 20		lda #$20	                lda #AscSP
.87b6		95 00		sta $00,x	                sta 0,x
.87b8		74 01		stz $01,x	                stz 1,x
.87ba		80 06		bra $87c2	                bra xt_fill     ; skip over code for ERASE
.87bc						xt_erase:
.87bc		ca		dex		                dex
.87bd		ca		dex		                dex
.87be		74 00		stz $00,x	                stz 0,x
.87c0		74 01		stz $01,x	                stz 1,x
.87c2						xt_fill:
.87c2		20 72 d7	jsr $d772	                jsr underflow_3
.87c5		b5 04		lda $04,x	                lda 4,x         ; LSB
.87c7		85 25		sta $25		                sta tmp1
.87c9		b5 05		lda $05,x	                lda 5,x
.87cb		85 26		sta $26		                sta tmp1+1
.87cd		b5 02		lda $02,x	                lda 2,x
.87cf		85 27		sta $27		                sta tmp2
.87d1		b5 03		lda $03,x	                lda 3,x
.87d3		85 28		sta $28		                sta tmp2+1
.87d5		b5 00		lda $00,x	                lda 0,x
.87d7		a8		tay		                tay
.87d8						_loop:
.87d8		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.87da		c5 26		cmp $26		                cmp tmp1+1
.87dc		90 21		bcc $87ff	                bcc _done               ; RAM_END < TMP1, so leave
.87de		d0 06		bne $87e6	                bne _check_counter      ; RAM_END is not smaller and not equal
.87e0		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.87e2		c5 25		cmp $25		                cmp tmp1
.87e4		90 19		bcc $87ff	                bcc _done               ; RAM_END < TMP1, so leave
.87e6						_check_counter:
.87e6		a5 27		lda $27		                lda tmp2
.87e8		05 28		ora $28		                ora tmp2+1
.87ea		f0 13		beq $87ff	                beq _done
.87ec		98		tya		                tya
.87ed		92 25		sta ($25)	                sta (tmp1)
.87ef		a5 27		lda $27		                lda tmp2
.87f1		d0 02		bne $87f5	                bne +
.87f3		c6 28		dec $28		                dec tmp2+1
.87f5		c6 27		dec $27		+               dec tmp2
.87f7		e6 25		inc $25		                inc tmp1
.87f9		d0 dd		bne $87d8	                bne _loop
.87fb		e6 26		inc $26		                inc tmp1+1
.87fd		80 d9		bra $87d8	                bra _loop
.87ff						_done:
.87ff		8a		txa		                txa
.8800		18		clc		                clc
.8801		69 06		adc #$06	                adc #6
.8803		aa		tax		                tax
.8804						z_blank:
.8804						z_erase:
.8804		60		rts		z_fill:         rts
.8805						xt_execute:
.8805		20 68 d7	jsr $d768	                jsr underflow_1
.8808		20 0c 88	jsr $880c	                jsr doexecute   ; do not combine to JMP (native coding)
.880b		60		rts		z_execute:      rts
.880c						doexecute:
.880c		b5 00		lda $00,x	                lda 0,x
.880e		85 04		sta $04		                sta ip
.8810		b5 01		lda $01,x	                lda 1,x
.8812		85 05		sta $05		                sta ip+1
.8814		e8		inx		                inx
.8815		e8		inx		                inx
.8816		6c 04 00	jmp ($0004)	                jmp (ip)
.8819						xt_exit:
.8819		60		rts		                rts             ; keep before z_exit
.881a						z_exit:
.881a						xt_fetch:
.881a		20 68 d7	jsr $d768	                jsr underflow_1
.881d		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.881f		a8		tay		                tay
.8820		f6 00		inc $00,x	                inc 0,x
.8822		d0 02		bne $8826	                bne +
.8824		f6 01		inc $01,x	                inc 1,x
.8826						+
.8826		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8828		95 01		sta $01,x	                sta 1,x
.882a		94 00		sty $00,x	                sty 0,x
.882c		60		rts		z_fetch:        rts
.882d						xt_find:
.882d		20 68 d7	jsr $d768	                jsr underflow_1
.8830		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8832		48		pha		                pha
.8833		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8835		48		pha		                pha
.8836		20 26 84	jsr $8426	                jsr xt_count            ; ( caddr -- addr u )
.8839		20 ce 9a	jsr $9ace	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.883c		b5 00		lda $00,x	                lda 0,x
.883e		15 01		ora $01,x	                ora 1,x
.8840		d0 0b		bne $884d	                bne _found_word
.8842		20 cf 9d	jsr $9dcf	                jsr xt_false            ; ( 0 0 )
.8845		68		pla		                pla                     ; LSB of address
.8846		95 02		sta $02,x	                sta 2,x
.8848		68		pla		                pla
.8849		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.884b		80 27		bra $8874	                bra _done               ; ( addr 0 )
.884d						_found_word:
.884d		68		pla		                pla
.884e		68		pla		                pla
.884f		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.8852		20 0c 9c	jsr $9c0c	                jsr xt_name_to_int      ; ( nt xt )
.8855		20 2e 92	jsr $922e	                jsr xt_swap             ; ( xt nt )
.8858		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.885a		f6 00		inc $00,x	                inc 0,x
.885c		d0 02		bne $8860	                bne +
.885e		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8860						+
.8860		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8862		29 04		and #$04	                and #IM
.8864		d0 08		bne $886e	                bne _immediate          ; bit set, we're immediate
.8866		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8868		95 00		sta $00,x	                sta 0,x
.886a		95 01		sta $01,x	                sta 1,x
.886c		80 06		bra $8874	                bra _done
.886e						_immediate:
.886e		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8870		95 00		sta $00,x	                sta 0,x
.8872		74 01		stz $01,x	                stz 1,x
.8874						_done:
.8874		60		rts		z_find:         rts
.8875						xt_fm_slash_mod:
.8875		20 72 d7	jsr $d772	                jsr underflow_3
.8878		64 27		stz $27		                stz tmp2        ; default: n is positive
.887a		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.887c		10 0e		bpl $888c	                bpl _check_d
.887e		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.8880		20 1f 8c	jsr $8c1f	                jsr xt_negate   ; NEGATE
.8883		20 6c 93	jsr $936c	                jsr xt_to_r     ; >R
.8886		20 3d 9e	jsr $9e3d	                jsr xt_dnegate  ; DNEGATE
.8889		20 f0 8e	jsr $8ef0	                jsr xt_r_from   ; R>
.888c						_check_d:
.888c		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.888e		10 0d		bpl $889d	                bpl _multiply
.8890		18		clc		                clc
.8891		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.8893		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.8895		95 02		sta $02,x	                sta 2,x
.8897		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8899		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.889b		95 03		sta $03,x	                sta 3,x
.889d						_multiply:
.889d		20 3c 95	jsr $953c	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.88a0		a5 27		lda $27		                lda tmp2
.88a2		f0 07		beq $88ab	                beq _done
.88a4		e8		inx		                inx             ; pretend that we SWAP
.88a5		e8		inx		                inx
.88a6		20 1f 8c	jsr $8c1f	                jsr xt_negate
.88a9		ca		dex		                dex
.88aa		ca		dex		                dex
.88ab						_done:
.88ab		60		rts		z_fm_slash_mod: rts
.88ac						load_evaluate:
.88ac		a9 ff		lda #$ff	                lda #$FF
.88ae		85 25		sta $25		                sta tmp1
.88b0		80 11		bra $88c3	                bra load_evaluate_start
.88b2						xt_evaluate:
.88b2		20 6d d7	jsr $d76d	                jsr underflow_2
.88b5		64 25		stz $25		                stz tmp1
.88b7		b5 00		lda $00,x	                lda 0,x
.88b9		15 01		ora $01,x	                ora 1,x
.88bb		d0 06		bne $88c3	                bne evaluate_got_work
.88bd		e8		inx		                inx
.88be		e8		inx		                inx
.88bf		e8		inx		                inx
.88c0		e8		inx		                inx
.88c1		80 42		bra $8905	                bra evaluate_done
.88c3						load_evaluate_start:
.88c3						evaluate_got_work:
.88c3		a0 05		ldy #$05	                ldy #blk_offset+1
.88c5		b1 08		lda ($08),y	                lda (up),y
.88c7		48		pha		                pha
.88c8		88		dey		                dey
.88c9		b1 08		lda ($08),y	                lda (up),y
.88cb		48		pha		                pha
.88cc		a5 25		lda $25		                lda tmp1
.88ce		d0 05		bne $88d5	                bne _nozero
.88d0		91 08		sta ($08),y	                sta (up),y
.88d2		c8		iny		                iny
.88d3		91 08		sta ($08),y	                sta (up),y
.88d5						_nozero:
.88d5		20 70 9b	jsr $9b70	                jsr xt_input_to_r
.88d8		a9 ff		lda #$ff	                lda #$FF
.88da		85 0a		sta $0a		                sta insrc
.88dc		85 0b		sta $0b		                sta insrc+1
.88de		64 10		stz $10		                stz toin
.88e0		64 11		stz $11		                stz toin+1
.88e2		b5 00		lda $00,x	                lda 0,x
.88e4		85 0e		sta $0e		                sta ciblen
.88e6		b5 01		lda $01,x	                lda 1,x
.88e8		85 0f		sta $0f		                sta ciblen+1
.88ea		b5 02		lda $02,x	                lda 2,x
.88ec		85 0c		sta $0c		                sta cib
.88ee		b5 03		lda $03,x	                lda 3,x
.88f0		85 0d		sta $0d		                sta cib+1
.88f2		e8		inx		                inx             ; A clean stack is a clean mind
.88f3		e8		inx		                inx
.88f4		e8		inx		                inx
.88f5		e8		inx		                inx
.88f6		20 e5 d6	jsr $d6e5	                jsr interpret   ; ( -- )
.88f9		20 7d 9d	jsr $9d7d	                jsr xt_r_to_input
.88fc		a0 04		ldy #$04	                ldy #blk_offset
.88fe		68		pla		                pla
.88ff		91 08		sta ($08),y	                sta (up),y
.8901		c8		iny		                iny
.8902		68		pla		                pla
.8903		91 08		sta ($08),y	                sta (up),y
.8905						evaluate_done:
.8905		60		rts		z_evaluate:     rts
.8906						xt_greater_than:
.8906		20 6d d7	jsr $d76d	                jsr underflow_2
.8909		a0 00		ldy #$00	                ldy #0          ; default false
.890b		20 a6 d6	jsr $d6a6	                jsr compare_16bit
.890e		f0 03		beq $8913	                beq _false
.8910		10 01		bpl $8913	                bpl _false
.8912		88		dey		                dey
.8913						_false:
.8913		98		tya		                tya
.8914		e8		inx		                inx
.8915		e8		inx		                inx
.8916		95 00		sta $00,x	                sta 0,x
.8918		95 01		sta $01,x	                sta 1,x
.891a		60		rts		z_greater_than: rts
.891b						xt_here:
.891b						xt_begin:
.891b						xt_asm_arrow:
.891b		ca		dex		                dex
.891c		ca		dex		                dex
.891d		a5 00		lda $00		                lda cp
.891f		95 00		sta $00,x	                sta 0,x
.8921		a5 01		lda $01		                lda cp+1
.8923		95 01		sta $01,x	                sta 1,x
.8925						z_here:
.8925						z_begin:
.8925						z_asm_arrow:
.8925		60		rts		                rts
.8926						xt_hex:
.8926		a9 10		lda #$10	                lda #16
.8928		85 18		sta $18		                sta base
.892a		64 19		stz $19		                stz base+1              ; paranoid
.892c		60		rts		z_hex:          rts
.892d						xt_hold:
.892d		20 68 d7	jsr $d768	                jsr underflow_1
.8930		a5 2b		lda $2b		                lda tohold
.8932		d0 02		bne $8936	                bne +
.8934		c6 2c		dec $2c		                dec tohold+1
.8936						+
.8936		c6 2b		dec $2b		                dec tohold
.8938		b5 00		lda $00,x	                lda 0,x
.893a		92 2b		sta ($2b)	                sta (tohold)
.893c		e8		inx		                inx
.893d		e8		inx		                inx
.893e		60		rts		z_hold:         rts
.893f						xt_i:
.893f		ca		dex		                dex
.8940		ca		dex		                dex
.8941		a4 1f		ldy $1f		                ldy loopctrl
.8943		38		sec		                sec
.8944		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.8946		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8949		95 00		sta $00,x	                sta 0,x
.894b		b9 01 01	lda $0101,y	                lda loopindex+1,y
.894e		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8951		95 01		sta $01,x	                sta 1,x
.8953		60		rts		z_i:            rts
.8954						xt_if:
.8954		20 95 97	jsr $9795	                jsr cmpl_0branch_later
.8957		60		rts		z_if:           rts
.8958						xt_immediate:
.8958		20 bf d6	jsr $d6bf	                jsr current_to_dp
.895b		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.895d		b1 02		lda ($02),y	                lda (dp),y
.895f		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.8961		91 02		sta ($02),y	                sta (dp),y
.8963		60		rts		z_immediate:    rts
.8964						xt_invert:
.8964		20 68 d7	jsr $d768	                jsr underflow_1
.8967		a9 ff		lda #$ff	                lda #$FF
.8969		55 00		eor $00,x	                eor 0,x         ; LSB
.896b		95 00		sta $00,x	                sta 0,x
.896d		a9 ff		lda #$ff	                lda #$FF
.896f		55 01		eor $01,x	                eor 1,x         ; MSB
.8971		95 01		sta $01,x	                sta 1,x
.8973		60		rts		z_invert:       rts
.8974						xt_is:
.8974		a5 1a		lda $1a		                lda state
.8976		05 1b		ora $1b		                ora state+1
.8978		f0 0c		beq $8986	                beq _interpreting
.897a		20 14 83	jsr $8314	                jsr xt_bracket_tick
.897d		a0 85		ldy #$85	                ldy #>xt_defer_store
.897f		a9 4b		lda #$4b	                lda #<xt_defer_store
.8981		20 58 97	jsr $9758	                jsr cmpl_subroutine
.8984		80 06		bra $898c	                bra _done
.8986						_interpreting:
.8986		20 42 92	jsr $9242	                jsr xt_tick
.8989		20 4b 85	jsr $854b	                jsr xt_defer_store
.898c						_done:
.898c		60		rts		z_is:           rts
.898d						xt_j:
.898d		ca		dex		                dex                 ; make space on the stack
.898e		ca		dex		                dex
.898f		a5 1f		lda $1f		                lda loopctrl
.8991		38		sec		                sec
.8992		e9 04		sbc #$04	                sbc #4
.8994		a8		tay		                tay
.8995		38		sec		                sec
.8996		b9 00 01	lda $0100,y	                lda loopindex,y
.8999		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.899c		95 00		sta $00,x	                sta 0,x
.899e		b9 01 01	lda $0101,y	                lda loopindex+1,y
.89a1		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.89a4		95 01		sta $01,x	                sta 1,x
.89a6		60		rts		z_j:            rts
.89a7						xt_key:
.89a7		20 b1 89	jsr $89b1	                jsr key_a               ; returns char in A
.89aa		ca		dex		                dex
.89ab		ca		dex		                dex
.89ac		95 00		sta $00,x	                sta 0,x
.89ae		74 01		stz $01,x	                stz 1,x
.89b0		60		rts		z_key:          rts
.89b1						key_a:
.89b1		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.89b4						xt_leave:
.89b4		a5 21		lda $21		                lda loopleave
.89b6		a4 22		ldy $22		                ldy loopleave+1
.89b8		20 5d 97	jsr $975d	                jsr cmpl_jump   ; emit the JMP chaining prior leave address
.89bb		38		sec		                sec
.89bc		a5 00		lda $00		                lda cp
.89be		e9 02		sbc #$02	                sbc #2
.89c0		85 21		sta $21		                sta loopleave
.89c2		a5 01		lda $01		                lda cp+1
.89c4		b0 01		bcs $89c7	                bcs +
.89c6		3a		dec a		                dea
.89c7		85 22		sta $22		+               sta loopleave+1
.89c9						z_leave:
.89c9		60		rts		                rts
.89ca						xt_left_bracket:
.89ca		64 1a		stz $1a		                stz state
.89cc		64 1b		stz $1b		                stz state+1
.89ce		60		rts		z_left_bracket: rts
.89cf						xt_less_number_sign:
.89cf		20 13 8d	jsr $8d13	                jsr xt_pad      ; ( addr )
.89d2		b5 00		lda $00,x	                lda 0,x
.89d4		85 2b		sta $2b		                sta tohold
.89d6		b5 01		lda $01,x	                lda 1,x
.89d8		85 2c		sta $2c		                sta tohold+1
.89da		e8		inx		                inx
.89db		e8		inx		                inx
.89dc						z_less_number_sign:
.89dc		60		rts		                rts
.89dd						xt_less_than:
.89dd		20 6d d7	jsr $d76d	                jsr underflow_2
.89e0		a0 00		ldy #$00	                ldy #0          ; default false
.89e2		20 a6 d6	jsr $d6a6	                jsr compare_16bit
.89e5		f0 03		beq $89ea	                beq _false
.89e7		30 01		bmi $89ea	                bmi _false
.89e9		88		dey		                dey
.89ea						_false:
.89ea		98		tya		                tya
.89eb		e8		inx		                inx
.89ec		e8		inx		                inx
.89ed		95 00		sta $00,x	                sta 0,x
.89ef		95 01		sta $01,x	                sta 1,x
.89f1		60		rts		z_less_than:    rts
.89f2						xt_literal:
.89f2		20 68 d7	jsr $d768	                jsr underflow_1
.89f5		a9 0a		lda #$0a	                lda #template_push_tos_size
.89f7		20 83 97	jsr $9783	                jsr check_nc_limit
.89fa		90 0c		bcc $8a08	                bcc _inline
.89fc		a0 8a		ldy #$8a	                ldy #>literal_runtime
.89fe		a9 3a		lda #$3a	                lda #<literal_runtime
.8a00		20 58 97	jsr $9758	                jsr cmpl_subroutine
.8a03		20 cd 83	jsr $83cd	                jsr xt_comma
.8a06		80 27		bra $8a2f	                bra z_literal
.8a08						_inline:
.8a08		a0 94		ldy #$94	                ldy #$94        ; STY opcode
.8a0a		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a0c		d0 02		bne $8a10	                bne +
.8a0e		a0 74		ldy #$74	                ldy #$74        ; STZ opcode
.8a10		5a		phy		+               phy
.8a11		b5 00		lda $00,x	                lda 0,x         ; LSB
.8a13		48		pha		                pha
.8a14		a0 02		ldy #$02	                ldy #2
.8a16		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a18		f0 03		beq $8a1d	                beq _copy
.8a1a		a0 00		ldy #$00	                ldy #0
.8a1c		48		pha		                pha
.8a1d		b9 30 8a	lda $8a30,y	_copy:          lda template_push_tos,y
.8a20		c9 ff		cmp #$ff	                cmp #$ff        ; is it a placeholder?
.8a22		d0 01		bne $8a25	                bne +
.8a24		68		pla		                pla
.8a25		20 68 97	jsr $9768	+               jsr cmpl_a
.8a28		c8		iny		                iny
.8a29		c0 0a		cpy #$0a	                cpy #template_push_tos_size
.8a2b		d0 f0		bne $8a1d	                bne _copy
.8a2d		e8		inx		                inx             ; drop the literal
.8a2e		e8		inx		                inx
.8a2f		60		rts		z_literal:      rts
.8a30						template_push_tos:
.8a30		a0 ff		ldy #$ff	                ldy #$ff        ; we'll omit this if MSB is zero
.8a32		a9 ff		lda #$ff	                lda #$ff
.8a34		ca		dex		                dex
.8a35		ca		dex		                dex
.8a36		95 00		sta $00,x	                sta 0,x
>8a38		ff 01				                .byte $ff, 1    ; this will become either sty 1,x or stz 1,x
=10						template_push_tos_size = * - template_push_tos
.8a3a						literal_runtime:
.8a3a		ca		dex		                dex
.8a3b		ca		dex		                dex
.8a3c		68		pla		                pla             ; LSB
.8a3d		85 25		sta $25		                sta tmp1
.8a3f		68		pla		                pla             ; MSB
.8a40		85 26		sta $26		                sta tmp1+1
.8a42		a0 01		ldy #$01	                ldy #1
.8a44		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.8a46		95 00		sta $00,x	                sta 0,x
.8a48		c8		iny		                iny
.8a49		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.8a4b		95 01		sta $01,x	                sta 1,x
.8a4d		98		tya		                tya
.8a4e		18		clc		                clc
.8a4f		65 25		adc $25		                adc tmp1
.8a51		a8		tay		                tay
.8a52		a5 26		lda $26		                lda tmp1+1
.8a54		69 00		adc #$00	                adc #0
.8a56		48		pha		                pha
.8a57		5a		phy		                phy
.8a58		60		rts		                rts
.8a59						xt_loop:
.8a59		ca		dex		                dex
.8a5a		ca		dex		                dex
.8a5b		ca		dex		                dex
.8a5c		ca		dex		                dex
.8a5d		a9 d2		lda #$d2	                lda #<loop_runtime
.8a5f		95 02		sta $02,x	                sta 2,x
.8a61		a9 8a		lda #$8a	                lda #>loop_runtime
.8a63		95 03		sta $03,x	                sta 3,x
.8a65		a9 11		lda #$11	                lda #loop_runtime_size
.8a67		95 00		sta $00,x	                sta 0,x
.8a69		74 01		stz $01,x	                stz 1,x
.8a6b		80 12		bra $8a7f	                bra xt_loop_common
.8a6d						xt_plus_loop:
.8a6d		ca		dex		                dex
.8a6e		ca		dex		                dex
.8a6f		ca		dex		                dex
.8a70		ca		dex		                dex
.8a71		a9 eb		lda #$eb	                lda #<plus_loop_runtime
.8a73		95 02		sta $02,x	                sta 2,x
.8a75		a9 8a		lda #$8a	                lda #>plus_loop_runtime
.8a77		95 03		sta $03,x	                sta 3,x
.8a79		a9 1a		lda #$1a	                lda #plus_loop_runtime_size
.8a7b		95 00		sta $00,x	                sta 0,x
.8a7d		74 01		stz $01,x	                stz 1,x
.8a7f						xt_loop_common:
.8a7f		20 05 8d	jsr $8d05	                jsr xt_over
.8a82		20 2e 92	jsr $922e	                jsr xt_swap             ; xt and xt' are the same
.8a85		20 26 97	jsr $9726	                jsr cmpl_by_limit
.8a88		90 05		bcc $8a8f	                bcc _native
.8a8a		20 cd 83	jsr $83cd	                jsr xt_comma
.8a8d		80 03		bra $8a92	                bra +
.8a8f						_native:
.8a8f		20 71 97	jsr $9771	                jsr cmpl_jump_tos
.8a92						+
.8a92		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.8a94		f0 19		beq $8aaf	                beq _noleave
.8a96						_next:
.8a96		a0 01		ldy #$01	                ldy #1
.8a98		b1 21		lda ($21),y	                lda (loopleave),y
.8a9a		48		pha		                pha
.8a9b		a5 01		lda $01		                lda cp+1
.8a9d		91 21		sta ($21),y	                sta (loopleave),y
.8a9f		88		dey		                dey
.8aa0		b1 21		lda ($21),y	                lda (loopleave),y
.8aa2		48		pha		                pha
.8aa3		a5 00		lda $00		                lda cp
.8aa5		91 21		sta ($21),y	                sta (loopleave),y
.8aa7		68		pla		                pla
.8aa8		85 21		sta $21		                sta loopleave
.8aaa		68		pla		                pla
.8aab		85 22		sta $22		                sta loopleave+1
.8aad		d0 e7		bne $8a96	                bne _next
.8aaf						_noleave:
.8aaf		b5 00		lda $00,x	                lda 0,x
.8ab1		85 21		sta $21		                sta loopleave
.8ab3		b5 01		lda $01,x	                lda 1,x
.8ab5		85 22		sta $22		                sta loopleave+1
.8ab7		a9 c4		lda #$c4	                lda #<xt_unloop
.8ab9		95 00		sta $00,x	                sta 0,x
.8abb		a9 95		lda #$95	                lda #>xt_unloop
.8abd		95 01		sta $01,x	                sta 1,x
.8abf		20 ba 96	jsr $96ba	                jsr xt_compile_comma
.8ac2		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.8ac4		f0 09		beq $8acf	                beq +
.8ac6		20 1b 89	jsr $891b	                jsr xt_here
.8ac9		20 2e 92	jsr $922e	                jsr xt_swap
.8acc		4c 18 92	jmp $9218	                jmp xt_store            ; write here as ?DO jmp target and return
.8acf		e8		inx		+               inx                     ; drop the ignored word for DO
.8ad0		e8		inx		                inx
.8ad1						z_loop:
.8ad1		60		rts		z_plus_loop:    rts
.8ad2						loop_runtime:
.8ad2		e6 20		inc $20		                inc loopidx0            ; increment the LSB of loopindex
.8ad4		d0 0d		bne $8ae3	                bne _repeat             ; avoid expensive test most of the time
.8ad6		a4 1f		ldy $1f		                ldy loopctrl
.8ad8		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8adb		1a		inc a		                ina
.8adc		c9 80		cmp #$80	                cmp #$80
.8ade		f0 06		beq $8ae6	                beq _done
.8ae0		99 01 01	sta $0101,y	                sta loopindex+1,y
=17						loop_runtime_size = * - loop_runtime
.8ae3						_repeat:
.8ae3		a9 00		lda #$00	                lda #0
>8ae5		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8ae6		a9 01		lda #$01	_done:          lda #1
.8ae8		4c 12 98	jmp $9812	                jmp zbranch_runtime
.8aeb						plus_loop_runtime:
.8aeb		18		clc		                clc
.8aec		b5 00		lda $00,x	                lda 0,x                 ; LSB of step
.8aee		65 20		adc $20		                adc loopidx0
.8af0		85 20		sta $20		                sta loopidx0
.8af2		e8		inx		                inx                     ; dump step from TOS before MSB test
.8af3		e8		inx		                inx                     ; since we might skip it
.8af4		b5 ff		lda $ff,x	                lda $FF,x               ; MSB of step since 1,x == -1,x+2
.8af6		d0 02		bne $8afa	                bne _chkv               ; if it's non-zero we have to check
.8af8		90 0b		bcc $8b05	                bcc _repeat             ; but if 0 and no carry, we're good
.8afa		b8		clv		_chkv:          clv
.8afb		a4 1f		ldy $1f		                ldy loopctrl            ; get LCB offset
.8afd		79 01 01	adc $0101,y	                adc loopindex+1,y       ; MSB of index
.8b00		99 01 01	sta $0101,y	                sta loopindex+1,y       ; put MSB of index back on stack
.8b03		70 03		bvs $8b08	                bvs _done               ; skip over JMP instruction
=26						plus_loop_runtime_size = * - plus_loop_runtime
.8b05						_repeat:
.8b05		a9 00		lda #$00	                lda #0
>8b07		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8b08		a9 01		lda #$01	_done:          lda #1
.8b0a		4c 12 98	jmp $9812	                jmp zbranch_runtime
.8b0d						xt_lshift:
.8b0d		20 6d d7	jsr $d76d	                jsr underflow_2
.8b10		b5 00		lda $00,x	                lda 0,x
.8b12		29 0f		and #$0f	                and #%00001111
.8b14		f0 08		beq $8b1e	                beq _done
.8b16		a8		tay		                tay
.8b17						_loop:
.8b17		16 02		asl $02,x	                asl 2,x
.8b19		36 03		rol $03,x	                rol 3,x
.8b1b		88		dey		                dey
.8b1c		d0 f9		bne $8b17	                bne _loop
.8b1e						_done:
.8b1e		e8		inx		                inx
.8b1f		e8		inx		                inx
.8b20		60		rts		z_lshift:       rts
.8b21						xt_m_star:
.8b21		20 6d d7	jsr $d76d	                jsr underflow_2
.8b24		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8b26		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.8b28		48		pha		                pha
.8b29		20 cf 80	jsr $80cf	                jsr xt_abs
.8b2c		20 2e 92	jsr $922e	                jsr xt_swap
.8b2f		20 cf 80	jsr $80cf	                jsr xt_abs
.8b32		20 7e 95	jsr $957e	                jsr xt_um_star          ; ( d )
.8b35		68		pla		                pla
.8b36		10 03		bpl $8b3b	                bpl _done
.8b38		20 3d 9e	jsr $9e3d	                jsr xt_dnegate
.8b3b						_done:
.8b3b		60		rts		z_m_star:       rts
.8b3c						xt_marker:
.8b3c		20 bf d6	jsr $d6bf	                jsr current_to_dp
.8b3f		a5 02		lda $02		                lda dp
.8b41		48		pha		                pha
.8b42		a5 03		lda $03		                lda dp+1
.8b44		48		pha		                pha
.8b45		a5 00		lda $00		                lda cp
.8b47		48		pha		                pha
.8b48		a5 01		lda $01		                lda cp+1
.8b4a		48		pha		                pha
.8b4b		20 40 84	jsr $8440	                jsr xt_create
.8b4e		a5 00		lda $00		                lda cp          ; LSB
.8b50		38		sec		                sec
.8b51		e9 02		sbc #$02	                sbc #2
.8b53		85 00		sta $00		                sta cp
.8b55		b0 02		bcs $8b59	                bcs +
.8b57		c6 01		dec $01		                dec cp+1        ; we only care about the borrow
.8b59						+
.8b59		a0 8b		ldy #$8b	                ldy #>marker_runtime
.8b5b		a9 77		lda #$77	                lda #<marker_runtime
.8b5d		20 64 97	jsr $9764	                jsr cmpl_word
.8b60		7a		ply		                ply                     ; MSB
.8b61		68		pla		                pla                     ; LSB
.8b62		20 64 97	jsr $9764	                jsr cmpl_word
.8b65		7a		ply		                ply                     ; MSB
.8b66		68		pla		                pla                     ; LSB
.8b67		20 64 97	jsr $9764	                jsr cmpl_word
.8b6a		a0 08		ldy #$08	                ldy #marker_start_offset
.8b6c						-
.8b6c		b1 08		lda ($08),y	                lda (up),y
.8b6e		20 68 97	jsr $9768	                jsr cmpl_a
.8b71		c8		iny		                iny
.8b72		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8b74		d0 f6		bne $8b6c	                bne -
.8b76		60		rts		z_marker:       rts
.8b77						marker_runtime:
.8b77		68		pla		                pla
.8b78		85 25		sta $25		                sta tmp1        ; LSB of address
.8b7a		68		pla		                pla
.8b7b		85 26		sta $26		                sta tmp1+1      ; MSB of address
.8b7d		a0 01		ldy #$01	                ldy #1          ; start at 1 due to RTS mechanics
.8b7f		b1 25		lda ($25),y	                lda (tmp1),y
.8b81		85 00		sta $00		                sta cp
.8b83		c8		iny		                iny
.8b84		b1 25		lda ($25),y	                lda (tmp1),y
.8b86		85 01		sta $01		                sta cp+1
.8b88		c8		iny		                iny
.8b89		b1 25		lda ($25),y	                lda (tmp1),y
.8b8b		85 02		sta $02		                sta dp
.8b8d		c8		iny		                iny
.8b8e		b1 25		lda ($25),y	                lda (tmp1),y
.8b90		85 03		sta $03		                sta dp+1
.8b92		38		sec		                sec
.8b93		a5 25		lda $25		                lda tmp1
.8b95		e9 03		sbc #$03	                sbc #marker_start_offset - 5
.8b97		85 25		sta $25		                sta tmp1
.8b99		b0 02		bcs $8b9d	                bcs +
.8b9b		c6 26		dec $26		                dec tmp1+1
.8b9d						+
.8b9d		a0 08		ldy #$08	                ldy #marker_start_offset
.8b9f						-
.8b9f		b1 25		lda ($25),y	                lda (tmp1),y
.8ba1		91 08		sta ($08),y	                sta (up),y
.8ba3		c8		iny		                iny
.8ba4		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8ba6		d0 f7		bne $8b9f	                bne -
.8ba8		20 d2 d6	jsr $d6d2	                jsr dp_to_current       ; Move the CURRENT DP back.
.8bab		60		rts		                rts
.8bac						xt_max:
.8bac		20 6d d7	jsr $d76d	                jsr underflow_2
.8baf		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bb1		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.8bb3		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bb5		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bb7		50 02		bvc $8bbb	                bvc _no_overflow
.8bb9		49 80		eor #$80	                eor #$80        ; complement negative flag
.8bbb						_no_overflow:
.8bbb		30 08		bmi $8bc5	                bmi _keep_nos
.8bbd		b5 00		lda $00,x	                lda 0,x
.8bbf		95 02		sta $02,x	                sta 2,x
.8bc1		b5 01		lda $01,x	                lda 1,x
.8bc3		95 03		sta $03,x	                sta 3,x
.8bc5						_keep_nos:
.8bc5		e8		inx		                inx
.8bc6		e8		inx		                inx
.8bc7		60		rts		z_max:          rts
.8bc8						xt_min:
.8bc8		20 6d d7	jsr $d76d	                jsr underflow_2
.8bcb		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bcd		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.8bcf		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bd1		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bd3		50 02		bvc $8bd7	                bvc _no_overflow
.8bd5		49 80		eor #$80	                eor #$80
.8bd7						_no_overflow:
.8bd7		10 08		bpl $8be1	                bpl _keep_nos
.8bd9		b5 00		lda $00,x	                lda 0,x
.8bdb		95 02		sta $02,x	                sta 2,x
.8bdd		b5 01		lda $01,x	                lda 1,x
.8bdf		95 03		sta $03,x	                sta 3,x
.8be1						_keep_nos:
.8be1		e8		inx		                inx
.8be2		e8		inx		                inx
.8be3		60		rts		z_min:          rts
.8be4						xt_minus:
.8be4		20 6d d7	jsr $d76d	                jsr underflow_2
.8be7		38		sec		                sec
.8be8		b5 02		lda $02,x	                lda 2,x         ; LSB
.8bea		f5 00		sbc $00,x	                sbc 0,x
.8bec		95 02		sta $02,x	                sta 2,x
.8bee		b5 03		lda $03,x	                lda 3,x         ; MSB
.8bf0		f5 01		sbc $01,x	                sbc 1,x
.8bf2		95 03		sta $03,x	                sta 3,x
.8bf4		e8		inx		                inx
.8bf5		e8		inx		                inx
.8bf6		60		rts		z_minus:        rts
.8bf7						xt_mod:
.8bf7		20 6d d7	jsr $d76d	                jsr underflow_2
.8bfa		20 6a 91	jsr $916a	                jsr xt_slash_mod
.8bfd		e8		inx		                inx             ; DROP
.8bfe		e8		inx		                inx
.8bff						z_mod:
.8bff		60		rts		                rts
.8c00						xt_move:
.8c00		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.8c02		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.8c04		f0 05		beq $8c0b	                beq _lsb                ; wasn't helpful, move to LSB
.8c06		b0 0e		bcs $8c16	                bcs _to_move_up         ; we want CMOVE>
.8c08		4c 20 9f	jmp $9f20	                jmp xt_cmove            ; JSR/RTS
.8c0b						_lsb:
.8c0b		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.8c0d		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.8c0f		f0 08		beq $8c19	                beq _equal              ; LSB is equal as well
.8c11		b0 03		bcs $8c16	                bcs _to_move_up         ; we want CMOVE>
.8c13		4c 20 9f	jmp $9f20	                jmp xt_cmove            ; JSR/RTS
.8c16						_to_move_up:
.8c16		4c 5b 9f	jmp $9f5b	                jmp xt_cmove_up         ; JSR/RTS
.8c19						_equal:
.8c19		8a		txa		                txa
.8c1a		18		clc		                clc
.8c1b		69 06		adc #$06	                adc #6
.8c1d		aa		tax		                tax
.8c1e		60		rts		z_move:         rts
.8c1f						xt_negate:
.8c1f		20 68 d7	jsr $d768	                jsr underflow_1
.8c22		a9 00		lda #$00	        	lda #0
.8c24		38		sec		                sec
.8c25		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8c27		95 00		sta $00,x	                sta 0,x
.8c29		a9 00		lda #$00	                lda #0
.8c2b		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.8c2d		95 01		sta $01,x	                sta 1,x
.8c2f		60		rts		z_negate:       rts
.8c30						xt_nip:
.8c30		20 6d d7	jsr $d76d	                jsr underflow_2
.8c33		b5 00		lda $00,x	                lda 0,x         ; LSB
.8c35		95 02		sta $02,x	                sta 2,x
.8c37		b5 01		lda $01,x	                lda 1,x         ; MSB
.8c39		95 03		sta $03,x	                sta 3,x
.8c3b		e8		inx		                inx
.8c3c		e8		inx		                inx
.8c3d		60		rts		z_nip:          rts
.8c3e						xt_not_equals:
.8c3e		20 6d d7	jsr $d76d	                jsr underflow_2
.8c41		a0 00		ldy #$00	                ldy #0                  ; default is true
.8c43		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8c45		d5 02		cmp $02,x	                cmp 2,x
.8c47		d0 0a		bne $8c53	                bne _not_equal
.8c49		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8c4b		d5 03		cmp $03,x	                cmp 3,x
.8c4d		d0 04		bne $8c53	                bne _not_equal
.8c4f		a9 ff		lda #$ff	                lda #$FF
.8c51		80 01		bra $8c54	                bra _done
.8c53						_not_equal:
.8c53		88		dey		                dey                     ; drop thru to done
.8c54						_done:
.8c54		98		tya		                tya
.8c55		e8		inx		                inx
.8c56		e8		inx		                inx
.8c57		95 00		sta $00,x	                sta 0,x
.8c59		95 01		sta $01,x	                sta 1,x
.8c5b		60		rts		z_not_equals:   rts
.8c5c						xt_number_sign:
.8c5c		20 6d d7	jsr $d76d	                jsr underflow_2         ; double number
.8c5f		20 fb 82	jsr $82fb	                jsr xt_base
.8c62		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( ud1 base )
.8c65		20 6c 93	jsr $936c	                jsr xt_to_r             ; >r
.8c68		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; 0
.8c6b		20 d9 8e	jsr $8ed9	                jsr xt_r_fetch          ; r@
.8c6e		20 3c 95	jsr $953c	                jsr xt_um_slash_mod     ; um/mod
.8c71		20 91 8f	jsr $8f91	                jsr xt_rot              ; rot
.8c74		20 91 8f	jsr $8f91	                jsr xt_rot              ; rot
.8c77		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; r>
.8c7a		20 3c 95	jsr $953c	                jsr xt_um_slash_mod     ; um/mod
.8c7d		20 91 8f	jsr $8f91	                jsr xt_rot              ; rot
.8c80		20 91 8f	jsr $8f91	                jsr xt_rot              ; ( ud rem )
.8c83		b5 00		lda $00,x	                lda 0,x
.8c85		a8		tay		                tay
.8c86		b9 ee d2	lda $d2ee,y	                lda s_abc_upper,y
.8c89		95 00		sta $00,x	                sta 0,x
.8c8b		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.8c8d		20 2d 89	jsr $892d	                jsr xt_hold
.8c90						z_number_sign:
.8c90		60		rts		                rts
.8c91						xt_number_sign_greater:
.8c91		20 6d d7	jsr $d76d	                jsr underflow_2         ; double number
.8c94		a5 2b		lda $2b		                lda tohold
.8c96		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.8c98		95 02		sta $02,x	                sta 2,x
.8c9a		a5 2c		lda $2c		                lda tohold+1
.8c9c		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.8c9e		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.8ca0		20 13 8d	jsr $8d13	                jsr xt_pad      ; ( addr addr pad )
.8ca3		38		sec		                sec
.8ca4		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.8ca6		f5 02		sbc $02,x	                sbc 2,x
.8ca8		95 02		sta $02,x	                sta 2,x
.8caa		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.8cac		f5 03		sbc $03,x	                sbc 3,x
.8cae		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.8cb0		e8		inx		                inx
.8cb1		e8		inx		                inx
.8cb2						z_number_sign_greater:
.8cb2		60		rts		                rts
.8cb3						xt_number_sign_s:
.8cb3		20 6d d7	jsr $d76d	                jsr underflow_2
.8cb6						_loop:
.8cb6		20 5c 8c	jsr $8c5c	                jsr xt_number_sign
.8cb9		b5 00		lda $00,x	                lda 0,x
.8cbb		15 01		ora $01,x	                ora 1,x
.8cbd		15 02		ora $02,x	                ora 2,x
.8cbf		15 03		ora $03,x	                ora 3,x
.8cc1		d0 f3		bne $8cb6	                bne _loop
.8cc3						z_number_sign_s:
.8cc3		60		rts		                rts
.8cc4						xt_of:
.8cc4		a0 8d		ldy #$8d	                ldy #>xt_over
.8cc6		a9 05		lda #$05	                lda #<xt_over
.8cc8		20 58 97	jsr $9758	                jsr cmpl_subroutine
.8ccb		a0 87		ldy #$87	                ldy #>xt_equal
.8ccd		a9 96		lda #$96	                lda #<xt_equal
.8ccf		20 58 97	jsr $9758	                jsr cmpl_subroutine
.8cd2		20 54 89	jsr $8954	                jsr xt_if
.8cd5		a0 86		ldy #$86	                ldy #>xt_drop
.8cd7		a9 9a		lda #$9a	                lda #<xt_drop
.8cd9		20 58 97	jsr $9758	                jsr cmpl_subroutine
.8cdc		60		rts		z_of:           rts
.8cdd						xt_one_minus:
.8cdd		20 68 d7	jsr $d768	                jsr underflow_1
.8ce0		b5 00		lda $00,x	                lda 0,x
.8ce2		d0 02		bne $8ce6	                bne +
.8ce4		d6 01		dec $01,x	                dec 1,x
.8ce6						+
.8ce6		d6 00		dec $00,x	                dec 0,x
.8ce8		60		rts		z_one_minus:    rts
.8ce9						xt_char_plus:
.8ce9						xt_one_plus:
.8ce9		20 68 d7	jsr $d768	                jsr underflow_1
.8cec		f6 00		inc $00,x	                inc 0,x
.8cee		d0 02		bne $8cf2	                bne _done
.8cf0		f6 01		inc $01,x	                inc 1,x
.8cf2						_done:
.8cf2						z_char_plus:
.8cf2		60		rts		z_one_plus:     rts
.8cf3						xt_or:
.8cf3		20 6d d7	jsr $d76d	                jsr underflow_2
.8cf6		b5 00		lda $00,x	                lda 0,x
.8cf8		15 02		ora $02,x	                ora 2,x
.8cfa		95 02		sta $02,x	                sta 2,x
.8cfc		b5 01		lda $01,x	                lda 1,x
.8cfe		15 03		ora $03,x	                ora 3,x
.8d00		95 03		sta $03,x	                sta 3,x
.8d02		e8		inx		                inx
.8d03		e8		inx		                inx
.8d04		60		rts		z_or:           rts
.8d05						xt_over:
.8d05		20 6d d7	jsr $d76d	                jsr underflow_2
.8d08		ca		dex		                dex
.8d09		ca		dex		                dex
.8d0a		b5 04		lda $04,x	                lda 4,x         ; LSB
.8d0c		95 00		sta $00,x	                sta 0,x
.8d0e		b5 05		lda $05,x	                lda 5,x         ; MSB
.8d10		95 01		sta $01,x	                sta 1,x
.8d12		60		rts		z_over:         rts
.8d13						xt_pad:
.8d13		ca		dex		                dex
.8d14		ca		dex		                dex
.8d15		a5 00		lda $00		                lda cp
.8d17		18		clc		                clc
.8d18		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.8d1a		95 00		sta $00,x	                sta 0,x
.8d1c		a5 01		lda $01		                lda cp+1
.8d1e		69 00		adc #$00	                adc #0          ; only need carry
.8d20		95 01		sta $01,x	                sta 1,x
.8d22		60		rts		z_pad:          rts
.8d23						xt_page:
.8d23		a9 1b		lda #$1b	                lda #AscESC
.8d25		20 c5 86	jsr $86c5	                jsr emit_a
.8d28		a9 5b		lda #$5b	                lda #'['
.8d2a		20 c5 86	jsr $86c5	                jsr emit_a
.8d2d		a9 32		lda #$32	                lda #'2'
.8d2f		20 c5 86	jsr $86c5	                jsr emit_a
.8d32		a9 4a		lda #$4a	                lda #'J'
.8d34		20 c5 86	jsr $86c5	                jsr emit_a
.8d37		20 cf 9d	jsr $9dcf	                jsr xt_zero
.8d3a		20 cf 9d	jsr $9dcf	                jsr xt_zero
.8d3d		20 a2 82	jsr $82a2	                jsr xt_at_xy
.8d40		60		rts		z_page:         rts
.8d41						xt_paren:
.8d41		ca		dex		                dex
.8d42		ca		dex		                dex
.8d43		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8d45		95 00		sta $00,x	                sta 0,x
.8d47		74 01		stz $01,x	                stz 1,x
.8d49		20 ac 8d	jsr $8dac	                jsr xt_parse
.8d4c		e8		inx		                inx
.8d4d		e8		inx		                inx
.8d4e		e8		inx		                inx
.8d4f		e8		inx		                inx
.8d50		60		rts		z_paren:        rts
.8d51						xt_parse_name:
.8d51		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.8d53		38		sec		                sec
.8d54		e5 10		sbc $10		                sbc toin
.8d56		85 25		sta $25		                sta tmp1
.8d58		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.8d5a		e5 11		sbc $11		                sbc toin+1
.8d5c		85 26		sta $26		                sta tmp1+1
.8d5e		a5 25		lda $25		                lda tmp1
.8d60		05 26		ora $26		                ora tmp1+1
.8d62		f0 28		beq $8d8c	                beq _empty_line
.8d64		a5 0c		lda $0c		                lda cib
.8d66		18		clc		                clc
.8d67		65 10		adc $10		                adc toin
.8d69		85 27		sta $27		                sta tmp2                ; LSB of first character
.8d6b		a5 0d		lda $0d		                lda cib+1
.8d6d		65 11		adc $11		                adc toin+1
.8d6f		85 28		sta $28		                sta tmp2+1              ; MSB
.8d71						_skip_loop:
.8d71		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.8d73		20 5b d7	jsr $d75b	                jsr is_whitespace
.8d76		90 1f		bcc $8d97	                bcc _char_found
.8d78		e6 27		inc $27		                inc tmp2
.8d7a		d0 02		bne $8d7e	                bne +
.8d7c		e6 28		inc $28		                inc tmp2+1
.8d7e						+
.8d7e		a5 25		lda $25		                lda tmp1
.8d80		d0 02		bne $8d84	                bne +
.8d82		c6 26		dec $26		                dec tmp1+1
.8d84		c6 25		dec $25		+               dec tmp1
.8d86		a5 25		lda $25		                lda tmp1
.8d88		05 26		ora $26		                ora tmp1+1
.8d8a		d0 e5		bne $8d71	                bne _skip_loop          ; fall through if empty line
.8d8c						_empty_line:
.8d8c		ca		dex		                dex
.8d8d		ca		dex		                dex
.8d8e		ca		dex		                dex
.8d8f		ca		dex		                dex
.8d90		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.8d92		74 01		stz $01,x	                stz 1,x
.8d94		4c 41 8e	jmp $8e41	                jmp z_parse_name        ; skip over PARSE
.8d97						_char_found:
.8d97		a5 27		lda $27		                lda tmp2
.8d99		38		sec		                sec
.8d9a		e5 0c		sbc $0c		                sbc cib
.8d9c		85 10		sta $10		                sta toin
.8d9e		a5 28		lda $28		                lda tmp2+1
.8da0		e5 0d		sbc $0d		                sbc cib+1
.8da2		85 11		sta $11		                sta toin+1
.8da4		ca		dex		                dex
.8da5		ca		dex		                dex
.8da6		a9 20		lda #$20	                lda #AscSP
.8da8		95 00		sta $00,x	                sta 0,x
.8daa		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.8dac						xt_parse:
.8dac		20 68 d7	jsr $d768	                jsr underflow_1
.8daf		a5 0e		lda $0e		                lda ciblen
.8db1		05 0f		ora $0f		                ora ciblen+1
.8db3		f0 0c		beq $8dc1	                beq _abort_parse
.8db5		a5 11		lda $11		                lda toin+1              ; MSB
.8db7		c5 0f		cmp $0f		                cmp ciblen+1
.8db9		90 0e		bcc $8dc9	                bcc _go_parse           ; unsigned comparison
.8dbb		a5 10		lda $10		                lda toin                ; LSB
.8dbd		c5 0e		cmp $0e		                cmp ciblen
.8dbf		90 08		bcc $8dc9	                bcc _go_parse
.8dc1						_abort_parse:
.8dc1		ca		dex		                dex
.8dc2		ca		dex		                dex
.8dc3		74 00		stz $00,x	                stz 0,x
.8dc5		74 01		stz $01,x	                stz 1,x
.8dc7		80 78		bra $8e41	                bra _done
.8dc9						_go_parse:
.8dc9		b5 00		lda $00,x	                lda 0,x
.8dcb		85 23		sta $23		                sta tmptos
.8dcd		ca		dex		                dex
.8dce		ca		dex		                dex
.8dcf		a5 0c		lda $0c		                lda cib
.8dd1		18		clc		                clc
.8dd2		65 10		adc $10		                adc toin        ; LSB
.8dd4		85 25		sta $25		                sta tmp1
.8dd6		85 27		sta $27		                sta tmp2
.8dd8		95 02		sta $02,x	                sta 2,x
.8dda		a5 0d		lda $0d		                lda cib+1
.8ddc		65 11		adc $11		                adc toin+1      ; MSB
.8dde		85 26		sta $26		                sta tmp1+1
.8de0		85 28		sta $28		                sta tmp2+1
.8de2		95 03		sta $03,x	                sta 3,x
.8de4		a5 0c		lda $0c		                lda cib
.8de6		18		clc		                clc
.8de7		65 0e		adc $0e		                adc ciblen
.8de9		85 29		sta $29		                sta tmp3
.8deb		a5 0d		lda $0d		                lda cib+1
.8ded		65 0f		adc $0f		                adc ciblen+1
.8def		85 2a		sta $2a		                sta tmp3+1
.8df1		64 24		stz $24		                stz tmptos+1
.8df3						_loop:
.8df3		a5 27		lda $27		                lda tmp2
.8df5		c5 29		cmp $29		                cmp tmp3
.8df7		d0 06		bne $8dff	                bne _not_empty
.8df9		a5 28		lda $28		                lda tmp2+1
.8dfb		c5 2a		cmp $2a		                cmp tmp3+1
.8dfd		f0 1d		beq $8e1c	                beq _eol
.8dff						_not_empty:
.8dff		b2 27		lda ($27)	                lda (tmp2)
.8e01		a4 23		ldy $23		                ldy tmptos
.8e03		c0 20		cpy #$20	                cpy #AscSP
.8e05		d0 07		bne $8e0e	                bne _not_whitespace
.8e07		20 5b d7	jsr $d75b	                jsr is_whitespace
.8e0a		90 02		bcc $8e0e	                bcc _not_whitespace
.8e0c		80 0c		bra $8e1a	                bra _found_delimiter
.8e0e						_not_whitespace:
.8e0e		c5 23		cmp $23		                cmp tmptos
.8e10		f0 08		beq $8e1a	                beq _found_delimiter
.8e12		e6 27		inc $27		                inc tmp2
.8e14		d0 dd		bne $8df3	                bne _loop
.8e16		e6 28		inc $28		                inc tmp2+1
.8e18		80 d9		bra $8df3	                bra _loop
.8e1a						_found_delimiter:
.8e1a		e6 24		inc $24		                inc tmptos+1
.8e1c						_eol:
.8e1c		a5 27		lda $27		                lda tmp2
.8e1e		38		sec		                sec
.8e1f		e5 25		sbc $25		                sbc tmp1
.8e21		95 00		sta $00,x	                sta 0,x
.8e23		a5 28		lda $28		                lda tmp2+1
.8e25		e5 26		sbc $26		                sbc tmp1+1
.8e27		95 01		sta $01,x	                sta 1,x
.8e29		a5 27		lda $27		                lda tmp2
.8e2b		38		sec		                sec
.8e2c		e5 0c		sbc $0c		                sbc cib
.8e2e		85 10		sta $10		                sta toin
.8e30		a5 28		lda $28		                lda tmp2+1
.8e32		e5 0d		sbc $0d		                sbc cib+1
.8e34		85 11		sta $11		                sta toin+1
.8e36		a5 10		lda $10		                lda toin
.8e38		18		clc		                clc
.8e39		65 24		adc $24		                adc tmptos+1
.8e3b		85 10		sta $10		                sta toin
.8e3d		90 02		bcc $8e41	                bcc +
.8e3f		e6 11		inc $11		                inc toin+1
.8e41						+
.8e41						_done:
.8e41						z_parse_name:
.8e41		60		rts		z_parse:        rts
.8e42						xt_pick:
.8e42		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.8e44		8a		txa		                txa
.8e45		75 00		adc $00,x	                adc 0,x
.8e47		a8		tay		                tay
.8e48		b9 02 00	lda $0002,y	                lda 0002,y
.8e4b		95 00		sta $00,x	                sta 0,x
.8e4d		b9 03 00	lda $0003,y	                lda 0003,y
.8e50		95 01		sta $01,x	                sta 1,x
.8e52		60		rts		z_pick:         rts
.8e53						xt_plus:
.8e53		20 6d d7	jsr $d76d	                jsr underflow_2
.8e56		18		clc		                clc
.8e57		b5 00		lda $00,x	                lda 0,x         ; LSB
.8e59		75 02		adc $02,x	                adc 2,x
.8e5b		95 02		sta $02,x	                sta 2,x
.8e5d		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.8e5f		75 03		adc $03,x	                adc 3,x
.8e61		95 03		sta $03,x	                sta 3,x
.8e63		e8		inx		                inx
.8e64		e8		inx		                inx
.8e65		60		rts		z_plus:         rts
.8e66						xt_plus_store:
.8e66		20 6d d7	jsr $d76d	                jsr underflow_2
.8e69		b5 00		lda $00,x	                lda 0,x
.8e6b		85 25		sta $25		                sta tmp1
.8e6d		b5 01		lda $01,x	                lda 1,x
.8e6f		85 26		sta $26		                sta tmp1+1
.8e71		a0 00		ldy #$00	                ldy #0          ; LSB
.8e73		b1 25		lda ($25),y	                lda (tmp1),y
.8e75		18		clc		                clc
.8e76		75 02		adc $02,x	                adc 2,x
.8e78		91 25		sta ($25),y	                sta (tmp1),y
.8e7a		c8		iny		                iny             ; MSB
.8e7b		b1 25		lda ($25),y	                lda (tmp1),y
.8e7d		75 03		adc $03,x	                adc 3,x
.8e7f		91 25		sta ($25),y	                sta (tmp1),y
.8e81		e8		inx		                inx
.8e82		e8		inx		                inx
.8e83		e8		inx		                inx
.8e84		e8		inx		                inx
.8e85		60		rts		z_plus_store:   rts
.8e86						xt_postpone:
.8e86		20 51 8d	jsr $8d51	                jsr xt_parse_name               ; ( -- addr n )
.8e89		b5 00		lda $00,x	                lda 0,x
.8e8b		15 01		ora $01,x	                ora 1,x
.8e8d		d0 05		bne $8e94	                bne +
.8e8f		a9 05		lda #$05	                lda #err_noname
.8e91		4c 7e d7	jmp $d77e	                jmp error
.8e94						+
.8e94		20 ce 9a	jsr $9ace	                jsr xt_find_name                ; ( -- nt | 0 )
.8e97		d0 05		bne $8e9e	                bne +
.8e99		a9 05		lda #$05	                lda #err_noname
.8e9b		4c 7e d7	jmp $d77e	                jmp error
.8e9e						+
.8e9e		b5 00		lda $00,x	                lda 0,x
.8ea0		85 25		sta $25		                sta tmp1
.8ea2		b5 01		lda $01,x	                lda 1,x
.8ea4		85 26		sta $26		                sta tmp1+1
.8ea6		20 0c 9c	jsr $9c0c	                jsr xt_name_to_int              ; ( nt -- xt )
.8ea9		e6 25		inc $25		                inc tmp1
.8eab		d0 02		bne $8eaf	                bne +
.8ead		e6 26		inc $26		                inc tmp1+1
.8eaf						+
.8eaf		b2 25		lda ($25)	                lda (tmp1)
.8eb1		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.8eb3		f0 05		beq $8eba	                beq _not_immediate
.8eb5		20 ba 96	jsr $96ba	                jsr xt_compile_comma
.8eb8		80 0a		bra $8ec4	                bra _done
.8eba						_not_immediate:
.8eba		20 f2 89	jsr $89f2	                jsr xt_literal
.8ebd		a0 96		ldy #$96	                ldy #>xt_compile_comma
.8ebf		a9 ba		lda #$ba	                lda #<xt_compile_comma
.8ec1		20 58 97	jsr $9758	                jsr cmpl_subroutine
.8ec4						_done:
.8ec4		60		rts		z_postpone:     rts
.8ec5						xt_question_dup:
.8ec5		20 68 d7	jsr $d768	                jsr underflow_1
.8ec8		b5 00		lda $00,x	                lda 0,x
.8eca		15 01		ora $01,x	                ora 1,x
.8ecc		f0 0a		beq $8ed8	                beq _done
.8ece		ca		dex		                dex
.8ecf		ca		dex		                dex
.8ed0		b5 02		lda $02,x	                lda 2,x
.8ed2		95 00		sta $00,x	                sta 0,x
.8ed4		b5 03		lda $03,x	                lda 3,x
.8ed6		95 01		sta $01,x	                sta 1,x
.8ed8						_done:
.8ed8		60		rts		z_question_dup: rts
.8ed9						xt_r_fetch:
.8ed9		68		pla		                pla                     ; LSB
.8eda		7a		ply		                ply                     ; MSB
.8edb		1a		inc a		                inc a
.8edc		85 25		sta $25		                sta tmp1                ; LSB
.8ede		d0 01		bne $8ee1	                bne +
.8ee0		c8		iny		                iny
.8ee1						+
.8ee1		84 26		sty $26		                sty tmp1+1              ; MSB
.8ee3		ca		dex		                dex
.8ee4		ca		dex		                dex
.8ee5		7a		ply		                ply             ; LSB
.8ee6		94 00		sty $00,x	                sty 0,x
.8ee8		68		pla		                pla             ; MSB
.8ee9		95 01		sta $01,x	                sta 1,x
.8eeb		48		pha		                pha
.8eec		5a		phy		                phy
.8eed		6c 25 00	jmp ($0025)	z_r_fetch:      jmp (tmp1)
.8ef0						xt_r_from:
.8ef0		68		pla		                pla                     ; LSB
.8ef1		7a		ply		                ply                     ; MSB
.8ef2		1a		inc a		                inc a
.8ef3		85 25		sta $25		                sta tmp1                ; LSB
.8ef5		d0 01		bne $8ef8	                bne +
.8ef7		c8		iny		                iny
.8ef8						+
.8ef8		84 26		sty $26		                sty tmp1+1              ; MSB
.8efa		ca		dex		                dex
.8efb		ca		dex		                dex
.8efc		68		pla		                pla             ; LSB
.8efd		95 00		sta $00,x	                sta 0,x
.8eff		68		pla		                pla             ; MSB
.8f00		95 01		sta $01,x	                sta 1,x
.8f02		6c 25 00	jmp ($0025)	z_r_from:       jmp (tmp1)
.8f05						xt_recurse:
.8f05		a0 00		ldy #$00	                ldy #0
.8f07		a9 20		lda #$20	                lda #OpJSR
.8f09		91 00		sta ($00),y	                sta (cp),y
.8f0b		c8		iny		                iny
.8f0c		24 1c		bit $1c		                bit status
.8f0e		70 0c		bvs $8f1c	                bvs _nt_in_workword
.8f10		a5 06		lda $06		                lda workword
.8f12		91 00		sta ($00),y	                sta (cp),y
.8f14		c8		iny		                iny
.8f15		a5 07		lda $07		                lda workword+1
.8f17		91 00		sta ($00),y	                sta (cp),y
.8f19		c8		iny		                iny
.8f1a		80 1b		bra $8f37	                bra _update_cp
.8f1c						_nt_in_workword:
.8f1c		a5 06		lda $06		                lda workword            ; LSB
.8f1e		18		clc		                clc
.8f1f		69 04		adc #$04	                adc #4
.8f21		85 25		sta $25		                sta tmp1
.8f23		a5 07		lda $07		                lda workword+1          ; MSB
.8f25		69 00		adc #$00	                adc #0
.8f27		85 26		sta $26		                sta tmp1+1
.8f29		b2 25		lda ($25)	                lda (tmp1)
.8f2b		91 00		sta ($00),y	                sta (cp),y
.8f2d		5a		phy		                phy
.8f2e		a0 01		ldy #$01	                ldy #1
.8f30		b1 25		lda ($25),y	                lda (tmp1),y
.8f32		7a		ply		                ply
.8f33		c8		iny		                iny
.8f34		91 00		sta ($00),y	                sta (cp),y
.8f36		c8		iny		                iny
.8f37						_update_cp:
.8f37		98		tya		                tya
.8f38		18		clc		                clc
.8f39		65 00		adc $00		                adc cp
.8f3b		85 00		sta $00		                sta cp
.8f3d		90 02		bcc $8f41	                bcc _done
.8f3f		e6 01		inc $01		                inc cp+1
.8f41						_done:
.8f41		60		rts		z_recurse:      rts
.8f42						xt_refill:
.8f42		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.8f44		d0 2d		bne $8f73	                bne _src_not_kbd
.8f46		ca		dex		                dex
.8f47		ca		dex		                dex
.8f48		ca		dex		                dex
.8f49		ca		dex		                dex
.8f4a		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.8f4c		95 02		sta $02,x	                sta 2,x
.8f4e		a5 0d		lda $0d		                lda cib+1
.8f50		95 03		sta $03,x	                sta 3,x
.8f52		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.8f54		64 0f		stz $0f		                stz ciblen+1
.8f56		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.8f58		95 00		sta $00,x	                sta 0,x
.8f5a		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.8f5c		20 e4 80	jsr $80e4	                jsr xt_accept           ; ( addr n1 -- n2)
.8f5f		b5 00		lda $00,x	                lda 0,x
.8f61		85 0e		sta $0e		                sta ciblen
.8f63		b5 01		lda $01,x	                lda 1,x
.8f65		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.8f67		64 10		stz $10		                stz toin
.8f69		64 11		stz $11		                stz toin+1
.8f6b		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.8f6d		95 00		sta $00,x	                sta 0,x
.8f6f		95 01		sta $01,x	                sta 1,x
.8f71		80 10		bra $8f83	                bra _done
.8f73						_src_not_kbd:
.8f73		1a		inc a		                ina
.8f74		d0 08		bne $8f7e	                bne _src_not_string
.8f76		ca		dex		                dex
.8f77		ca		dex		                dex
.8f78		74 00		stz $00,x	                stz 0,x
.8f7a		74 01		stz $01,x	                stz 1,x
.8f7c		80 05		bra $8f83	                bra z_refill
.8f7e						_src_not_string:
.8f7e		a9 01		lda #$01	                lda #err_badsource
.8f80		4c 7e d7	jmp $d77e	                jmp error
.8f83						_done:
.8f83		60		rts		z_refill:       rts
.8f84						xt_repeat:
.8f84		20 1f 82	jsr $821f	                jsr xt_again
.8f87		4c b4 86	jmp $86b4	                jmp xt_then
.8f8a						z_repeat:
.8f8a						xt_right_bracket:
.8f8a		a9 ff		lda #$ff	                lda #$FF
.8f8c		85 1a		sta $1a		                sta state
.8f8e		85 1b		sta $1b		                sta state+1
.8f90						z_right_bracket:
.8f90		60		rts		                rts
.8f91						xt_rot:
.8f91		20 72 d7	jsr $d772	                jsr underflow_3
.8f94		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.8f96		b5 03		lda $03,x	                lda 3,x
.8f98		95 05		sta $05,x	                sta 5,x
.8f9a		b5 01		lda $01,x	                lda 1,x
.8f9c		95 03		sta $03,x	                sta 3,x
.8f9e		94 01		sty $01,x	                sty 1,x
.8fa0		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.8fa2		b5 02		lda $02,x	                lda 2,x
.8fa4		95 04		sta $04,x	                sta 4,x
.8fa6		b5 00		lda $00,x	                lda 0,x
.8fa8		95 02		sta $02,x	                sta 2,x
.8faa		94 00		sty $00,x	                sty 0,x
.8fac		60		rts		z_rot:          rts
.8fad						xt_rshift:
.8fad		20 6d d7	jsr $d76d	                jsr underflow_2
.8fb0		b5 00		lda $00,x	                lda 0,x
.8fb2		29 0f		and #$0f	                and #%00001111
.8fb4		f0 08		beq $8fbe	                beq _done               ; if 0 shifts, quit
.8fb6		a8		tay		                tay
.8fb7						_loop:
.8fb7		56 03		lsr $03,x	                lsr 3,x
.8fb9		76 02		ror $02,x	                ror 2,x
.8fbb		88		dey		                dey
.8fbc		d0 f9		bne $8fb7	                bne _loop
.8fbe						_done:
.8fbe		e8		inx		                inx
.8fbf		e8		inx		                inx
.8fc0		60		rts		z_rshift:       rts
.8fc1						xt_s_backslash_quote:
.8fc1		a9 ff		lda #$ff	                lda #$FF
.8fc3		85 27		sta $27		                sta tmp2
.8fc5		64 28		stz $28		                stz tmp2+1
.8fc7		20 de 8f	jsr $8fde	                jsr s_quote_start
.8fca						z_s_backslash_quote:
.8fca		60		rts		                rts
.8fcb						convert_hex_value:
.8fcb		c9 41		cmp #$41	        cmp #'A'
.8fcd		90 07		bcc $8fd6	        bcc _digit
.8fcf		29 df		and #$df	        and #$DF                ; Make it uppercase.
.8fd1		38		sec		        sec
.8fd2		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.8fd4		80 03		bra $8fd9	        bra _done
.8fd6						_digit:
.8fd6		38		sec		        sec
.8fd7		e9 30		sbc #$30	        sbc #'0'
.8fd9						_done:
.8fd9		60		rts		        rts
.8fda						xt_s_quote:
.8fda		64 27		stz $27		                stz tmp2
.8fdc		64 28		stz $28		                stz tmp2+1
.8fde						s_quote_start:
.8fde		20 79 97	jsr $9779	                jsr cmpl_jump_later
.8fe1		20 1b 89	jsr $891b	                jsr xt_here             ; the start of the string
.8fe4						_savechars_loop:
.8fe4		a5 11		lda $11		                lda toin+1              ; MSB
.8fe6		c5 0f		cmp $0f		                cmp ciblen+1
.8fe8		90 2a		bcc $9014	                bcc _input_fine         ; unsigned comparison
.8fea		a5 10		lda $10		                lda toin                ; LSB
.8fec		c5 0e		cmp $0e		                cmp ciblen
.8fee		90 24		bcc $9014	                bcc _input_fine
.8ff0		a5 27		lda $27		                lda tmp2
.8ff2		48		pha		                pha
.8ff3		a5 28		lda $28		                lda tmp2+1
.8ff5		48		pha		                pha
.8ff6		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.8ff8		48		pha		                pha
.8ff9		20 42 8f	jsr $8f42	                jsr xt_refill           ; ( -- f )
.8ffc		68		pla		                pla
.8ffd		85 29		sta $29		                sta tmp3
.8fff		68		pla		                pla
.9000		85 28		sta $28		                sta tmp2+1
.9002		68		pla		                pla
.9003		85 27		sta $27		                sta tmp2
.9005		b5 00		lda $00,x	                lda 0,x
.9007		15 01		ora $01,x	                ora 1,x
.9009		d0 05		bne $9010	                bne _refill_ok
.900b		a9 06		lda #$06	                lda #err_refill
.900d		4c 7e d7	jmp $d77e	                jmp error
.9010						_refill_ok:
.9010		e8		inx		                inx
.9011		e8		inx		                inx
.9012		80 d0		bra $8fe4	                bra _savechars_loop
.9014						_input_fine:
.9014		a5 0c		lda $0c		                lda cib
.9016		18		clc		                clc
.9017		65 10		adc $10		                adc toin        ; LSB
.9019		85 25		sta $25		                sta tmp1
.901b		a5 0d		lda $0d		                lda cib+1
.901d		65 11		adc $11		                adc toin+1      ; MSB
.901f		85 26		sta $26		                sta tmp1+1
.9021		b2 25		lda ($25)	                lda (tmp1)
.9023		24 27		bit $27		                bit tmp2
.9025		30 03		bmi $902a	                bmi _handle_escapes    ; Only checking bit 7
.9027		4c ad 90	jmp $90ad	                jmp _regular_char
.902a						_handle_escapes:
.902a		24 28		bit $28		                bit tmp2+1
.902c		30 03		bmi $9031	                bmi _escaped
.902e		4c a3 90	jmp $90a3	                jmp _not_escaped
.9031						_escaped:
.9031		70 3c		bvs $906f	                bvs _check_esc_chars
.9033		a9 01		lda #$01	                lda #1
.9035		24 28		bit $28		                bit tmp2+1
.9037		d0 10		bne $9049	                bne _esc_x_second_digit
.9039		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.903b		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.903d		20 cb 8f	jsr $8fcb	                jsr convert_hex_value
.9040		0a		asl a		                asl
.9041		0a		asl a		                asl
.9042		0a		asl a		                asl
.9043		0a		asl a		                asl
.9044		85 29		sta $29		                sta tmp3    ; Save it for later.
.9046		4c b4 90	jmp $90b4	                jmp _next_character
.9049						_esc_x_second_digit:
.9049		64 28		stz $28		                stz tmp2+1
.904b		b2 25		lda ($25)	                lda (tmp1)
.904d		20 cb 8f	jsr $8fcb	                jsr convert_hex_value
.9050		05 29		ora $29		                ora tmp3
.9052		4c b1 90	jmp $90b1	                jmp _save_character
.9055						_esc_tr_table:
>9055		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9056		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9057		00 00				    .byte   0,0             ; c, d no escape
>9059		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>905a		0c				    .byte   12              ; f -> FF (ASCII value 12)
>905b		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9060		0a				    .byte   10              ; l -> LF (ASCII value 10)
>9061		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9062		0a				    .byte   10              ; n behaves like l --> lf
>9063		00 00				    .byte   0,0             ; o,p
>9065		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9066		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9067		00				    .byte   0               ; s
>9068		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9069		00				    .byte   0               ; u
>906a		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>906b		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>906e		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.906f						_check_esc_chars:
.906f		64 28		stz $28		                stz tmp2+1
.9071		c9 61		cmp #$61	                cmp #'a'
.9073		30 1a		bmi $908f	                bmi _check_esc_quote
.9075		c9 7b		cmp #$7b	                cmp #'z'+1
.9077		10 16		bpl $908f	                bpl _check_esc_quote
.9079		a8		tay		                tay
.907a		b9 f4 8f	lda $8ff4,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.907d		d0 03		bne $9082	                bne _esc_replace
.907f		98		tya		                tya                     ; revert if no translation
.9080		80 0d		bra $908f	                bra _check_esc_quote
.9082		10 2d		bpl $90b1	_esc_replace:   bpl _save_character     ; simple replacement
.9084		29 7f		and #$7f	                and #$7F                ; clear hi bit
.9086		f0 29		beq $90b1	                beq _save_character     ; NUL we can just output
.9088		20 68 97	jsr $9768	                jsr cmpl_a              ; else output first char (CR)
.908b		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.908d		80 22		bra $90b1	                bra _save_character
.908f						_check_esc_quote:
.908f		c9 22		cmp #$22	                cmp #'"'
.9091		f0 1e		beq $90b1	                beq _save_character
.9093		c9 78		cmp #$78	                cmp #'x'
.9095		d0 06		bne $909d	                bne _check_esc_backslash
.9097		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.9099		85 28		sta $28		                sta tmp2+1
.909b		80 17		bra $90b4	                bra _next_character
.909d						_check_esc_backslash:
.909d		c9 5c		cmp #$5c	                cmp #'\'
.909f		d0 0c		bne $90ad	                bne _regular_char
.90a1		80 0e		bra $90b1	                bra _save_character
.90a3						_not_escaped:
.90a3		c9 5c		cmp #$5c	                cmp #'\'
.90a5		d0 06		bne $90ad	                bne _regular_char
.90a7		a9 ff		lda #$ff	                lda #$FF
.90a9		85 28		sta $28		                sta tmp2+1
.90ab		80 07		bra $90b4	                bra _next_character
.90ad						_regular_char:
.90ad		c9 22		cmp #$22	                cmp #'"'
.90af		f0 0c		beq $90bd	                beq _found_string_end
.90b1						_save_character:
.90b1		20 68 97	jsr $9768	                jsr cmpl_a
.90b4						_next_character:
.90b4		e6 10		inc $10		                inc toin
.90b6		d0 02		bne $90ba	                bne _savechars_loop_longjump
.90b8		e6 11		inc $11		                inc toin+1
.90ba						_savechars_loop_longjump:
.90ba		4c e4 8f	jmp $8fe4	                jmp _savechars_loop
.90bd						_found_string_end:
.90bd		e6 10		inc $10		                inc toin
.90bf		d0 02		bne $90c3	                bne +
.90c1		e6 11		inc $11		                inc toin+1
.90c3						+
.90c3		20 1b 89	jsr $891b	                jsr xt_here
.90c6		20 91 8f	jsr $8f91	                jsr xt_rot
.90c9		20 18 92	jsr $9218	                jsr xt_store    ; Update the jmp target
.90cc		20 1b 89	jsr $891b	                jsr xt_here
.90cf		20 05 8d	jsr $8d05	                jsr xt_over
.90d2		20 e4 8b	jsr $8be4	                jsr xt_minus    ; HERE - addr gives string length
.90d5		a5 1a		lda $1a		                lda state
.90d7		05 1b		ora $1b		                ora state+1             ; paranoid
.90d9		f0 03		beq $90de	                beq _done
.90db		20 3a a1	jsr $a13a	                jsr cmpl_sliteral         ; ( addr u -- )
.90de						_done:
.90de		60		rts		z_s_quote:      rts
.90df						xt_s_to_d:
.90df		20 68 d7	jsr $d768	                jsr underflow_1
.90e2		ca		dex		                dex
.90e3		ca		dex		                dex
.90e4		74 00		stz $00,x	                stz 0,x
.90e6		74 01		stz $01,x	                stz 1,x
.90e8		b5 03		lda $03,x	                lda 3,x
.90ea		10 04		bpl $90f0	                bpl _done
.90ec		d6 00		dec $00,x	                dec 0,x
.90ee		d6 01		dec $01,x	                dec 1,x
.90f0						_done:
.90f0		60		rts		z_s_to_d:       rts
.90f1						xt_semicolon:
.90f1		24 1c		bit $1c		                bit status
.90f3		70 11		bvs $9106	                bvs _colonword
.90f5		a9 60		lda #$60	                lda #OpRTS
.90f7		20 68 97	jsr $9768	                jsr cmpl_a
.90fa		ca		dex		                dex
.90fb		ca		dex		                dex
.90fc		a5 06		lda $06		                lda workword
.90fe		95 00		sta $00,x	                sta 0,x
.9100		a5 07		lda $07		                lda workword+1
.9102		95 01		sta $01,x	                sta 1,x
.9104		80 45		bra $914b	                bra _semicolon_done
.9106						_colonword:
.9106		a0 06		ldy #$06	                ldy #6
.9108		a5 00		lda $00		                lda cp
.910a		91 06		sta ($06),y	                sta (workword),y
.910c		c8		iny		                iny
.910d		a5 01		lda $01		                lda cp+1
.910f		91 06		sta ($06),y	                sta (workword),y
.9111		a9 60		lda #$60	                lda #OpRTS
.9113		20 68 97	jsr $9768	                jsr cmpl_a
.9116		24 1c		bit $1c		                bit status
.9118		10 26		bpl $9140	                bpl _new_word   ; Bit 7 is clear = new word
.911a		ca		dex		                dex
.911b		ca		dex		                dex
.911c		ca		dex		                dex
.911d		ca		dex		                dex
.911e		b2 06		lda ($06)	                lda (workword)
.9120		95 00		sta $00,x	                sta 0,x
.9122		74 01		stz $01,x	                stz 1,x
.9124		a5 06		lda $06		                lda workword
.9126		18		clc		                clc
.9127		69 08		adc #$08	                adc #8
.9129		95 02		sta $02,x	                sta 2,x
.912b		a5 07		lda $07		                lda workword+1
.912d		69 00		adc #$00	                adc #0                  ; only want carry
.912f		95 03		sta $03,x	                sta 3,x
.9131		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9133		20 a4 d7	jsr $d7a4	                jsr print_string_no_lf
.9136		20 b7 94	jsr $94b7	                jsr xt_type
.9139		20 cb 91	jsr $91cb	                jsr xt_space
.913c		a9 80		lda #$80	                lda #%10000000
.913e		14 1c		trb $1c		                trb status
.9140						_new_word:
.9140		a5 06		lda $06		                lda workword
.9142		85 02		sta $02		                sta dp
.9144		a5 07		lda $07		                lda workword+1
.9146		85 03		sta $03		                sta dp+1
.9148		20 d2 d6	jsr $d6d2	                jsr dp_to_current       ; Save the updated DP to the
.914b						_semicolon_done:
.914b		64 1a		stz $1a		                stz state
.914d		64 1b		stz $1b		                stz state+1
.914f		60		rts		z_semicolon:    rts
.9150						xt_sign:
.9150		20 68 d7	jsr $d768	                jsr underflow_1
.9153		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9155		30 04		bmi $915b	                bmi _minus
.9157		e8		inx		                inx
.9158		e8		inx		                inx
.9159		80 09		bra $9164	                bra _done
.915b						_minus:
.915b		a9 2d		lda #$2d	                lda #'-'
.915d		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.915f		74 01		stz $01,x	                stz 1,x         ; paranoid
.9161		20 2d 89	jsr $892d	                jsr xt_hold
.9164						_done:
.9164		60		rts		z_sign:         rts
.9165						xt_slash:
.9165		a9 00		lda #$00	                lda #0
.9167		48		pha		                pha
.9168		80 03		bra $916d	                bra slashmod_common
.916a						xt_slash_mod:
.916a		a9 ff		lda #$ff	                lda #$FF
.916c		48		pha		                pha             ; falls through to _common
.916d						slashmod_common:
.916d		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R
.9170		20 df 90	jsr $90df	                jsr xt_s_to_d           ; S>D
.9173		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R>
.9176		20 82 91	jsr $9182	                jsr xt_sm_slash_rem     ; SM/REM
.9179		68		pla		                pla
.917a		d0 05		bne $9181	                bne _done
.917c		20 2e 92	jsr $922e	                jsr xt_swap
.917f		e8		inx		                inx             ; DROP
.9180		e8		inx		                inx
.9181						_done:
.9181						z_slash_mod:
.9181		60		rts		z_slash:        rts
.9182						xt_sm_slash_rem:
.9182		20 72 d7	jsr $d772	                jsr underflow_3 ; contains double number
.9185		b5 03		lda $03,x	                lda 3,x
.9187		48		pha		                pha
.9188		b5 01		lda $01,x	                lda 1,x
.918a		55 03		eor $03,x	                eor 3,x
.918c		48		pha		                pha
.918d		20 cf 80	jsr $80cf	                jsr xt_abs
.9190		e8		inx		                inx             ; pretend we pushed n1 to R
.9191		e8		inx		                inx
.9192		20 1e 9e	jsr $9e1e	                jsr xt_dabs
.9195		ca		dex		                dex
.9196		ca		dex		                dex
.9197		20 3c 95	jsr $953c	                jsr xt_um_slash_mod     ; UM/MOD
.919a		68		pla		                pla
.919b		10 03		bpl $91a0	                bpl +
.919d		20 1f 8c	jsr $8c1f	                jsr xt_negate
.91a0						+
.91a0		68		pla		                pla
.91a1		10 07		bpl $91aa	                bpl _done
.91a3		e8		inx		                inx             ; pretend we pushed quotient to R
.91a4		e8		inx		                inx
.91a5		20 1f 8c	jsr $8c1f	                jsr xt_negate
.91a8		ca		dex		                dex
.91a9		ca		dex		                dex
.91aa						_done:
.91aa		60		rts		z_sm_slash_rem: rts
.91ab						xt_source:
.91ab		ca		dex		                dex
.91ac		ca		dex		                dex
.91ad		a5 0c		lda $0c		                lda cib
.91af		95 00		sta $00,x	                sta 0,x
.91b1		a5 0d		lda $0d		                lda cib+1
.91b3		95 01		sta $01,x	                sta 1,x
.91b5		ca		dex		                dex
.91b6		ca		dex		                dex
.91b7		a5 0e		lda $0e		                lda ciblen
.91b9		95 00		sta $00,x	                sta 0,x
.91bb		a5 0f		lda $0f		                lda ciblen+1
.91bd		95 01		sta $01,x	                sta 1,x
.91bf		60		rts		z_source:       rts
.91c0						xt_source_id:
.91c0		ca		dex		                dex
.91c1		ca		dex		                dex
.91c2		a5 0a		lda $0a		                lda insrc
.91c4		95 00		sta $00,x	                sta 0,x
.91c6		a5 0b		lda $0b		                lda insrc+1
.91c8		95 01		sta $01,x	                sta 1,x
.91ca		60		rts		z_source_id:    rts
.91cb						xt_space:
.91cb		a9 20		lda #$20	                lda #AscSP
.91cd		20 c5 86	jsr $86c5	                jsr emit_a
.91d0		60		rts		z_space:        rts
.91d1						xt_spaces:
.91d1		20 68 d7	jsr $d768	                jsr underflow_1
.91d4		b5 01		lda $01,x	                lda 1,x         ; ANS says this word takes a signed value
.91d6		30 10		bmi $91e8	                bmi _done       ; but prints no spaces for negative values.
.91d8		b4 00		ldy $00,x	                ldy 0,x
.91da		f0 08		beq $91e4	                beq _msb
.91dc						_loop:
.91dc		a9 20		lda #$20	                lda #AscSP
.91de		20 c5 86	jsr $86c5	                jsr emit_a      ; user routine preserves X and Y
.91e1		88		dey		                dey
.91e2		d0 f8		bne $91dc	                bne _loop       ; Y is zero on exit so looping again emits 256 more spaces
.91e4						_msb:
.91e4		d6 01		dec $01,x	                dec 1,x         ; when decrementing MSB goes negative, it was zero so we're done
.91e6		10 f4		bpl $91dc	                bpl _loop       ; otherwise emit another 256 spaces
.91e8		e8		inx		_done:          inx
.91e9		e8		inx		                inx
.91ea		60		rts		z_spaces:       rts
.91eb						xt_star:
.91eb		20 6d d7	jsr $d76d	                jsr underflow_2
.91ee		20 7e 95	jsr $957e	                jsr xt_um_star
.91f1		e8		inx		                inx
.91f2		e8		inx		                inx
.91f3		60		rts		z_star:         rts
.91f4						xt_star_slash:
.91f4		20 fd 91	jsr $91fd	                jsr xt_star_slash_mod
.91f7		20 2e 92	jsr $922e	                jsr xt_swap
.91fa		e8		inx		                inx
.91fb		e8		inx		                inx
.91fc						z_star_slash:
.91fc		60		rts		                rts
.91fd						xt_star_slash_mod:
.91fd		20 72 d7	jsr $d772	                jsr underflow_3
.9200		20 6c 93	jsr $936c	                jsr xt_to_r
.9203		20 21 8b	jsr $8b21	                jsr xt_m_star
.9206		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.9209		20 82 91	jsr $9182	                jsr xt_sm_slash_rem
.920c						z_star_slash_mod:
.920c		60		rts		                rts
.920d						xt_state:
.920d		ca		dex		                dex
.920e		ca		dex		                dex
.920f		a9 1a		lda #$1a	                lda #<state
.9211		95 00		sta $00,x	                sta 0,x
.9213		a9 00		lda #$00	                lda #>state
.9215		95 01		sta $01,x	                sta 1,x
.9217		60		rts		z_state:        rts
.9218						xt_store:
.9218		20 6d d7	jsr $d76d	                jsr underflow_2
.921b		b5 02		lda $02,x	                lda 2,x         ; LSB
.921d		81 00		sta ($00,x)	                sta (0,x)
.921f		f6 00		inc $00,x	                inc 0,x
.9221		d0 02		bne $9225	                bne +
.9223		f6 01		inc $01,x	                inc 1,x
.9225						+
.9225		b5 03		lda $03,x	                lda 3,x         ; MSB
.9227		81 00		sta ($00,x)	                sta (0,x)
.9229		e8		inx		                inx             ; 2DROP
.922a		e8		inx		                inx
.922b		e8		inx		                inx
.922c		e8		inx		                inx
.922d		60		rts		z_store:        rts
.922e						xt_swap:
.922e		20 6d d7	jsr $d76d	                jsr underflow_2
.9231		b5 00		lda $00,x	                lda 0,x         ; LSB
.9233		b4 02		ldy $02,x	                ldy 2,x
.9235		95 02		sta $02,x	                sta 2,x
.9237		94 00		sty $00,x	                sty 0,x
.9239		b5 01		lda $01,x	                lda 1,x         ; MSB
.923b		b4 03		ldy $03,x	                ldy 3,x
.923d		95 03		sta $03,x	                sta 3,x
.923f		94 01		sty $01,x	                sty 1,x
.9241		60		rts		z_swap:         rts
.9242						xt_tick:
.9242		20 51 8d	jsr $8d51	                jsr xt_parse_name       ; ( -- addr u )
.9245		b5 00		lda $00,x	                lda 0,x
.9247		15 01		ora $01,x	                ora 1,x
.9249		d0 05		bne $9250	                bne +
.924b		a9 05		lda #$05	                lda #err_noname
.924d		4c 7e d7	jmp $d77e	                jmp error
.9250						+
.9250		20 ce 9a	jsr $9ace	                jsr xt_find_name        ; ( addr u -- nt )
.9253		b5 00		lda $00,x	                lda 0,x
.9255		15 01		ora $01,x	                ora 1,x
.9257		d0 05		bne $925e	                bne +
.9259		a9 08		lda #$08	                lda #err_syntax
.925b		4c 7e d7	jmp $d77e	                jmp error
.925e						+
.925e		20 0c 9c	jsr $9c0c	                jsr xt_name_to_int      ; ( nt -- xt )
.9261		60		rts		z_tick:         rts
.9262						xt_to:
.9262		20 42 92	jsr $9242	                jsr xt_tick             ; ( [n] xt )
.9265		b5 00		lda $00,x	                lda 0,x                 ; LSB
.9267		18		clc		                clc
.9268		69 03		adc #$03	                adc #3
.926a		85 25		sta $25		                sta tmp1
.926c		b5 01		lda $01,x	                lda 1,x                 ; MSB
.926e		69 00		adc #$00	                adc #0                  ; we just want the carry
.9270		85 26		sta $26		                sta tmp1+1
.9272		a5 1a		lda $1a		                lda state
.9274		05 1b		ora $1b		                ora state+1
.9276		f0 14		beq $928c	                beq _interpret
.9278		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.927a		95 00		sta $00,x	                sta 0,x
.927c		a5 26		lda $26		                lda tmp1+1
.927e		95 01		sta $01,x	                sta 1,x
.9280		20 f2 89	jsr $89f2	                jsr xt_literal      ; generate the runtime for LITERAL tmp1
.9283		a0 92		ldy #$92	                ldy #>xt_store      ; write the runtime for !
.9285		a9 18		lda #$18	                lda #<xt_store
.9287		20 58 97	jsr $9758	                jsr cmpl_subroutine
.928a		80 11		bra $929d	                bra _done
.928c						_interpret:
.928c		20 6d d7	jsr $d76d	                jsr underflow_2
.928f		e8		inx		                inx
.9290		e8		inx		                inx                     ; leaving just ( n )
.9291		b5 00		lda $00,x	                lda 0,x
.9293		92 25		sta ($25)	                sta (tmp1)              ; LSB
.9295		a0 01		ldy #$01	                ldy #1
.9297		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9299		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.929b		e8		inx		                inx                     ; DROP
.929c		e8		inx		                inx
.929d						_done:
.929d		60		rts		z_to:           rts
.929e						xt_to_body:
.929e		20 68 d7	jsr $d768	                jsr underflow_1
.92a1		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( xt xt )
.92a4		20 86 9b	jsr $9b86	                jsr xt_int_to_name      ; ( xt nt )
.92a7		f6 00		inc $00,x	                inc 0,x
.92a9		d0 02		bne $92ad	                bne +
.92ab		f6 01		inc $01,x	                inc 1,x
.92ad						+
.92ad		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.92af		29 20		and #$20	                and #HC
.92b1		f0 0b		beq $92be	                beq _no_cfa
.92b3		18		clc		                clc
.92b4		b5 02		lda $02,x	                lda 2,x         ; LSB
.92b6		69 03		adc #$03	                adc #3
.92b8		95 02		sta $02,x	                sta 2,x
.92ba		90 02		bcc $92be	                bcc _no_cfa
.92bc		f6 03		inc $03,x	                inc 3,x         ; MSB
.92be						_no_cfa:
.92be		e8		inx		                inx             ; get rid of the nt
.92bf		e8		inx		                inx
.92c0		60		rts		z_to_body:      rts
.92c1						xt_to_in:
.92c1		ca		dex		                dex
.92c2		ca		dex		                dex
.92c3		a9 10		lda #$10	                lda #<toin
.92c5		95 00		sta $00,x	                sta 0,x
.92c7		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.92c9		95 01		sta $01,x	                sta 1,x
.92cb		60		rts		z_to_in:        rts
.92cc						xt_to_number:
.92cc		20 77 d7	jsr $d777	                jsr underflow_4
.92cf		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.92d1		85 2d		sta $2d		                sta scratch
.92d3		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.92d5		85 2e		sta $2e		                sta scratch+1
.92d7		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.92d9		85 2f		sta $2f		                sta scratch+2
.92db		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.92dd		85 30		sta $30		                sta scratch+3
.92df		ca		dex		                dex
.92e0		ca		dex		                dex
.92e1						_loop:
.92e1		a1 04		lda ($04,x)	                lda (4,x)
.92e3		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.92e5		74 01		stz $01,x	                stz 1,x                 ; paranoid
.92e7		20 72 9a	jsr $9a72	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.92ea		b5 00		lda $00,x	                lda 0,x
.92ec		d0 04		bne $92f2	                bne _digit_ok
.92ee		e8		inx		                inx
.92ef		e8		inx		                inx
.92f0		80 67		bra $9359	                bra _done       ; ( ud-lo ud-hi addr u char )
.92f2						_digit_ok:
.92f2		b5 02		lda $02,x	                lda 2,x
.92f4		85 31		sta $31		                sta scratch+4
.92f6		b5 03		lda $03,x	                lda 3,x
.92f8		85 32		sta $32		                sta scratch+5
.92fa		a5 2f		lda $2f		                lda scratch+2
.92fc		95 02		sta $02,x	                sta 2,x         ; NOS
.92fe		a5 30		lda $30		                lda scratch+3
.9300		95 03		sta $03,x	                sta 3,x
.9302		a5 18		lda $18		                lda base
.9304		95 00		sta $00,x	                sta 0,x         ; TOS
.9306		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.9308		20 7e 95	jsr $957e	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.930b		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.930d		85 33		sta $33		                sta scratch+6
.930f		b5 03		lda $03,x	                lda 3,x
.9311		85 34		sta $34		                sta scratch+7
.9313		a5 2d		lda $2d		                lda scratch
.9315		95 02		sta $02,x	                sta 2,x
.9317		a5 2e		lda $2e		                lda scratch+1
.9319		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.931b		a5 18		lda $18		                lda base
.931d		95 00		sta $00,x	                sta 0,x
.931f		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.9321		20 7e 95	jsr $957e	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.9324		b5 00		lda $00,x	                lda 0,x
.9326		85 2f		sta $2f		                sta scratch+2
.9328		b5 01		lda $01,x	                lda 1,x
.932a		85 30		sta $30		                sta scratch+3
.932c		b5 02		lda $02,x	                lda 2,x
.932e		85 2d		sta $2d		                sta scratch
.9330		b5 03		lda $03,x	                lda 3,x
.9332		85 2e		sta $2e		                sta scratch+1
.9334		18		clc		                clc
.9335		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.9337		65 31		adc $31		                adc scratch+4   ; n LSB
.9339		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.933b		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.933d		65 32		adc $32		                adc scratch+5   ; n MSB
.933f		85 2e		sta $2e		                sta scratch+1
.9341		a5 2f		lda $2f		                lda scratch+2   ; LSB
.9343		65 33		adc $33		                adc scratch+6
.9345		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.9347		a5 30		lda $30		                lda scratch+3   ; MSB
.9349		65 34		adc $34		                adc scratch+7
.934b		85 30		sta $30		                sta scratch+3
.934d		e8		inx		                inx
.934e		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.934f		f6 04		inc $04,x	                inc 4,x
.9351		d0 02		bne $9355	                bne +
.9353		f6 05		inc $05,x	                inc 5,x
.9355						+
.9355		d6 02		dec $02,x	                dec 2,x
.9357		d0 88		bne $92e1	                bne _loop
.9359						_done:
.9359		e8		inx		                inx
.935a		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.935b		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.935d		95 06		sta $06,x	                sta 6,x
.935f		a5 2e		lda $2e		                lda scratch+1
.9361		95 07		sta $07,x	                sta 7,x
.9363		a5 2f		lda $2f		                lda scratch+2
.9365		95 04		sta $04,x	                sta 4,x
.9367		a5 30		lda $30		                lda scratch+3
.9369		95 05		sta $05,x	                sta 5,x
.936b		60		rts		z_to_number:    rts
.936c						xt_to_r:
.936c		68		pla		                pla                     ; LSB
.936d		7a		ply		                ply                     ; MSB
.936e		1a		inc a		                inc a
.936f		85 25		sta $25		                sta tmp1                ; LSB
.9371		d0 01		bne $9374	                bne +
.9373		c8		iny		                iny
.9374						+
.9374		84 26		sty $26		                sty tmp1+1              ; MSB
.9376		20 68 d7	jsr $d768	                jsr underflow_1
.9379		b5 01		lda $01,x	                lda 1,x         ; MSB
.937b		48		pha		                pha
.937c		b5 00		lda $00,x	                lda 0,x         ; LSB
.937e		48		pha		                pha
.937f		e8		inx		                inx
.9380		e8		inx		                inx
.9381		6c 25 00	jmp ($0025)	z_to_r:         jmp (tmp1)
.9384						xt_true:
.9384		ca		dex		                dex
.9385		ca		dex		                dex
.9386		a9 ff		lda #$ff	                lda #$FF
.9388		95 00		sta $00,x	                sta 0,x
.938a		95 01		sta $01,x	                sta 1,x
.938c		60		rts		z_true:         rts
.938d						xt_tuck:
.938d		20 6d d7	jsr $d76d	                jsr underflow_2
.9390		ca		dex		                dex
.9391		ca		dex		                dex
.9392		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.9394		b5 02		lda $02,x	                lda 2,x
.9396		95 04		sta $04,x	                sta 4,x
.9398		94 02		sty $02,x	                sty 2,x
.939a		95 00		sta $00,x	                sta 0,x
.939c		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.939e		b5 03		lda $03,x	                lda 3,x
.93a0		95 05		sta $05,x	                sta 5,x
.93a2		94 03		sty $03,x	                sty 3,x         ; bba
.93a4		95 01		sta $01,x	                sta 1,x         ; baa
.93a6		60		rts		z_tuck:         rts
.93a7						xt_two_drop:
.93a7		20 6d d7	jsr $d76d	                jsr underflow_2
.93aa		e8		inx		                inx
.93ab		e8		inx		                inx
.93ac		e8		inx		                inx
.93ad		e8		inx		                inx
.93ae		60		rts		z_two_drop:     rts
.93af						xt_two_dup:
.93af		20 6d d7	jsr $d76d	                jsr underflow_2
.93b2		ca		dex		                dex
.93b3		ca		dex		                dex
.93b4		ca		dex		                dex
.93b5		ca		dex		                dex
.93b6		b5 04		lda $04,x	                lda 4,x         ; TOS
.93b8		95 00		sta $00,x	                sta 0,x
.93ba		b5 05		lda $05,x	                lda 5,x
.93bc		95 01		sta $01,x	                sta 1,x
.93be		b5 06		lda $06,x	                lda 6,x         ; NOS
.93c0		95 02		sta $02,x	                sta 2,x
.93c2		b5 07		lda $07,x	                lda 7,x
.93c4		95 03		sta $03,x	                sta 3,x
.93c6		60		rts		z_two_dup:      rts
.93c7						xt_two_fetch:
.93c7		20 68 d7	jsr $d768	                jsr underflow_1
.93ca		b5 00		lda $00,x	                lda 0,x
.93cc		85 25		sta $25		                sta tmp1
.93ce		b4 01		ldy $01,x	                ldy 1,x
.93d0		84 26		sty $26		                sty tmp1+1
.93d2		ca		dex		                dex             ; reuse one stack element
.93d3		ca		dex		                dex
.93d4		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.93d6		95 00		sta $00,x	                sta 0,x
.93d8		a0 01		ldy #$01	                ldy #1          ; copy next
.93da		b1 25		lda ($25),y	                lda (tmp1),y
.93dc		95 01		sta $01,x	                sta 1,x
.93de		c8		iny		                iny             ; copy next
.93df		b1 25		lda ($25),y	                lda (tmp1),y
.93e1		95 02		sta $02,x	                sta 2,x
.93e3		c8		iny		                iny             ; copy next
.93e4		b1 25		lda ($25),y	                lda (tmp1),y
.93e6		95 03		sta $03,x	                sta 3,x
.93e8		60		rts		z_two_fetch:    rts
.93e9						xt_two_over:
.93e9		20 77 d7	jsr $d777	                jsr underflow_4
.93ec		ca		dex		                dex
.93ed		ca		dex		                dex
.93ee		ca		dex		                dex
.93ef		ca		dex		                dex
.93f0		b5 08		lda $08,x	                lda 8,x
.93f2		95 00		sta $00,x	                sta 0,x
.93f4		b5 09		lda $09,x	                lda 9,x
.93f6		95 01		sta $01,x	                sta 1,x
.93f8		b5 0a		lda $0a,x	                lda 10,x
.93fa		95 02		sta $02,x	                sta 2,x
.93fc		b5 0b		lda $0b,x	                lda 11,x
.93fe		95 03		sta $03,x	                sta 3,x
.9400		60		rts		z_two_over:     rts
.9401						xt_two_r_fetch:
.9401		68		pla		                pla                     ; LSB
.9402		7a		ply		                ply                     ; MSB
.9403		1a		inc a		                inc a
.9404		85 25		sta $25		                sta tmp1                ; LSB
.9406		d0 01		bne $9409	                bne +
.9408		c8		iny		                iny
.9409						+
.9409		84 26		sty $26		                sty tmp1+1              ; MSB
.940b		8a		txa		                txa             ; set up tos as $100+SP
.940c		ba		tsx		                tsx
.940d		86 23		stx $23		                stx tmptos
.940f		aa		tax		                tax
.9410		a9 01		lda #$01	                lda #1
.9412		85 24		sta $24		                sta tmptos+1
.9414		a0 04		ldy #$04	                ldy #4
.9416						-
.9416		ca		dex		                dex
.9417		b1 23		lda ($23),y	                lda (tmptos),y    ; $100+SP+Y
.9419		95 00		sta $00,x	                sta 0,x
.941b		88		dey		                dey
.941c		d0 f8		bne $9416	                bne -
.941e		6c 25 00	jmp ($0025)	z_two_r_fetch:  jmp (tmp1)
.9421						xt_two_r_from:
.9421		68		pla		                pla                     ; LSB
.9422		7a		ply		                ply                     ; MSB
.9423		1a		inc a		                inc a
.9424		85 25		sta $25		                sta tmp1                ; LSB
.9426		d0 01		bne $9429	                bne +
.9428		c8		iny		                iny
.9429						+
.9429		84 26		sty $26		                sty tmp1+1              ; MSB
.942b		8a		txa		                txa
.942c		38		sec		                sec
.942d		e9 08		sbc #$08	                sbc #8
.942f		aa		tax		                tax
.9430		a0 04		ldy #$04	                ldy #4
.9432						-
.9432		68		pla		                pla
.9433		95 04		sta $04,x	                sta 4,x
.9435		e8		inx		                inx
.9436		88		dey		                dey
.9437		d0 f9		bne $9432	                bne -
.9439		6c 25 00	jmp ($0025)	z_two_r_from:   jmp (tmp1)
.943c						xt_two_slash:
.943c		20 68 d7	jsr $d768	                jsr underflow_1
.943f		b5 01		lda $01,x	                lda 1,x
.9441		0a		asl a		                asl                     ; save the sign
.9442		76 01		ror $01,x	                ror 1,x
.9444		76 00		ror $00,x	                ror 0,x
.9446		60		rts		z_two_slash:    rts
.9447						xt_two_star:
.9447						xt_cells:
.9447		20 68 d7	jsr $d768	                jsr underflow_1
.944a		16 00		asl $00,x	                asl 0,x
.944c		36 01		rol $01,x	                rol 1,x
.944e						z_cells:
.944e		60		rts		z_two_star:     rts
.944f						xt_two_store:
.944f		20 72 d7	jsr $d772	                jsr underflow_3
.9452		b5 00		lda $00,x	                lda 0,x
.9454		85 25		sta $25		                sta tmp1
.9456		b4 01		ldy $01,x	                ldy 1,x
.9458		84 26		sty $26		                sty tmp1+1
.945a		e8		inx		                inx
.945b		e8		inx		                inx
.945c		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.945e		92 25		sta ($25)	                sta (tmp1)
.9460		b5 01		lda $01,x	                lda 1,x         ; copy next
.9462		a0 01		ldy #$01	                ldy #1
.9464		91 25		sta ($25),y	                sta (tmp1),y
.9466		b5 02		lda $02,x	                lda 2,x         ; copy next
.9468		c8		iny		                iny
.9469		91 25		sta ($25),y	                sta (tmp1),y
.946b		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.946d		c8		iny		                iny
.946e		91 25		sta ($25),y	                sta (tmp1),y
.9470		e8		inx		                inx             ; 2DROP
.9471		e8		inx		                inx
.9472		e8		inx		                inx
.9473		e8		inx		                inx
.9474		60		rts		z_two_store:    rts
.9475						xt_two_swap:
.9475		20 77 d7	jsr $d777	                jsr underflow_4
.9478		b5 00		lda $00,x	                lda 0,x
.947a		b4 04		ldy $04,x	                ldy 4,x
.947c		95 04		sta $04,x	                sta 4,x
.947e		94 00		sty $00,x	                sty 0,x
.9480		b5 01		lda $01,x	                lda 1,x
.9482		b4 05		ldy $05,x	                ldy 5,x
.9484		95 05		sta $05,x	                sta 5,x
.9486		94 01		sty $01,x	                sty 1,x
.9488		b5 02		lda $02,x	                lda 2,x
.948a		b4 06		ldy $06,x	                ldy 6,x
.948c		95 06		sta $06,x	                sta 6,x
.948e		94 02		sty $02,x	                sty 2,x
.9490		b5 03		lda $03,x	                lda 3,x
.9492		b4 07		ldy $07,x	                ldy 7,x
.9494		95 07		sta $07,x	                sta 7,x
.9496		94 03		sty $03,x	                sty 3,x
.9498		60		rts		z_two_swap:     rts
.9499						xt_two_to_r:
.9499		68		pla		                pla                     ; LSB
.949a		7a		ply		                ply                     ; MSB
.949b		1a		inc a		                inc a
.949c		85 25		sta $25		                sta tmp1                ; LSB
.949e		d0 01		bne $94a1	                bne +
.94a0		c8		iny		                iny
.94a1						+
.94a1		84 26		sty $26		                sty tmp1+1              ; MSB
.94a3		20 6d d7	jsr $d76d	                jsr underflow_2
.94a6		8a		txa		                txa
.94a7		18		clc		                clc
.94a8		69 08		adc #$08	                adc #8
.94aa		aa		tax		                tax
.94ab		a0 04		ldy #$04	                ldy #4
.94ad						-
.94ad		ca		dex		                dex
.94ae		b5 fc		lda $fc,x	                lda $fc,x
.94b0		48		pha		                pha
.94b1		88		dey		                dey
.94b2		d0 f9		bne $94ad	                bne -
.94b4		6c 25 00	jmp ($0025)	z_two_to_r:     jmp (tmp1)
.94b7						xt_type:
.94b7		20 6d d7	jsr $d76d	                jsr underflow_2
.94ba		b5 02		lda $02,x	                lda 2,x
.94bc		85 25		sta $25		                sta tmp1
.94be		b5 03		lda $03,x	                lda 3,x
.94c0		85 26		sta $26		                sta tmp1+1
.94c2						_loop:
.94c2		b5 00		lda $00,x	                lda 0,x
.94c4		15 01		ora $01,x	                ora 1,x
.94c6		f0 15		beq $94dd	                beq _done
.94c8		b2 25		lda ($25)	                lda (tmp1)
.94ca		20 c5 86	jsr $86c5	                jsr emit_a      ; avoids stack foolery
.94cd		e6 25		inc $25		                inc tmp1
.94cf		d0 02		bne $94d3	                bne +
.94d1		e6 26		inc $26		                inc tmp1+1
.94d3						+
.94d3		b5 00		lda $00,x	                lda 0,x
.94d5		d0 02		bne $94d9	                bne +
.94d7		d6 01		dec $01,x	                dec 1,x
.94d9						+
.94d9		d6 00		dec $00,x	                dec 0,x
.94db		80 e5		bra $94c2	                bra _loop
.94dd						_done:
.94dd		e8		inx		                inx
.94de		e8		inx		                inx
.94df		e8		inx		                inx
.94e0		e8		inx		                inx
.94e1		60		rts		z_type:         rts
.94e2						xt_u_dot:
.94e2		20 68 d7	jsr $d768	                jsr underflow_1
.94e5		20 d5 d7	jsr $d7d5	                jsr print_u
.94e8		a9 20		lda #$20	                lda #AscSP
.94ea		20 c5 86	jsr $86c5	                jsr emit_a
.94ed		60		rts		z_u_dot:        rts
.94ee						xt_u_dot_r:
.94ee		20 6d d7	jsr $d76d	                jsr underflow_2
.94f1		20 6c 93	jsr $936c	                jsr xt_to_r
.94f4		20 cf 9d	jsr $9dcf	                jsr xt_zero
.94f7		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.94fa		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.94fd		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.9500		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.9503		20 05 8d	jsr $8d05	                jsr xt_over
.9506		20 e4 8b	jsr $8be4	                jsr xt_minus
.9509		20 d1 91	jsr $91d1	                jsr xt_spaces
.950c		20 b7 94	jsr $94b7	                jsr xt_type
.950f		60		rts		z_u_dot_r:      rts
.9510						xt_u_greater_than:
.9510		20 6d d7	jsr $d76d	                jsr underflow_2
.9513		b5 00		lda $00,x	                lda 0,x
.9515		d5 02		cmp $02,x	                cmp 2,x
.9517		b5 01		lda $01,x	                lda 1,x
.9519		f5 03		sbc $03,x	                sbc 3,x
.951b		e8		inx		                inx
.951c		e8		inx		                inx
.951d		a9 00		lda #$00	                lda #0
.951f		69 ff		adc #$ff	                adc #$FF
.9521		95 00		sta $00,x	                sta 0,x         ; store flag
.9523		95 01		sta $01,x	                sta 1,x
.9525		60		rts		z_u_greater_than:    rts
.9526						xt_u_less_than:
.9526		20 6d d7	jsr $d76d	                jsr underflow_2
.9529		b5 02		lda $02,x	                lda 2,x
.952b		d5 00		cmp $00,x	                cmp 0,x
.952d		b5 03		lda $03,x	                lda 3,x
.952f		f5 01		sbc $01,x	                sbc 1,x
.9531		e8		inx		                inx
.9532		e8		inx		                inx
.9533		a9 00		lda #$00	                lda #0
.9535		69 ff		adc #$ff	                adc #$FF
.9537		95 00		sta $00,x	                sta 0,x         ; store flag
.9539		95 01		sta $01,x	                sta 1,x
.953b		60		rts		z_u_less_than:    rts
.953c						xt_um_slash_mod:
.953c		20 72 d7	jsr $d772	                jsr underflow_3
.953f		b5 00		lda $00,x	                lda 0,x
.9541		15 01		ora $01,x	                ora 1,x
.9543		d0 05		bne $954a	                bne _not_zero
.9545		a9 04		lda #$04	                lda #err_divzero
.9547		4c 7e d7	jmp $d77e	                jmp error
.954a						_not_zero:
.954a		a9 11		lda #$11	                lda #17
.954c		85 23		sta $23		                sta tmptos
.954e						_loop:
.954e		36 04		rol $04,x	                rol 4,x
.9550		36 05		rol $05,x	                rol 5,x
.9552		c6 23		dec $23		                dec tmptos
.9554		f0 22		beq $9578	                beq _done
.9556		36 02		rol $02,x	                rol 2,x
.9558		36 03		rol $03,x	                rol 3,x
.955a		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.955c		26 25		rol $25		                rol tmp1
.955e		38		sec		                sec
.955f		b5 02		lda $02,x	                lda 2,x
.9561		f5 00		sbc $00,x	                sbc 0,x
.9563		85 26		sta $26		                sta tmp1+1
.9565		b5 03		lda $03,x	                lda 3,x
.9567		f5 01		sbc $01,x	                sbc 1,x
.9569		a8		tay		                tay
.956a		a5 25		lda $25		                lda tmp1
.956c		e9 00		sbc #$00	                sbc #0
.956e		90 de		bcc $954e	                bcc _loop
.9570		a5 26		lda $26		                lda tmp1+1
.9572		95 02		sta $02,x	                sta 2,x
.9574		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.9576		80 d6		bra $954e	                bra _loop
.9578						_done:
.9578		e8		inx		                inx
.9579		e8		inx		                inx
.957a		20 2e 92	jsr $922e	                jsr xt_swap
.957d		60		rts		z_um_slash_mod: rts
.957e						xt_um_star:
.957e		20 6d d7	jsr $d76d	                jsr underflow_2
.9581		18		clc		                clc
.9582		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.9584		e9 00		sbc #$00	                sbc #0
.9586		85 27		sta $27		                sta tmp2
.9588		b5 01		lda $01,x	                lda 1,x
.958a		e9 00		sbc #$00	                sbc #0
.958c		90 31		bcc $95bf	                bcc _zero       ; is TOS zero?
.958e		85 28		sta $28		                sta tmp2+1
.9590		a9 00		lda #$00	                lda #0
.9592		85 25		sta $25		                sta tmp1
.9594		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.9596		ca		dex		                dex
.9597		ca		dex		                dex
.9598						_outer_loop:
.9598		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.959a		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.959c						_inner_loop:
.959c		90 0c		bcc $95aa	                bcc _no_add
.959e		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.95a0		a5 25		lda $25		                lda tmp1
.95a2		65 27		adc $27		                adc tmp2
.95a4		85 25		sta $25		                sta tmp1
.95a6		a5 26		lda $26		                lda tmp1+1
.95a8		65 28		adc $28		                adc tmp2+1
.95aa						_no_add:
.95aa		6a		ror a		                ror
.95ab		66 25		ror $25		                ror tmp1
.95ad		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.95af		88		dey		                dey
.95b0		d0 ea		bne $959c	                bne _inner_loop ; go back for one more shift?
.95b2		e8		inx		                inx
.95b3		e4 29		cpx $29		                cpx tmp3
.95b5		d0 e1		bne $9598	                bne _outer_loop ; go back for eight more shifts?
.95b7		95 01		sta $01,x	                sta 1,x
.95b9		a5 25		lda $25		                lda tmp1
.95bb		95 00		sta $00,x	                sta 0,x
.95bd		80 04		bra $95c3	                bra _done
.95bf						_zero:
.95bf		74 02		stz $02,x	                stz 2,x
.95c1		74 03		stz $03,x	                stz 3,x
.95c3						_done:
.95c3		60		rts		z_um_star:      rts
.95c4						xt_unloop:
.95c4		a4 1f		ldy $1f		                ldy loopctrl
.95c6		88		dey		                dey
.95c7		88		dey		                dey
.95c8		88		dey		                dey
.95c9		88		dey		                dey
.95ca		84 1f		sty $1f		                sty loopctrl
.95cc		30 05		bmi $95d3	                bmi z_unloop            ; no active loops?
.95ce		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.95d1		85 20		sta $20		                sta loopidx0
.95d3		60		rts		z_unloop:       rts
.95d4						xt_until:
.95d4		20 aa 97	jsr $97aa	                jsr cmpl_0branch_tos
.95d7		60		rts		z_until:        rts
.95d8						xt_unused:
.95d8		ca		dex		                dex
.95d9		ca		dex		                dex
.95da		a9 00		lda #$00	                lda #<cp_end
.95dc		38		sec		                sec
.95dd		e5 00		sbc $00		                sbc cp
.95df		95 00		sta $00,x	                sta 0,x
.95e1		a9 7c		lda #$7c	                lda #>cp_end
.95e3		e5 01		sbc $01		                sbc cp+1
.95e5		95 01		sta $01,x	                sta 1,x
.95e7		60		rts		z_unused:       rts
.95e8						xt_variable:
.95e8		20 40 84	jsr $8440	                jsr xt_create
.95eb		a9 00		lda #$00	                lda #0
.95ed		92 00		sta ($00)	                sta (cp)
.95ef		e6 00		inc $00		                inc cp
.95f1		d0 02		bne $95f5	                bne +
.95f3		e6 01		inc $01		                inc cp+1
.95f5						+
.95f5		92 00		sta ($00)	                sta (cp)
.95f7		e6 00		inc $00		                inc cp
.95f9		d0 02		bne $95fd	                bne +
.95fb		e6 01		inc $01		                inc cp+1
.95fd						+
.95fd		20 08 84	jsr $8408	                jsr adjust_z
.9600		60		rts		z_variable:     rts
.9601						xt_while:
.9601		20 95 97	jsr $9795	                jsr cmpl_0branch_later          ; branch to location we'll determine later
.9604		20 2e 92	jsr $922e	                jsr xt_swap
.9607		60		rts		z_while:        rts
.9608						xt_within:
.9608		20 72 d7	jsr $d772	                jsr underflow_3
.960b		20 05 8d	jsr $8d05	                jsr xt_over
.960e		20 e4 8b	jsr $8be4	                jsr xt_minus
.9611		20 6c 93	jsr $936c	                jsr xt_to_r
.9614		20 e4 8b	jsr $8be4	                jsr xt_minus
.9617		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.961a		20 26 95	jsr $9526	                jsr xt_u_less_than
.961d		60		rts		z_within:       rts
.961e						xt_word:
.961e		20 68 d7	jsr $d768	                jsr underflow_1
.9621		a4 10		ldy $10		                ldy toin                ; >IN
.9623						_loop:
.9623		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.9625		f0 09		beq $9630	                beq _found_char
.9627		b1 0c		lda ($0c),y	                lda (cib),y
.9629		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.962b		d0 03		bne $9630	                bne _found_char
.962d		c8		iny		                iny
.962e		80 f3		bra $9623	                bra _loop
.9630						_found_char:
.9630		84 10		sty $10		                sty toin
.9632		20 ac 8d	jsr $8dac	                jsr xt_parse            ; Returns ( addr u )
.9635		b5 00		lda $00,x	                lda 0,x
.9637		92 00		sta ($00)	                sta (cp)                ; Save length of string
.9639		48		pha		                pha                     ; Keep copy of length for later
.963a		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr u u )
.963d		a5 00		lda $00		                lda cp
.963f		18		clc		                clc
.9640		69 01		adc #$01	                adc #1
.9642		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.9644		a5 01		lda $01		                lda cp+1
.9646		69 00		adc #$00	                adc #0
.9648		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.964a		20 00 8c	jsr $8c00	                jsr xt_move
.964d		ca		dex		                dex
.964e		ca		dex		                dex
.964f		a5 00		lda $00		                lda cp
.9651		95 00		sta $00,x	                sta 0,x
.9653		a5 01		lda $01		                lda cp+1
.9655		95 01		sta $01,x	                sta 1,x
.9657		68		pla		                pla                     ; length of string
.9658		18		clc		                clc
.9659		65 00		adc $00		                adc cp
.965b		85 00		sta $00		                sta cp
.965d		90 02		bcc $9661	                bcc z_word
.965f		e6 01		inc $01		                inc cp+1
.9661		60		rts		z_word:         rts
.9662						xt_xor:
.9662		20 6d d7	jsr $d76d	                jsr underflow_2
.9665		b5 00		lda $00,x	                lda 0,x
.9667		55 02		eor $02,x	                eor 2,x
.9669		95 02		sta $02,x	                sta 2,x
.966b		b5 01		lda $01,x	                lda 1,x
.966d		55 03		eor $03,x	                eor 3,x
.966f		95 03		sta $03,x	                sta 3,x
.9671		e8		inx		                inx
.9672		e8		inx		                inx
.9673		60		rts		z_xor:          rts
.9674						xt_zero_equal:
.9674		20 68 d7	jsr $d768	                jsr underflow_1
.9677		b5 00		lda $00,x	                lda 0,x
.9679		15 01		ora $01,x	                ora 1,x
.967b		f0 02		beq $967f	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.967d		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.967f						_zero:
.967f		49 ff		eor #$ff	                eor #$FF        ; now just invert:
.9681		95 00		sta $00,x	                sta 0,x
.9683		95 01		sta $01,x	                sta 1,x
.9685		60		rts		z_zero_equal:   rts
.9686						xt_zero_greater:
.9686		20 68 d7	jsr $d768	                jsr underflow_1
.9689		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.968b		b5 01		lda $01,x	                lda 1,x         ; MSB
.968d		30 05		bmi $9694	                bmi _done       ; TOS is negative, keep FLASE
.968f		15 00		ora $00,x	                ora 0,x
.9691		f0 01		beq $9694	                beq _done       ; TOS is zero, keep FALSE
.9693		88		dey		                dey             ; TOS is postive, make true
.9694						_done:
.9694		98		tya		                tya
.9695		95 00		sta $00,x	                sta 0,x
.9697		95 01		sta $01,x	                sta 1,x
.9699		60		rts		z_zero_greater: rts
.969a						xt_zero_less:
.969a		20 68 d7	jsr $d768	                jsr underflow_1
.969d		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.969f		b5 01		lda $01,x	                lda 1,x         ; MSB
.96a1		10 01		bpl $96a4	                bpl _done       ; TOS is positive, so keep FALSE
.96a3		88		dey		                dey             ; TOS is negative, make TRUE
.96a4						_done:
.96a4		98		tya		                tya
.96a5		95 00		sta $00,x	                sta 0,x
.96a7		95 01		sta $01,x	                sta 1,x
.96a9		60		rts		z_zero_less:    rts
.96aa						xt_zero_unequal:
.96aa		20 68 d7	jsr $d768	                jsr underflow_1
.96ad		b5 00		lda $00,x	                lda 0,x
.96af		15 01		ora $01,x	                ora 1,x
.96b1		f0 02		beq $96b5	                beq _zero
.96b3		a9 ff		lda #$ff	                lda #$FF
.96b5						_zero:
.96b5		95 00		sta $00,x	                sta 0,x
.96b7		95 01		sta $01,x	                sta 1,x
.96b9		60		rts		z_zero_unequal: rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/compile.asm

.96ba						xt_compile_comma:
.96ba		20 68 d7	jsr $d768	                jsr underflow_1
.96bd		20 a0 86	jsr $86a0	                jsr xt_dup              ; keep an unadjusted copy of xt
.96c0		20 a0 86	jsr $86a0	                jsr xt_dup              ; plus one to convert to nt
.96c3		20 86 9b	jsr $9b86	                jsr xt_int_to_name
.96c6		b5 00		lda $00,x	                lda 0,x
.96c8		15 01		ora $01,x	                ora 1,x
.96ca		f0 6b		beq $9737	                beq cmpl_as_call        ; No nt so unknown size; must compile as a JSR
.96cc		20 a0 86	jsr $86a0	                jsr xt_dup
.96cf		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; status is at nt+1
.96d2		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.96d4		e8		inx		                inx                     ; drop pointer
.96d5		e8		inx		                inx
.96d6		85 29		sta $29		                sta tmp3                ; keep copy of status byte
.96d8		29 08		and #$08	                and #NN
.96da		d0 5b		bne $9737	                bne cmpl_as_call        ; never native
.96dc		20 ae 9d	jsr $9dae	                jsr xt_wordsize
.96df		a5 29		lda $29		                lda tmp3
.96e1		29 40		and #$40	                and #ST
.96e3		f0 16		beq $96fb	                beq _check_uf
=10						_strip_sz = 10  ; skip the standard 10 byte header which saves return address + 1 to tmp1
.96e5		18		clc		                clc
.96e6		b5 02		lda $02,x	                lda 2,x
.96e8		69 0a		adc #$0a	                adc #_strip_sz
.96ea		95 02		sta $02,x	                sta 2,x
.96ec		90 02		bcc $96f0	                bcc +
.96ee		f6 03		inc $03,x	                inc 3,x                 ; we just care about the carry
.96f0						+
.96f0		38		sec		                sec
.96f1		b5 00		lda $00,x	                lda 0,x
.96f3		e9 0a		sbc #$0a	                sbc #_strip_sz
.96f5		95 00		sta $00,x	                sta 0,x
.96f7		b0 02		bcs $96fb	                bcs +
.96f9		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.96fb						+
.96fb						_check_uf:
.96fb		a5 29		lda $29		                lda tmp3
.96fd		29 10		and #$10	                and #UF
.96ff		f0 1f		beq $9720	                beq _check_limit
.9701		a0 02		ldy #$02	                ldy #uf_strip_offset
.9703		b1 08		lda ($08),y	                lda (up),y
.9705		c8		iny		                iny
.9706		11 08		ora ($08),y	                ora (up),y
.9708		f0 16		beq $9720	                beq _check_limit
.970a		18		clc		                clc
.970b		b5 02		lda $02,x	                lda 2,x
.970d		69 03		adc #$03	                adc #3
.970f		95 02		sta $02,x	                sta 2,x
.9711		90 02		bcc $9715	                bcc +
.9713		f6 03		inc $03,x	                inc 3,x                  ; we just care about the carry
.9715						+
.9715		38		sec		                sec
.9716		b5 00		lda $00,x	                lda 0,x
.9718		e9 03		sbc #$03	                sbc #3
.971a		95 00		sta $00,x	                sta 0,x
.971c		b0 02		bcs $9720	                bcs +
.971e		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.9720						+
.9720						_check_limit:
.9720		a5 29		lda $29		                lda tmp3
.9722		29 02		and #$02	                and #AN                 ; check Always Native (AN) bit
.9724		d0 1e		bne $9744	                bne cmpl_inline         ; always natively compile
.9726						cmpl_by_limit:
.9726		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.9728		b5 01		lda $01,x	                lda 1,x                 ; MSB of word size
.972a		d1 08		cmp ($08),y	                cmp (up),y              ; user-defined limit MSB
.972c		90 16		bcc $9744	                bcc cmpl_inline         ; borrow (C=0) means size < limit
.972e		d0 07		bne $9737	                bne cmpl_as_call        ; else non-zero means size > limit
.9730		88		dey		                dey
.9731		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.9733		d5 00		cmp $00,x	                cmp 0,x
.9735		b0 0d		bcs $9744	                bcs cmpl_inline         ; not bigger, so good to go
.9737						cmpl_as_call:
.9737		20 a7 93	jsr $93a7	                jsr xt_two_drop         ; either way 2drop leaves original xt
.973a		a9 20		lda #$20	                lda #OpJSR
.973c		20 68 97	jsr $9768	                jsr cmpl_a
.973f		20 cd 83	jsr $83cd	                jsr xt_comma
.9742		38		sec		                sec
.9743		60		rts		                rts
.9744						cmpl_inline:
.9744		20 1b 89	jsr $891b	                jsr xt_here
.9747		20 2e 92	jsr $922e	                jsr xt_swap
.974a		20 a0 86	jsr $86a0	                jsr xt_dup
.974d		20 27 82	jsr $8227	                jsr xt_allot            ; allocate space for the word
.9750		20 00 8c	jsr $8c00	                jsr xt_move
.9753		20 9a 86	jsr $869a	                jsr xt_drop             ; drop original xt
.9756		18		clc		                clc
.9757		60		rts		                rts
.9758						z_compile_comma:
.9758						cmpl_subroutine:
.9758		48		pha		                pha             ; save LSB of address
.9759		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR
.975b		80 03		bra $9760	                bra +
.975d						cmpl_jump:
.975d		48		pha		                pha             ; save LSB of address
.975e		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP, fall thru
.9760						+
.9760		20 68 97	jsr $9768	                jsr cmpl_a      ; compile opcode
.9763		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.9764						cmpl_word:
.9764		20 68 97	jsr $9768	                jsr cmpl_a      ; compile LSB of address
.9767		98		tya		                tya             ; fall thru for MSB
.9768						cmpl_a:
.9768		92 00		sta ($00)	                sta (cp)
.976a		e6 00		inc $00		                inc cp
.976c		d0 02		bne $9770	                bne _done
.976e		e6 01		inc $01		                inc cp+1
.9770						_done:
.9770		60		rts		                rts
.9771						cmpl_jump_tos:
.9771		a9 4c		lda #$4c	                lda #OpJMP
.9773		20 68 97	jsr $9768	                jsr cmpl_a
.9776		4c cd 83	jmp $83cd	                jmp xt_comma
.9779						cmpl_jump_later:
.9779		a9 4c		lda #$4c	                lda #OpJMP
.977b		20 68 97	jsr $9768	                jsr cmpl_a
.977e		20 1b 89	jsr $891b	                jsr xt_here
.9781		80 e1		bra $9764	                bra cmpl_word
.9783						check_nc_limit:
.9783		48		pha		                pha
.9784		38		sec		                sec
.9785		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.9787		b1 08		lda ($08),y	                lda (up),y              ; if MSB non zero we're good, leave with C=0
.9789		f0 01		beq $978c	                beq +
.978b		18		clc		                clc
.978c						+
.978c		68		pla		                pla
.978d		90 05		bcc $9794	                bcc _done
.978f		3a		dec a		                dea                     ; simplify test to A-1 < nc-limit
.9790		88		dey		                dey
.9791		d1 08		cmp ($08),y	                cmp (up),y              ; A-1 < LSB leaves C=0, else C=1
.9793		1a		inc a		                ina                     ; restore A, preserves carry
.9794						_done:
.9794		60		rts		                rts
.9795						cmpl_0branch_later:
.9795		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; dummy placeholder, which forces long jmp in native version
.9798		20 aa 97	jsr $97aa	                jsr cmpl_0branch_tos    ; generate native or subroutine branch code
.979b		20 1b 89	jsr $891b	                jsr xt_here             ; either way the target address is two bytes before here
.979e		38		sec		                sec
.979f		b5 00		lda $00,x	                lda 0,x
.97a1		e9 02		sbc #$02	                sbc #2
.97a3		95 00		sta $00,x	                sta 0,x
.97a5		b0 02		bcs $97a9	                bcs +
.97a7		d6 01		dec $01,x	                dec 1,x
.97a9						+
.97a9		60		rts		                rts
.97aa						cmpl_0branch_tos:
.97aa		a9 0b		lda #$0b	                lda #ztest_runtime_size+5       ; typical size of inline form
.97ac		20 83 97	jsr $9783	                jsr check_nc_limit              ; returns C=0 if we should native compile
.97af		90 0a		bcc $97bb	                bcc _inline
.97b1		a0 98		ldy #$98	                ldy #>zero_branch_runtime
.97b3		a9 0c		lda #$0c	                lda #<zero_branch_runtime
.97b5		20 58 97	jsr $9758	                jsr cmpl_subroutine             ; call the 0branch runtime
.97b8		4c cd 83	jmp $83cd	                jmp xt_comma                    ; add the payload and return
.97bb						_inline:
.97bb		a0 00		ldy #$00	                ldy #0
.97bd						-
.97bd		b9 0c 98	lda $980c,y	                lda ztest_runtime,y
.97c0		20 68 97	jsr $9768	                jsr cmpl_a
.97c3		c8		iny		                iny
.97c4		c0 06		cpy #$06	                cpy #ztest_runtime_size
.97c6		d0 f5		bne $97bd	                bne -
.97c8		b5 00		lda $00,x	                lda 0,x
.97ca		15 01		ora $01,x	                ora 1,x
.97cc		f0 31		beq $97ff	                beq _long               ; always use the long form if target is 0
.97ce		20 a0 86	jsr $86a0	                jsr xt_dup
.97d1		20 1b 89	jsr $891b	                jsr xt_here
.97d4		18		clc		                clc
.97d5		a9 02		lda #$02	                lda #2
.97d7		75 00		adc $00,x	                adc 0,x
.97d9		95 00		sta $00,x	                sta 0,x
.97db		90 02		bcc $97df	                bcc +
.97dd		f6 01		inc $01,x	                inc 1,x
.97df						+
.97df		20 e4 8b	jsr $8be4	                jsr xt_minus
.97e2		e8		inx		                inx             ; pre-drop offset and use wraparound indexing to preserve flags
.97e3		e8		inx		                inx
.97e4		b5 ff		lda $ff,x	                lda $ff,x
.97e6		a8		tay		                tay             ; Y=MSB of offset
.97e7		b5 fe		lda $fe,x	                lda $fe,x       ; A=LSB, setting N flag to bit 7
.97e9		30 04		bmi $97ef	                bmi _minus
.97eb		c0 00		cpy #$00	                cpy #0          ; if LSB is positive we need MSB = 0
.97ed		80 02		bra $97f1	                bra +
.97ef		c0 ff		cpy #$ff	_minus:         cpy #$ff        ; if LSB is negative we need MSB = ff
.97f1		d0 0c		bne $97ff	+               bne _long
.97f3		a9 f0		lda #$f0	                lda #OpBEQ
.97f5		20 68 97	jsr $9768	                jsr cmpl_a
.97f8		b5 fe		lda $fe,x	                lda $fe,x
.97fa		e8		inx		                inx             ; drop the original address we used to calc offset
.97fb		e8		inx		                inx
.97fc		4c 68 97	jmp $9768	                jmp cmpl_a
.97ff						_long:
.97ff		a9 d0		lda #$d0	                lda #OpBNE
.9801		20 68 97	jsr $9768	                jsr cmpl_a
.9804		a9 03		lda #$03	                lda #3
.9806		20 68 97	jsr $9768	                jsr cmpl_a
.9809		4c 71 97	jmp $9771	                jmp cmpl_jump_tos
.980c						zero_branch_runtime:
.980c						ztest_runtime:
.980c		e8		inx		                inx
.980d		e8		inx		                inx
.980e		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.9810		15 ff		ora $ff,x	                ora $FF,x
=6						ztest_runtime_size = * - ztest_runtime
.9812						zbranch_runtime:
.9812		7a		ply		                ply
.9813		84 25		sty $25		                sty tmp1
.9815		7a		ply		                ply
.9816		84 26		sty $26		                sty tmp1+1
.9818		a8		tay		                tay             ; test if A = 0 which tells us whether to branch
.9819		f0 0d		beq $9828	                beq _branch
.981b		18		clc		                clc
.981c		a5 25		lda $25		                lda tmp1        ; LSB
.981e		69 03		adc #$03	                adc #3          ; skip two bytes plus the extra for jsr/rts behavior
.9820		85 25		sta $25		                sta tmp1
.9822		90 11		bcc $9835	                bcc _jmp
.9824		e6 26		inc $26		                inc tmp1+1
.9826		80 0d		bra $9835	                bra _jmp
.9828						_branch:
.9828		a0 01		ldy #$01	                ldy #1
.982a		b1 25		lda ($25),y	                lda (tmp1),y
.982c		48		pha		                pha                     ; stash the LSB until we've read the MSB too
.982d		c8		iny		                iny
.982e		b1 25		lda ($25),y	                lda (tmp1),y
.9830		85 26		sta $26		                sta tmp1+1              ; update tmp1 with our branch target
.9832		68		pla		                pla
.9833		85 25		sta $25		                sta tmp1
.9835						_jmp:
.9835		6c 25 00	jmp ($0025)	                jmp (tmp1)

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tools.asm

.9838						xt_bye:
.9838		4c 31 f0	jmp $f031	                jmp kernel_bye
.983b						z_bye:
.983b						xt_dot_s:
.983b		20 52 85	jsr $8552	                jsr xt_depth    ; ( -- u )
.983e		a9 3c		lda #$3c	                lda #'<'
.9840		20 c5 86	jsr $86c5	                jsr emit_a
.9843		b5 00		lda $00,x	                lda 0,x
.9845		48		pha		                pha
.9846		ca		dex		                dex             ; DUP
.9847		ca		dex		                dex
.9848		95 00		sta $00,x	                sta 0,x
.984a		74 01		stz $01,x	                stz 1,x
.984c		20 d5 d7	jsr $d7d5	                jsr print_u
.984f		a9 3e		lda #$3e	                lda #'>'
.9851		20 c5 86	jsr $86c5	                jsr emit_a
.9854		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.9856		20 c5 86	jsr $86c5	                jsr emit_a
.9859		e8		inx		                inx
.985a		e8		inx		                inx
.985b		e0 78		cpx #$78	                cpx #dsp0
.985d		f0 1e		beq $987d	                beq _done
.985f		7a		ply		                ply
.9860		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.9862		85 29		sta $29		                sta tmp3
.9864		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.9866						_loop:
.9866		ca		dex		                dex
.9867		ca		dex		                dex
.9868		b2 29		lda ($29)	                lda (tmp3)
.986a		95 01		sta $01,x	                sta 1,x
.986c		c6 29		dec $29		                dec tmp3
.986e		b2 29		lda ($29)	                lda (tmp3)
.9870		95 00		sta $00,x	                sta 0,x
.9872		c6 29		dec $29		                dec tmp3
.9874		5a		phy		                phy
.9875		20 30 86	jsr $8630	                jsr xt_dot
.9878		7a		ply		                ply
.9879		88		dey		                dey
.987a		d0 ea		bne $9866	                bne _loop
.987c		48		pha		                pha             ; dummy to balance stack
.987d						_done:
.987d		68		pla		                pla
.987e		60		rts		z_dot_s:        rts
.987f						xt_dump:
.987f		20 6d d7	jsr $d76d	                jsr underflow_2
.9882						_row:
.9882		a0 10		ldy #$10	                ldy #16
.9884		64 27		stz $27		                stz tmp2
.9886		20 3a 84	jsr $843a	                jsr xt_cr
.9889		b5 03		lda $03,x	                lda 3,x
.988b		20 33 d6	jsr $d633	                jsr byte_to_ascii
.988e		b5 02		lda $02,x	                lda 2,x
.9890		20 33 d6	jsr $d633	                jsr byte_to_ascii
.9893		20 cb 91	jsr $91cb	                jsr xt_space
.9896		20 cb 91	jsr $91cb	                jsr xt_space
.9899						_loop:
.9899		b5 00		lda $00,x	                lda 0,x
.989b		15 01		ora $01,x	                ora 1,x
.989d		f0 39		beq $98d8	                beq _all_printed
.989f		a1 02		lda ($02,x)	                lda (2,x)
.98a1		48		pha		                pha                     ; byte_to_ascii destroys A
.98a2		20 33 d6	jsr $d633	                jsr byte_to_ascii
.98a5		20 cb 91	jsr $91cb	                jsr xt_space
.98a8		68		pla		                pla
.98a9		20 4e d7	jsr $d74e	                jsr is_printable
.98ac		b0 02		bcs $98b0	                bcs _printable
.98ae		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.98b0						_printable:
.98b0		5a		phy		                phy                     ; save counter
.98b1		a4 27		ldy $27		                ldy tmp2
.98b3		91 00		sta ($00),y	                sta (cp),y
.98b5		e6 27		inc $27		                inc tmp2
.98b7		7a		ply		                ply
.98b8		c0 09		cpy #$09	                cpy #9
.98ba		d0 03		bne $98bf	                bne _next_char
.98bc		20 cb 91	jsr $91cb	                jsr xt_space
.98bf						_next_char:
.98bf		f6 02		inc $02,x	                inc 2,x
.98c1		d0 02		bne $98c5	                bne _counter
.98c3		f6 03		inc $03,x	                inc 3,x
.98c5						_counter:
.98c5		b5 00		lda $00,x	                lda 0,x
.98c7		d0 02		bne $98cb	                bne +
.98c9		d6 01		dec $01,x	                dec 1,x
.98cb						+
.98cb		d6 00		dec $00,x	                dec 0,x
.98cd		88		dey		                dey
.98ce		d0 c9		bne $9899	                bne _loop               ; next byte
.98d0		20 cb 91	jsr $91cb	                jsr xt_space
.98d3		20 e6 98	jsr $98e6	                jsr dump_print_ascii
.98d6		80 aa		bra $9882	                bra _row                ; new row
.98d8						_all_printed:
.98d8		a5 27		lda $27		                lda tmp2
.98da		f0 06		beq $98e2	                beq _done
.98dc		20 cb 91	jsr $91cb	                jsr xt_space
.98df		20 e6 98	jsr $98e6	                jsr dump_print_ascii
.98e2						_done:
.98e2		20 a7 93	jsr $93a7	                jsr xt_two_drop         ; one byte less than 4x INX
.98e5		60		rts		z_dump:         rts
.98e6						dump_print_ascii:
.98e6		a0 00		ldy #$00	                ldy #0
.98e8						_ascii_loop:
.98e8		b1 00		lda ($00),y	                lda (cp),y
.98ea		20 c5 86	jsr $86c5	                jsr emit_a
.98ed		c8		iny		                iny
.98ee		c0 08		cpy #$08	                cpy #8
.98f0		d0 03		bne $98f5	                bne +
.98f2		20 cb 91	jsr $91cb	                jsr xt_space
.98f5						+
.98f5		c6 27		dec $27		                dec tmp2
.98f7		d0 ef		bne $98e8	                bne _ascii_loop
.98f9		60		rts		                rts
.98fa						xt_question:
.98fa		20 1a 88	jsr $881a	                jsr xt_fetch
.98fd		20 30 86	jsr $8630	                jsr xt_dot
.9900		60		rts		z_question:     rts
.9901						xt_see:
.9901		20 51 8d	jsr $8d51	                jsr xt_parse_name       ; ( addr u )
.9904		20 ce 9a	jsr $9ace	                jsr xt_find_name        ; ( nt | 0 )
.9907		b5 00		lda $00,x	                lda 0,x
.9909		15 01		ora $01,x	                ora 1,x
.990b		d0 05		bne $9912	                bne +
.990d		a9 05		lda #$05	                lda #err_noname
.990f		4c 7e d7	jmp $d77e	                jmp error
.9912						+
.9912		20 3a 84	jsr $843a	                jsr xt_cr
.9915		a5 18		lda $18		                lda base
.9917		48		pha		                pha
.9918		20 26 89	jsr $8926	                jsr xt_hex
.991b		a9 09		lda #$09	                lda #str_see_nt
.991d		20 a4 d7	jsr $d7a4	                jsr print_string_no_lf
.9920		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.9923		20 e2 94	jsr $94e2	                jsr xt_u_dot
.9926		20 cb 91	jsr $91cb	                jsr xt_space            ; ( nt )
.9929		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.992c		20 0c 9c	jsr $9c0c	                jsr xt_name_to_int      ; ( nt xt )
.992f		a9 0a		lda #$0a	                lda #str_see_xt
.9931		20 a4 d7	jsr $d7a4	                jsr print_string_no_lf
.9934		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt xt xt )
.9937		20 e2 94	jsr $94e2	                jsr xt_u_dot
.993a		20 3a 84	jsr $843a	                jsr xt_cr               ; ( nt xt )
.993d		a9 08		lda #$08	                lda #str_see_flags
.993f		20 a4 d7	jsr $d7a4	                jsr print_string_no_lf
.9942		20 05 8d	jsr $8d05	                jsr xt_over             ; ( nt xt nt )
.9945		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9948		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( nt xt flags )
.994b		b5 00		lda $00,x	                lda 0,x
.994d		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.994f						_flag_loop:
.994f		48		pha		                pha
.9950		29 01		and #$01	                and #%00000001
.9952		18		clc		                clc
.9953		69 30		adc #$30	                adc #'0'
.9955		20 c5 86	jsr $86c5	                jsr emit_a
.9958		20 cb 91	jsr $91cb	                jsr xt_space
.995b		68		pla		                pla
.995c		6a		ror a		                ror                     ; Next flag
.995d		88		dey		                dey
.995e		d0 ef		bne $994f	                bne _flag_loop
.9960		20 3a 84	jsr $843a	                jsr xt_cr
.9963		e8		inx		                inx
.9964		e8		inx		                inx                     ; ( nt xt )
.9965		a9 0b		lda #$0b	                lda #str_see_size
.9967		20 a4 d7	jsr $d7a4	                jsr print_string_no_lf
.996a		20 2e 92	jsr $922e	                jsr xt_swap             ; ( xt nt )
.996d		20 ae 9d	jsr $9dae	                jsr xt_wordsize         ; ( xt u )
.9970		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9973		20 0a 85	jsr $850a	                jsr xt_decimal
.9976		20 e2 94	jsr $94e2	                jsr xt_u_dot            ; ( xt u )
.9979		20 26 89	jsr $8926	                jsr xt_hex
.997c		20 3a 84	jsr $843a	                jsr xt_cr
.997f		20 af 93	jsr $93af	                jsr xt_two_dup          ; ( xt u xt u )
.9982		20 7f 98	jsr $987f	                jsr xt_dump
.9985		20 3a 84	jsr $843a	                jsr xt_cr
.9988		20 7c a1	jsr $a17c	                jsr xt_disasm
.998b		68		pla		                pla
.998c		85 18		sta $18		                sta base
.998e		60		rts		z_see:          rts
.998f						xt_words:
.998f		20 3a 84	jsr $843a	                jsr xt_cr
.9992		a9 00		lda #$00	                lda #0
.9994		48		pha		                pha
.9995		ca		dex		                dex                     ; Make room on the stack for
.9996		ca		dex		                dex                     ; a dictionary pointer.
.9997		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.9999						_wordlist_loop:
.9999		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.999b		a5 29		lda $29		                lda tmp3
.999d		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.999f		d0 02		bne $99a3	                bne _have_wordlist
.99a1		80 45		bra $99e8	                bra _words_done
.99a3						_have_wordlist:
.99a3		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.99a4		69 23		adc #$23	                adc #search_order_offset
.99a6		a8		tay		                tay
.99a7		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.99a9		0a		asl a		                asl                     ; Turn offset into cells offset.
.99aa		18		clc		                clc
.99ab		69 0a		adc #$0a	                adc #wordlists_offset
.99ad		a8		tay		                tay
.99ae		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.99b0		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.99b2		c8		iny		                iny
.99b3		b1 08		lda ($08),y	                lda (up),y
.99b5		95 01		sta $01,x	                sta 1,x
.99b7						_loop:
.99b7		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.99ba		20 29 9c	jsr $9c29	                jsr xt_name_to_string   ; ( nt addr u )
.99bd		68		pla		                pla
.99be		18		clc		                clc
.99bf		75 00		adc $00,x	                adc 0,x
.99c1		1a		inc a		                ina                     ; don't forget the space between words
.99c2		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.99c4		90 06		bcc $99cc	                bcc +
.99c6		20 3a 84	jsr $843a	                jsr xt_cr
.99c9		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.99cb		1a		inc a		                ina                     ; with length of this word.
.99cc						+
.99cc		48		pha		                pha
.99cd		20 b7 94	jsr $94b7	                jsr xt_type             ; ( nt )
.99d0		a9 20		lda #$20	                lda #AscSP
.99d2		20 c5 86	jsr $86c5	                jsr emit_a
.99d5		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+
.99d8		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+
.99db		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( nt+1 )
.99de		b5 00		lda $00,x	                lda 0,x
.99e0		15 01		ora $01,x	                ora 1,x
.99e2		d0 d3		bne $99b7	                bne _loop
.99e4		e6 29		inc $29		                inc tmp3
.99e6		80 b1		bra $9999	                bra _wordlist_loop
.99e8						_words_done:
.99e8		68		pla		                pla                     ; dump counter
.99e9		e8		inx		                inx
.99ea		e8		inx		                inx
.99eb		60		rts		z_words:        rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tali.asm

.99ec						xt_allow_native:
.99ec		20 bf d6	jsr $d6bf	                jsr current_to_dp
.99ef		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.99f1		b1 02		lda ($02),y	                lda (dp),y
.99f3		29 f5		and #$f5	                and #$FF-NN-AN  ; AN and NN flag is clear.
.99f5		91 02		sta ($02),y	                sta (dp),y
.99f7						z_allow_native:
.99f7		60		rts		                rts
.99f8						xt_always_native:
.99f8		20 bf d6	jsr $d6bf	                jsr current_to_dp
.99fb		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.99fd		b1 02		lda ($02),y	                lda (dp),y
.99ff		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.9a01		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.9a03		91 02		sta ($02),y	                sta (dp),y
.9a05						z_always_native:
.9a05		60		rts		                rts
.9a06						xt_bell:
.9a06		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.9a08		20 c5 86	jsr $86c5	                jsr emit_a
.9a0b		60		rts		z_bell:         rts
.9a0c						xt_bounds:
.9a0c		20 6d d7	jsr $d76d	                jsr underflow_2
.9a0f		18		clc		                clc
.9a10		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.9a12		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.9a14		75 02		adc $02,x	                adc 2,x
.9a16		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.9a18		94 00		sty $00,x	                sty 0,x
.9a1a		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.9a1c		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.9a1e		75 03		adc $03,x	                adc 3,x
.9a20		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.9a22		94 01		sty $01,x	                sty 1,x
.9a24		60		rts		z_bounds:       rts
.9a25						xt_cleave:
.9a25		20 6d d7	jsr $d76d	                jsr underflow_2
.9a28		20 fb 9f	jsr $9ffb	                jsr xt_minus_leading    ; -LEADING ( addr u )
.9a2b		20 70 9b	jsr $9b70	                jsr xt_input_to_r       ; save old imput state
.9a2e		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.9a30		85 0e		sta $0e		                sta ciblen
.9a32		b5 01		lda $01,x	                lda 1,x
.9a34		85 0f		sta $0f		                sta ciblen+1
.9a36		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.9a38		85 0c		sta $0c		                sta cib
.9a3a		b5 03		lda $03,x	                lda 3,x
.9a3c		85 0d		sta $0d		                sta cib+1
.9a3e		64 10		stz $10		                stz toin        ; >IN pointer is zero
.9a40		64 11		stz $11		                stz toin+1
.9a42		20 51 8d	jsr $8d51	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.9a45		b5 00		lda $00,x	                lda 0,x
.9a47		15 01		ora $01,x	                ora 1,x
.9a49		f0 23		beq $9a6e	                beq _done
.9a4b		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.9a4d		38		sec		                sec
.9a4e		f5 00		sbc $00,x	                sbc 0,x
.9a50		95 04		sta $04,x	                sta 4,x
.9a52		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.9a54		f5 01		sbc $01,x	                sbc 1,x
.9a56		95 05		sta $05,x	                sta 5,x
.9a58		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.9a5a		18		clc		                clc
.9a5b		75 00		adc $00,x	                adc 0,x
.9a5d		95 06		sta $06,x	                sta 6,x
.9a5f		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.9a61		75 01		adc $01,x	                adc 1,x
.9a63		95 07		sta $07,x	                sta 7,x
.9a65		20 75 94	jsr $9475	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.9a68		20 fb 9f	jsr $9ffb	                jsr xt_minus_leading
.9a6b		20 75 94	jsr $9475	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.9a6e						_done:
.9a6e		20 7d 9d	jsr $9d7d	                jsr xt_r_to_input
.9a71		60		rts		z_cleave:       rts
.9a72						xt_digit_question:
.9a72		20 68 d7	jsr $d768	                jsr underflow_1
.9a75		ca		dex		                dex
.9a76		ca		dex		                dex
.9a77		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.9a79		74 01		stz $01,x	                stz 1,x
.9a7b		74 03		stz $03,x	                stz 3,x                 ; paranoid
.9a7d		b5 02		lda $02,x	                lda 2,x
.9a7f		c9 30		cmp #$30	                cmp #'0'
.9a81		90 23		bcc $9aa6	                bcc _done               ; failure flag already set
.9a83		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.9a85		90 12		bcc $9a99	                bcc _checkbase
.9a87		c9 41		cmp #$41	                cmp #'A'
.9a89		90 1b		bcc $9aa6	                bcc _done               ; failure flag is already set
.9a8b		c9 61		cmp #$61	                cmp #'a'
.9a8d		90 07		bcc $9a96	                bcc _case_done          ; not lower case, too low
.9a8f		c9 7b		cmp #$7b	                cmp #'z'+1
.9a91		b0 03		bcs $9a96	                bcs _case_done          ; not lower case, too high
.9a93		18		clc		                clc                     ; just right
.9a94		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.9a96						_case_done:
.9a96		38		sec		                sec
.9a97		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.9a99						_checkbase:
.9a99		38		sec		                sec
.9a9a		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.9a9c		c5 18		cmp $18		                cmp base
.9a9e		b0 06		bcs $9aa6	                bcs _done               ; already have false flag
.9aa0		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.9aa2		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.9aa4		d6 01		dec $01,x	                dec 1,x
.9aa6						_done:
.9aa6						z_digit_question:
.9aa6		60		rts		                rts
.9aa7						xt_execute_parsing:
.9aa7		20 72 d7	jsr $d772	                jsr underflow_3
.9aaa		20 70 9b	jsr $9b70	                jsr xt_input_to_r       ; save normal input for later
.9aad		20 53 9c	jsr $9c53	                jsr xt_not_rote         ; -ROT ( xt addr u )
.9ab0		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.9ab2		85 0e		sta $0e		                sta ciblen
.9ab4		b5 01		lda $01,x	                lda 1,x
.9ab6		85 0f		sta $0f		                sta ciblen+1
.9ab8		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.9aba		85 0c		sta $0c		                sta cib
.9abc		b5 03		lda $03,x	                lda 3,x
.9abe		85 0d		sta $0d		                sta cib+1
.9ac0		64 10		stz $10		                stz toin                ; Set >IN to zero
.9ac2		64 11		stz $11		                stz toin+1
.9ac4		20 a7 93	jsr $93a7	                jsr xt_two_drop         ; 2DROP ( xt )
.9ac7		20 05 88	jsr $8805	                jsr xt_execute
.9aca		20 7d 9d	jsr $9d7d	                jsr xt_r_to_input
.9acd						z_execute_parsing:
.9acd		60		rts		                rts
.9ace						xt_find_name:
.9ace		20 6d d7	jsr $d76d	                jsr underflow_2
.9ad1		b5 00		lda $00,x	                lda 0,x
.9ad3		15 01		ora $01,x	                ora 1,x
.9ad5		d0 03		bne $9ada	                bne _nonempty
.9ad7		4c 0b 9b	jmp $9b0b	                jmp _fail_done
.9ada						_nonempty:
.9ada		64 29		stz $29		                stz tmp3                ; Start at the beginning
.9adc						_wordlist_loop:
.9adc		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9ade		a5 29		lda $29		                lda tmp3
.9ae0		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.9ae2		f0 27		beq $9b0b	                beq _fail_done
.9ae4		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9ae5		69 23		adc #$23	                adc #search_order_offset
.9ae7		a8		tay		                tay
.9ae8		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.9aea		0a		asl a		                asl                     ; Turn offset into cells offset.
.9aeb		18		clc		                clc
.9aec		69 0a		adc #$0a	                adc #wordlists_offset
.9aee		a8		tay		                tay
.9aef		b1 08		lda ($08),y	                lda (up),y
.9af1		85 25		sta $25		                sta tmp1
.9af3		c8		iny		                iny
.9af4		b1 08		lda ($08),y	                lda (up),y
.9af6		85 26		sta $26		                sta tmp1+1
.9af8		20 4a d6	jsr $d64a	                jsr find_header_name
.9afb		d0 04		bne $9b01	                bne _success
.9afd		e6 29		inc $29		                inc tmp3
.9aff		80 db		bra $9adc	                bra _wordlist_loop
.9b01						_success:
.9b01		a5 25		lda $25		                lda tmp1
.9b03		95 02		sta $02,x	                sta 2,x
.9b05		a5 26		lda $26		                lda tmp1+1
.9b07		95 03		sta $03,x	                sta 3,x
.9b09		80 04		bra $9b0f	                bra _done
.9b0b						_fail_done:
.9b0b		74 02		stz $02,x	                stz 2,x         ; failure flag
.9b0d		74 03		stz $03,x	                stz 3,x
.9b0f						_done:
.9b0f		e8		inx		                inx
.9b10		e8		inx		                inx
.9b11		60		rts		z_find_name:    rts
.9b12						xt_hexstore:
.9b12		20 72 d7	jsr $d772	                jsr underflow_3
.9b15		20 a0 86	jsr $86a0	                jsr xt_dup              ; Save copy of original address
.9b18		20 99 94	jsr $9499	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b1b						_loop:
.9b1b		b5 00		lda $00,x	                lda 0,x
.9b1d		15 01		ora $01,x	                ora 1,x
.9b1f		f0 36		beq $9b57	                beq _done
.9b21		20 25 9a	jsr $9a25	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9b24		20 99 94	jsr $9499	                jsr xt_two_to_r
.9b27		20 cf 9d	jsr $9dcf	                jsr xt_zero
.9b2a		20 cf 9d	jsr $9dcf	                jsr xt_zero
.9b2d		20 21 94	jsr $9421	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9b30		20 cc 92	jsr $92cc	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9b33		b5 00		lda $00,x	                lda 0,x
.9b35		15 01		ora $01,x	                ora 1,x
.9b37		d0 17		bne $9b50	                bne _have_chars_left
.9b39		20 a7 93	jsr $93a7	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9b3c		20 18 9e	jsr $9e18	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9b3f		20 d9 8e	jsr $8ed9	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9b42		20 37 83	jsr $8337	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b45		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R>
.9b48		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+
.9b4b		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9b4e		80 cb		bra $9b1b	                bra _loop
.9b50						_have_chars_left:
.9b50		8a		txa		                txa
.9b51		18		clc		                clc
.9b52		69 08		adc #$08	                adc #8
.9b54		aa		tax		                tax
.9b55		80 c4		bra $9b1b	                bra _loop
.9b57						_done:
.9b57		e8		inx		                inx
.9b58		e8		inx		                inx
.9b59		e8		inx		                inx
.9b5a		e8		inx		                inx                     ; 2DROP
.9b5b		20 21 94	jsr $9421	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.9b5e		20 2e 92	jsr $922e	                jsr xt_swap
.9b61		20 e4 8b	jsr $8be4	                jsr xt_minus            ; ( n )
.9b64		60		rts		z_hexstore:     rts
.9b65						xt_input:
.9b65		ca		dex		                dex
.9b66		ca		dex		                dex
.9b67		a9 14		lda #$14	                lda #<input
.9b69		95 00		sta $00,x	                sta 0,x
.9b6b		a9 00		lda #$00	                lda #>input
.9b6d		95 01		sta $01,x	                sta 1,x
.9b6f		60		rts		z_input:        rts
.9b70						xt_input_to_r:
.9b70		68		pla		                pla
.9b71		85 25		sta $25		                sta tmp1
.9b73		68		pla		                pla
.9b74		85 26		sta $26		                sta tmp1+1
.9b76		a0 07		ldy #$07	                ldy #7
.9b78						_loop:
.9b78		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9b7b		48		pha		                pha
.9b7c		88		dey		                dey
.9b7d		10 f9		bpl $9b78	                bpl _loop
.9b7f		a5 26		lda $26		                lda tmp1+1
.9b81		48		pha		                pha
.9b82		a5 25		lda $25		                lda tmp1
.9b84		48		pha		                pha
.9b85		60		rts		z_input_to_r: 	rts
.9b86						xt_int_to_name:
.9b86		20 68 d7	jsr $d768	                jsr underflow_1
.9b89		ca		dex		                dex
.9b8a		ca		dex		                dex
.9b8b		74 00		stz $00,x	                stz 0,x
.9b8d		74 01		stz $01,x	                stz 1,x
.9b8f						_wordlist_loop:
.9b8f		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9b91		0a		asl a		                asl                     ; Turn offset into cells offset.
.9b92		18		clc		                clc
.9b93		69 0a		adc #$0a	                adc #wordlists_offset
.9b95		a8		tay		                tay
.9b96		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9b98		85 27		sta $27		                sta tmp2                ; into tmp2
.9b9a		c8		iny		                iny
.9b9b		b1 08		lda ($08),y	                lda (up),y
.9b9d		85 28		sta $28		                sta tmp2+1
.9b9f		a5 27		lda $27		                lda tmp2
.9ba1		05 28		ora $28		                ora tmp2+1
.9ba3		f0 36		beq $9bdb	                beq _next_wordlist
.9ba5		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9ba7		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9ba9		b5 03		lda $03,x	                lda 3,x
.9bab		85 2a		sta $2a		                sta tmp3+1
.9bad						_loop:
.9bad		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9baf		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.9bb1		c5 29		cmp $29		                cmp tmp3
.9bb3		d0 07		bne $9bbc	                bne _no_match
.9bb5		c8		iny		                iny
.9bb6		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9bb8		c5 2a		cmp $2a		                cmp tmp3+1
.9bba		f0 30		beq $9bec	                beq _match
.9bbc						_no_match:
.9bbc		18		clc		                clc
.9bbd		a5 27		lda $27		                lda tmp2
.9bbf		69 02		adc #$02	                adc #2
.9bc1		85 27		sta $27		                sta tmp2
.9bc3		90 02		bcc $9bc7	                bcc +
.9bc5		e6 28		inc $28		                inc tmp2+1
.9bc7						+
.9bc7		a0 00		ldy #$00	                ldy #0
.9bc9		b1 27		lda ($27),y	                lda (tmp2),y
.9bcb		48		pha		                pha
.9bcc		c8		iny		                iny
.9bcd		11 27		ora ($27),y	                ora (tmp2),y
.9bcf		f0 09		beq $9bda	                beq _zero
.9bd1		b1 27		lda ($27),y	                lda (tmp2),y
.9bd3		85 28		sta $28		                sta tmp2+1
.9bd5		68		pla		                pla
.9bd6		85 27		sta $27		                sta tmp2
.9bd8		80 d3		bra $9bad	                bra _loop
.9bda						_zero:
.9bda		68		pla		                pla             ; Leftover from above loop
.9bdb						_next_wordlist:
.9bdb		b5 00		lda $00,x	                lda 0,x
.9bdd		1a		inc a		                ina
.9bde		95 00		sta $00,x	                sta 0,x
.9be0		c9 0c		cmp #$0c	                cmp #max_wordlists
.9be2		d0 ab		bne $9b8f	                bne _wordlist_loop
.9be4		e8		inx		                inx
.9be5		e8		inx		                inx
.9be6		74 00		stz $00,x	                stz 0,x
.9be8		74 01		stz $01,x	                stz 1,x
.9bea		80 0a		bra $9bf6	                bra z_int_to_name
.9bec						_match:
.9bec		e8		inx		                inx
.9bed		e8		inx		                inx
.9bee		a5 27		lda $27		                lda tmp2
.9bf0		95 00		sta $00,x	                sta 0,x
.9bf2		a5 28		lda $28		                lda tmp2+1
.9bf4		95 01		sta $01,x	                sta 1,x
.9bf6		60		rts		z_int_to_name:  rts
.9bf7						xt_latestnt:
.9bf7		ca		dex		                dex
.9bf8		ca		dex		                dex
.9bf9		20 bf d6	jsr $d6bf	                jsr current_to_dp
.9bfc		a5 02		lda $02		                lda dp
.9bfe		95 00		sta $00,x	                sta 0,x
.9c00		a5 03		lda $03		                lda dp+1
.9c02		95 01		sta $01,x	                sta 1,x
.9c04		60		rts		z_latestnt:     rts
.9c05						xt_latestxt:
.9c05		20 f7 9b	jsr $9bf7	                jsr xt_latestnt         ; ( nt )
.9c08		20 0c 9c	jsr $9c0c	                jsr xt_name_to_int      ; ( xt )
.9c0b		60		rts		z_latestxt:     rts
.9c0c						xt_name_to_int:
.9c0c		20 68 d7	jsr $d768	                jsr underflow_1
.9c0f		b5 00		lda $00,x	                lda 0,x
.9c11		18		clc		                clc
.9c12		69 04		adc #$04	                adc #4
.9c14		85 29		sta $29		                sta tmp3
.9c16		b5 01		lda $01,x	                lda 1,x
.9c18		90 01		bcc $9c1b	                bcc _done
.9c1a		1a		inc a		                ina
.9c1b						_done:
.9c1b		85 2a		sta $2a		                sta tmp3+1
.9c1d		a0 00		ldy #$00	                ldy #0
.9c1f		b1 29		lda ($29),y	                lda (tmp3),y
.9c21		95 00		sta $00,x	                sta 0,x
.9c23		c8		iny		                iny
.9c24		b1 29		lda ($29),y	                lda (tmp3),y
.9c26		95 01		sta $01,x	                sta 1,x
.9c28		60		rts		z_name_to_int:  rts
.9c29						xt_name_to_string:
.9c29		20 68 d7	jsr $d768	                jsr underflow_1
.9c2c		ca		dex		                dex
.9c2d		ca		dex		                dex
.9c2e		a1 02		lda ($02,x)	                lda (2,x)
.9c30		95 00		sta $00,x	                sta 0,x
.9c32		74 01		stz $01,x	                stz 1,x
.9c34		b5 02		lda $02,x	                lda 2,x         ; LSB
.9c36		18		clc		                clc
.9c37		69 08		adc #$08	                adc #8
.9c39		95 02		sta $02,x	                sta 2,x
.9c3b		90 02		bcc $9c3f	                bcc z_name_to_string
.9c3d		f6 03		inc $03,x	                inc 3,x         ; MSB
.9c3f						z_name_to_string:
.9c3f		60		rts		                rts
.9c40						xt_nc_limit:
.9c40		a9 00		lda #$00	                lda #nc_limit_offset
.9c42		4c 24 d6	jmp $d624	                jmp push_upvar_tos
.9c45						z_nc_limit:
.9c45						xt_never_native:
.9c45		20 bf d6	jsr $d6bf	                jsr current_to_dp
.9c48		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9c4a		b1 02		lda ($02),y	                lda (dp),y
.9c4c		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9c4e		29 fd		and #$fd	                and #$FF-AN     ; and AN flag is clear.
.9c50		91 02		sta ($02),y	                sta (dp),y
.9c52						z_never_native:
.9c52		60		rts		                rts
.9c53						xt_not_rote:
.9c53		20 72 d7	jsr $d772	                jsr underflow_3
.9c56		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9c58		b5 03		lda $03,x	                lda 3,x
.9c5a		95 01		sta $01,x	                sta 1,x
.9c5c		b5 05		lda $05,x	                lda 5,x
.9c5e		95 03		sta $03,x	                sta 3,x
.9c60		94 05		sty $05,x	                sty 5,x
.9c62		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9c64		b5 02		lda $02,x	                lda 2,x
.9c66		95 00		sta $00,x	                sta 0,x
.9c68		b5 04		lda $04,x	                lda 4,x
.9c6a		95 02		sta $02,x	                sta 2,x
.9c6c		94 04		sty $04,x	                sty 4,x
.9c6e		60		rts		z_not_rote:     rts
.9c6f						xt_number:
.9c6f		20 6d d7	jsr $d76d	                jsr underflow_2
.9c72		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.9c74		a5 18		lda $18		                lda base
.9c76		48		pha		                pha
.9c77		20 af 93	jsr $93af	                jsr xt_two_dup
.9c7a		a1 02		lda ($02,x)	                lda (2,x)
.9c7c		c9 23		cmp #$23	                cmp #'#'                ; decimal?
.9c7e		d0 04		bne $9c84	                bne _check_hex
.9c80		a9 0a		lda #$0a	                lda #10
.9c82		80 42		bra $9cc6	                bra _base_changed
.9c84						_check_hex:
.9c84		c9 24		cmp #$24	                cmp #'$'
.9c86		d0 04		bne $9c8c	                bne _check_binary
.9c88		a9 10		lda #$10	                lda #16
.9c8a		80 3a		bra $9cc6	                bra _base_changed
.9c8c						_check_binary:
.9c8c		c9 25		cmp #$25	                cmp #'%'
.9c8e		d0 04		bne $9c94	                bne _check_char
.9c90		a9 02		lda #$02	                lda #2
.9c92		80 32		bra $9cc6	                bra _base_changed
.9c94						_check_char:
.9c94		c9 27		cmp #$27	                cmp #"'"
.9c96		d0 3a		bne $9cd2	                bne _check_minus
.9c98		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9c9a		c9 03		cmp #$03	                cmp #3
.9c9c		d0 26		bne $9cc4	                bne _not_a_char
.9c9e		b5 01		lda $01,x	                lda 1,x
.9ca0		d0 22		bne $9cc4	                bne _not_a_char ; No compare needed to check for non-zero.
.9ca2		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9ca4		18		clc		                clc
.9ca5		69 02		adc #$02	                adc #2          ; length of string
.9ca7		85 23		sta $23		                sta tmptos
.9ca9		b5 03		lda $03,x	                lda 3,x
.9cab		69 00		adc #$00	                adc #0          ; only need carry
.9cad		85 24		sta $24		                sta tmptos+1
.9caf		b2 23		lda ($23)	                lda (tmptos)
.9cb1		c9 27		cmp #$27	                cmp #"'"
.9cb3		d0 0f		bne $9cc4	                bne _not_a_char
.9cb5		f6 02		inc $02,x	                inc 2,x
.9cb7		d0 02		bne $9cbb	                bne +
.9cb9		f6 03		inc $03,x	                inc 3,x
.9cbb						+
.9cbb		a1 02		lda ($02,x)	                lda (2,x)
.9cbd		95 02		sta $02,x	                sta 2,x
.9cbf		74 03		stz $03,x	                stz 3,x
.9cc1		4c 44 9d	jmp $9d44	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9cc4						_not_a_char:
.9cc4		80 5c		bra $9d22	                bra _number_error
.9cc6						_base_changed:
.9cc6		85 18		sta $18		                sta base        ; Switch to the new base
.9cc8		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9cca		d0 02		bne $9cce	                bne +
.9ccc		f6 03		inc $03,x	                inc 3,x
.9cce						+
.9cce		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9cd0		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9cd2						_check_minus:
.9cd2		c9 2d		cmp #$2d	                cmp #'-'
.9cd4		d0 0c		bne $9ce2	                bne _check_dot
.9cd6		a9 80		lda #$80	                lda #$80
.9cd8		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.9cda		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9cdc		d0 02		bne $9ce0	                bne +
.9cde		f6 03		inc $03,x	                inc 3,x
.9ce0						+
.9ce0		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9ce2						_check_dot:
.9ce2		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9ce4		18		clc		                clc
.9ce5		75 00		adc $00,x	                adc 0,x         ; length of string
.9ce7		85 23		sta $23		                sta tmptos
.9ce9		b5 03		lda $03,x	                lda 3,x
.9ceb		69 00		adc #$00	                adc #0          ; only need carry
.9ced		85 24		sta $24		                sta tmptos+1
.9cef		a5 23		lda $23		                lda tmptos
.9cf1		d0 02		bne $9cf5	                bne +
.9cf3		c6 24		dec $24		                dec tmptos+1
.9cf5						+
.9cf5		c6 23		dec $23		                dec tmptos
.9cf7		b2 23		lda ($23)	                lda (tmptos)
.9cf9		c9 2e		cmp #$2e	                cmp #'.'
.9cfb		d0 04		bne $9d01	                bne _main
.9cfd		e6 1e		inc $1e		                inc tmpdsp
.9cff		d6 00		dec $00,x	                dec 0,x
.9d01						_main:
.9d01		ca		dex		                dex
.9d02		ca		dex		                dex
.9d03		ca		dex		                dex
.9d04		ca		dex		                dex
.9d05		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9d07		95 00		sta $00,x	                sta 0,x
.9d09		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9d0b		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9d0d		95 02		sta $02,x	                sta 2,x
.9d0f		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9d11		95 03		sta $03,x	                sta 3,x
.9d13		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9d15		74 05		stz $05,x	                stz 5,x
.9d17		74 06		stz $06,x	                stz 6,x
.9d19		74 07		stz $07,x	                stz 7,x
.9d1b		20 cc 92	jsr $92cc	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9d1e		b5 00		lda $00,x	                lda 0,x
.9d20		f0 1e		beq $9d40	                beq _all_converted
.9d22						_number_error:
.9d22		20 a7 93	jsr $93a7	                jsr xt_two_drop ; >NUMBER modified addr u
.9d25		20 a7 93	jsr $93a7	                jsr xt_two_drop ; ud   (partially converted number)
.9d28		a9 3e		lda #$3e	                lda #'>'
.9d2a		20 c5 86	jsr $86c5	                jsr emit_a
.9d2d		20 b7 94	jsr $94b7	                jsr xt_type
.9d30		a9 3c		lda #$3c	                lda #'<'
.9d32		20 c5 86	jsr $86c5	                jsr emit_a
.9d35		20 cb 91	jsr $91cb	                jsr xt_space
.9d38		68		pla		                pla
.9d39		85 18		sta $18		                sta base
.9d3b		a9 08		lda #$08	                lda #err_syntax
.9d3d		4c 7e d7	jmp $d77e	                jmp error
.9d40						_all_converted:
.9d40		e8		inx		                inx ; Drop the current addr u
.9d41		e8		inx		                inx
.9d42		e8		inx		                inx
.9d43		e8		inx		                inx
.9d44						_drop_original_string:
.9d44		20 75 94	jsr $9475	                jsr xt_two_swap  ; Drop the original addr u
.9d47		20 a7 93	jsr $93a7	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9d4a		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9d4c		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9d4e		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9d4f		f0 0a		beq $9d5b	                beq _single
.9d51		98		tya		                tya
.9d52		04 1c		tsb $1c		                tsb status
.9d54		90 0f		bcc $9d65	                bcc _done       ; no minus, all done
.9d56		20 3d 9e	jsr $9e3d	                jsr xt_dnegate
.9d59		80 0a		bra $9d65	                bra _done
.9d5b						_single:
.9d5b		e8		inx		                inx
.9d5c		e8		inx		                inx
.9d5d		98		tya		                tya
.9d5e		14 1c		trb $1c		                trb status
.9d60		90 03		bcc $9d65	                bcc _done       ; no minus, all done
.9d62		20 1f 8c	jsr $8c1f	                jsr xt_negate
.9d65						_done:
.9d65		68		pla		                pla
.9d66		85 18		sta $18		                sta base
.9d68		60		rts		z_number:       rts
.9d69						xt_editor_wordlist:
.9d69						xt_one:
.9d69		ca		dex		                dex
.9d6a		ca		dex		                dex
.9d6b		a9 01		lda #$01	                lda #1
.9d6d		95 00		sta $00,x	                sta 0,x
.9d6f		74 01		stz $01,x	                stz 1,x
.9d71						z_editor_wordlist:
.9d71						z_one:
.9d71		60		rts		                rts
.9d72						xt_output:
.9d72		ca		dex		                dex
.9d73		ca		dex		                dex
.9d74		a9 12		lda #$12	                lda #<output
.9d76		95 00		sta $00,x	                sta 0,x
.9d78		a9 00		lda #$00	                lda #>output
.9d7a		95 01		sta $01,x	                sta 1,x
.9d7c		60		rts		z_output:       rts
.9d7d						xt_r_to_input:
.9d7d		68		pla		                pla
.9d7e		85 25		sta $25		                sta tmp1
.9d80		68		pla		                pla
.9d81		85 26		sta $26		                sta tmp1+1
.9d83		a0 00		ldy #$00	                ldy #0
.9d85						_loop:
.9d85		68		pla		                pla
.9d86		99 0a 00	sta $000a,y	                sta insrc,y
.9d89		c8		iny		                iny
.9d8a		c0 08		cpy #$08	                cpy #8
.9d8c		d0 f7		bne $9d85	                bne _loop
.9d8e		a5 26		lda $26		                lda tmp1+1
.9d90		48		pha		                pha
.9d91		a5 25		lda $25		                lda tmp1
.9d93		48		pha		                pha
.9d94		60		rts		z_r_to_input: 	rts
.9d95						xt_strip_underflow:
.9d95		a9 02		lda #$02	                lda #uf_strip_offset
.9d97		4c 24 d6	jmp $d624	                jmp push_upvar_tos
.9d9a						z_strip_underflow:
.9d9a						xt_assembler_wordlist:
.9d9a						xt_two:
.9d9a		ca		dex		                dex
.9d9b		ca		dex		                dex
.9d9c		a9 02		lda #$02	                lda #2
.9d9e		95 00		sta $00,x	                sta 0,x
.9da0		74 01		stz $01,x	                stz 1,x
.9da2						z_assembler_wordlist:
.9da2		60		rts		z_two:          rts
.9da3						xt_useraddr:
.9da3		ca		dex		                dex
.9da4		ca		dex		                dex
.9da5		a9 08		lda #$08	                lda #<up
.9da7		95 00		sta $00,x	                sta 0,x
.9da9		a9 00		lda #$00	                lda #>up
.9dab		95 01		sta $01,x	                sta 1,x
.9dad		60		rts		z_useraddr:     rts
.9dae						xt_wordsize:
.9dae		20 68 d7	jsr $d768	                jsr underflow_1
.9db1		b5 00		lda $00,x	                lda 0,x
.9db3		85 25		sta $25		                sta tmp1
.9db5		b5 01		lda $01,x	                lda 1,x
.9db7		85 26		sta $26		                sta tmp1+1
.9db9		a0 06		ldy #$06	                ldy #6
.9dbb		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.9dbd		88		dey		                dey
.9dbe		88		dey		                dey
.9dbf		38		sec		                sec
.9dc0		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.9dc2		95 00		sta $00,x	                sta 0,x
.9dc4		a0 07		ldy #$07	                ldy #7
.9dc6		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.9dc8		88		dey		                dey
.9dc9		88		dey		                dey
.9dca		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.9dcc		95 01		sta $01,x	                sta 1,x
.9dce		60		rts		z_wordsize:     rts
.9dcf						xt_case:
.9dcf						xt_false:
.9dcf						xt_forth_wordlist:
.9dcf						xt_zero:
.9dcf		ca		dex		                dex             ; push
.9dd0		ca		dex		                dex
.9dd1		74 00		stz $00,x	                stz 0,x
.9dd3		74 01		stz $01,x	                stz 1,x
.9dd5						z_case:
.9dd5						z_false:
.9dd5						z_forth_wordlist:
.9dd5						z_zero:
.9dd5		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/double.asm

.9dd6						xt_d_minus:
.9dd6		20 77 d7	jsr $d777	                jsr underflow_4 ; two double numbers
.9dd9		38		sec		                sec
.9dda		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.9ddc		f5 02		sbc $02,x	                sbc 2,x
.9dde		95 06		sta $06,x	                sta 6,x
.9de0		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.9de2		f5 03		sbc $03,x	                sbc 3,x
.9de4		95 07		sta $07,x	                sta 7,x
.9de6		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.9de8		f5 00		sbc $00,x	                sbc 0,x
.9dea		95 04		sta $04,x	                sta 4,x
.9dec		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.9dee		f5 01		sbc $01,x	                sbc 1,x
.9df0		95 05		sta $05,x	                sta 5,x
.9df2		e8		inx		                inx
.9df3		e8		inx		                inx
.9df4		e8		inx		                inx
.9df5		e8		inx		                inx
.9df6		60		rts		z_d_minus:      rts
.9df7						xt_d_plus:
.9df7		20 77 d7	jsr $d777	                jsr underflow_4 ; two double numbers
.9dfa		18		clc		                clc
.9dfb		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.9dfd		75 06		adc $06,x	                adc 6,x
.9dff		95 06		sta $06,x	                sta 6,x
.9e01		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.9e03		75 07		adc $07,x	                adc 7,x
.9e05		95 07		sta $07,x	                sta 7,x
.9e07		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.9e09		75 04		adc $04,x	                adc 4,x
.9e0b		95 04		sta $04,x	                sta 4,x
.9e0d		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.9e0f		75 05		adc $05,x	                adc 5,x
.9e11		95 05		sta $05,x	                sta 5,x
.9e13		e8		inx		                inx
.9e14		e8		inx		                inx
.9e15		e8		inx		                inx
.9e16		e8		inx		                inx
.9e17		60		rts		z_d_plus:       rts
.9e18						xt_d_to_s:
.9e18		20 6d d7	jsr $d76d	                jsr underflow_2
.9e1b		e8		inx		                inx
.9e1c		e8		inx		                inx
.9e1d		60		rts		z_d_to_s:       rts
.9e1e						xt_dabs:
.9e1e		20 6d d7	jsr $d76d	                jsr underflow_2 ; double number
.9e21		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.9e23		10 17		bpl $9e3c	                bpl _done       ; positive, we get off light
.9e25		a0 00		ldy #$00	                ldy #0
.9e27		38		sec		                sec
.9e28		98		tya		                tya
.9e29		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e2b		95 02		sta $02,x	                sta 2,x
.9e2d		98		tya		                tya
.9e2e		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e30		95 03		sta $03,x	                sta 3,x
.9e32		98		tya		                tya
.9e33		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e35		95 00		sta $00,x	                sta 0,x
.9e37		98		tya		                tya
.9e38		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9e3a		95 01		sta $01,x	                sta 1,x
.9e3c						_done:
.9e3c		60		rts		z_dabs:         rts
.9e3d						xt_dnegate:
.9e3d		20 6d d7	jsr $d76d	                jsr underflow_2 ; double number
.9e40		a0 00		ldy #$00	     		ldy #0
.9e42		38		sec		                sec
.9e43		98		tya		                tya
.9e44		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e46		95 02		sta $02,x	                sta 2,x
.9e48		98		tya		                tya
.9e49		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e4b		95 03		sta $03,x	                sta 3,x
.9e4d		98		tya		                tya
.9e4e		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e50		95 00		sta $00,x	                sta 0,x
.9e52		98		tya		                tya
.9e53		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9e55		95 01		sta $01,x	                sta 1,x
.9e57		60		rts		z_dnegate:      rts
.9e58						xt_d_dot:
.9e58		20 6d d7	jsr $d76d	                jsr underflow_2
.9e5b		20 8d 93	jsr $938d	                jsr xt_tuck
.9e5e		20 1e 9e	jsr $9e1e	                jsr xt_dabs
.9e61		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9e64		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.9e67		20 91 8f	jsr $8f91	                jsr xt_rot
.9e6a		20 50 91	jsr $9150	                jsr xt_sign
.9e6d		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.9e70		20 b7 94	jsr $94b7	                jsr xt_type
.9e73		20 cb 91	jsr $91cb	                jsr xt_space
.9e76		60		rts		z_d_dot:        rts
.9e77						xt_d_dot_r:
.9e77		20 72 d7	jsr $d772	                jsr underflow_3
.9e7a		20 6c 93	jsr $936c	                jsr xt_to_r
.9e7d		20 8d 93	jsr $938d	                jsr xt_tuck
.9e80		20 1e 9e	jsr $9e1e	                jsr xt_dabs
.9e83		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9e86		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.9e89		20 91 8f	jsr $8f91	                jsr xt_rot
.9e8c		20 50 91	jsr $9150	                jsr xt_sign
.9e8f		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.9e92		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.9e95		20 05 8d	jsr $8d05	                jsr xt_over
.9e98		20 e4 8b	jsr $8be4	                jsr xt_minus
.9e9b		20 d1 91	jsr $91d1	                jsr xt_spaces
.9e9e		20 b7 94	jsr $94b7	                jsr xt_type
.9ea1		60		rts		z_d_dot_r:      rts
.9ea2						xt_two_constant:
.9ea2		20 6d d7	jsr $d76d	                jsr underflow_2
.9ea5		20 40 84	jsr $8440	                jsr xt_create
.9ea8		20 2e 92	jsr $922e	                jsr xt_swap
.9eab		20 cd 83	jsr $83cd	                jsr xt_comma
.9eae		20 cd 83	jsr $83cd	                jsr xt_comma
.9eb1		20 fe 85	jsr $85fe	                jsr does_runtime    ; does> turns into these two routines.
.9eb4		20 fd d5	jsr $d5fd	                jsr dodoes
.9eb7		20 a0 86	jsr $86a0	                jsr xt_dup
.9eba		20 1a 88	jsr $881a	                jsr xt_fetch
.9ebd		20 2e 92	jsr $922e	                jsr xt_swap
.9ec0		20 43 83	jsr $8343	                jsr xt_cell_plus
.9ec3		20 1a 88	jsr $881a	                jsr xt_fetch
.9ec6		60		rts		z_two_constant: rts
.9ec7						xt_two_literal:
.9ec7		20 6d d7	jsr $d76d	                jsr underflow_2 ; double number
.9eca		a9 0a		lda #$0a	                lda #template_push_tos_size
.9ecc		0a		asl a		                asl
.9ecd		20 83 97	jsr $9783	                jsr check_nc_limit
.9ed0		b0 09		bcs $9edb	                bcs _no_inline
.9ed2		20 2e 92	jsr $922e	                jsr xt_swap
.9ed5		20 f2 89	jsr $89f2	                jsr xt_literal
.9ed8		4c f2 89	jmp $89f2	                jmp xt_literal
.9edb						_no_inline:
.9edb		20 3a a1	jsr $a13a	                jsr cmpl_two_literal
.9ede		60		rts		z_two_literal:  rts
.9edf						xt_two_variable:
.9edf		20 40 84	jsr $8440	                jsr xt_create
.9ee2		ca		dex		                dex
.9ee3		ca		dex		                dex
.9ee4		a9 04		lda #$04	                lda #4
.9ee6		95 00		sta $00,x	                sta 0,x
.9ee8		74 01		stz $01,x	                stz 1,x
.9eea		20 27 82	jsr $8227	                jsr xt_allot
.9eed		60		rts		z_two_variable: rts
.9eee						xt_ud_dot:
.9eee		20 6d d7	jsr $d76d	                jsr underflow_2 ; double number
.9ef1		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9ef4		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.9ef7		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.9efa		20 b7 94	jsr $94b7	                jsr xt_type
.9efd		20 cb 91	jsr $91cb	                jsr xt_space
.9f00		60		rts		z_ud_dot:        rts
.9f01						xt_ud_dot_r:
.9f01		20 72 d7	jsr $d772	                jsr underflow_3
.9f04		20 6c 93	jsr $936c	                jsr xt_to_r
.9f07		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9f0a		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.9f0d		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.9f10		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.9f13		20 05 8d	jsr $8d05	                jsr xt_over
.9f16		20 e4 8b	jsr $8be4	                jsr xt_minus
.9f19		20 d1 91	jsr $91d1	                jsr xt_spaces
.9f1c		20 b7 94	jsr $94b7	                jsr xt_type
.9f1f		60		rts		z_ud_dot_r:      rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/string.asm

.9f20						xt_cmove:
.9f20		20 72 d7	jsr $d772	                jsr underflow_3
.9f23		b5 02		lda $02,x	                lda 2,x
.9f25		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9f27		b5 03		lda $03,x	                lda 3,x
.9f29		85 28		sta $28		                sta tmp2+1
.9f2b		b5 04		lda $04,x	                lda 4,x
.9f2d		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9f2f		b5 05		lda $05,x	                lda 5,x
.9f31		85 26		sta $26		                sta tmp1+1
.9f33		a0 00		ldy #$00	                ldy #0
.9f35		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.9f37		f0 0f		beq $9f48	                beq _dopartial
.9f39						_page:
.9f39		b1 25		lda ($25),y	                lda (tmp1),y
.9f3b		91 27		sta ($27),y	                sta (tmp2),y
.9f3d		c8		iny		                iny
.9f3e		d0 f9		bne $9f39	                bne _page
.9f40		e6 26		inc $26		                inc tmp1+1
.9f42		e6 28		inc $28		                inc tmp2+1
.9f44		d6 01		dec $01,x	                dec 1,x
.9f46		d0 f1		bne $9f39	                bne _page
.9f48						_dopartial:
.9f48		b5 00		lda $00,x	                lda 0,x         ; length of last page
.9f4a		f0 09		beq $9f55	                beq _done
.9f4c						_partial:
.9f4c		b1 25		lda ($25),y	                lda (tmp1),y
.9f4e		91 27		sta ($27),y	                sta (tmp2),y
.9f50		c8		iny		                iny
.9f51		d6 00		dec $00,x	                dec 0,x
.9f53		d0 f7		bne $9f4c	                bne _partial
.9f55						_done:
.9f55		8a		txa		                txa
.9f56		18		clc		                clc
.9f57		69 06		adc #$06	                adc #6
.9f59		aa		tax		                tax
.9f5a		60		rts		z_cmove:        rts
.9f5b						xt_cmove_up:
.9f5b		20 72 d7	jsr $d772	                jsr underflow_3
.9f5e		b5 02		lda $02,x	                lda 2,x
.9f60		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9f62		b5 03		lda $03,x	                lda 3,x
.9f64		18		clc		                clc
.9f65		75 01		adc $01,x	                adc 1,x
.9f67		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.9f69		b5 04		lda $04,x	                lda 4,x
.9f6b		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9f6d		b5 05		lda $05,x	                lda 5,x
.9f6f		18		clc		                clc
.9f70		75 01		adc $01,x	                adc 1,x
.9f72		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.9f74		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.9f76		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.9f78		f0 0e		beq $9f88	                beq _nopartial
.9f7a						_outerloop:
.9f7a		88		dey		                dey
.9f7b		f0 07		beq $9f84	                beq _finishpage
.9f7d						_innerloop:
.9f7d		b1 25		lda ($25),y	                lda (tmp1),y
.9f7f		91 27		sta ($27),y	                sta (tmp2),y
.9f81		88		dey		                dey
.9f82		d0 f9		bne $9f7d	                bne _innerloop
.9f84						_finishpage:
.9f84		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.9f86		92 27		sta ($27)	                sta (tmp2)
.9f88						_nopartial:
.9f88		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.9f8a		c6 28		dec $28		                dec tmp2+1
.9f8c		d6 01		dec $01,x	                dec 1,x
.9f8e		d0 ea		bne $9f7a	                bne _outerloop
.9f90		8a		txa		                txa
.9f91		18		clc		                clc
.9f92		69 06		adc #$06	                adc #6
.9f94		aa		tax		                tax
.9f95		60		rts		z_cmove_up:     rts
.9f96						xt_compare:
.9f96		20 77 d7	jsr $d777	                jsr underflow_4
.9f99		b5 02		lda $02,x	                lda 2,x
.9f9b		85 27		sta $27		                sta tmp2
.9f9d		b5 03		lda $03,x	                lda 3,x
.9f9f		85 28		sta $28		                sta tmp2+1
.9fa1		b5 06		lda $06,x	                lda 6,x
.9fa3		85 25		sta $25		                sta tmp1
.9fa5		b5 07		lda $07,x	                lda 7,x
.9fa7		85 26		sta $26		                sta tmp1+1
.9fa9						_compare_loop:
.9fa9		b5 04		lda $04,x	                lda 4,x
.9fab		15 05		ora $05,x	                ora 5,x
.9fad		f0 2c		beq $9fdb	                beq _str1_done
.9faf		b5 00		lda $00,x	                lda 0,x
.9fb1		15 01		ora $01,x	                ora 1,x
.9fb3		f0 3a		beq $9fef	                beq _greater    ; Str2 empty first
.9fb5		b2 25		lda ($25)	                lda (tmp1)
.9fb7		d2 27		cmp ($27)	                cmp (tmp2)
.9fb9		90 26		bcc $9fe1	                bcc _less
.9fbb		d0 32		bne $9fef	                bne _greater
.9fbd		e6 25		inc $25		                inc tmp1
.9fbf		d0 02		bne $9fc3	                bne +
.9fc1		e6 26		inc $26		                inc tmp1+1
.9fc3						+
.9fc3		e6 27		inc $27		                inc tmp2
.9fc5		d0 02		bne $9fc9	                bne +
.9fc7		e6 28		inc $28		                inc tmp2+1
.9fc9						+
.9fc9		b5 04		lda $04,x	                lda 4,x
.9fcb		d0 02		bne $9fcf	                bne +
.9fcd		d6 05		dec $05,x	                dec 5,x
.9fcf						+
.9fcf		d6 04		dec $04,x	                dec 4,x
.9fd1		b5 00		lda $00,x	                lda 0,x
.9fd3		d0 02		bne $9fd7	                bne +
.9fd5		d6 01		dec $01,x	                dec 1,x
.9fd7						+
.9fd7		d6 00		dec $00,x	                dec 0,x
.9fd9		80 ce		bra $9fa9	                bra _compare_loop
.9fdb						_str1_done:
.9fdb		b5 00		lda $00,x	                lda 0,x
.9fdd		15 01		ora $01,x	                ora 1,x
.9fdf		f0 08		beq $9fe9	                beq _equal      ; Both out of letters
.9fe1						_less:
.9fe1		a9 ff		lda #$ff	                lda #$FF
.9fe3		95 06		sta $06,x	                sta 6,x
.9fe5		95 07		sta $07,x	                sta 7,x
.9fe7		80 0c		bra $9ff5	                bra _done
.9fe9						_equal:
.9fe9		74 06		stz $06,x	                stz 6,x
.9feb		74 07		stz $07,x	                stz 7,x
.9fed		80 06		bra $9ff5	                bra _done
.9fef						_greater:
.9fef		a9 01		lda #$01	                lda #1
.9ff1		95 06		sta $06,x	                sta 6,x
.9ff3		74 07		stz $07,x	                stz 7,x
.9ff5						_done:
.9ff5		8a		txa		                txa
.9ff6		18		clc		                clc
.9ff7		69 06		adc #$06	                adc #6
.9ff9		aa		tax		                tax
.9ffa		60		rts		z_compare:      rts
.9ffb						xt_minus_leading:
.9ffb		20 6d d7	jsr $d76d	                jsr underflow_2
.9ffe						_loop:
.9ffe		b5 00		lda $00,x	                lda 0,x
.a000		15 01		ora $01,x	                ora 1,x
.a002		f0 0f		beq $a013	                beq _done
.a004		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.a006		20 5b d7	jsr $d75b	                jsr is_whitespace
.a009		90 08		bcc $a013	                bcc _done
.a00b		20 69 9d	jsr $9d69	                jsr xt_one              ; ( addr u 1 )
.a00e		20 f0 a0	jsr $a0f0	                jsr xt_slash_string     ; ( addr+ u-1 )
.a011		80 eb		bra $9ffe	                bra _loop
.a013						_done:
.a013						z_minus_leading:
.a013		60		rts		                rts
.a014						xt_minus_trailing:
.a014		20 6d d7	jsr $d76d	                jsr underflow_2
.a017		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.a019		15 01		ora $01,x	                ora 1,x         ; MSB of n
.a01b		f0 33		beq $a050	                beq _done
.a01d		18		clc		                clc
.a01e		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.a020		75 00		adc $00,x	                adc 0,x
.a022		85 25		sta $25		                sta tmp1
.a024		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.a026		75 01		adc $01,x	                adc 1,x
.a028		85 26		sta $26		                sta tmp1+1
.a02a		a5 25		lda $25		                lda tmp1
.a02c		d0 02		bne $a030	                bne +
.a02e		c6 26		dec $26		                dec tmp1+1
.a030						+
.a030		c6 25		dec $25		                dec tmp1
.a032						_loop:
.a032		b2 25		lda ($25)	                lda (tmp1)
.a034		c9 20		cmp #$20	                cmp #AscSP
.a036		d0 18		bne $a050	                bne _done
.a038		a5 25		lda $25		                lda tmp1
.a03a		d0 02		bne $a03e	                bne +
.a03c		c6 26		dec $26		                dec tmp1+1
.a03e						+
.a03e		c6 25		dec $25		                dec tmp1
.a040		b5 00		lda $00,x	                lda 0,x
.a042		d0 02		bne $a046	                bne +
.a044		d6 01		dec $01,x	                dec 1,x
.a046						+
.a046		d6 00		dec $00,x	                dec 0,x
.a048		b5 00		lda $00,x	                lda 0,x
.a04a		15 01		ora $01,x	                ora 1,x
.a04c		f0 02		beq $a050	                beq _done       ; Count has reached zero - we're done!
.a04e		80 e2		bra $a032	                bra _loop
.a050						_done:
.a050						z_minus_trailing:
.a050		60		rts		                rts
.a051						xt_search:
.a051		20 77 d7	jsr $d777	                jsr underflow_4
.a054		b5 00		lda $00,x	                lda 0,x
.a056		15 01		ora $01,x	                ora 1,x
.a058		d0 0b		bne $a065	                bne _start_search
.a05a		e8		inx		                inx             ; Remove u2
.a05b		e8		inx		                inx
.a05c		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.a05e		95 00		sta $00,x	                sta 0,x
.a060		95 01		sta $01,x	                sta 1,x
.a062		4c ef a0	jmp $a0ef	                jmp z_search
.a065						_start_search:
.a065		20 cf 9d	jsr $9dcf	                jsr xt_zero
.a068						_search_loop:
.a068		18		clc		                clc
.a069		b5 00		lda $00,x	                lda 0,x
.a06b		75 02		adc $02,x	                adc 2,x
.a06d		85 25		sta $25		                sta tmp1
.a06f		b5 01		lda $01,x	                lda 1,x
.a071		75 03		adc $03,x	                adc 3,x
.a073		d5 07		cmp $07,x	                cmp 7,x
.a075		90 12		bcc $a089	                bcc _init_comparison ; Obviously less
.a077		d0 06		bne $a07f	                bne _not_found
.a079		b5 06		lda $06,x	                lda 6,x
.a07b		c5 25		cmp $25		                cmp tmp1
.a07d		b0 0a		bcs $a089	                bcs _init_comparison
.a07f						_not_found:
.a07f		e8		inx		                inx             ; Remove offset
.a080		e8		inx		                inx
.a081		e8		inx		                inx             ; Remove u2
.a082		e8		inx		                inx
.a083		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.a085		74 01		stz $01,x	                stz 1,x
.a087		80 66		bra $a0ef	                bra z_search
.a089						_init_comparison:
.a089		18		clc		                clc
.a08a		b5 08		lda $08,x	                lda 8,x
.a08c		75 00		adc $00,x	                adc 0,x
.a08e		85 25		sta $25		                sta tmp1
.a090		b5 09		lda $09,x	                lda 9,x
.a092		75 01		adc $01,x	                adc 1,x
.a094		85 26		sta $26		                sta tmp1+1
.a096		b5 04		lda $04,x	                lda 4,x
.a098		85 27		sta $27		                sta tmp2
.a09a		b5 05		lda $05,x	                lda 5,x
.a09c		85 28		sta $28		                sta tmp2+1
.a09e		b5 02		lda $02,x	                lda 2,x
.a0a0		85 29		sta $29		                sta tmp3
.a0a2		b5 03		lda $03,x	                lda 3,x
.a0a4		85 2a		sta $2a		                sta tmp3+1
.a0a6						_comparison_loop:
.a0a6		b2 25		lda ($25)	                lda (tmp1)
.a0a8		d2 27		cmp ($27)	                cmp (tmp2)
.a0aa		f0 05		beq $a0b1	                beq _letters_match
.a0ac		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.a0af		80 b7		bra $a068	                bra _search_loop
.a0b1						_letters_match:
.a0b1		e6 25		inc $25		                inc tmp1
.a0b3		d0 02		bne $a0b7	                bne +
.a0b5		e6 26		inc $26		                inc tmp1+1
.a0b7						+
.a0b7		e6 27		inc $27		                inc tmp2
.a0b9		d0 02		bne $a0bd	                bne +
.a0bb		e6 28		inc $28		                inc tmp2+1
.a0bd						+
.a0bd		a5 29		lda $29		                lda tmp3
.a0bf		d0 02		bne $a0c3	                bne +
.a0c1		c6 2a		dec $2a		                dec tmp3+1
.a0c3						+
.a0c3		c6 29		dec $29		                dec tmp3
.a0c5		a5 29		lda $29		                lda tmp3
.a0c7		05 2a		ora $2a		                ora tmp3+1
.a0c9		d0 db		bne $a0a6	                bne _comparison_loop ; Check the next letter
.a0cb		18		clc		                clc
.a0cc		b5 00		lda $00,x	                lda 0,x
.a0ce		75 08		adc $08,x	                adc 8,x
.a0d0		95 08		sta $08,x	                sta 8,x
.a0d2		b5 01		lda $01,x	                lda 1,x
.a0d4		75 09		adc $09,x	                adc 9,x
.a0d6		95 09		sta $09,x	                sta 9,x
.a0d8		38		sec		                sec
.a0d9		b5 06		lda $06,x	                lda 6,x
.a0db		f5 00		sbc $00,x	                sbc 0,x
.a0dd		95 06		sta $06,x	                sta 6,x
.a0df		b5 07		lda $07,x	                lda 7,x
.a0e1		f5 01		sbc $01,x	                sbc 1,x
.a0e3		95 07		sta $07,x	                sta 7,x
.a0e5		e8		inx		                inx             ; drop offset
.a0e6		e8		inx		                inx
.a0e7		e8		inx		                inx             ; drop u2
.a0e8		e8		inx		                inx
.a0e9		a9 ff		lda #$ff	                lda #$FF
.a0eb		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.a0ed		95 01		sta $01,x	                sta 1,x
.a0ef		60		rts		z_search:       rts
.a0f0						xt_slash_string:
.a0f0		20 72 d7	jsr $d772	                jsr underflow_3
.a0f3		18		clc		                clc             ; 3OS+TOS
.a0f4		b5 00		lda $00,x	                lda 0,x
.a0f6		75 04		adc $04,x	                adc 4,x
.a0f8		95 04		sta $04,x	                sta 4,x
.a0fa		b5 01		lda $01,x	                lda 1,x
.a0fc		75 05		adc $05,x	                adc 5,x
.a0fe		95 05		sta $05,x	                sta 5,x
.a100		38		sec		                sec             ; NOS-TOS
.a101		b5 02		lda $02,x	                lda 2,x
.a103		f5 00		sbc $00,x	                sbc 0,x
.a105		95 02		sta $02,x	                sta 2,x
.a107		b5 03		lda $03,x	                lda 3,x
.a109		f5 01		sbc $01,x	                sbc 1,x
.a10b		95 03		sta $03,x	                sta 3,x
.a10d		e8		inx		                inx
.a10e		e8		inx		                inx
.a10f		60		rts		z_slash_string: rts
.a110						xt_sliteral:
.a110		20 6d d7	jsr $d76d	                jsr underflow_2
.a113		20 79 97	jsr $9779	                jsr cmpl_jump_later
.a116		20 6c 93	jsr $936c	                jsr xt_to_r
.a119		20 1b 89	jsr $891b	                jsr xt_here
.a11c		20 2e 92	jsr $922e	                jsr xt_swap
.a11f		20 a0 86	jsr $86a0	                jsr xt_dup
.a122		20 27 82	jsr $8227	                jsr xt_allot            ; reserve u bytes for string
.a125		20 1b 89	jsr $891b	                jsr xt_here
.a128		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.a12b		20 18 92	jsr $9218	                jsr xt_store            ; point jmp past string
.a12e		20 af 93	jsr $93af	                jsr xt_two_dup
.a131		20 99 94	jsr $9499	                jsr xt_two_to_r
.a134		20 00 8c	jsr $8c00	                jsr xt_move             ; copy u bytes from addr -> addr'
.a137		20 21 94	jsr $9421	                jsr xt_two_r_from
.a13a						cmpl_sliteral:
.a13a						cmpl_two_literal:
.a13a		a0 a1		ldy #$a1	                ldy #>sliteral_runtime
.a13c		a9 54		lda #$54	                lda #<sliteral_runtime
.a13e		20 58 97	jsr $9758	                jsr cmpl_subroutine
.a141		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a143		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a145		20 64 97	jsr $9764	                jsr cmpl_word
.a148		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a14a		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a14c		20 64 97	jsr $9764	                jsr cmpl_word
.a14f		e8		inx		                inx
.a150		e8		inx		                inx
.a151		e8		inx		                inx
.a152		e8		inx		                inx
.a153		60		rts		z_sliteral:     rts
.a154						sliteral_runtime:
.a154		ca		dex		                dex
.a155		ca		dex		                dex
.a156		ca		dex		                dex
.a157		ca		dex		                dex
.a158		68		pla		                pla
.a159		85 25		sta $25		                sta tmp1        ; LSB of address
.a15b		7a		ply		                ply
.a15c		84 26		sty $26		                sty tmp1+1      ; MSB of address
.a15e		18		clc		                clc
.a15f		69 04		adc #$04	                adc #4
.a161		90 01		bcc $a164	                bcc +
.a163		c8		iny		                iny
.a164						+
.a164		5a		phy		                phy
.a165		48		pha		                pha
.a166		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a168		b1 25		lda ($25),y	                lda (tmp1),y
.a16a		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a16c		c8		iny		                iny
.a16d		b1 25		lda ($25),y	                lda (tmp1),y
.a16f		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a171		c8		iny		                iny
.a172		b1 25		lda ($25),y	                lda (tmp1),y
.a174		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a176		c8		iny		                iny
.a177		b1 25		lda ($25),y	                lda (tmp1),y
.a179		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a17b		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/disasm.asm

.a17c						xt_disasm:
.a17c		20 6d d7	jsr $d76d	                jsr underflow_2
.a17f		20 83 a1	jsr $a183	                jsr disassembler
.a182		60		rts		z_disasm:       rts
.a183						disassembler:
.a183		64 32		stz $32		                stz scratch+5   ; flag indicating whether we're arriving at sliteral (vs 2literal)
.a185		20 3a 84	jsr $843a	                jsr xt_cr       ; ( addr u )
.a188						_byte_loop:
.a188		20 05 8d	jsr $8d05	                jsr xt_over     ; ( addr u addr )
.a18b		20 e2 94	jsr $94e2	                jsr xt_u_dot    ; ( addr u )
.a18e		20 cb 91	jsr $91cb	                jsr xt_space
.a191		a9 8b		lda #$8b	                lda #<oc_index_table
.a193		85 27		sta $27		                sta tmp2
.a195		a9 b3		lda #$b3	                lda #>oc_index_table
.a197		85 28		sta $28		                sta tmp2+1
.a199		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.a19b		85 2d		sta $2d		                sta scratch     ; Save opcode
.a19d		0a		asl a		                asl             ; multiply by two for offset
.a19e		90 02		bcc $a1a2	                bcc +
.a1a0		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.a1a2						+
.a1a2		a8		tay		                tay             ; use Y as the index
.a1a3		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a1a5		85 29		sta $29		                sta tmp3
.a1a7		48		pha		                pha
.a1a8		c8		iny		                iny
.a1a9		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a1ab		85 2a		sta $2a		                sta tmp3+1
.a1ad		48		pha		                pha
.a1ae		b2 29		lda ($29)	                lda (tmp3)
.a1b0		a8		tay		                tay                     ; save copy of lengths byte
.a1b1		10 3c		bpl $a1ef	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.a1b3		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.a1b6		f6 04		inc $04,x	                inc 4,x
.a1b8		d0 02		bne $a1bc	                bne +
.a1ba		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.a1bc						+
.a1bc		b5 02		lda $02,x	                lda 2,x
.a1be		d0 02		bne $a1c2	                bne +
.a1c0		d6 03		dec $03,x	                dec 3,x
.a1c2						+
.a1c2		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.a1c4		a1 04		lda ($04,x)	                lda (4,x)
.a1c6		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.a1c8		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.a1ca		98		tya		                tya                     ; retrieve copy of lengths byte
.a1cb		2a		rol a		                rol                     ; shift bit 6 to bit 7
.a1cc		10 14		bpl $a1e2	                bpl _print_operand
.a1ce		f6 04		inc $04,x	                inc 4,x
.a1d0		d0 02		bne $a1d4	                bne +
.a1d2		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.a1d4						+
.a1d4		b5 02		lda $02,x	                lda 2,x
.a1d6		d0 02		bne $a1da	                bne +
.a1d8		d6 03		dec $03,x	                dec 3,x
.a1da						+
.a1da		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.a1dc		a1 04		lda ($04,x)	                lda (4,x)
.a1de		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.a1e0		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.a1e2						_print_operand:
.a1e2		ca		dex		                dex
.a1e3		ca		dex		                dex
.a1e4		a9 05		lda #$05	                lda #5
.a1e6		95 00		sta $00,x	                sta 0,x
.a1e8		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.a1ea		20 ee 94	jsr $94ee	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.a1ed		80 0b		bra $a1fa	                bra _print_mnemonic
.a1ef						_no_operand:
.a1ef		ca		dex		                dex
.a1f0		ca		dex		                dex
.a1f1		a9 05		lda #$05	                lda #5
.a1f3		95 00		sta $00,x	                sta 0,x
.a1f5		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.a1f7		20 d1 91	jsr $91d1	                jsr xt_spaces           ; ( addr u )
.a1fa						_print_mnemonic:
.a1fa		20 cb 91	jsr $91cb	                jsr xt_space
.a1fd		ca		dex		                dex
.a1fe		ca		dex		                dex                     ; ( addr u ? )
.a1ff		68		pla		                pla                     ; MSB
.a200		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.a202		68		pla		                pla                     ; LSB
.a203		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.a205		20 26 84	jsr $8426	                jsr xt_count            ; ( addr u addr-o u-o )
.a208		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a20a		b5 00		lda $00,x	                lda 0,x
.a20c		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.a20e		95 00		sta $00,x	                sta 0,x
.a210		20 b7 94	jsr $94b7	                jsr xt_type             ; ( addr u )
.a213		a5 2d		lda $2d		                lda scratch
.a215		c9 20		cmp #$20	                cmp #OpJSR
.a217		d0 15		bne $a22e	                bne _not_jsr
.a219		ca		dex		                dex
.a21a		ca		dex		                dex
.a21b		a9 05		lda #$05	                lda #5
.a21d		95 00		sta $00,x	                sta 0,x
.a21f		74 01		stz $01,x	                stz 1,x
.a221		20 d1 91	jsr $91d1	                jsr xt_spaces
.a224		20 ff a2	jsr $a2ff	                jsr disasm_special
.a227		b0 70		bcs $a299	                bcs _printing_done
.a229		20 df a2	jsr $a2df	                jsr disasm_jsr
.a22c		b0 6b		bcs $a299	                bcs _printing_done
.a22e						_not_jsr:
.a22e		c9 4c		cmp #$4c	                cmp #OpJMP
.a230		d0 2d		bne $a25f	                bne _not_jmp
.a232		a5 2e		lda $2e		                lda scratch+1   ; Copy the pointer.
.a234		85 30		sta $30		                sta scratch+3
.a236		a5 2f		lda $2f		                lda scratch+2
.a238		85 31		sta $31		                sta scratch+4
.a23a		b2 30		lda ($30)	                lda (scratch+3)
.a23c		c9 20		cmp #$20	                cmp #OpJSR          ; check for JSR
.a23e		d0 59		bne $a299	                bne _printing_done
.a240		e6 30		inc $30		                inc scratch+3
.a242		d0 02		bne $a246	                bne +
.a244		e6 31		inc $31		                inc scratch+4
.a246						+
.a246		b2 30		lda ($30)	                lda (scratch+3)
.a248		c9 54		cmp #$54	                cmp #<sliteral_runtime
.a24a		d0 4d		bne $a299	                bne _printing_done
.a24c		e6 30		inc $30		                inc scratch+3
.a24e		d0 02		bne $a252	                bne +
.a250		e6 31		inc $31		                inc scratch+4
.a252						+
.a252		b2 30		lda ($30)	                lda (scratch+3)
.a254		c9 a1		cmp #$a1	                cmp #>sliteral_runtime
.a256		d0 41		bne $a299	                bne _printing_done
.a258		c6 32		dec $32		                dec scratch+5                   ; flag for next go round
.a25a		20 b5 a2	jsr $a2b5	                jsr disasm_sliteral_jump
.a25d		80 3a		bra $a299	                bra _printing_done
.a25f						_not_jmp:
.a25f		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.a261		f0 06		beq $a269	                beq _is_rel
.a263		29 1f		and #$1f	                and #$1F
.a265		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.a267		d0 30		bne $a299	                bne _printing_done
.a269						_is_rel:
.a269		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.a26b		ca		dex		                dex
.a26c		ca		dex		                dex
.a26d		74 01		stz $01,x	                stz 1,x
.a26f		a5 2e		lda $2e		                lda scratch+1
.a271		95 00		sta $00,x	                sta 0,x
.a273		10 04		bpl $a279	                bpl +
.a275		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.a277		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.a279		38		sec		+               sec                 ; start counting from address after opcode
.a27a		75 04		adc $04,x	                adc 4,x
.a27c		95 00		sta $00,x	                sta 0,x
.a27e		b5 01		lda $01,x	                lda 1,x
.a280		75 05		adc $05,x	                adc 5,x
.a282		95 01		sta $01,x	                sta 1,x
.a284		5a		phy		                phy                 ; save the direction indicator
.a285		ca		dex		                dex
.a286		ca		dex		                dex
.a287		a9 09		lda #$09	                lda #9
.a289		95 00		sta $00,x	                sta 0,x
.a28b		74 01		stz $01,x	                stz 1,x
.a28d		20 ee 94	jsr $94ee	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.a290		a9 20		lda #$20	                lda #AscSP          ; print space and branch direction indicator
.a292		20 c5 86	jsr $86c5	                jsr emit_a
.a295		68		pla		                pla
.a296		20 c5 86	jsr $86c5	                jsr emit_a
.a299						_printing_done:
.a299		20 3a 84	jsr $843a	                jsr xt_cr
.a29c		f6 02		inc $02,x	                inc 2,x
.a29e		d0 02		bne $a2a2	                bne +
.a2a0		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.a2a2						+
.a2a2		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; ( addr+1 u-1 )
.a2a5		b5 00		lda $00,x	                lda 0,x                 ; All done?
.a2a7		15 01		ora $01,x	                ora 1,x
.a2a9		f0 07		beq $a2b2	                beq _done
.a2ab		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.a2ad		30 03		bmi $a2b2	                bmi _done
.a2af		4c 88 a1	jmp $a188	                jmp _byte_loop          ; out of range for BRA
.a2b2						_done:
.a2b2		4c a7 93	jmp $93a7	                jmp xt_two_drop         ; JSR/RTS
.a2b5						disasm_sliteral_jump:
.a2b5		20 2e 92	jsr $922e	                jsr xt_swap
.a2b8		ca		dex		                dex
.a2b9		ca		dex		                dex
.a2ba		a5 2e		lda $2e		                lda scratch+1
.a2bc		95 00		sta $00,x	                sta 0,x
.a2be		a5 2f		lda $2f		                lda scratch+2
.a2c0		95 01		sta $01,x	                sta 1,x
.a2c2		20 2e 92	jsr $922e	                jsr xt_swap
.a2c5		20 e4 8b	jsr $8be4	                jsr xt_minus
.a2c8		20 dd 8c	jsr $8cdd	                jsr xt_one_minus
.a2cb		20 e4 8b	jsr $8be4	                jsr xt_minus
.a2ce		ca		dex		                dex
.a2cf		ca		dex		                dex
.a2d0		a5 2e		lda $2e		                lda scratch+1
.a2d2		95 00		sta $00,x	                sta 0,x
.a2d4		a5 2f		lda $2f		                lda scratch+2
.a2d6		95 01		sta $01,x	                sta 1,x
.a2d8		20 dd 8c	jsr $8cdd	                jsr xt_one_minus
.a2db		20 2e 92	jsr $922e	                jsr xt_swap ; ( new_addr new_n )
.a2de		60		rts		                rts
.a2df						disasm_jsr:
.a2df		ca		dex		                dex
.a2e0		ca		dex		                dex
.a2e1		a5 2e		lda $2e		                lda scratch+1
.a2e3		95 00		sta $00,x	                sta 0,x
.a2e5		a5 2f		lda $2f		                lda scratch+2
.a2e7		95 01		sta $01,x	                sta 1,x
.a2e9		20 86 9b	jsr $9b86	                jsr xt_int_to_name
.a2ec		b5 00		lda $00,x	                lda 0,x
.a2ee		15 01		ora $01,x	                ora 1,x
.a2f0		f0 08		beq $a2fa	                beq _no_nt
.a2f2		20 29 9c	jsr $9c29	                jsr xt_name_to_string
.a2f5		20 b7 94	jsr $94b7	                jsr xt_type
.a2f8		38		sec		                sec
.a2f9		60		rts		                rts
.a2fa						_no_nt:
.a2fa		20 a7 93	jsr $93a7	                jsr xt_two_drop
.a2fd		18		clc		                clc
.a2fe		60		rts		                rts
.a2ff						disasm_special:
.a2ff		a0 2c		ldy #$2c	                ldy #(_end_handlers - _special_handlers - 4)
.a301		b9 8d a3	lda $a38d,y	_check:         lda _special_handlers,y
.a304		c5 2e		cmp $2e		                cmp scratch+1
.a306		d0 07		bne $a30f	                bne _next
.a308		b9 8e a3	lda $a38e,y	                lda _special_handlers+1,y
.a30b		c5 2f		cmp $2f		                cmp scratch+2
.a30d		f0 08		beq $a317	                beq _found_handler
.a30f		88		dey		_next:          dey
.a310		88		dey		                dey
.a311		88		dey		                dey
.a312		88		dey		                dey
.a313		10 ec		bpl $a301	                bpl _check
.a315		18		clc		                clc
.a316		60		rts		                rts
.a317						_found_handler:
.a317		a5 32		lda $32		                lda scratch+5               ; are we expecting sliteral?
.a319		f0 04		beq $a31f	                beq +
.a31b		64 32		stz $32		                stz scratch+5               ; yes, skip 2literal and match again
.a31d		80 f0		bra $a30f	                bra _next
.a31f						+
.a31f		b9 90 a3	lda $a390,y	                lda _special_handlers+3,y   ; payload + prefix
.a322		48		pha		                pha                         ; stash a copy for payload later
.a323		4a		lsr a		                lsr
.a324		4a		lsr a		                lsr
.a325		f0 06		beq $a32d	                beq _no_prefix
.a327		18		clc		                clc
.a328		69 20		adc #$20	                adc #32
.a32a		20 c5 86	jsr $86c5	                jsr emit_a
.a32d						_no_prefix:
.a32d		b9 8f a3	lda $a38f,y	                lda _special_handlers+2,y   ; string index
.a330		20 a4 d7	jsr $d7a4	                jsr print_string_no_lf
.a333		68		pla		                pla
.a334		29 03		and #$03	                and #3                      ; payload is 0, 1 or 2 words
.a336		f0 0f		beq $a347	                beq _done
.a338		c9 03		cmp #$03	                cmp #3                      ; but 3 means a double-word
.a33a		d0 03		bne $a33f	                bne _show_payload
.a33c		4c 61 a3	jmp $a361	                jmp _print_2literal
.a33f						_show_payload:
.a33f		48		pha		                pha
.a340		20 49 a3	jsr $a349	                jsr _print_literal
.a343		68		pla		                pla
.a344		3a		dec a		                dea
.a345		d0 f8		bne $a33f	                bne _show_payload
.a347		38		sec		_done:          sec
.a348		60		rts		                rts
.a349						_print_literal:
.a349		20 2e 92	jsr $922e	                jsr xt_swap ; switch to (u addr)
.a34c		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.a34f		20 a0 86	jsr $86a0	                jsr xt_dup
.a352		20 fa 98	jsr $98fa	                jsr xt_question ; Print the value at the address
.a355		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.a358		20 2e 92	jsr $922e	                jsr xt_swap ; (addr+2 u)
.a35b		20 dd 8c	jsr $8cdd	                jsr xt_one_minus
.a35e		4c dd 8c	jmp $8cdd	                jmp xt_one_minus ; (addr+2 u-2)
.a361						_print_2literal:
.a361		20 2e 92	jsr $922e	                jsr xt_swap
.a364		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.a367		20 a0 86	jsr $86a0	                jsr xt_dup
.a36a		20 c7 93	jsr $93c7	                jsr xt_two_fetch
.a36d		20 2e 92	jsr $922e	                jsr xt_swap             ; 2! / 2@ put MSW first; but 2literal writes LSW first
.a370		20 58 9e	jsr $9e58	                jsr xt_d_dot
.a373		18		clc		                clc
.a374		b5 00		lda $00,x	                lda 0,x
.a376		69 03		adc #$03	                adc #3
.a378		95 00		sta $00,x	                sta 0,x
.a37a		90 02		bcc $a37e	                bcc +
.a37c		f6 01		inc $01,x	                inc 1,x
.a37e						+
.a37e		20 2e 92	jsr $922e	                jsr xt_swap ; ( addr+4 u )
.a381		38		sec		                sec
.a382		b5 00		lda $00,x	                lda 0,x
.a384		e9 04		sbc #$04	                sbc #4
.a386		95 00		sta $00,x	                sta 0,x
.a388		b0 02		bcs $a38c	                bcs +
.a38a		d6 01		dec $01,x	                dec 1,x
.a38c						+
.a38c		60		rts		                rts
.a38d						_special_handlers:
>a38d		68 d7				    .word underflow_1
>a38f		0c 44				        .byte str_disasm_sdc, 0 + ('1'-32)*4
>a391		6d d7				    .word underflow_2
>a393		0c 48				        .byte str_disasm_sdc, 0 + ('2'-32)*4
>a395		72 d7				    .word underflow_3
>a397		0c 4c				        .byte str_disasm_sdc, 0 + ('3'-32)*4
>a399		77 d7				    .word underflow_4
>a39b		0c 50				        .byte str_disasm_sdc, 0 + ('4'-32)*4
>a39d		3a 8a				    .word literal_runtime
>a39f		0d 01				        .byte str_disasm_lit, 1
>a3a1		54 a1				    .word sliteral_runtime
>a3a3		0d ce				        .byte str_disasm_lit, 2 + ('S'-32)*4
>a3a5		54 a1				    .word sliteral_runtime                      ; 2literal and sliteral use the same runtime
>a3a7		0d 4b				        .byte str_disasm_lit, 3 + ('2'-32)*4    ; list is searched in reverse, put 2literal first
>a3a9		0c 98				    .word zero_branch_runtime
>a3ab		0e 01				        .byte str_disasm_0bra, 1
>a3ad		d2 8a				    .word loop_runtime
>a3af		0f 01				        .byte str_disasm_loop, 1
>a3b1		eb 8a				    .word plus_loop_runtime
>a3b3		0f 2d				        .byte str_disasm_loop, 1 + ('+'-32)*4
>a3b5		bc 85				    .word do_runtime
>a3b7		10 00				        .byte str_disasm_do, 0
>a3b9		a4 85				    .word question_do_runtime
>a3bb		10 7d				        .byte str_disasm_do, 1 + ('?'-32)*4
.a3bd						_end_handlers:
.a3bd						disassembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/assembler.asm

.a3bd						assembler:
.a3bd						xt_asm_adc_h:
.a3bd		a9 69		lda #$69	                lda #$69
.a3bf		4c 18 a7	jmp $a718	                jmp asm_common
.a3c2						z_asm_adc_h:
.a3c2						xt_asm_adc_x:
.a3c2		a9 7d		lda #$7d	                lda #$7D
.a3c4		4c 18 a7	jmp $a718	                jmp asm_common
.a3c7						z_asm_adc_x:
.a3c7						xt_asm_adc_y:
.a3c7		a9 79		lda #$79	                lda #$79
.a3c9		4c 18 a7	jmp $a718	                jmp asm_common
.a3cc						z_asm_adc_y:
.a3cc						xt_asm_adc_z:
.a3cc		a9 65		lda #$65	                lda #$65
.a3ce		4c 18 a7	jmp $a718	                jmp asm_common
.a3d1						z_asm_adc_z:
.a3d1						xt_asm_adc_zi:
.a3d1		a9 72		lda #$72	                lda #$72
.a3d3		4c 18 a7	jmp $a718	                jmp asm_common
.a3d6						z_asm_adc_zi:
.a3d6						xt_asm_adc_ziy:
.a3d6		a9 71		lda #$71	                lda #$71
.a3d8		4c 18 a7	jmp $a718	                jmp asm_common
.a3db						z_asm_adc_ziy:
.a3db						xt_asm_adc_zx:
.a3db		a9 75		lda #$75	                lda #$75
.a3dd		4c 18 a7	jmp $a718	                jmp asm_common
.a3e0						z_asm_adc_zx:
.a3e0						xt_asm_adc_zxi:
.a3e0		a9 61		lda #$61	                lda #$61
.a3e2		4c 18 a7	jmp $a718	                jmp asm_common
.a3e5						z_asm_adc_zxi:
.a3e5						xt_asm_and:
.a3e5		a9 2d		lda #$2d	                lda #$2D
.a3e7		4c 18 a7	jmp $a718	                jmp asm_common
.a3ea						z_asm_and:
.a3ea						xt_asm_and_h:
.a3ea		a9 29		lda #$29	                lda #$29
.a3ec		4c 18 a7	jmp $a718	                jmp asm_common
.a3ef						z_asm_and_h:
.a3ef						xt_asm_and_x:
.a3ef		a9 3d		lda #$3d	                lda #$3D
.a3f1		4c 18 a7	jmp $a718	                jmp asm_common
.a3f4						z_asm_and_x:
.a3f4						xt_asm_and_y:
.a3f4		a9 39		lda #$39	                lda #$39
.a3f6		4c 18 a7	jmp $a718	                jmp asm_common
.a3f9						z_asm_and_y:
.a3f9						xt_asm_and_z:
.a3f9		a9 25		lda #$25	                lda #$25
.a3fb		4c 18 a7	jmp $a718	                jmp asm_common
.a3fe						z_asm_and_z:
.a3fe						xt_asm_and_zi:
.a3fe		a9 32		lda #$32	                lda #$32
.a400		4c 18 a7	jmp $a718	                jmp asm_common
.a403						z_asm_and_zi:
.a403						xt_asm_and_ziy:
.a403		a9 31		lda #$31	                lda #$31
.a405		4c 18 a7	jmp $a718	                jmp asm_common
.a408						z_asm_and_ziy:
.a408						xt_asm_and_zx:
.a408		a9 35		lda #$35	                lda #$35
.a40a		4c 18 a7	jmp $a718	                jmp asm_common
.a40d						z_asm_and_zx:
.a40d						xt_asm_and_zxi:
.a40d		a9 21		lda #$21	                lda #$21
.a40f		4c 18 a7	jmp $a718	                jmp asm_common
.a412						z_asm_and_zxi:
.a412						xt_asm_asl:
.a412		a9 0e		lda #$0e	                lda #$0E
.a414		4c 18 a7	jmp $a718	                jmp asm_common
.a417						z_asm_asl:
.a417						xt_asm_asl_a:
.a417		a9 0a		lda #$0a	                lda #$0A
.a419		4c 18 a7	jmp $a718	                jmp asm_common
.a41c						z_asm_asl_a:
.a41c						xt_asm_asl_x:
.a41c		a9 1e		lda #$1e	                lda #$1E
.a41e		4c 18 a7	jmp $a718	                jmp asm_common
.a421						z_asm_asl_x:
.a421						xt_asm_asl_z:
.a421		a9 06		lda #$06	                lda #$06
.a423		4c 18 a7	jmp $a718	                jmp asm_common
.a426						z_asm_asl_z:
.a426						xt_asm_asl_zx:
.a426		a9 16		lda #$16	                lda #$16
.a428		4c 18 a7	jmp $a718	                jmp asm_common
.a42b						z_asm_asl_zx:
.a42b						xt_asm_bcc:
.a42b		a9 90		lda #$90	                lda #$90
.a42d		4c 18 a7	jmp $a718	                jmp asm_common
.a430						z_asm_bcc:
.a430						xt_asm_bcs:
.a430		a9 b0		lda #$b0	                lda #$B0
.a432		a0 02		ldy #$02	                ldy #2
.a434		4c 18 a7	jmp $a718	                jmp asm_common
.a437						z_asm_bcs:
.a437						xt_asm_beq:
.a437		a9 f0		lda #$f0	                lda #$F0
.a439		4c 18 a7	jmp $a718	                jmp asm_common
.a43c						z_asm_beq:
.a43c						xt_asm_bit:
.a43c		a9 2c		lda #$2c	                lda #$2C
.a43e		4c 18 a7	jmp $a718	                jmp asm_common
.a441						z_asm_bit:
.a441						xt_asm_bit_h:
.a441		a9 89		lda #$89	                lda #$89
.a443		4c 18 a7	jmp $a718	                jmp asm_common
.a446						z_asm_bit_h:
.a446						xt_asm_bit_x:
.a446		a9 3c		lda #$3c	                lda #$3C
.a448		4c 18 a7	jmp $a718	                jmp asm_common
.a44b						z_asm_bit_x:
.a44b						xt_asm_bit_z:
.a44b		a9 24		lda #$24	                lda #$24
.a44d		4c 18 a7	jmp $a718	                jmp asm_common
.a450						z_asm_bit_z:
.a450						xt_asm_bit_zx:
.a450		a9 34		lda #$34	                lda #$34
.a452		4c 18 a7	jmp $a718	                jmp asm_common
.a455						z_asm_bit_zx:
.a455						xt_asm_bmi:
.a455		a9 30		lda #$30	                lda #$30
.a457		4c 18 a7	jmp $a718	                jmp asm_common
.a45a						z_asm_bmi:
.a45a						xt_asm_bne:
.a45a		a9 d0		lda #$d0	                lda #$D0
.a45c		4c 18 a7	jmp $a718	                jmp asm_common
.a45f						z_asm_bne:
.a45f						xt_asm_bpl:
.a45f		a9 10		lda #$10	                lda #$10
.a461		4c 18 a7	jmp $a718	                jmp asm_common
.a464						z_asm_bpl:
.a464						xt_asm_bra:
.a464		a9 80		lda #$80	                lda #$80
.a466		4c 18 a7	jmp $a718	                jmp asm_common
.a469						z_asm_bra:
.a469						xt_asm_brk:
.a469		a9 00		lda #$00	                lda #$00
.a46b		4c 18 a7	jmp $a718	                jmp asm_common
.a46e						z_asm_brk:
.a46e						xt_asm_bvc:
.a46e		a9 50		lda #$50	                lda #$50
.a470		4c 18 a7	jmp $a718	                jmp asm_common
.a473						z_asm_bvc:
.a473						xt_asm_bvs:
.a473		a9 70		lda #$70	                lda #$70
.a475		4c 18 a7	jmp $a718	                jmp asm_common
.a478						z_asm_bvs:
.a478						xt_asm_clc:
.a478		a9 18		lda #$18	                lda #$18
.a47a		4c 18 a7	jmp $a718	                jmp asm_common
.a47d						z_asm_clc:
.a47d						xt_asm_cld:
.a47d		a9 d8		lda #$d8	                lda #$D8
.a47f		4c 18 a7	jmp $a718	                jmp asm_common
.a482						z_asm_cld:
.a482						xt_asm_cli:
.a482		a9 58		lda #$58	                lda #$58
.a484		4c 18 a7	jmp $a718	                jmp asm_common
.a487						z_asm_cli:
.a487						xt_asm_clv:
.a487		a9 b8		lda #$b8	                lda #$B8
.a489		4c 18 a7	jmp $a718	                jmp asm_common
.a48c						z_asm_clv:
.a48c						xt_asm_cmp:
.a48c		a9 cd		lda #$cd	                lda #$CD
.a48e		4c 18 a7	jmp $a718	                jmp asm_common
.a491						z_asm_cmp:
.a491						xt_asm_cmp_h:
.a491		a9 c9		lda #$c9	                lda #$C9
.a493		4c 18 a7	jmp $a718	                jmp asm_common
.a496						z_asm_cmp_h:
.a496						xt_asm_cmp_x:
.a496		a9 dd		lda #$dd	                lda #$DD
.a498		4c 18 a7	jmp $a718	                jmp asm_common
.a49b						z_asm_cmp_x:
.a49b						xt_asm_cmp_y:
.a49b		a9 d9		lda #$d9	                lda #$D9
.a49d		4c 18 a7	jmp $a718	                jmp asm_common
.a4a0						z_asm_cmp_y:
.a4a0						xt_asm_cmp_z:
.a4a0		a9 c5		lda #$c5	                lda #$C5
.a4a2		4c 18 a7	jmp $a718	                jmp asm_common
.a4a5						z_asm_cmp_z:
.a4a5						xt_asm_cmp_zi:
.a4a5		a9 d2		lda #$d2	                lda #$D2
.a4a7		4c 18 a7	jmp $a718	                jmp asm_common
.a4aa						z_asm_cmp_zi:
.a4aa						xt_asm_cmp_ziy:
.a4aa		a9 d1		lda #$d1	                lda #$D1
.a4ac		4c 18 a7	jmp $a718	                jmp asm_common
.a4af						z_asm_cmp_ziy:
.a4af						xt_asm_cmp_zx:
.a4af		a9 d5		lda #$d5	                lda #$D5
.a4b1		4c 18 a7	jmp $a718	                jmp asm_common
.a4b4						z_asm_cmp_zx:
.a4b4						xt_asm_cmp_zxi:
.a4b4		a9 c1		lda #$c1	                lda #$C1
.a4b6		4c 18 a7	jmp $a718	                jmp asm_common
.a4b9						z_asm_cmp_zxi:
.a4b9						xt_asm_cpx:
.a4b9		a9 ec		lda #$ec	                lda #$EC
.a4bb		4c 18 a7	jmp $a718	                jmp asm_common
.a4be						z_asm_cpx:
.a4be						xt_asm_cpx_h:
.a4be		a9 e0		lda #$e0	                lda #$E0
.a4c0		4c 18 a7	jmp $a718	                jmp asm_common
.a4c3						z_asm_cpx_h:
.a4c3						xt_asm_cpx_z:
.a4c3		a9 e4		lda #$e4	                lda #$E4
.a4c5		4c 18 a7	jmp $a718	                jmp asm_common
.a4c8						z_asm_cpx_z:
.a4c8						xt_asm_cpy:
.a4c8		a9 cc		lda #$cc	                lda #$CC
.a4ca		a0 03		ldy #$03	                ldy #3
.a4cc		4c 18 a7	jmp $a718	                jmp asm_common
.a4cf						z_asm_cpy:
.a4cf						xt_asm_cpy_h:
.a4cf		a9 c0		lda #$c0	                lda #$C0
.a4d1		4c 18 a7	jmp $a718	                jmp asm_common
.a4d4						z_asm_cpy_h:
.a4d4						xt_asm_cpy_z:
.a4d4		a9 c4		lda #$c4	                lda #$C4
.a4d6		4c 18 a7	jmp $a718	                jmp asm_common
.a4d9						z_asm_cpy_z:
.a4d9						xt_asm_dec:
.a4d9		a9 ce		lda #$ce	                lda #$CE
.a4db		4c 18 a7	jmp $a718	                jmp asm_common
.a4de						z_asm_dec:
.a4de						xt_asm_dec_a:
.a4de		a9 3a		lda #$3a	                lda #$3A
.a4e0		4c 18 a7	jmp $a718	                jmp asm_common
.a4e3						z_asm_dec_a:
.a4e3						xt_asm_dec_x:
.a4e3		a9 de		lda #$de	                lda #$DE
.a4e5		4c 18 a7	jmp $a718	                jmp asm_common
.a4e8						z_asm_dec_x:
.a4e8						xt_asm_dec_z:
.a4e8		a9 c6		lda #$c6	                lda #$C6
.a4ea		4c 18 a7	jmp $a718	                jmp asm_common
.a4ed						z_asm_dec_z:
.a4ed						xt_asm_dec_zx:
.a4ed		a9 d6		lda #$d6	                lda #$D6
.a4ef		4c 18 a7	jmp $a718	                jmp asm_common
.a4f2						z_asm_dec_zx:
.a4f2						xt_asm_dex:
.a4f2		a9 ca		lda #$ca	                lda #$CA
.a4f4		4c 18 a7	jmp $a718	                jmp asm_common
.a4f7						z_asm_dex:
.a4f7						xt_asm_dey:
.a4f7		a9 88		lda #$88	                lda #$88
.a4f9		4c 18 a7	jmp $a718	                jmp asm_common
.a4fc						z_asm_dey:
.a4fc						xt_asm_eor:
.a4fc		a9 4d		lda #$4d	                lda #$4D
.a4fe		4c 18 a7	jmp $a718	                jmp asm_common
.a501						z_asm_eor:
.a501						xt_asm_eor_h:
.a501		a9 49		lda #$49	                lda #$49
.a503		4c 18 a7	jmp $a718	                jmp asm_common
.a506						z_asm_eor_h:
.a506						xt_asm_eor_x:
.a506		a9 5d		lda #$5d	                lda #$5D
.a508		4c 18 a7	jmp $a718	                jmp asm_common
.a50b						z_asm_eor_x:
.a50b						xt_asm_eor_y:
.a50b		a9 59		lda #$59	                lda #$59
.a50d		4c 18 a7	jmp $a718	                jmp asm_common
.a510						z_asm_eor_y:
.a510						xt_asm_eor_z:
.a510		a9 45		lda #$45	                lda #$45
.a512		4c 18 a7	jmp $a718	                jmp asm_common
.a515						z_asm_eor_z:
.a515						xt_asm_eor_zi:
.a515		a9 52		lda #$52	                lda #$52
.a517		4c 18 a7	jmp $a718	                jmp asm_common
.a51a						z_asm_eor_zi:
.a51a						xt_asm_eor_ziy:
.a51a		a9 51		lda #$51	                lda #$51
.a51c		4c 18 a7	jmp $a718	                jmp asm_common
.a51f						z_asm_eor_ziy:
.a51f						xt_asm_eor_zx:
.a51f		a9 55		lda #$55	                lda #$55
.a521		4c 18 a7	jmp $a718	                jmp asm_common
.a524						z_asm_eor_zx:
.a524						xt_asm_eor_zxi:
.a524		a9 41		lda #$41	                lda #$41
.a526		4c 18 a7	jmp $a718	                jmp asm_common
.a529						z_asm_eor_zxi:
.a529						xt_asm_inc:
.a529		a9 ee		lda #$ee	                lda #$EE
.a52b		4c 18 a7	jmp $a718	                jmp asm_common
.a52e						z_asm_inc:
.a52e						xt_asm_inc_a:
.a52e		a9 1a		lda #$1a	                lda #$1A
.a530		4c 18 a7	jmp $a718	                jmp asm_common
.a533						z_asm_inc_a:
.a533						xt_asm_inc_x:
.a533		a9 fe		lda #$fe	                lda #$FE
.a535		4c 18 a7	jmp $a718	                jmp asm_common
.a538						z_asm_inc_x:
.a538						xt_asm_inc_z:
.a538		a9 e6		lda #$e6	                lda #$E6
.a53a		4c 18 a7	jmp $a718	                jmp asm_common
.a53d						z_asm_inc_z:
.a53d						xt_asm_inc_zx:
.a53d		a9 f6		lda #$f6	                lda #$F6
.a53f		4c 18 a7	jmp $a718	                jmp asm_common
.a542						z_asm_inc_zx:
.a542						xt_asm_inx:
.a542		a9 e8		lda #$e8	                lda #$E8
.a544		4c 18 a7	jmp $a718	                jmp asm_common
.a547						z_asm_inx:
.a547						xt_asm_iny:
.a547		a9 c8		lda #$c8	                lda #$C8
.a549		4c 18 a7	jmp $a718	                jmp asm_common
.a54c						z_asm_iny:
.a54c						xt_asm_jmp:
.a54c		a9 4c		lda #$4c	                lda #$4C
.a54e		4c 18 a7	jmp $a718	                jmp asm_common
.a551						z_asm_jmp:
.a551						xt_asm_jmp_i:
.a551		a9 6c		lda #$6c	                lda #$6C
.a553		4c 18 a7	jmp $a718	                jmp asm_common
.a556						z_asm_jmp_i:
.a556						xt_asm_jmp_xi:
.a556		a9 7c		lda #$7c	                lda #$7C
.a558		4c 18 a7	jmp $a718	                jmp asm_common
.a55b						z_asm_jmp_xi:
.a55b						xt_asm_jsr:
.a55b		a9 20		lda #$20	                lda #$20
.a55d		4c 18 a7	jmp $a718	                jmp asm_common
.a560						z_asm_jsr:
.a560						xt_asm_lda:
.a560		a9 ad		lda #$ad	                lda #$AD
.a562		4c 18 a7	jmp $a718	                jmp asm_common
.a565						z_asm_lda:
.a565						xt_asm_lda_h:
.a565		a9 a9		lda #$a9	                lda #$A9
.a567		4c 18 a7	jmp $a718	                jmp asm_common
.a56a						z_asm_lda_h:
.a56a						xt_asm_lda_x:
.a56a		a9 bd		lda #$bd	                lda #$BD
.a56c		4c 18 a7	jmp $a718	                jmp asm_common
.a56f						z_asm_lda_x:
.a56f						xt_asm_lda_y:
.a56f		a9 b9		lda #$b9	                lda #$B9
.a571		4c 18 a7	jmp $a718	                jmp asm_common
.a574						z_asm_lda_y:
.a574						xt_asm_lda_z:
.a574		a9 a5		lda #$a5	                lda #$A5
.a576		4c 18 a7	jmp $a718	                jmp asm_common
.a579						z_asm_lda_z:
.a579						xt_asm_lda_zi:
.a579		a9 b2		lda #$b2	                lda #$B2
.a57b		4c 18 a7	jmp $a718	                jmp asm_common
.a57e						z_asm_lda_zi:
.a57e						xt_asm_lda_ziy:
.a57e		a9 b1		lda #$b1	                lda #$B1
.a580		4c 18 a7	jmp $a718	                jmp asm_common
.a583						z_asm_lda_ziy:
.a583						xt_asm_lda_zx:
.a583		a9 b5		lda #$b5	                lda #$B5
.a585		4c 18 a7	jmp $a718	                jmp asm_common
.a588						z_asm_lda_zx:
.a588						xt_asm_lda_zxi:
.a588		a9 a1		lda #$a1	                lda #$A1
.a58a		4c 18 a7	jmp $a718	                jmp asm_common
.a58d						z_asm_lda_zxi:
.a58d						xt_asm_ldx:
.a58d		a9 ae		lda #$ae	                lda #$AE
.a58f		4c 18 a7	jmp $a718	                jmp asm_common
.a592						z_asm_ldx:
.a592						xt_asm_ldx_h:
.a592		a9 a2		lda #$a2	                lda #$A2
.a594		4c 18 a7	jmp $a718	                jmp asm_common
.a597						z_asm_ldx_h:
.a597						xt_asm_ldx_y:
.a597		a9 be		lda #$be	                lda #$BE
.a599		4c 18 a7	jmp $a718	                jmp asm_common
.a59c						z_asm_ldx_y:
.a59c						xt_asm_ldx_z:
.a59c		a9 a6		lda #$a6	                lda #$A6
.a59e		4c 18 a7	jmp $a718	                jmp asm_common
.a5a1						z_asm_ldx_z:
.a5a1						xt_asm_ldx_zy:
.a5a1		a9 b6		lda #$b6	                lda #$B6
.a5a3		4c 18 a7	jmp $a718	                jmp asm_common
.a5a6						z_asm_ldx_zy:
.a5a6						xt_asm_ldy:
.a5a6		a9 ac		lda #$ac	                lda #$AC
.a5a8		4c 18 a7	jmp $a718	                jmp asm_common
.a5ab						z_asm_ldy:
.a5ab						xt_asm_ldy_h:
.a5ab		a9 a0		lda #$a0	                lda #$A0
.a5ad		4c 18 a7	jmp $a718	                jmp asm_common
.a5b0						z_asm_ldy_h:
.a5b0						xt_asm_ldy_x:
.a5b0		a9 bc		lda #$bc	                lda #$BC
.a5b2		4c 18 a7	jmp $a718	                jmp asm_common
.a5b5						z_asm_ldy_x:
.a5b5						xt_asm_ldy_z:
.a5b5		a9 a4		lda #$a4	                lda #$A4
.a5b7		4c 18 a7	jmp $a718	                jmp asm_common
.a5ba						z_asm_ldy_z:
.a5ba						xt_asm_ldy_zx:
.a5ba		a9 b4		lda #$b4	                lda #$B4
.a5bc		4c 18 a7	jmp $a718	                jmp asm_common
.a5bf						z_asm_ldy_zx:
.a5bf						xt_asm_lsr:
.a5bf		a9 4e		lda #$4e	                lda #$4E
.a5c1		4c 18 a7	jmp $a718	                jmp asm_common
.a5c4						z_asm_lsr:
.a5c4						xt_asm_lsr_a:
.a5c4		a9 4a		lda #$4a	                lda #$4A
.a5c6		4c 18 a7	jmp $a718	                jmp asm_common
.a5c9						z_asm_lsr_a:
.a5c9						xt_asm_lsr_x:
.a5c9		a9 5e		lda #$5e	                lda #$5E
.a5cb		4c 18 a7	jmp $a718	                jmp asm_common
.a5ce						z_asm_lsr_x:
.a5ce						xt_asm_lsr_z:
.a5ce		a9 46		lda #$46	                lda #$46
.a5d0		4c 18 a7	jmp $a718	                jmp asm_common
.a5d3						z_asm_lsr_z:
.a5d3						xt_asm_lsr_zx:
.a5d3		a9 56		lda #$56	                lda #$56
.a5d5		4c 18 a7	jmp $a718	                jmp asm_common
.a5d8						z_asm_lsr_zx:
.a5d8						xt_asm_nop:
.a5d8		a9 ea		lda #$ea	                lda #$EA
.a5da		4c 18 a7	jmp $a718	                jmp asm_common
.a5dd						z_asm_nop:
.a5dd						xt_asm_ora:
.a5dd		a9 0d		lda #$0d	                lda #$0D
.a5df		4c 18 a7	jmp $a718	                jmp asm_common
.a5e2						z_asm_ora:
.a5e2						xt_asm_ora_h:
.a5e2		a9 09		lda #$09	                lda #$09
.a5e4		4c 18 a7	jmp $a718	                jmp asm_common
.a5e7						z_asm_ora_h:
.a5e7						xt_asm_ora_x:
.a5e7		a9 1d		lda #$1d	                lda #$1D
.a5e9		4c 18 a7	jmp $a718	                jmp asm_common
.a5ec						z_asm_ora_x:
.a5ec						xt_asm_ora_y:
.a5ec		a9 19		lda #$19	                lda #$19
.a5ee		4c 18 a7	jmp $a718	                jmp asm_common
.a5f1						z_asm_ora_y:
.a5f1						xt_asm_ora_z:
.a5f1		a9 05		lda #$05	                lda #$05
.a5f3		4c 18 a7	jmp $a718	                jmp asm_common
.a5f6						z_asm_ora_z:
.a5f6						xt_asm_ora_zi:
.a5f6		a9 12		lda #$12	                lda #$12
.a5f8		a0 02		ldy #$02	                ldy #2
.a5fa		4c 18 a7	jmp $a718	                jmp asm_common
.a5fd						z_asm_ora_zi:
.a5fd						xt_asm_ora_ziy:
.a5fd		a9 11		lda #$11	                lda #$11
.a5ff		4c 18 a7	jmp $a718	                jmp asm_common
.a602						z_asm_ora_ziy:
.a602						xt_asm_ora_zx:
.a602		a9 15		lda #$15	                lda #$15
.a604		4c 18 a7	jmp $a718	                jmp asm_common
.a607						z_asm_ora_zx:
.a607						xt_asm_ora_zxi:
.a607		a9 01		lda #$01	                lda #$01
.a609		4c 18 a7	jmp $a718	                jmp asm_common
.a60c						z_asm_ora_zxi:
.a60c						xt_asm_pha:
.a60c		a9 48		lda #$48	                lda #$48
.a60e		4c 18 a7	jmp $a718	                jmp asm_common
.a611						z_asm_pha:
.a611						xt_asm_php:
.a611		a9 08		lda #$08	                lda #$08
.a613		4c 18 a7	jmp $a718	                jmp asm_common
.a616						z_asm_php:
.a616						xt_asm_phx:
.a616		a9 da		lda #$da	                lda #$DA
.a618		4c 18 a7	jmp $a718	                jmp asm_common
.a61b						z_asm_phx:
.a61b						xt_asm_phy:
.a61b		a9 5a		lda #$5a	                lda #$5A
.a61d		4c 18 a7	jmp $a718	                jmp asm_common
.a620						z_asm_phy:
.a620						xt_asm_pla:
.a620		a9 68		lda #$68	                lda #$68
.a622		4c 18 a7	jmp $a718	                jmp asm_common
.a625						z_asm_pla:
.a625						xt_asm_plp:
.a625		a9 28		lda #$28	                lda #$28
.a627		4c 18 a7	jmp $a718	                jmp asm_common
.a62a						z_asm_plp:
.a62a						xt_asm_plx:
.a62a		a9 fa		lda #$fa	                lda #$FA
.a62c		4c 18 a7	jmp $a718	                jmp asm_common
.a62f						z_asm_plx:
.a62f						xt_asm_ply:
.a62f		a9 7a		lda #$7a	                lda #$7A
.a631		4c 18 a7	jmp $a718	                jmp asm_common
.a634						z_asm_ply:
.a634						xt_asm_rol:
.a634		a9 2e		lda #$2e	                lda #$2E
.a636		4c 18 a7	jmp $a718	                jmp asm_common
.a639						z_asm_rol:
.a639						xt_asm_rol_a:
.a639		a9 2a		lda #$2a	                lda #$2A
.a63b		4c 18 a7	jmp $a718	                jmp asm_common
.a63e						z_asm_rol_a:
.a63e						xt_asm_rol_x:
.a63e		a9 3e		lda #$3e	                lda #$3E
.a640		4c 18 a7	jmp $a718	                jmp asm_common
.a643						z_asm_rol_x:
.a643						xt_asm_rol_z:
.a643		a9 26		lda #$26	                lda #$26
.a645		4c 18 a7	jmp $a718	                jmp asm_common
.a648						z_asm_rol_z:
.a648						xt_asm_rol_zx:
.a648		a9 36		lda #$36	                lda #$36
.a64a		4c 18 a7	jmp $a718	                jmp asm_common
.a64d						z_asm_rol_zx:
.a64d						xt_asm_ror:
.a64d		a9 6e		lda #$6e	                lda #$6E
.a64f		4c 18 a7	jmp $a718	                jmp asm_common
.a652						z_asm_ror:
.a652						xt_asm_ror_a:
.a652		a9 6a		lda #$6a	                lda #$6A
.a654		4c 18 a7	jmp $a718	                jmp asm_common
.a657						z_asm_ror_a:
.a657						xt_asm_ror_x:
.a657		a9 7e		lda #$7e	                lda #$7E
.a659		4c 18 a7	jmp $a718	                jmp asm_common
.a65c						z_asm_ror_x:
.a65c						xt_asm_ror_z:
.a65c		a9 66		lda #$66	                lda #$66
.a65e		4c 18 a7	jmp $a718	                jmp asm_common
.a661						z_asm_ror_z:
.a661						xt_asm_ror_zx:
.a661		a9 76		lda #$76	                lda #$76
.a663		4c 18 a7	jmp $a718	                jmp asm_common
.a666						z_asm_ror_zx:
.a666						xt_asm_rti:
.a666		a9 40		lda #$40	                lda #$40
.a668		4c 18 a7	jmp $a718	                jmp asm_common
.a66b						z_asm_rti:
.a66b						xt_asm_rts:
.a66b		a9 60		lda #$60	                lda #$60
.a66d		4c 18 a7	jmp $a718	                jmp asm_common
.a670						z_asm_rts:
.a670						xt_asm_sbc:
.a670		a9 ed		lda #$ed	                lda #$ED
.a672		4c 18 a7	jmp $a718	                jmp asm_common
.a675						z_asm_sbc:
.a675						xt_asm_sbc_h:
.a675		a9 e9		lda #$e9	                lda #$E9
.a677		4c 18 a7	jmp $a718	                jmp asm_common
.a67a						z_asm_sbc_h:
.a67a						xt_asm_sbc_x:
.a67a		a9 fd		lda #$fd	                lda #$FD
.a67c		4c 18 a7	jmp $a718	                jmp asm_common
.a67f						z_asm_sbc_x:
.a67f						xt_asm_sbc_y:
.a67f		a9 f9		lda #$f9	                lda #$F9
.a681		4c 18 a7	jmp $a718	                jmp asm_common
.a684						z_asm_sbc_y:
.a684						xt_asm_sbc_z:
.a684		a9 e5		lda #$e5	                lda #$E5
.a686		4c 18 a7	jmp $a718	                jmp asm_common
.a689						z_asm_sbc_z:
.a689						xt_asm_sbc_zi:
.a689		a9 f2		lda #$f2	                lda #$F2
.a68b		4c 18 a7	jmp $a718	                jmp asm_common
.a68e						z_asm_sbc_zi:
.a68e						xt_asm_sbc_ziy:
.a68e		a9 f1		lda #$f1	                lda #$F1
.a690		4c 18 a7	jmp $a718	                jmp asm_common
.a693						z_asm_sbc_ziy:
.a693						xt_asm_sbc_zx:
.a693		a9 f5		lda #$f5	                lda #$F5
.a695		4c 18 a7	jmp $a718	                jmp asm_common
.a698						z_asm_sbc_zx:
.a698						xt_asm_sbc_zxi:
.a698		a9 e1		lda #$e1	                lda #$E1
.a69a		80 7c		bra $a718	                bra asm_common  ; <-- limit for BRA instead of JMP
.a69c						z_asm_sbc_zxi:
.a69c						xt_asm_sec:
.a69c		a9 38		lda #$38	                lda #$38
.a69e		80 78		bra $a718	                bra asm_common
.a6a0						z_asm_sec:
.a6a0						xt_asm_sed:
.a6a0		a9 f8		lda #$f8	                lda #$F8
.a6a2		80 74		bra $a718	                bra asm_common
.a6a4						z_asm_sed:
.a6a4						xt_asm_sei:
.a6a4		a9 78		lda #$78	                lda #$78
.a6a6		80 70		bra $a718	                bra asm_common
.a6a8						z_asm_sei:
.a6a8						xt_asm_sta:
.a6a8		a9 8d		lda #$8d	                lda #$8D
.a6aa		80 6c		bra $a718	                bra asm_common
.a6ac						z_asm_sta:
.a6ac						xt_asm_sta_x:
.a6ac		a9 9d		lda #$9d	                lda #$9D
.a6ae		80 68		bra $a718	                bra asm_common
.a6b0						z_asm_sta_x:
.a6b0						xt_asm_sta_y:
.a6b0		a9 99		lda #$99	                lda #$99
.a6b2		80 64		bra $a718	                bra asm_common
.a6b4						z_asm_sta_y:
.a6b4						xt_asm_sta_z:
.a6b4		a9 85		lda #$85	                lda #$85
.a6b6		80 60		bra $a718	                bra asm_common
.a6b8						z_asm_sta_z:
.a6b8						xt_asm_sta_zi:
.a6b8		a9 92		lda #$92	                lda #$92
.a6ba		80 5c		bra $a718	                bra asm_common
.a6bc						z_asm_sta_zi:
.a6bc						xt_asm_sta_ziy:
.a6bc		a9 91		lda #$91	                lda #$91
.a6be		80 58		bra $a718	                bra asm_common
.a6c0						z_asm_sta_ziy:
.a6c0						xt_asm_sta_zx:
.a6c0		a9 95		lda #$95	                lda #$95
.a6c2		80 54		bra $a718	                bra asm_common
.a6c4						z_asm_sta_zx:
.a6c4						xt_asm_sta_zxi:
.a6c4		a9 81		lda #$81	                lda #$81
.a6c6		80 50		bra $a718	                bra asm_common
.a6c8						z_asm_sta_zxi:
.a6c8						xt_asm_stx:
.a6c8		a9 8e		lda #$8e	                lda #$8E
.a6ca		80 4c		bra $a718	                bra asm_common
.a6cc						z_asm_stx:
.a6cc						xt_asm_stx_z:
.a6cc		a9 86		lda #$86	                lda #$86
.a6ce		80 48		bra $a718	                bra asm_common
.a6d0						z_asm_stx_z:
.a6d0						xt_asm_stx_zy:
.a6d0		a9 96		lda #$96	                lda #$96
.a6d2		80 44		bra $a718	                bra asm_common
.a6d4						z_asm_stx_zy:
.a6d4						xt_asm_sty:
.a6d4		a9 8c		lda #$8c	                lda #$8C
.a6d6		80 40		bra $a718	                bra asm_common
.a6d8						z_asm_sty:
.a6d8						xt_asm_sty_z:
.a6d8		a9 84		lda #$84	                lda #$84
.a6da		80 3c		bra $a718	                bra asm_common
.a6dc						z_asm_sty_z:
.a6dc						xt_asm_sty_zx:
.a6dc		a9 94		lda #$94	                lda #$94
.a6de		80 38		bra $a718	                bra asm_common
.a6e0						z_asm_sty_zx:
.a6e0						xt_asm_stz:
.a6e0		a9 9c		lda #$9c	                lda #$9C
.a6e2		80 34		bra $a718	                bra asm_common
.a6e4						z_asm_stz:
.a6e4						xt_asm_stz_x:
.a6e4		a9 9e		lda #$9e	                lda #$9E
.a6e6		80 30		bra $a718	                bra asm_common
.a6e8						z_asm_stz_x:
.a6e8						xt_asm_stz_z:
.a6e8		a9 64		lda #$64	                lda #$64
.a6ea		80 2c		bra $a718	                bra asm_common
.a6ec						z_asm_stz_z:
.a6ec						xt_asm_stz_zx:
.a6ec		a9 74		lda #$74	                lda #$74
.a6ee		80 28		bra $a718	                bra asm_common
.a6f0						z_asm_stz_zx:
.a6f0						xt_asm_tax:
.a6f0		a9 aa		lda #$aa	                lda #$AA
.a6f2		80 24		bra $a718	                bra asm_common
.a6f4						z_asm_tax:
.a6f4						xt_asm_tay:
.a6f4		a9 a8		lda #$a8	                lda #$A8
.a6f6		80 20		bra $a718	                bra asm_common
.a6f8						z_asm_tay:
.a6f8						xt_asm_trb:
.a6f8		a9 1c		lda #$1c	                lda #$1C
.a6fa		80 1c		bra $a718	                bra asm_common
.a6fc						z_asm_trb:
.a6fc						xt_asm_trb_z:
.a6fc		a9 14		lda #$14	                lda #$14
.a6fe		80 18		bra $a718	                bra asm_common
.a700						z_asm_trb_z:
.a700						xt_asm_tsb:
.a700		a9 0c		lda #$0c	                lda #$0C
.a702		80 14		bra $a718	                bra asm_common
.a704						z_asm_tsb:
.a704						xt_asm_tsb_z:
.a704		a9 04		lda #$04	                lda #$04
.a706		80 10		bra $a718	                bra asm_common
.a708						z_asm_tsb_z:
.a708						xt_asm_tsx:
.a708		a9 ba		lda #$ba	                lda #$BA
.a70a		80 0c		bra $a718	                bra asm_common
.a70c						z_asm_tsx:
.a70c						xt_asm_txa:
.a70c		a9 8a		lda #$8a	                lda #$8A
.a70e		80 08		bra $a718	                bra asm_common
.a710						z_asm_txa:
.a710						xt_asm_txs:
.a710		a9 9a		lda #$9a	                lda #$9A
.a712		80 04		bra $a718	                bra asm_common
.a714						z_asm_txs:
.a714						xt_asm_tya:
.a714		a9 98		lda #$98	                lda #$98
.a716		80 00		bra $a718	                bra asm_common
.a718						z_asm_tya:
.a718						asm_common:
.a718		a8		tay		                tay
.a719		20 68 97	jsr $9768	                jsr cmpl_a
.a71c		a9 8b		lda #$8b	                lda #<oc_index_table
.a71e		85 27		sta $27		                sta tmp2
.a720		a9 b3		lda #$b3	                lda #>oc_index_table
.a722		85 28		sta $28		                sta tmp2+1
.a724		98		tya		                tya             ; retrieve opcode
.a725		0a		asl a		                asl             ; times two for offset
.a726		90 02		bcc $a72a	                bcc +
.a728		e6 28		inc $28		                inc tmp2+1
.a72a						+
.a72a		a8		tay		                tay             ; use Y as the index
.a72b		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a72d		85 29		sta $29		                sta tmp3
.a72f		c8		iny		                iny
.a730		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a732		85 2a		sta $2a		                sta tmp3+1
.a734		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.a736		2a		rol a		                rol
.a737		2a		rol a		                rol
.a738		2a		rol a		                rol             ; Three times because we go through Carry
.a739		29 03		and #$03	                and #%00000011
.a73b		a8		tay		                tay
.a73c		88		dey		                dey
.a73d		f0 12		beq $a751	                beq _done
.a73f		20 68 d7	jsr $d768	                jsr underflow_1
.a742		b5 00		lda $00,x	                lda 0,x
.a744		20 68 97	jsr $9768	                jsr cmpl_a      ; does not use Y
.a747		88		dey		                dey
.a748		f0 05		beq $a74f	                beq _done_drop
.a74a		b5 01		lda $01,x	                lda 1,x
.a74c		20 68 97	jsr $9768	                jsr cmpl_a      ; Fall through to _done_drop
.a74f						_done_drop:
.a74f		e8		inx		                inx
.a750		e8		inx		                inx             ; Fall through to _done
.a751						_done:
.a751		60		rts		                rts             ; Returns to original caller
.a752						xt_asm_push_a:
.a752		a0 00		ldy #$00	                ldy #0
.a754						_loop:
.a754		b9 62 a7	lda $a762,y	                lda asm_push_a_data,y
.a757		c9 ff		cmp #$ff	                cmp #$FF
.a759		f0 06		beq $a761	                beq _done
.a75b		20 68 97	jsr $9768	                jsr cmpl_a      ; does not change Y
.a75e		c8		iny		                iny
.a75f		80 f3		bra $a754	                bra _loop
.a761						_done:
.a761						z_asm_push_a:
.a761		60		rts		                rts
.a762						asm_push_a_data:
>a762		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>a768		ff				        .byte $FF               ; terminator
.a769						xt_asm_back_jump:
.a769						z_asm_back_jump:
.a769		60		rts		                rts
.a76a						xt_asm_back_branch:
.a76a		20 1b 89	jsr $891b	                jsr xt_here             ; ( addr-l addr-h )
.a76d		20 e4 8b	jsr $8be4	                jsr xt_minus            ; ( offset )
.a770		3a		dec a		                dea
.a771		3a		dec a		                dea
.a772						z_asm_back_branch:
.a772		60		rts		                rts
.a773						assembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/ed.asm

.a773						xt_ed:
.a773		20 77 a7	jsr $a777	                jsr ed6502      ; kept in separate file
.a776		60		rts		z_ed:           rts
=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.a777						ed6502:
.a777		a5 18		lda $18		                lda base
.a779		85 3a		sta $3a		                sta ed_base
.a77b		a9 0a		lda #$0a	                lda #10
.a77d		85 18		sta $18		                sta base
.a77f		64 35		stz $35		                stz ed_head
.a781		64 36		stz $36		                stz ed_head+1
.a783		64 37		stz $37		                stz ed_cur
.a785		64 38		stz $38		                stz ed_cur+1
.a787		64 39		stz $39		                stz ed_flags
.a789		20 cf 9d	jsr $9dcf	                jsr xt_zero
.a78c		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; ( addr-t u-t )
.a78f		20 3a 84	jsr $843a	                jsr xt_cr
.a792						ed_input_loop:
.a792		a9 81		lda #$81	                lda #%10000001
.a794		14 39		trb $39		                trb ed_flags
.a796		20 71 ac	jsr $ac71	                jsr ed_get_input
.a799		a5 0e		lda $0e		                lda ciblen
.a79b		d0 1f		bne $a7bc	                bne _command_mode
.a79d		ca		dex		                dex
.a79e		ca		dex		                dex                     ; ( addr-t u-t ? )
.a79f		a5 37		lda $37		                lda ed_cur
.a7a1		95 00		sta $00,x	                sta 0,x
.a7a3		a5 38		lda $38		                lda ed_cur+1
.a7a5		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.a7a7		a9 80		lda #$80	                lda #%10000000
.a7a9		04 39		tsb $39		                tsb ed_flags
.a7ab		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.a7ae		20 8d ac	jsr $ac8d	                jsr ed_is_valid_line
.a7b1		b0 03		bcs $a7b6	                bcs +
.a7b3		4c 61 ac	jmp $ac61	                jmp ed_error_1drop
.a7b6						+
.a7b6		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.a7b9		4c 87 a8	jmp $a887	                jmp _line_number_only_from_external
.a7bc						_command_mode:
.a7bc		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.a7bf		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.a7c2		b2 0c		lda ($0c)	                lda (cib)
.a7c4		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.a7c6		d0 3a		bne $a802	                bne _prefix_dollar
.a7c8		20 82 ac	jsr $ac82	                jsr ed_have_text
.a7cb		a5 37		lda $37		                lda ed_cur
.a7cd		95 02		sta $02,x	                sta 2,x
.a7cf		a5 38		lda $38		                lda ed_cur+1
.a7d1		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a7d3		a9 80		lda #$80	                lda #%10000000
.a7d5		04 39		tsb $39		                tsb ed_flags
.a7d7		a5 0e		lda $0e		                lda ciblen
.a7d9		3a		dec a		                dea                     ; sets Z if A was 1
.a7da		d0 03		bne $a7df	                bne +
.a7dc		4c 87 a8	jmp $a887	                jmp _line_number_only_from_external
.a7df						+
.a7df		ca		dex		                dex
.a7e0		ca		dex		                dex
.a7e1		ca		dex		                dex
.a7e2		ca		dex		                dex
.a7e3		a5 0c		lda $0c		                lda cib
.a7e5		95 02		sta $02,x	                sta 2,x
.a7e7		a5 0d		lda $0d		                lda cib+1
.a7e9		95 03		sta $03,x	                sta 3,x
.a7eb		a5 0e		lda $0e		                lda ciblen
.a7ed		95 00		sta $00,x	                sta 0,x
.a7ef		a5 0f		lda $0f		                lda ciblen+1
.a7f1		95 01		sta $01,x	                sta 1,x
.a7f3		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.a7f6		20 2e 92	jsr $922e	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.a7f9		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.a7fc		20 2e 92	jsr $922e	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.a7ff		4c df a8	jmp $a8df	                jmp _check_for_para2
.a802						_prefix_dollar:
.a802		b2 0c		lda ($0c)	                lda (cib)
.a804		c9 24		cmp #$24	                cmp #'$'
.a806		d0 1c		bne $a824	                bne _prefix_percent
.a808		20 82 ac	jsr $ac82	                jsr ed_have_text
.a80b		e8		inx		                inx
.a80c		e8		inx		                inx                     ; ( addr-t u-t 0 )
.a80d		20 af ac	jsr $acaf	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.a810		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.a813		a9 80		lda #$80	                lda #%10000000
.a815		04 39		tsb $39		                tsb ed_flags
.a817		a5 0e		lda $0e		                lda ciblen
.a819		3a		dec a		                dea                     ; sets Z if A was 1
.a81a		d0 03		bne $a81f	                bne +
.a81c		4c 87 a8	jmp $a887	                jmp _line_number_only_from_external
.a81f						+
.a81f		a0 01		ldy #$01	                ldy #01
.a821		4c 5b a9	jmp $a95b	                jmp _check_command
.a824						_prefix_percent:
.a824		b2 0c		lda ($0c)	                lda (cib)
.a826		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.a828		f0 04		beq $a82e	                beq _whole_text
.a82a		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.a82c		d0 17		bne $a845	                bne _prefix_semicolon
.a82e						_whole_text:
.a82e		20 82 ac	jsr $ac82	                jsr ed_have_text
.a831		a9 01		lda #$01	                lda #01
.a833		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.a835		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.a837						_semicolon_entry:
.a837		e8		inx		                inx
.a838		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.a839		20 af ac	jsr $acaf	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a83c		a9 80		lda #$80	                lda #%10000000
.a83e		04 39		tsb $39		                tsb ed_flags
.a840		a0 01		ldy #$01	                ldy #01
.a842		4c 5b a9	jmp $a95b	                jmp _check_command
.a845						_prefix_semicolon:
.a845		b2 0c		lda ($0c)	                lda (cib)
.a847		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.a849		d0 0d		bne $a858	                bne _prefix_number
.a84b		20 82 ac	jsr $ac82	                jsr ed_have_text
.a84e		a5 37		lda $37		                lda ed_cur
.a850		95 02		sta $02,x	                sta 2,x
.a852		a5 38		lda $38		                lda ed_cur+1
.a854		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a856		80 df		bra $a837	                bra _semicolon_entry
.a858						_prefix_number:
.a858		20 cf 9d	jsr $9dcf	                jsr xt_zero
.a85b		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.a85e		ca		dex		                dex
.a85f		ca		dex		                dex
.a860		ca		dex		                dex
.a861		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.a862		a5 0c		lda $0c		                lda cib
.a864		95 02		sta $02,x	                sta 2,x
.a866		a5 0d		lda $0d		                lda cib+1
.a868		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.a86a		a5 0e		lda $0e		                lda ciblen
.a86c		95 00		sta $00,x	                sta 0,x
.a86e		a5 0f		lda $0f		                lda ciblen+1
.a870		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.a872		20 cc 92	jsr $92cc	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.a875		b5 00		lda $00,x	                lda 0,x
.a877		15 01		ora $01,x	                ora 1,x
.a879		d0 24		bne $a89f	                bne _have_unconverted_chars
.a87b		e8		inx		                inx
.a87c		e8		inx		                inx
.a87d		e8		inx		                inx
.a87e		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.a87f		20 18 9e	jsr $9e18	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.a882		20 53 9c	jsr $9c53	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.a885		e8		inx		                inx
.a886		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.a887						_line_number_only_from_external:
.a887		20 2e 92	jsr $922e	                jsr xt_swap             ; ( addr-t u-t 0 u )
.a88a		20 8d ac	jsr $ac8d	                jsr ed_is_valid_line
.a88d		b0 03		bcs $a892	                bcs +
.a88f		4c 5f ac	jmp $ac5f	                jmp ed_error_2drop
.a892						+
.a892		20 2e 92	jsr $922e	                jsr xt_swap             ; ( addr-t u-t u 0 )
.a895		20 1c ad	jsr $ad1c	                jsr ed_para1_to_cur
.a898		a9 80		lda #$80	                lda #%10000000
.a89a		04 39		tsb $39		                tsb ed_flags
.a89c		4c 3a ab	jmp $ab3a	                jmp ed_cmd_p_from_external
.a89f						_have_unconverted_chars:
.a89f		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.a8a2		ca		dex		                dex
.a8a3		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.a8a4		a5 0e		lda $0e		                lda ciblen
.a8a6		95 00		sta $00,x	                sta 0,x
.a8a8		a5 0f		lda $0f		                lda ciblen+1
.a8aa		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.a8ac		20 96 87	jsr $8796	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.a8af		b5 00		lda $00,x	                lda 0,x
.a8b1		15 01		ora $01,x	                ora 1,x
.a8b3		f0 0e		beq $a8c3	                beq _no_command_yet
.a8b5		8a		txa		                txa
.a8b6		18		clc		                clc
.a8b7		69 0a		adc #$0a	                adc #10
.a8b9		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.a8ba		a9 80		lda #$80	                lda #%10000000
.a8bc		14 39		trb $39		                trb ed_flags
.a8be		a0 00		ldy #$00	                ldy #00
.a8c0		4c 5b a9	jmp $a95b	                jmp _check_command
.a8c3						_no_command_yet:
.a8c3		e8		inx		                inx
.a8c4		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.a8c5		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.a8c8		20 53 9c	jsr $9c53	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.a8cb		20 18 9e	jsr $9e18	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.a8ce		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a8d0		95 06		sta $06,x	                sta 6,x
.a8d2		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a8d4		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.a8d6		e8		inx		                inx
.a8d7		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.a8d8		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.a8db		a9 80		lda #$80	                lda #%10000000
.a8dd		04 39		tsb $39		                tsb ed_flags
.a8df						_check_for_para2:
.a8df		a1 02		lda ($02,x)	                lda (2,x)
.a8e1		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.a8e3		f0 0d		beq $a8f2	                beq _got_comma
.a8e5		38		sec		                sec
.a8e6		a5 0e		lda $0e		                lda ciblen
.a8e8		f5 00		sbc $00,x	                sbc 0,x
.a8ea		a8		tay		                tay
.a8eb		e8		inx		                inx
.a8ec		e8		inx		                inx
.a8ed		e8		inx		                inx
.a8ee		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.a8ef		4c 5b a9	jmp $a95b	                jmp _check_command
.a8f2						_got_comma:
.a8f2		f6 02		inc $02,x	                inc 2,x
.a8f4		d0 02		bne $a8f8	                bne +
.a8f6		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.a8f8						+
.a8f8		b5 01		lda $01,x	                lda 1,x
.a8fa		f0 02		beq $a8fe	                beq +
.a8fc		d6 01		dec $01,x	                dec 1,x
.a8fe						+
.a8fe		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.a900		a1 02		lda ($02,x)	                lda (2,x)
.a902		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.a904		d0 14		bne $a91a	                bne _para2_not_dollar
.a906		38		sec		                sec
.a907		a5 0e		lda $0e		                lda ciblen
.a909		f5 02		sbc $02,x	                sbc 2,x
.a90b		a8		tay		                tay
.a90c		c8		iny		                iny
.a90d		5a		phy		                phy
.a90e		8a		txa		                txa
.a90f		18		clc		                clc
.a910		69 06		adc #$06	                adc #06
.a912		aa		tax		                tax                     ; ( addr-t u-t para1 )
.a913		20 af ac	jsr $acaf	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a916		7a		ply		                ply
.a917		4c 5b a9	jmp $a95b	                jmp _check_command
.a91a						_para2_not_dollar:
.a91a		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.a91d		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.a920		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.a923		20 91 8f	jsr $8f91	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.a926		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.a929		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.a92c		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.a92f		20 cc 92	jsr $92cc	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.a932		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.a935		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.a938		20 96 87	jsr $8796	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.a93b		b5 00		lda $00,x	                lda 0,x
.a93d		15 01		ora $01,x	                ora 1,x
.a93f		f0 08		beq $a949	                beq _second_number
.a941		8a		txa		                txa
.a942		18		clc		                clc
.a943		69 0c		adc #$0c	                adc #12
.a945		aa		tax		                tax                     ; back to ( addr-t u-t )
.a946		4c 63 ac	jmp $ac63	                jmp ed_error
.a949						_second_number:
.a949		e8		inx		                inx
.a94a		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.a94b		38		sec		                sec
.a94c		a5 0e		lda $0e		                lda ciblen
.a94e		f5 00		sbc $00,x	                sbc 0,x
.a950		48		pha		                pha
.a951		20 a7 93	jsr $93a7	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.a954		20 18 9e	jsr $9e18	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.a957		20 30 8c	jsr $8c30	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.a95a		7a		ply		                ply
.a95b						_check_command:
.a95b		24 39		bit $39		                bit ed_flags
.a95d		30 08		bmi $a967	                bmi _check_command_have_arg
.a95f		a5 37		lda $37		                lda ed_cur
.a961		95 02		sta $02,x	                sta 2,x
.a963		a5 38		lda $38		                lda ed_cur+1
.a965		95 03		sta $03,x	                sta 3,x
.a967						_check_command_have_arg:
.a967		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.a969		85 25		sta $25		                sta tmp1
.a96b		da		phx		                phx
.a96c		a2 00		ldx #$00	                ldx #00
.a96e						_cmd_loop:
.a96e		bd 47 ad	lda $ad47,x	                lda ed_cmd_list,x
.a971		f0 07		beq $a97a	                beq _illegal_command    ; zero marks end of list
.a973		c5 25		cmp $25		                cmp tmp1
.a975		f0 07		beq $a97e	                beq _found_cmd
.a977		e8		inx		                inx
.a978		80 f4		bra $a96e	                bra _cmd_loop
.a97a						_illegal_command:
.a97a		fa		plx		                plx
.a97b		4c 5f ac	jmp $ac5f	                jmp ed_error_2drop
.a97e						_found_cmd:
.a97e		8a		txa		                txa
.a97f		0a		asl a		                asl
.a980		aa		tax		                tax                     ; X * 2 for table
.a981		7c 52 ad	jmp ($ad52,x)	                jmp (ed_cmd_table,x)
.a984						ed_next_command:
.a984		e8		inx		                inx
.a985		e8		inx		                inx
.a986		e8		inx		                inx
.a987		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.a988		4c 92 a7	jmp $a792	                jmp ed_input_loop
.a98b						ed_all_done:
.a98b		64 0e		stz $0e		                stz ciblen
.a98d		64 0f		stz $0f		                stz ciblen+1
.a98f		20 a7 93	jsr $93a7	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.a992		a5 3a		lda $3a		                lda ed_base
.a994		85 18		sta $18		                sta base
.a996		60		rts		                rts
.a997						ed_cmd_a:
.a997		fa		plx		                plx
.a998		e8		inx		                inx
.a999		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.a99a						ed_entry_cmd_i:
.a99a		20 e5 ac	jsr $ace5	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.a99d		20 3a 84	jsr $843a	                jsr xt_cr
.a9a0						_next_string_loop:
.a9a0		20 71 ac	jsr $ac71	                jsr ed_get_input
.a9a3		b2 0c		lda ($0c)	                lda (cib)
.a9a5		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.a9a7		d0 16		bne $a9bf	                bne _add_line
.a9a9		a4 0e		ldy $0e		                ldy ciblen
.a9ab		c0 01		cpy #$01	                cpy #01
.a9ad		d0 10		bne $a9bf	                bne _add_line
.a9af		a4 0f		ldy $0f		                ldy ciblen+1
.a9b1		d0 0c		bne $a9bf	                bne _add_line
.a9b3		e8		inx		                inx
.a9b4		e8		inx		                inx
.a9b5		a9 40		lda #$40	                lda #%01000000
.a9b7		04 39		tsb $39		                tsb ed_flags
.a9b9		20 3a 84	jsr $843a	                jsr xt_cr
.a9bc		4c 92 a7	jmp $a792	                jmp ed_input_loop
.a9bf						_add_line:
.a9bf		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.a9c2		20 1b 89	jsr $891b	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.a9c5		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.a9c8		20 1a 88	jsr $881a	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.a9cb		20 cd 83	jsr $83cd	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.a9ce		20 8d 93	jsr $938d	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.a9d1		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.a9d4		20 18 92	jsr $9218	                jsr xt_store            ; ! ( addr-t u-t here )
.a9d7		20 1b 89	jsr $891b	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.a9da		a5 00		lda $00		                lda cp
.a9dc		18		clc		                clc
.a9dd		69 04		adc #$04	                adc #04
.a9df		85 00		sta $00		                sta cp
.a9e1		90 02		bcc $a9e5	                bcc +
.a9e3		e6 01		inc $01		                inc cp+1
.a9e5						+
.a9e5		e6 37		inc $37		                inc ed_cur
.a9e7		d0 02		bne $a9eb	                bne +
.a9e9		e6 38		inc $38		                inc ed_cur+1
.a9eb						+
.a9eb		20 1b 89	jsr $891b	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.a9ee		20 a0 86	jsr $86a0	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.a9f1		ca		dex		                dex
.a9f2		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.a9f3		a5 0c		lda $0c		                lda cib
.a9f5		95 00		sta $00,x	                sta 0,x
.a9f7		a5 0d		lda $0d		                lda cib+1
.a9f9		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.a9fb		20 2e 92	jsr $922e	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.a9fe		ca		dex		                dex
.a9ff		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.aa00		a5 0e		lda $0e		                lda ciblen
.aa02		95 00		sta $00,x	                sta 0,x
.aa04		a5 0f		lda $0f		                lda ciblen+1
.aa06		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.aa08		20 00 8c	jsr $8c00	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.aa0b		18		clc		                clc
.aa0c		a5 00		lda $00		                lda cp
.aa0e		65 0e		adc $0e		                adc ciblen
.aa10		85 00		sta $00		                sta cp
.aa12		90 06		bcc $aa1a	                bcc +
.aa14		a5 01		lda $01		                lda cp+1
.aa16		65 0f		adc $0f		                adc ciblen+1
.aa18		85 01		sta $01		                sta cp+1
.aa1a						+
.aa1a		20 05 8d	jsr $8d05	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.aa1d		20 18 92	jsr $9218	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.aa20		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+
.aa23		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.aa26		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.aa29		a5 0e		lda $0e		                lda ciblen
.aa2b		95 02		sta $02,x	                sta 2,x
.aa2d		a5 0f		lda $0f		                lda ciblen+1
.aa2f		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.aa31		20 18 92	jsr $9218	                jsr xt_store            ; ! ( addr-t u-t here )
.aa34		20 3a 84	jsr $843a	                jsr xt_cr
.aa37		4c a0 a9	jmp $a9a0	                jmp _next_string_loop
.aa3a						ed_cmd_d:
.aa3a		fa		plx		                plx
.aa3b		20 82 ac	jsr $ac82	                jsr ed_have_text
.aa3e		20 d7 ac	jsr $acd7	                jsr ed_no_line_zero
.aa41		b5 00		lda $00,x	                lda 0,x
.aa43		15 01		ora $01,x	                ora 1,x
.aa45		d0 08		bne $aa4f	                bne +
.aa47		20 05 8d	jsr $8d05	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.aa4a		20 8c aa	jsr $aa8c	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.aa4d		80 33		bra $aa82	                bra _cmd_d_done
.aa4f						+
.aa4f		20 8d ac	jsr $ac8d	                jsr ed_is_valid_line      ; result is in C flag
.aa52		b0 03		bcs $aa57	                bcs _cmd_d_loop
.aa54		4c 5f ac	jmp $ac5f	                jmp ed_error_2drop
.aa57						_cmd_d_loop:
.aa57		20 af 93	jsr $93af	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.aa5a		20 06 89	jsr $8906	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.aa5d		b5 00		lda $00,x	                lda 0,x
.aa5f		15 01		ora $01,x	                ora 1,x
.aa61		d0 0d		bne $aa70	                bne _cmd_d_done_with_flag
.aa63		e8		inx		                inx
.aa64		e8		inx		                inx                     ; Get rid of the flag from >
.aa65		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.aa68		20 8c aa	jsr $aa8c	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.aa6b		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.aa6e		80 e7		bra $aa57	                bra _cmd_d_loop
.aa70						_cmd_d_done_with_flag:
.aa70		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.aa71		e8		inx		                inx
.aa72		b5 02		lda $02,x	                lda 2,x
.aa74		d0 02		bne $aa78	                bne +
.aa76		d6 03		dec $03,x	                dec 3,x
.aa78						+
.aa78		d6 02		dec $02,x	                dec 2,x
.aa7a		b5 02		lda $02,x	                lda 2,x
.aa7c		85 37		sta $37		                sta ed_cur
.aa7e		b5 03		lda $03,x	                lda 3,x
.aa80		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.aa82						_cmd_d_done:
.aa82		a9 40		lda #$40	                lda #%01000000
.aa84		04 39		tsb $39		                tsb ed_flags
.aa86		20 3a 84	jsr $843a	                jsr xt_cr
.aa89		4c 84 a9	jmp $a984	                jmp ed_next_command
.aa8c						_cmd_d_common:
.aa8c		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.aa8f		20 e5 ac	jsr $ace5	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.aa92		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.aa95		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.aa98		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.aa9b		20 e5 ac	jsr $ace5	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.aa9e		20 18 92	jsr $9218	                jsr xt_store            ; ! ( addr-t u-t )
.aaa1		60		rts		                rts
.aaa2						ed_cmd_equ:
.aaa2		fa		plx		                plx
.aaa3		a5 35		lda $35		                lda ed_head
.aaa5		05 36		ora $36		                ora ed_head+1
.aaa7		d0 08		bne $aab1	                bne _cmd_equ_have_text
.aaa9		ca		dex		                dex
.aaaa		ca		dex		                dex
.aaab		74 00		stz $00,x	                stz 0,x
.aaad		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.aaaf		80 21		bra $aad2	                bra _cmd_equ_done
.aab1						_cmd_equ_have_text:
.aab1		20 d7 ac	jsr $acd7	                jsr ed_no_line_zero
.aab4		24 39		bit $39		                bit ed_flags
.aab6		30 0c		bmi $aac4	                bmi _cmd_equ_have_para
.aab8		ca		dex		                dex
.aab9		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.aaba		a5 37		lda $37		                lda ed_cur
.aabc		95 00		sta $00,x	                sta 0,x
.aabe		a5 38		lda $38		                lda ed_cur+1
.aac0		95 01		sta $01,x	                sta 1,x
.aac2		80 0e		bra $aad2	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.aac4						_cmd_equ_have_para:
.aac4		b5 00		lda $00,x	                lda 0,x
.aac6		15 01		ora $01,x	                ora 1,x
.aac8		d0 05		bne $aacf	                bne _cmd_equ_two_paras
.aaca		20 05 8d	jsr $8d05	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.aacd		80 03		bra $aad2	                bra _cmd_equ_done
.aacf						_cmd_equ_two_paras:
.aacf		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.aad2						_cmd_equ_done:
.aad2		20 3a 84	jsr $843a	                jsr xt_cr               ; number goes on new line
.aad5		20 e2 94	jsr $94e2	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.aad8		20 3a 84	jsr $843a	                jsr xt_cr
.aadb		4c 84 a9	jmp $a984	                jmp ed_next_command
.aade						ed_cmd_f:
.aade		fa		plx		                plx
.aadf		24 39		bit $39		                bit ed_flags
.aae1		30 17		bmi $aafa	                bmi _cmd_f_have_para
.aae3		20 3a 84	jsr $843a	                jsr xt_cr
.aae6		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.aae9		20 91 8f	jsr $8f91	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.aaec		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.aaef		20 e2 94	jsr $94e2	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.aaf2		20 53 9c	jsr $9c53	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.aaf5		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.aaf8		80 11		bra $ab0b	                bra _cmd_f_done
.aafa						_cmd_f_have_para:
.aafa		20 05 8d	jsr $8d05	                jsr xt_over
.aafd		20 3a 84	jsr $843a	                jsr xt_cr
.ab00		20 e2 94	jsr $94e2	                jsr xt_u_dot
.ab03		b5 02		lda $02,x	                lda 2,x
.ab05		95 06		sta $06,x	                sta 6,x
.ab07		b5 03		lda $03,x	                lda 3,x
.ab09		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.ab0b						_cmd_f_done:
.ab0b		20 3a 84	jsr $843a	                jsr xt_cr
.ab0e		4c 84 a9	jmp $a984	                jmp ed_next_command
.ab11						ed_cmd_i:
.ab11		fa		plx		                plx
.ab12		e8		inx		                inx
.ab13		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.ab14		24 39		bit $39		                bit ed_flags
.ab16		30 08		bmi $ab20	                bmi _cmd_i_have_para
.ab18		a5 37		lda $37		                lda ed_cur
.ab1a		95 00		sta $00,x	                sta 0,x
.ab1c		a5 38		lda $38		                lda ed_cur+1
.ab1e		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.ab20						_cmd_i_have_para:
.ab20		b5 00		lda $00,x	                lda 0,x
.ab22		15 01		ora $01,x	                ora 1,x
.ab24		f0 09		beq $ab2f	                beq _cmd_i_done
.ab26		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.ab29		20 cf 9d	jsr $9dcf	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.ab2c		20 ac 8b	jsr $8bac	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.ab2f						_cmd_i_done:
.ab2f		4c 9a a9	jmp $a99a	                jmp ed_entry_cmd_i
.ab32						ed_cmd_n:
.ab32		fa		plx		                plx
.ab33		a9 01		lda #$01	                lda #%00000001
.ab35		04 39		tsb $39		                tsb ed_flags
.ab37		80 05		bra $ab3e	                bra ed_cmd_p_entry_for_cmd_n
.ab39						ed_cmd_p:
.ab39		fa		plx		                plx
.ab3a						ed_cmd_p_from_external:
.ab3a		a9 01		lda #$01	                lda #%00000001
.ab3c		14 39		trb $39		                trb ed_flags
.ab3e						ed_cmd_p_entry_for_cmd_n:
.ab3e		20 82 ac	jsr $ac82	                jsr ed_have_text
.ab41		20 d7 ac	jsr $acd7	                jsr ed_no_line_zero
.ab44		20 3a 84	jsr $843a	                jsr xt_cr
.ab47		b5 00		lda $00,x	                lda 0,x
.ab49		15 01		ora $01,x	                ora 1,x
.ab4b		d0 10		bne $ab5d	                bne _cmd_p_loop
.ab4d		b5 02		lda $02,x	                lda 2,x
.ab4f		85 37		sta $37		                sta ed_cur
.ab51		b5 03		lda $03,x	                lda 3,x
.ab53		85 38		sta $38		                sta ed_cur+1
.ab55		20 05 8d	jsr $8d05	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.ab58		20 86 ab	jsr $ab86	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ab5b		80 26		bra $ab83	                bra _cmd_p_all_done
.ab5d						_cmd_p_loop:
.ab5d		20 af 93	jsr $93af	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ab60		20 06 89	jsr $8906	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.ab63		b5 00		lda $00,x	                lda 0,x
.ab65		15 01		ora $01,x	                ora 1,x
.ab67		d0 10		bne $ab79	                bne _cmd_p_done
.ab69		e8		inx		                inx
.ab6a		e8		inx		                inx                     ; Get rid of the flag from >
.ab6b		20 05 8d	jsr $8d05	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.ab6e		20 86 ab	jsr $ab86	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ab71		f6 02		inc $02,x	                inc 2,x
.ab73		d0 02		bne $ab77	                bne +
.ab75		f6 03		inc $03,x	                inc 3,x
.ab77						+
.ab77		80 e4		bra $ab5d	                bra _cmd_p_loop
.ab79						_cmd_p_done:
.ab79		e8		inx		                inx
.ab7a		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.ab7b		b5 00		lda $00,x	                lda 0,x
.ab7d		85 37		sta $37		                sta ed_cur
.ab7f		b5 01		lda $01,x	                lda 1,x
.ab81		85 38		sta $38		                sta ed_cur+1
.ab83						_cmd_p_all_done:
.ab83		4c 84 a9	jmp $a984	                jmp ed_next_command
.ab86						_cmd_p_common:
.ab86		a5 39		lda $39		                lda ed_flags
.ab88		4a		lsr a		                lsr                     ; bit 0 now in carry
.ab89		90 0b		bcc $ab96	                bcc _cmd_p_common_no_num
.ab8b		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.ab8e		20 e2 94	jsr $94e2	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.ab91		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.ab93		20 c5 86	jsr $86c5	                jsr emit_a
.ab96						_cmd_p_common_no_num:
.ab96		20 e5 ac	jsr $ace5	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.ab99		20 25 ad	jsr $ad25	                jsr ed_print_addr
.ab9c		60		rts		                rts
.ab9d						ed_cmd_q:
.ab9d		fa		plx		                plx
.ab9e		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.aba0		50 03		bvc $aba5	                bvc +
.aba2		4c 5f ac	jmp $ac5f	                jmp ed_error_2drop
.aba5						+
.aba5		4c 8b a9	jmp $a98b	                jmp ed_all_done            ; can't fall thru because of PLX
.aba8						ed_cmd_qq:
.aba8		fa		plx		                plx
.aba9		4c 8b a9	jmp $a98b	                jmp ed_all_done
.abac						ed_cmd_w:
.abac		fa		plx		                plx
.abad		20 82 ac	jsr $ac82	                jsr ed_have_text
.abb0		24 39		bit $39		                bit ed_flags
.abb2		30 13		bmi $abc7	                bmi _cmd_w_have_para
.abb4		b5 06		lda $06,x	                lda 6,x
.abb6		15 07		ora $07,x	                ora 7,x
.abb8		d0 03		bne $abbd	                bne +
.abba		4c 5f ac	jmp $ac5f	                jmp ed_error_2drop
.abbd						+
.abbd		b5 06		lda $06,x	                lda 6,x
.abbf		95 02		sta $02,x	                sta 2,x
.abc1		b5 07		lda $07,x	                lda 7,x
.abc3		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.abc5		80 08		bra $abcf	                bra _cmd_w_para_ready
.abc7						_cmd_w_have_para:
.abc7		b5 02		lda $02,x	                lda 2,x
.abc9		95 06		sta $06,x	                sta 6,x
.abcb		b5 03		lda $03,x	                lda 3,x
.abcd		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.abcf						_cmd_w_para_ready:
.abcf		a9 35		lda #$35	                lda #<ed_head
.abd1		95 00		sta $00,x	                sta 0,x
.abd3		a9 00		lda #$00	                lda #>ed_head
.abd5		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.abd7		20 05 8d	jsr $8d05	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.abda		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.abdd						_cmd_w_loop:
.abdd		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.abe0		b5 00		lda $00,x	                lda 0,x
.abe2		15 01		ora $01,x	                ora 1,x
.abe4		f0 55		beq $ac3b	                beq _cmd_w_eol
.abe6		20 af 93	jsr $93af	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.abe9		20 99 94	jsr $9499	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.abec		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.abef		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.abf2		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.abf5		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.abf8		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.abfb		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.abfe		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ac01		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ac04		20 53 9c	jsr $9c53	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ac07		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ac0a		20 91 8f	jsr $8f91	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ac0d		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ac10		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ac13		20 00 8c	jsr $8c00	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ac16		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ac19		20 21 94	jsr $9421	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ac1c		20 53 9c	jsr $9c53	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ac1f		20 53 8e	jsr $8e53	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ac22		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ac25		ca		dex		                dex
.ac26		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ac27		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ac29		95 00		sta $00,x	                sta 0,x
.ac2b		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ac2d		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ac30		20 18 92	jsr $9218	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ac33		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ac36		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ac39		80 a2		bra $abdd	                bra _cmd_w_loop
.ac3b						_cmd_w_eol:
.ac3b		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ac3e		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ac41		20 e4 8b	jsr $8be4	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ac44		b5 00		lda $00,x	                lda 0,x
.ac46		95 04		sta $04,x	                sta 4,x
.ac48		b5 01		lda $01,x	                lda 1,x
.ac4a		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ac4c		20 3a 84	jsr $843a	                jsr xt_cr
.ac4f		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ac52		20 e2 94	jsr $94e2	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ac55		20 3a 84	jsr $843a	                jsr xt_cr
.ac58		a9 40		lda #$40	                lda #%01000000
.ac5a		14 39		trb $39		                trb ed_flags
.ac5c		4c 84 a9	jmp $a984	                jmp ed_next_command
.ac5f						ed_error_2drop:
.ac5f		e8		inx		                inx
.ac60		e8		inx		                inx                     ; drop through to _error_1drop
.ac61						ed_error_1drop:
.ac61		e8		inx		                inx
.ac62		e8		inx		                inx                     ; drop through to _error
.ac63						ed_error:
.ac63		20 3a 84	jsr $843a	                jsr xt_cr
.ac66		a9 3f		lda #$3f	                lda #'?'
.ac68		20 c5 86	jsr $86c5	                jsr emit_a
.ac6b		20 3a 84	jsr $843a	                jsr xt_cr
.ac6e		4c 92 a7	jmp $a792	                jmp ed_input_loop
.ac71						ed_get_input:
.ac71		20 42 8f	jsr $8f42	                jsr xt_refill           ;  ( addr-t u-t f )
.ac74		b5 00		lda $00,x	                lda 0,x
.ac76		15 01		ora $01,x	                ora 1,x
.ac78		d0 05		bne $ac7f	                bne +
.ac7a		7a		ply		                ply
.ac7b		7a		ply		                ply
.ac7c		4c 61 ac	jmp $ac61	                jmp ed_error_1drop
.ac7f						+
.ac7f		e8		inx		                inx
.ac80		e8		inx		                inx
.ac81		60		rts		                rts
.ac82						ed_have_text:
.ac82		a5 35		lda $35		                lda ed_head
.ac84		05 36		ora $36		                ora ed_head+1
.ac86		d0 04		bne $ac8c	                bne +
.ac88		7a		ply		                ply
.ac89		7a		ply		                ply
.ac8a		80 d7		bra $ac63	                bra ed_error
.ac8c						+
.ac8c		60		rts		                rts
.ac8d						ed_is_valid_line:
.ac8d		38		sec		                sec                             ; default is legal line number
.ac8e		b5 00		lda $00,x	                lda 0,x
.ac90		15 01		ora $01,x	                ora 1,x
.ac92		f0 19		beq $acad	                beq _is_valid_line_nope_zero    ; ( n )
.ac94		20 a0 86	jsr $86a0	                jsr xt_dup                      ; DUP ( n n )
.ac97		20 af ac	jsr $acaf	                jsr ed_last_line                  ; ( n n last )
.ac9a		20 2e 92	jsr $922e	                jsr xt_swap                     ; SWAP ( n last n )
.ac9d		20 dd 89	jsr $89dd	                jsr xt_less_than                ; < ( n f )
.aca0		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.aca2		15 01		ora $01,x	                ora 1,x
.aca4		d0 05		bne $acab	                bne _is_valid_line_too_small
.aca6		e8		inx		                inx
.aca7		e8		inx		                inx                     ; DROP flag ( n )
.aca8		38		sec		                sec                     ; Who knows what's happened to C by now
.aca9		80 03		bra $acae	                bra _is_valid_line_done ; only one exit from this routine
.acab						_is_valid_line_too_small:
.acab		e8		inx		                inx
.acac		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.acad						_is_valid_line_nope_zero:
.acad		18		clc		                clc                     ; drop through to _is_valid_line_done
.acae						_is_valid_line_done:
.acae		60		rts		                rts
.acaf						ed_last_line:
.acaf		64 25		stz $25		                stz tmp1
.acb1		64 26		stz $26		                stz tmp1+1
.acb3		ca		dex		                dex
.acb4		ca		dex		                dex                     ; ( ? )
.acb5		a9 35		lda #$35	                lda #<ed_head
.acb7		95 00		sta $00,x	                sta 0,x
.acb9		a9 00		lda #$00	                lda #>ed_head
.acbb		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.acbd						_last_line_loop:
.acbd		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( addr | 0 )
.acc0		b5 00		lda $00,x	                lda 0,x
.acc2		15 01		ora $01,x	                ora 1,x
.acc4		f0 08		beq $acce	                beq _last_line_done
.acc6		e6 25		inc $25		                inc tmp1
.acc8		d0 02		bne $accc	                bne +
.acca		e6 26		inc $26		                inc tmp1+1
.accc						+
.accc		80 ef		bra $acbd	                bra _last_line_loop
.acce						_last_line_done:
.acce		a5 25		lda $25		                lda tmp1
.acd0		95 00		sta $00,x	                sta 0,x
.acd2		a5 26		lda $26		                lda tmp1+1
.acd4		95 01		sta $01,x	                sta 1,x                 ; ( u )
.acd6		60		rts		                rts
.acd7						ed_no_line_zero:
.acd7		b5 02		lda $02,x	                lda 2,x
.acd9		15 03		ora $03,x	                ora 3,x
.acdb		d0 07		bne $ace4	                bne _no_line_zero_done
.acdd		24 39		bit $39		                bit ed_flags
.acdf		10 03		bpl $ace4	                bpl _no_line_zero_done
.ace1		4c 5f ac	jmp $ac5f	                jmp ed_error_2drop
.ace4						_no_line_zero_done:
.ace4		60		rts		                rts
.ace5						ed_num_to_addr:
.ace5		ca		dex		                dex
.ace6		ca		dex		                dex                     ; ( u ? )
.ace7		a9 35		lda #$35	                lda #<ed_head
.ace9		95 00		sta $00,x	                sta 0,x
.aceb		a9 00		lda #$00	                lda #>ed_head
.aced		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.acef		b5 02		lda $02,x	                lda 2,x
.acf1		15 03		ora $03,x	                ora 3,x
.acf3		d0 05		bne $acfa	                bne _num_to_addr_loop
.acf5		20 30 8c	jsr $8c30	                jsr xt_nip              ; ( addr-h )
.acf8		80 21		bra $ad1b	                bra _num_to_addr_done
.acfa						_num_to_addr_loop:
.acfa		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( u addr1 )
.acfd		b5 00		lda $00,x	                lda 0,x
.acff		15 01		ora $01,x	                ora 1,x
.ad01		d0 05		bne $ad08	                bne +
.ad03		20 30 8c	jsr $8c30	                jsr xt_nip              ; NIP ( addr1 )
.ad06		80 13		bra $ad1b	                bra _num_to_addr_done
.ad08						+
.ad08		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr1 u )
.ad0b		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.ad0e		b5 00		lda $00,x	                lda 0,x
.ad10		15 01		ora $01,x	                ora 1,x
.ad12		f0 05		beq $ad19	                beq _num_to_addr_finished
.ad14		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.ad17		80 e1		bra $acfa	                bra _num_to_addr_loop
.ad19						_num_to_addr_finished:
.ad19		e8		inx		                inx
.ad1a		e8		inx		                inx                     ; ( addr )
.ad1b						_num_to_addr_done:
.ad1b		60		rts		                rts
.ad1c						ed_para1_to_cur:
.ad1c		b5 02		lda $02,x	                lda 2,x
.ad1e		85 37		sta $37		                sta ed_cur
.ad20		b5 03		lda $03,x	                lda 3,x
.ad22		85 38		sta $38		                sta ed_cur+1
.ad24		60		rts		                rts
.ad25						ed_print_addr:
.ad25		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.ad28		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; ( addr+2 )
.ad2b		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr+2 addr+2 )
.ad2e		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.ad31		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.ad34		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( addr+2 u-s )
.ad37		20 2e 92	jsr $922e	                jsr xt_swap             ; ( u-s addr+2 )
.ad3a		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( u-s addr-s )
.ad3d		20 2e 92	jsr $922e	                jsr xt_swap             ; ( addr-s u-s )
.ad40		20 b7 94	jsr $94b7	                jsr xt_type
.ad43		20 3a 84	jsr $843a	                jsr xt_cr
.ad46		60		rts		                rts
>ad47		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>ad4f		71 51 00
.ad52						ed_cmd_table:
>ad52		97 a9 de aa 11 ab 3a aa		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>ad5a		39 ab 32 ab
>ad5e		a2 aa ac ab 9d ab a8 ab		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ad66						ed6502_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/block.asm

.ad66						xt_blk:
.ad66		a9 04		lda #$04	                lda #blk_offset
.ad68		4c 24 d6	jmp $d624	                jmp push_upvar_tos
.ad6b						z_blk:
.ad6b						xt_blkbuffer:
.ad6b		ca		dex		                dex
.ad6c		ca		dex		                dex
.ad6d		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ad6f		b1 08		lda ($08),y	                lda (up),y
.ad71		95 00		sta $00,x	                sta 0,x
.ad73		c8		iny		                iny             ; Move along to the next byte
.ad74		b1 08		lda ($08),y	                lda (up),y
.ad76		95 01		sta $01,x	                sta 1,x
.ad78		60		rts		z_blkbuffer:    rts
.ad79						xt_block:
.ad79		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ad7b		b1 08		lda ($08),y	                lda (up),y
.ad7d		d5 00		cmp $00,x	                cmp 0,x
.ad7f		d0 0f		bne $ad90	                bne _not_in_buffer
.ad81		c8		iny		                iny
.ad82		b1 08		lda ($08),y	                lda (up),y
.ad84		d5 01		cmp $01,x	                cmp 1,x
.ad86		d0 08		bne $ad90	                bne _not_in_buffer
.ad88		a0 30		ldy #$30	                ldy #buffstatus_offset
.ad8a		b1 08		lda ($08),y	                lda (up),y
.ad8c		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.ad8e		d0 30		bne $adc0	                bne _done       ; It's already in the buffer and in use.
.ad90						_not_in_buffer:
.ad90		a0 30		ldy #$30	                ldy #buffstatus_offset
.ad92		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.ad94		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.ad96		d0 0c		bne $ada4	                bne _buffer_available ; Unused or not dirty = available
.ad98		20 6b ad	jsr $ad6b	                jsr xt_blkbuffer
.ad9b		20 75 af	jsr $af75	                jsr xt_buffblocknum
.ad9e		20 1a 88	jsr $881a	                jsr xt_fetch
.ada1		20 62 af	jsr $af62	                jsr xt_block_write
.ada4						_buffer_available:
.ada4		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ada6		b5 00		lda $00,x	                lda 0,x
.ada8		91 08		sta ($08),y	                sta (up),y
.adaa		c8		iny		                iny
.adab		b5 01		lda $01,x	                lda 1,x
.adad		91 08		sta ($08),y	                sta (up),y
.adaf		20 6b ad	jsr $ad6b	                jsr xt_blkbuffer
.adb2		20 2e 92	jsr $922e	                jsr xt_swap
.adb5		20 4a af	jsr $af4a	                jsr xt_block_read
.adb8		a9 01		lda #$01	                lda #1
.adba		a0 30		ldy #$30	                ldy #buffstatus_offset
.adbc		91 08		sta ($08),y	                sta (up),y
.adbe		ca		dex		                dex
.adbf		ca		dex		                dex
.adc0						_done:
.adc0		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.adc2		b1 08		lda ($08),y	                lda (up),y
.adc4		95 00		sta $00,x	                sta 0,x
.adc6		c8		iny		                iny
.adc7		b1 08		lda ($08),y	                lda (up),y
.adc9		95 01		sta $01,x	                sta 1,x
.adcb		60		rts		z_block:        rts
.adcc						xt_block_c65_init:
=0						io_blk_status = 0
=0						io_blk_action = 0
=0						io_blk_number = 0
=0						io_blk_buffer = 0
.adcc		a9 ff		lda #$ff	                lda #$ff
.adce		8d 11 f0	sta $f011	                sta io_blk_status
.add1		a9 00		lda #$00	                lda #$0
.add3		8d 10 f0	sta $f010	                sta io_blk_action
.add6		ad 11 f0	lda $f011	                lda io_blk_status      ; $0 if OK, $ff otherwise
.add9		49 ff		eor #$ff	                eor #$ff            ; invert to forth true/false
.addb		ca		dex		                dex
.addc		ca		dex		                dex
.addd		95 00		sta $00,x	                sta 0,x             ; true ($ff) if OK, false (0) otherwise
.addf		95 01		sta $01,x	                sta 1,x
.ade1		ca		dex		                dex
.ade2		ca		dex		                dex
.ade3		a9 06		lda #$06	                lda #<c65_blk_read
.ade5		95 00		sta $00,x	                sta 0,x
.ade7		a9 ae		lda #$ae	                lda #>c65_blk_read
.ade9		95 01		sta $01,x	                sta 1,x
.adeb		20 58 af	jsr $af58	                jsr xt_block_read_vector
.adee		20 18 92	jsr $9218	                jsr xt_store
.adf1		ca		dex		                dex
.adf2		ca		dex		                dex
.adf3		a9 02		lda #$02	                lda #<c65_blk_write
.adf5		95 00		sta $00,x	                sta 0,x
.adf7		a9 ae		lda #$ae	                lda #>c65_blk_write
.adf9		95 01		sta $01,x	                sta 1,x
.adfb		20 70 af	jsr $af70	                jsr xt_block_write_vector
.adfe		20 18 92	jsr $9218	                jsr xt_store
.ae01						z_block_c65_init:
.ae01		60		rts		                rts
.ae02		a0 02		ldy #$02	c65_blk_write:  ldy #2
.ae04		80 02		bra $ae08	                bra c65_blk_rw
.ae06		a0 01		ldy #$01	c65_blk_read:   ldy #1
.ae08		b5 00		lda $00,x	c65_blk_rw:     lda 0,x                 ; ( addr blk# )
.ae0a		8d 12 f0	sta $f012	                sta io_blk_number
.ae0d		b5 01		lda $01,x	                lda 1,x
.ae0f		8d 13 f0	sta $f013	                sta io_blk_number+1
.ae12		b5 02		lda $02,x	                lda 2,x
.ae14		8d 14 f0	sta $f014	                sta io_blk_buffer
.ae17		b5 03		lda $03,x	                lda 3,x
.ae19		8d 15 f0	sta $f015	                sta io_blk_buffer+1
.ae1c		8c 10 f0	sty $f010	                sty io_blk_action       ; trigger the r/w
.ae1f		e8		inx		                inx                     ; clean up stack
.ae20		e8		inx		                inx
.ae21		e8		inx		                inx
.ae22		e8		inx		                inx
.ae23		60		rts		                rts
.ae24						xt_block_ramdrive_init:
.ae24		20 68 d7	jsr $d768	                jsr underflow_1
.ae27		20 54 a1	jsr $a154	                jsr sliteral_runtime
>ae2a		32 ae 18 01			                .word ramdrive_code, ramdrive_code_end-ramdrive_code
.ae2e		20 b2 88	jsr $88b2	                jsr xt_evaluate
.ae31						z_block_ramdrive_init:
.ae31		60		rts		                rts
.ae32						ramdrive_code:
>ae32		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>ae3a		77 61 70 20 64 65 63 69 6d 61 6c
>ae45		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>ae4c		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>ae50		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>ae58		20 72 61 6d 64 72 69 76 65
>ae61		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>ae69		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>ae77		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>ae7f		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>ae8f		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>ae9f		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>aea7		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>aeb6		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>aebe		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>aece		31 30 32 34 20 6d 6f 76 65 20 3b
>aed9		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>aee1		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>aef1		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>af01		20 21
>af03		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>af0b		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>af1b		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>af2b		6f 72 20 21
>af2f		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>af37		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>af47		65 20 21
.af4a						ramdrive_code_end:
.af4a						xt_block_read:
.af4a		a0 32		ldy #$32	                ldy #blockread_offset
.af4c		b1 08		lda ($08),y	                lda (up),y
.af4e		85 25		sta $25		                sta tmp1
.af50		c8		iny		                iny
.af51		b1 08		lda ($08),y	                lda (up),y
.af53		85 26		sta $26		                sta tmp1+1
.af55		6c 25 00	jmp ($0025)	                jmp (tmp1)
.af58						z_block_read:
.af58						xt_block_read_vector:
.af58		a9 32		lda #$32	                lda #blockread_offset
.af5a		4c 24 d6	jmp $d624	                jmp push_upvar_tos
.af5d						z_block_read_vector:
.af5d						xt_block_word_error:
.af5d		a9 0c		lda #$0c	                lda #err_blockwords
.af5f		4c 7e d7	jmp $d77e	                jmp error       ; no RTS needed
.af62						xt_block_write:
.af62		a0 34		ldy #$34	                ldy #blockwrite_offset
.af64		b1 08		lda ($08),y	                lda (up),y
.af66		85 25		sta $25		                sta tmp1
.af68		c8		iny		                iny
.af69		b1 08		lda ($08),y	                lda (up),y
.af6b		85 26		sta $26		                sta tmp1+1
.af6d		6c 25 00	jmp ($0025)	                jmp (tmp1)
.af70						z_block_write:
.af70						xt_block_write_vector:
.af70		a9 34		lda #$34	                lda #blockwrite_offset
.af72		4c 24 d6	jmp $d624	                jmp push_upvar_tos
.af75						z_block_write_vector:
.af75						xt_buffblocknum:
.af75		a9 2e		lda #$2e	                lda #buffblocknum_offset
.af77		4c 24 d6	jmp $d624	                jmp push_upvar_tos
.af7a						z_buffblocknum:
.af7a						xt_buffer:
.af7a		a0 30		ldy #$30	                ldy #buffstatus_offset
.af7c		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.af7e		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.af80		d0 0c		bne $af8e	                bne _buffer_available ; Unused or not dirty = available
.af82		20 6b ad	jsr $ad6b	                jsr xt_blkbuffer
.af85		20 75 af	jsr $af75	                jsr xt_buffblocknum
.af88		20 1a 88	jsr $881a	                jsr xt_fetch
.af8b		20 62 af	jsr $af62	                jsr xt_block_write
.af8e						_buffer_available:
.af8e		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.af90		b5 00		lda $00,x	                lda 0,x
.af92		91 08		sta ($08),y	                sta (up),y
.af94		c8		iny		                iny
.af95		b5 01		lda $01,x	                lda 1,x
.af97		91 08		sta ($08),y	                sta (up),y
.af99		a9 01		lda #$01	                lda #1
.af9b		a0 30		ldy #$30	                ldy #buffstatus_offset
.af9d		91 08		sta ($08),y	                sta (up),y
.af9f		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.afa1		b1 08		lda ($08),y	                lda (up),y
.afa3		95 00		sta $00,x	                sta 0,x
.afa5		c8		iny		                iny
.afa6		b1 08		lda ($08),y	                lda (up),y
.afa8		95 01		sta $01,x	                sta 1,x
.afaa		60		rts		z_buffer:       rts
.afab						xt_buffstatus:
.afab		a9 30		lda #$30	                lda #buffstatus_offset
.afad		4c 24 d6	jmp $d624	                jmp push_upvar_tos
.afb0						z_buffstatus:
.afb0						xt_empty_buffers:
.afb0		a0 30		ldy #$30	                ldy #buffstatus_offset
.afb2		a9 00		lda #$00	                lda #0
.afb4		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.afb6						z_empty_buffers:
.afb6		60		rts		                rts
.afb7						xt_flush:
.afb7		20 12 b0	jsr $b012	                jsr xt_save_buffers
.afba		a0 30		ldy #$30	                ldy #buffstatus_offset
.afbc		a9 00		lda #$00	                lda #0
.afbe		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.afc0						z_flush:
.afc0		60		rts		                rts
.afc1						xt_list:
.afc1		20 68 d7	jsr $d768	                jsr underflow_1
.afc4		20 2d b0	jsr $b02d	                jsr xt_scr
.afc7		20 18 92	jsr $9218	                jsr xt_store
.afca		20 cc b0	jsr $b0cc	                jsr xt_editor_l
.afcd		60		rts		z_list:         rts
.afce						xt_load:
.afce		20 68 d7	jsr $d768	                jsr underflow_1
.afd1		a0 05		ldy #$05	                ldy #blk_offset+1
.afd3		b1 08		lda ($08),y	                lda (up),y
.afd5		48		pha		                pha
.afd6		88		dey		                dey
.afd7		b1 08		lda ($08),y	                lda (up),y
.afd9		48		pha		                pha
.afda		b5 00		lda $00,x	                lda 0,x
.afdc		91 08		sta ($08),y	                sta (up),y
.afde		c8		iny		                iny
.afdf		b5 01		lda $01,x	                lda 1,x
.afe1		91 08		sta ($08),y	                sta (up),y
.afe3		20 79 ad	jsr $ad79	                jsr xt_block
.afe6		ca		dex		                dex
.afe7		ca		dex		                dex
.afe8		a9 04		lda #$04	                lda #4
.afea		95 01		sta $01,x	                sta 1,x
.afec		74 00		stz $00,x	                stz 0,x
.afee		20 ac 88	jsr $88ac	                jsr load_evaluate
.aff1		a0 04		ldy #$04	                ldy #blk_offset
.aff3		68		pla		                pla
.aff4		91 08		sta ($08),y	                sta (up),y
.aff6		c8		iny		                iny
.aff7		68		pla		                pla
.aff8		91 08		sta ($08),y	                sta (up),y
.affa		88		dey		                dey
.affb		11 08		ora ($08),y	                ora (up),y
.affd		f0 12		beq $b011	                beq _done
.afff		ca		dex		                dex
.b000		ca		dex		                dex
.b001		a0 04		ldy #$04	                ldy #blk_offset
.b003		b1 08		lda ($08),y	                lda (up),y
.b005		95 00		sta $00,x	                sta 0,x
.b007		c8		iny		                iny
.b008		b1 08		lda ($08),y	                lda (up),y
.b00a		95 01		sta $01,x	                sta 1,x
.b00c		20 79 ad	jsr $ad79	                jsr xt_block
.b00f		e8		inx		                inx
.b010		e8		inx		                inx
.b011						_done:
.b011		60		rts		z_load:         rts
.b012						xt_save_buffers:
.b012		a0 30		ldy #$30	                ldy #buffstatus_offset
.b014		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b016		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b018		d0 12		bne $b02c	                bne _done       ; Either not used or not dirty = done!
.b01a		20 6b ad	jsr $ad6b	                jsr xt_blkbuffer
.b01d		20 75 af	jsr $af75	                jsr xt_buffblocknum
.b020		20 1a 88	jsr $881a	                jsr xt_fetch
.b023		20 62 af	jsr $af62	                jsr xt_block_write
.b026		a9 01		lda #$01	                lda #1
.b028		a0 30		ldy #$30	                ldy #buffstatus_offset
.b02a		91 08		sta ($08),y	                sta (up),y
.b02c						_done:
.b02c		60		rts		z_save_buffers: rts
.b02d						xt_scr:
.b02d		a9 06		lda #$06	                lda #scr_offset
.b02f		4c 24 d6	jmp $d624	                jmp push_upvar_tos
.b032						z_scr:
.b032						xt_thru:
.b032		20 6d d7	jsr $d76d	                jsr underflow_2
.b035		b5 01		lda $01,x	                lda 1,x
.b037		48		pha		                pha
.b038		b5 00		lda $00,x	                lda 0,x
.b03a		48		pha		                pha
.b03b		e8		inx		                inx
.b03c		e8		inx		                inx
.b03d						_thru_loop:
.b03d		b5 01		lda $01,x	                lda 1,x
.b03f		48		pha		                pha
.b040		b5 00		lda $00,x	                lda 0,x
.b042		48		pha		                pha
.b043		20 ce af	jsr $afce	                jsr xt_load
.b046		68		pla		                pla
.b047		85 25		sta $25		                sta tmp1
.b049		68		pla		                pla
.b04a		85 26		sta $26		                sta tmp1+1
.b04c		68		pla		                pla
.b04d		85 27		sta $27		                sta tmp2
.b04f		68		pla		                pla
.b050		85 28		sta $28		                sta tmp2+1
.b052		c5 26		cmp $26		                cmp tmp1+1
.b054		d0 08		bne $b05e	                bne _next_screen
.b056		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.b058		c5 25		cmp $25		                cmp tmp1
.b05a		d0 02		bne $b05e	                bne _next_screen
.b05c		80 18		bra $b076	                bra _done       ; We just did the last screen.
.b05e						_next_screen:
.b05e		a5 28		lda $28		                lda tmp2+1
.b060		48		pha		                pha
.b061		a5 27		lda $27		                lda tmp2
.b063		48		pha		                pha
.b064		e6 25		inc $25		                inc tmp1
.b066		d0 02		bne $b06a	                bne +
.b068		e6 26		inc $26		                inc tmp1+1
.b06a						+
.b06a		ca		dex		                dex
.b06b		ca		dex		                dex
.b06c		a5 25		lda $25		                lda tmp1
.b06e		95 00		sta $00,x	                sta 0,x
.b070		a5 26		lda $26		                lda tmp1+1
.b072		95 01		sta $01,x	                sta 1,x
.b074		80 c7		bra $b03d	                bra _thru_loop
.b076						_done:
.b076		60		rts		z_thru:         rts
.b077						xt_update:
.b077		a0 30		ldy #$30	                ldy #buffstatus_offset
.b079		b1 08		lda ($08),y	                lda (up),y
.b07b		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.b07d		91 08		sta ($08),y	                sta (up),y
.b07f		60		rts		z_update:       rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/editor.asm

.b080						xt_editor_screen_helper:
.b080		20 a0 86	jsr $86a0	                jsr xt_dup
.b083		20 2d b0	jsr $b02d	                jsr xt_scr
.b086		20 18 92	jsr $9218	                jsr xt_store
.b089		4c 7a af	jmp $af7a	                jmp xt_buffer
.b08c						xt_editor_enter_screen:
.b08c		20 80 b0	jsr $b080	                jsr xt_editor_screen_helper
.b08f		20 9a 86	jsr $869a	                jsr xt_drop
.b092		64 35		stz $35		                stz ed_head
.b094						_prompt_loop:
.b094		ca		dex		                dex
.b095		ca		dex		                dex
.b096		a5 35		lda $35		                lda ed_head
.b098		95 00		sta $00,x	                sta 0,x
.b09a		74 01		stz $01,x	                stz 1,x
.b09c		20 5f b1	jsr $b15f	                jsr xt_editor_o
.b09f		e6 35		inc $35		                inc ed_head
.b0a1		a9 10		lda #$10	                lda #16
.b0a3		c5 35		cmp $35		                cmp ed_head
.b0a5		d0 ed		bne $b094	                bne _prompt_loop
.b0a7						z_editor_enter_screen:
.b0a7		60		rts		                rts
.b0a8						xt_editor_erase_screen:
.b0a8		20 80 b0	jsr $b080	                jsr xt_editor_screen_helper
.b0ab		ca		dex		                dex
.b0ac		ca		dex		                dex
.b0ad		74 00		stz $00,x	                stz 0,x
.b0af		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.b0b1		95 01		sta $01,x	                sta 1,x
.b0b3		20 b2 87	jsr $87b2	                jsr xt_blank
.b0b6		20 77 b0	jsr $b077	                jsr xt_update
.b0b9						z_editor_erase_screen:
.b0b9		60		rts		                rts
.b0ba						xt_editor_el:
.b0ba		20 46 b1	jsr $b146	                jsr xt_editor_line
.b0bd		ca		dex		                dex
.b0be		ca		dex		                dex
.b0bf		a9 40		lda #$40	                lda #64
.b0c1		95 00		sta $00,x	                sta 0,x
.b0c3		74 01		stz $01,x	                stz 1,x
.b0c5		20 b2 87	jsr $87b2	                jsr xt_blank
.b0c8		20 77 b0	jsr $b077	                jsr xt_update
.b0cb		60		rts		z_editor_el:    rts
.b0cc						xt_editor_l:
.b0cc		ca		dex		                dex             ; Put SCR on the stack.
.b0cd		ca		dex		                dex
.b0ce		a0 06		ldy #$06	                ldy #scr_offset
.b0d0		b1 08		lda ($08),y	                lda (up),y
.b0d2		95 00		sta $00,x	                sta 0,x
.b0d4		c8		iny		                iny
.b0d5		b1 08		lda ($08),y	                lda (up),y
.b0d7		95 01		sta $01,x	                sta 1,x
.b0d9		20 79 ad	jsr $ad79	                jsr xt_block    ; Get the current screen.
.b0dc		20 3a 84	jsr $843a	                jsr xt_cr
.b0df		80 08		bra $b0e9	                bra _after_screen_msg
.b0e1						_screen_msg:
>b0e1		53 63 72 65 65 6e 20 23		                .text "Screen #"
.b0e9						_after_screen_msg:
.b0e9		20 54 a1	jsr $a154	                jsr sliteral_runtime
>b0ec		e1 b0 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.b0f0		20 b7 94	jsr $94b7	                jsr xt_type
.b0f3		20 2d b0	jsr $b02d	                jsr xt_scr
.b0f6		20 1a 88	jsr $881a	                jsr xt_fetch
.b0f9		ca		dex		                dex
.b0fa		ca		dex		                dex
.b0fb		a9 04		lda #$04	                lda #4          ; four spaces
.b0fd		95 00		sta $00,x	                sta 0,x
.b0ff		74 01		stz $01,x	                stz 1,x
.b101		20 ee 94	jsr $94ee	                jsr xt_u_dot_r
.b104		64 29		stz $29		                stz tmp3
.b106						_line_loop:
.b106		20 3a 84	jsr $843a	                jsr xt_cr
.b109		ca		dex		                dex
.b10a		ca		dex		                dex
.b10b		ca		dex		                dex
.b10c		ca		dex		                dex
.b10d		74 03		stz $03,x	                stz 3,x
.b10f		a5 29		lda $29		                lda tmp3
.b111		95 02		sta $02,x	                sta 2,x
.b113		74 01		stz $01,x	                stz 1,x
.b115		a9 02		lda #$02	                lda #2
.b117		95 00		sta $00,x	                sta 0,x
.b119		20 ee 94	jsr $94ee	                jsr xt_u_dot_r
.b11c		20 cb 91	jsr $91cb	                jsr xt_space
.b11f		20 a0 86	jsr $86a0	                jsr xt_dup
.b122		ca		dex		                dex
.b123		ca		dex		                dex
.b124		a9 40		lda #$40	                lda #64
.b126		95 00		sta $00,x	                sta 0,x
.b128		74 01		stz $01,x	                stz 1,x
.b12a		20 b7 94	jsr $94b7	                jsr xt_type
.b12d		18		clc		                clc
.b12e		a9 40		lda #$40	                lda #64
.b130		75 00		adc $00,x	                adc 0,x
.b132		95 00		sta $00,x	                sta 0,x
.b134		90 02		bcc $b138	                bcc +
.b136		f6 01		inc $01,x	                inc 1,x
.b138						+
.b138		e6 29		inc $29		                inc tmp3
.b13a		a5 29		lda $29		                lda tmp3
.b13c		c9 10		cmp #$10	                cmp #16
.b13e		d0 c6		bne $b106	                bne _line_loop
.b140		20 3a 84	jsr $843a	                jsr xt_cr
.b143		e8		inx		                inx
.b144		e8		inx		                inx
.b145		60		rts		z_editor_l:            rts
.b146						xt_editor_line:
.b146		20 68 d7	jsr $d768	                jsr underflow_1
.b149		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.b14b						_shift_tos_left:
.b14b		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.b14d		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.b14f		88		dey		                dey
.b150		d0 f9		bne $b14b	                bne _shift_tos_left
.b152		20 2d b0	jsr $b02d	                jsr xt_scr
.b155		20 1a 88	jsr $881a	                jsr xt_fetch
.b158		20 79 ad	jsr $ad79	                jsr xt_block
.b15b		20 53 8e	jsr $8e53	                jsr xt_plus
.b15e		60		rts		z_editor_line:  rts
.b15f						xt_editor_o:
.b15f		20 3a 84	jsr $843a	                jsr xt_cr
.b162		20 a0 86	jsr $86a0	                jsr xt_dup
.b165		20 9a 9d	jsr $9d9a	                jsr xt_two
.b168		20 ee 94	jsr $94ee	                jsr xt_u_dot_r
.b16b		20 cb 91	jsr $91cb	                jsr xt_space
.b16e		a9 2a		lda #$2a	                lda #'*'
.b170		20 c5 86	jsr $86c5	                jsr emit_a
.b173		20 cb 91	jsr $91cb	                jsr xt_space
.b176		20 46 b1	jsr $b146	                jsr xt_editor_line
.b179		20 a0 86	jsr $86a0	                jsr xt_dup      ; Save a copy of the line address for later.
.b17c		ca		dex		                dex
.b17d		ca		dex		                dex
.b17e		a9 40		lda #$40	                lda #64         ; chars/line
.b180		95 00		sta $00,x	                sta 0,x
.b182		74 01		stz $01,x	                stz 1,x
.b184		20 e4 80	jsr $80e4	                jsr xt_accept
.b187		20 a0 86	jsr $86a0	                jsr xt_dup
.b18a		20 53 9c	jsr $9c53	                jsr xt_not_rote ; -rot
.b18d		20 53 8e	jsr $8e53	                jsr xt_plus
.b190		ca		dex		                dex
.b191		ca		dex		                dex
.b192		a9 40		lda #$40	                lda #64         ; chars/line
.b194		95 00		sta $00,x	                sta 0,x
.b196		74 01		stz $01,x	                stz 1,x
.b198		20 91 8f	jsr $8f91	                jsr xt_rot
.b19b		20 e4 8b	jsr $8be4	                jsr xt_minus
.b19e		20 b2 87	jsr $87b2	                jsr xt_blank
.b1a1		20 77 b0	jsr $b077	                jsr xt_update
.b1a4		60		rts		z_editor_o:     rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/wordlist.asm

.b1a5						xt_also:
.b1a5		20 d0 b1	jsr $b1d0	                jsr xt_get_order
.b1a8		20 05 8d	jsr $8d05	                jsr xt_over
.b1ab		20 2e 92	jsr $922e	                jsr xt_swap
.b1ae		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.b1b1		20 d9 b2	jsr $b2d9	                jsr xt_set_order
.b1b4		60		rts		z_also:         rts
.b1b5						xt_definitions:
.b1b5		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.b1b7		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.b1b9		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.b1bb		91 08		sta ($08),y	                sta (up),y
.b1bd		60		rts		z_definitions:  rts
.b1be						xt_forth:
.b1be		a0 23		ldy #$23	                ldy #search_order_offset
.b1c0		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.b1c2		91 08		sta ($08),y	                sta (up),y
.b1c4						z_forth:
.b1c4		60		rts		                rts
.b1c5						xt_get_current:
.b1c5		ca		dex		                dex
.b1c6		ca		dex		                dex
.b1c7		a0 08		ldy #$08	                ldy #current_offset
.b1c9		b1 08		lda ($08),y	                lda (up),y
.b1cb		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.b1cd		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.b1cf		60		rts		z_get_current:  rts
.b1d0						xt_get_order:
.b1d0		a0 22		ldy #$22	                ldy #num_order_offset
.b1d2		b1 08		lda ($08),y	                lda (up),y
.b1d4		85 25		sta $25		                sta tmp1
.b1d6		f0 16		beq $b1ee	                beq _done       ; If zero, there are no wordlists.
.b1d8						_loop:
.b1d8		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.b1da		a9 23		lda #$23	                lda #search_order_offset
.b1dc		18		clc		                clc
.b1dd		65 25		adc $25		                adc tmp1
.b1df		a8		tay		                tay
.b1e0		ca		dex		                dex
.b1e1		ca		dex		                dex
.b1e2		b1 08		lda ($08),y	                lda (up),y
.b1e4		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.b1e6		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.b1e8		a9 00		lda #$00	                lda #0
.b1ea		c5 25		cmp $25		                cmp tmp1
.b1ec		d0 ea		bne $b1d8	                bne _loop
.b1ee						_done:
.b1ee		ca		dex		                dex
.b1ef		ca		dex		                dex
.b1f0		a0 22		ldy #$22	                ldy #num_order_offset
.b1f2		b1 08		lda ($08),y	                lda (up),y
.b1f4		95 00		sta $00,x	                sta 0,x
.b1f6		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.b1f8		60		rts		z_get_order:    rts
.b1f9						xt_only:
.b1f9		20 84 93	jsr $9384	                jsr xt_true
.b1fc		20 d9 b2	jsr $b2d9	                jsr xt_set_order
.b1ff		60		rts		z_only:         rts
.b200						xt_order:
.b200		20 3a 84	jsr $843a	                jsr xt_cr
.b203		20 d0 b1	jsr $b1d0	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.b206		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.b208		f0 1e		beq $b228	                beq _drop_done
.b20a		a8		tay		                tay
.b20b						_loop:
.b20b		e8		inx		                inx
.b20c		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.b20d		b5 00		lda $00,x	                lda 0,x
.b20f		5a		phy		                phy
.b210		20 2b b2	jsr $b22b	                jsr order_print_wid_string   ; internal helper function
.b213		7a		ply		                ply
.b214		88		dey		                dey
.b215		d0 f4		bne $b20b	                bne _loop
.b217		20 cb 91	jsr $91cb	                jsr xt_space
.b21a		20 cb 91	jsr $91cb	                jsr xt_space
.b21d		20 c5 b1	jsr $b1c5	                jsr xt_get_current      ; ( wid )
.b220		b5 00		lda $00,x	                lda 0,x
.b222		20 2b b2	jsr $b22b	                jsr order_print_wid_string
.b225		20 3a 84	jsr $843a	                jsr xt_cr
.b228						_drop_done:
.b228		e8		inx		                inx
.b229		e8		inx		                inx
.b22a						z_order:
.b22a		60		rts		                rts
.b22b						order_print_wid_string:
.b22b		c9 04		cmp #$04	                cmp #4
.b22d		90 09		bcc $b238	                bcc _output_string      ; less than 4, print a real string
.b22f		ca		dex		                dex
.b230		ca		dex		                dex
.b231		95 00		sta $00,x	                sta 0,x
.b233		74 01		stz $01,x	                stz 1,x
.b235		4c e2 94	jmp $94e2	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.b238						_output_string:
.b238		a8		tay		                tay
.b239		b9 3f b2	lda $b23f,y	                lda _wid_data,y
.b23c		4c a4 d7	jmp $d7a4	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.b23f						_wid_data:
>b23f		04				        .byte str_wid_forth            ; WID 0: "Forth"
>b240		05				        .byte str_wid_editor           ; WID 1: "Editor"
>b241		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>b242		07				        .byte str_wid_root             ; WID 3: "Root"
.b243						xt_previous:
.b243		20 d0 b1	jsr $b1d0	                jsr xt_get_order
.b246		20 30 8c	jsr $8c30	                jsr xt_nip
.b249		20 dd 8c	jsr $8cdd	                jsr xt_one_minus
.b24c		20 d9 b2	jsr $b2d9	                jsr xt_set_order
.b24f		60		rts		z_previous:     rts
.b250						xt_root_wordlist:
.b250		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.b251		ca		dex		                dex
.b252		a9 03		lda #$03	                lda #3
.b254		95 00		sta $00,x	                sta 0,x
.b256		74 01		stz $01,x	                stz 1,x
.b258						z_root_wordlist:
.b258		60		rts		                rts
.b259						xt_search_wordlist:
.b259		20 72 d7	jsr $d772	                jsr underflow_3
.b25c		a5 08		lda $08		                lda up
.b25e		18		clc		                clc
.b25f		69 0a		adc #$0a	                adc #wordlists_offset
.b261		85 27		sta $27		                sta tmp2
.b263		a5 09		lda $09		                lda up+1
.b265		69 00		adc #$00	                adc #0          ; Adding carry
.b267		85 28		sta $28		                sta tmp2+1
.b269		b5 00		lda $00,x	                lda 0,x
.b26b		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.b26c		65 27		adc $27		                adc tmp2
.b26e		85 27		sta $27		                sta tmp2
.b270		90 02		bcc $b274	                bcc +
.b272		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.b274						+
.b274		e8		inx		                inx
.b275		e8		inx		                inx
.b276		b5 00		lda $00,x	                lda 0,x
.b278		15 01		ora $01,x	                ora 1,x
.b27a		f0 4e		beq $b2ca	                beq _done
.b27c		a5 27		lda $27		                lda tmp2
.b27e		05 28		ora $28		                ora tmp2+1
.b280		f0 48		beq $b2ca	                beq _done
.b282		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.b284		85 25		sta $25		                sta tmp1
.b286		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.b288		d0 02		bne $b28c	                bne +
.b28a		e6 28		inc $28		                inc tmp2+1
.b28c						+
.b28c		b2 27		lda ($27)	                lda (tmp2)
.b28e		85 26		sta $26		                sta tmp1+1
.b290		20 4a d6	jsr $d64a	                jsr find_header_name
.b293		f0 31		beq $b2c6	                beq _fail_done
.b295		e8		inx		                inx
.b296		e8		inx		                inx
.b297		a5 25		lda $25		                lda tmp1
.b299		95 00		sta $00,x	                sta 0,x
.b29b		a5 26		lda $26		                lda tmp1+1
.b29d		95 01		sta $01,x	                sta 1,x
.b29f		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.b2a2		20 0c 9c	jsr $9c0c	                jsr xt_name_to_int      ; ( nt xt )
.b2a5		20 2e 92	jsr $922e	                jsr xt_swap             ; ( xt nt )
.b2a8		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.b2aa		f6 00		inc $00,x	                inc 0,x
.b2ac		d0 02		bne $b2b0	                bne +
.b2ae		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.b2b0						+
.b2b0		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.b2b2		29 04		and #$04	                and #IM
.b2b4		d0 08		bne $b2be	                bne _immediate          ; bit set, we're immediate
.b2b6		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.b2b8		95 00		sta $00,x	                sta 0,x
.b2ba		95 01		sta $01,x	                sta 1,x
.b2bc		80 0e		bra $b2cc	                bra _done_nodrop
.b2be						_immediate:
.b2be		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.b2c0		95 00		sta $00,x	                sta 0,x
.b2c2		74 01		stz $01,x	                stz 1,x
.b2c4		80 06		bra $b2cc	                bra _done_nodrop
.b2c6						_fail_done:
.b2c6		74 02		stz $02,x	                stz 2,x         ; failure flag
.b2c8		74 03		stz $03,x	                stz 3,x
.b2ca						_done:
.b2ca		e8		inx		                inx
.b2cb		e8		inx		                inx
.b2cc						_done_nodrop:
.b2cc						z_search_wordlist:
.b2cc		60		rts		                rts
.b2cd						xt_set_current:
.b2cd		20 68 d7	jsr $d768	                jsr underflow_1
.b2d0		a0 08		ldy #$08	                ldy #current_offset
.b2d2		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.b2d4		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.b2d6		e8		inx		                inx
.b2d7		e8		inx		                inx
.b2d8		60		rts		z_set_current:  rts
.b2d9						xt_set_order:
.b2d9		a9 ff		lda #$ff	                lda #$FF
.b2db		d5 01		cmp $01,x	                cmp 1,x
.b2dd		d0 12		bne $b2f1	                bne _start
.b2df		d5 00		cmp $00,x	                cmp 0,x
.b2e1		d0 0e		bne $b2f1	                bne _start
.b2e3		ca		dex		                dex             ; Make room for the count.
.b2e4		ca		dex		                dex
.b2e5		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.b2e7		a9 03		lda #$03	                lda #3
.b2e9		95 02		sta $02,x	                sta 2,x
.b2eb		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.b2ed		a9 01		lda #$01	                lda #1
.b2ef		95 00		sta $00,x	                sta 0,x
.b2f1						_start:
.b2f1		a0 22		ldy #$22	                ldy #num_order_offset
.b2f3		b5 00		lda $00,x	                lda 0,x
.b2f5		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.b2f7		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.b2f9		e8		inx		                inx             ; Drop the count off the data stack.
.b2fa		e8		inx		                inx
.b2fb		a5 25		lda $25		                lda tmp1
.b2fd		f0 0d		beq $b30c	                beq _done       ; If zero, there are no wordlists.
.b2ff		a0 23		ldy #$23	                ldy #search_order_offset
.b301						_loop:
.b301		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.b303		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.b305		c8		iny		                iny
.b306		e8		inx		                inx
.b307		e8		inx		                inx
.b308		c6 25		dec $25		                dec tmp1
.b30a		d0 f5		bne $b301	                bne _loop
.b30c						_done:
.b30c		60		rts		z_set_order:    rts
.b30d						xt_to_order:
.b30d		20 6c 93	jsr $936c	                jsr xt_to_r
.b310		20 d0 b1	jsr $b1d0	                jsr xt_get_order
.b313		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.b316		20 2e 92	jsr $922e	                jsr xt_swap
.b319		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.b31c		20 d9 b2	jsr $b2d9	                jsr xt_set_order
.b31f		60		rts		z_to_order:     rts
.b320						xt_wordlist:
.b320		a0 09		ldy #$09	                ldy #num_wordlists_offset
.b322		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.b324		c9 0c		cmp #$0c	                cmp #max_wordlists
.b326		d0 05		bne $b32d	                bne _ok
.b328		a9 0b		lda #$0b	                lda #err_wordlist
.b32a		4c 7e d7	jmp $d77e	                jmp error
.b32d						_ok:
.b32d		1a		inc a		                ina             ; Increment the wordlist#
.b32e		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.b330		ca		dex		                dex             ; and put it on the stack.
.b331		ca		dex		                dex
.b332		95 00		sta $00,x	                sta 0,x
.b334		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.b336		60		rts		z_wordlist:     rts

;******  Return to file: platform/../words/all.asm


;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.b337						cold_zp_table:
>b337	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>b339	0002	1a bb				dp:         .word dictionary_start  ; Dictionary Pointer
>b33b	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>b33d	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>b33f	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>b341	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>b343	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>b345	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>b347	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>b349	0012	2d f0				output:     .word kernel_putc       ; vector for EMIT
>b34b	0014	27 f0				input:      .word kernel_getc       ; vector for KEY
>b34d	0016	00 00				havekey:    .word 0                 ; vector for KEY?  (unused see https://github.com/SamCoVT/TaliForth2/issues/62)
>b34f	0018	0a 00				base:       .word 10                ; number radix, default decimal
>b351	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>b353	001c	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>b355	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>b356	001f					loopctrl:   .byte ?         ; Offset and flags for DO/LOOP/+LOOP control.
>b357	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$100						lcbstack = $100
=256						loopindex = lcbstack+0      ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack+2      ; loop control block offset for limit fudge factor
>b358	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>b35a	0023					tmptos:     .word ?         ; temporary TOS storage
>b35c	0025					tmp1:       .word ?         ; temporary storage
>b35e	0027					tmp2:       .word ?         ; temporary storage
>b360	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>b362	002b					tohold:     .word ?         ; pointer for formatted output
>b364	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>b36c	0035					tmped:      .word ?,?,?     ; temporary for editors
.b355						cold_zp_table_end:
.b355						cold_user_table:
>b355	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>b357	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>b359	0004	00 00				blk_offset:             .word 0         ; BLK
>b35b	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
.b35d	0008					marker_start_offset:
>b35d	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>b35e	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.b35f	000a					wordlists_offset:
>b35f	000a	1a bb				    .word dictionary_start              ; FORTH-WORDLIST
>b361	000c	79 c9				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>b363	000e	c9 c9				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>b365	0010	38 c9				    .word root_dictionary_start         ; ROOT-WORDLIST
>b367	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>b36f	001a	00 00 00 00 00 00 00 00
>b377	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.b378	0023					search_order_offset:
>b378	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>b380	002b	00
.b381	002c					marker_end_offset:
>b381	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>b383	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>b385	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>b387	0032	5d af				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>b389	0034	5d af				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.b38b						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$d0						OpBNE   = $D0
=$f0						OpBEQ   = $F0
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=64						ST = 64 ; Includes stack juggling stripped for native compile
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../opcodes.asm

.b38b						oc_index_table:
>b38b		8b b5 8f b5 36 ba 36 ba		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc07
>b393		97 b5 9d b5 a3 b5 a9 b5
>b39b		b0 b5 b4 b5 ba b5 36 ba		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>b3a3		c0 b5 c4 b5 c8 b5 cc b5
>b3ab		d1 b5 d5 b5 dd b5 36 ba		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>b3b3		e4 b5 ea b5 f1 b5 f8 b5
>b3bb		ff b5 03 b6 09 b6 36 ba		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc1E, oc1F
>b3c3		0f b6 13 b6 19 b6 1f b6
>b3cb		24 b6 28 b6 36 ba 36 ba		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>b3d3		30 b6 36 b6 3c b6 42 b6
>b3db		49 b6 4d b6 53 b6 36 ba		        .word oc28, oc29, oc2A, oc__, oc2C, oc2D, oc2E, oc2F
>b3e3		59 b6 5d b6 62 b6 66 b6
>b3eb		6b b6 6f b6 77 b6 36 ba		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>b3f3		7e b6 86 b6 8d b6 94 b6
>b3fb		9b b6 9f b6 a5 b6 36 ba		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc3F
>b403		ab b6 b1 b6 b7 b6 bd b6
>b40b		c2 b6 c6 b6 36 ba 36 ba		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>b413		36 ba ce b6 d4 b6 da b6
>b41b		e1 b6 e5 b6 eb b6 36 ba		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>b423		f1 b6 f5 b6 f9 b6 fd b6
>b42b		02 b7 06 b7 0e b7 36 ba		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>b433		36 ba 15 b7 1c b7 23 b7
>b43b		2a b7 2e b7 34 b7 36 ba		        .word oc58, oc59, oc5A, oc__, oc__, oc5D, oc5E, oc5F
>b443		36 ba 38 b7 3e b7 44 b7
>b44b		49 b7 4d b7 36 ba 36 ba		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b453		55 b7 5b b7 61 b7 67 b7
>b45b		6e b7 72 b7 78 b7 36 ba		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>b463		7e b7 84 b7 88 b7 8c b7
>b46b		91 b7 95 b7 9d b7 36 ba		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b473		a4 b7 ab b7 b2 b7 b9 b7
>b47b		c0 b7 c4 b7 ca b7 36 ba		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>b483		ce b7 d5 b7 db b7 e1 b7
>b48b		e6 b7 ea b7 36 ba 36 ba		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc87
>b493		f2 b7 f8 b7 fe b7 04 b8
>b49b		0b b8 0f b8 15 b8 36 ba		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>b4a3		19 b8 1d b8 21 b8 25 b8
>b4ab		2a b8 2e b8 36 b8 36 ba		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b4b3		3d b8 44 b8 4b b8 52 b8
>b4bb		59 b8 5d b8 63 b8 36 ba		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>b4c3		67 b8 6b b8 71 b8 77 b8
>b4cb		7c b8 82 b8 8a b8 36 ba		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>b4d3		90 b8 96 b8 9c b8 a2 b8
>b4db		a9 b8 ad b8 b3 b8 36 ba		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>b4e3		b7 b8 bb b8 bf b8 c3 b8
>b4eb		c8 b8 cc b8 d4 b8 36 ba		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>b4f3		db b8 e2 b8 e9 b8 f0 b8
>b4fb		f7 b8 fb b8 01 b9 36 ba		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>b503		05 b9 0b b9 11 b9 17 b9
>b50b		1c b9 22 b9 36 ba 36 ba		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>b513		2a b9 30 b9 36 b9 3c b9
>b51b		43 b9 47 b9 4d b9 36 ba		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>b523		51 b9 55 b9 59 b9 5d b9
>b52b		62 b9 66 b9 6e b9 36 ba		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>b533		36 ba 75 b9 7c b9 83 b9
>b53b		8a b9 8e b9 94 b9 36 ba		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>b543		36 ba 98 b9 9e b9 a4 b9
>b54b		a9 b9 af b9 36 ba 36 ba		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>b553		b7 b9 bd b9 c3 b9 c9 b9
>b55b		d0 b9 d4 b9 da b9 36 ba		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>b563		de b9 e2 b9 e6 b9 ea b9
>b56b		ef b9 f3 b9 fb b9 36 ba		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>b573		36 ba 02 ba 09 ba 10 ba
>b57b		17 ba 1b ba 21 ba 36 ba		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>b583		36 ba 25 ba 2b ba 31 ba
>b58b		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b58f		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b597		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b59d		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b5a3		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b5a9		86 72 6d 62 30 2e 7a			oc07:	.text 2*64+6, "rmb0.z"
>b5b0		43 70 68 70				oc08:	.text 1*64+3, "php"
>b5b4		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b5ba		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>b5c0		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>b5c4		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>b5c8		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>b5cc		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>b5d1		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b5d5		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b5dd		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b5e4		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b5ea		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b5f1		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b5f8		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b5ff		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b603		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b609		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b60f		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b613		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b619		c5 61 73 6c 2e 78			oc1E:	.text 3*64+5, "asl.x"
>b61f		c4 62 62 72 31				oc1F:	.text 3*64+4, "bbr1"
>b624		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b628		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b630		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b636		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b63c		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b642		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b649		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b64d		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b653		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b659		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b65d		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b662		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b666		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b66b		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b66f		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b677		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b67e		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b686		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b68d		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b694		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b69b		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b69f		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b6a5		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b6ab		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b6b1		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b6b7		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b6bd		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b6c2		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b6c6		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b6ce		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b6d4		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b6da		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b6e1		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b6e5		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b6eb		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b6f1		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b6f5		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b6f9		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b6fd		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b702		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b706		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b70e		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b715		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b71c		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b723		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b72a		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b72e		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b734		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b738		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b73e		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b744		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b749		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b74d		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b755		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b75b		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b761		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b767		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b76e		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b772		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b778		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b77e		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b784		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b788		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b78c		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b791		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b795		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b79d		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b7a4		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b7ab		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b7b2		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b7b9		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b7c0		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b7c4		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b7ca		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b7ce		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b7d5		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b7db		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b7e1		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b7e6		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b7ea		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b7f2		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b7f8		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b7fe		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b804		86 73 6d 62 30 2e 7a			oc87:	.text 2*64+6, "smb0.z"
>b80b		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b80f		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b815		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b819		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b81d		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b821		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b825		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b82a		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b82e		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b836		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b83d		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b844		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b84b		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b852		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b859		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b85d		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b863		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b867		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b86b		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b871		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b877		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b87c		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b882		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b88a		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b890		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b896		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b89c		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b8a2		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b8a9		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b8ad		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b8b3		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b8b7		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b8bb		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b8bf		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b8c3		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b8c8		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b8cc		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b8d4		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b8db		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b8e2		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b8e9		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b8f0		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b8f7		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b8fb		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b901		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>b905		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>b90b		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>b911		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>b917		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>b91c		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>b922		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>b92a		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>b930		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>b936		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>b93c		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>b943		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>b947		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>b94d		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>b951		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>b955		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>b959		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>b95d		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>b962		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>b966		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>b96e		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>b975		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>b97c		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>b983		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>b98a		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>b98e		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>b994		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>b998		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>b99e		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>b9a4		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>b9a9		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>b9af		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>b9b7		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>b9bd		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>b9c3		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>b9c9		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>b9d0		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>b9d4		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>b9da		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>b9de		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>b9e2		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>b9e6		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>b9ea		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>b9ef		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>b9f3		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>b9fb		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>ba02		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>ba09		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>ba10		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>ba17		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>ba1b		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>ba21		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>ba25		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>ba2b		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>ba31		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>ba36		01 3f					oc__:	.text 1, "?"

;******  Return to file: platform/../taliforth.asm

.ba38						forth_words_start:
>ba38		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>ba40		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>ba50		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>ba60		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>ba70		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>ba80		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>ba90		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>baa0		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bab0		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>bac0		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>bad0		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>bae0		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>baf0		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bb00		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bb10		78 69 74 29 20 63 72 20
.bb18						forth_words_end:
.bb18						user_words_start:
>bb18		20 20				.binary "user_words.asc"
.bb1a						user_words_end:

;******  Processing file: platform/../words/headers.asm

.bb1a						dictionary_start:
="drop"						    _s := "" ? "" : str(.drop)
>bb1a		04 10				    .byte len(_s), UF
>bb1c		26 bb 9a 86 9f 86		    .word false ? 0 : +, xt_drop, z_drop
>bb22		64 72 6f 70			    .text _s
.bb26						+
="dup"						    _s := "" ? "" : str(.dup)
>bb26		03 10				    .byte len(_s), UF
>bb28		31 bb a0 86 ad 86		    .word false ? 0 : +, xt_dup, z_dup
>bb2e		64 75 70			    .text _s
.bb31						+
="swap"						    _s := "" ? "" : str(.swap)
>bb31		04 10				    .byte len(_s), UF
>bb33		3d bb 2e 92 41 92		    .word false ? 0 : +, xt_swap, z_swap
>bb39		73 77 61 70			    .text _s
.bb3d						+
="!"						    _s := "!" ? "!" : str(.store)
>bb3d		01 10				    .byte len(_s), UF
>bb3f		46 bb 18 92 2d 92		    .word false ? 0 : +, xt_store, z_store
>bb45		21				    .text _s
.bb46						+
="@"						    _s := "@" ? "@" : str(.fetch)
>bb46		01 10				    .byte len(_s), UF
>bb48		4f bb 1a 88 2c 88		    .word false ? 0 : +, xt_fetch, z_fetch
>bb4e		40				    .text _s
.bb4f						+
="over"						    _s := "" ? "" : str(.over)
>bb4f		04 10				    .byte len(_s), UF
>bb51		5b bb 05 8d 12 8d		    .word false ? 0 : +, xt_over, z_over
>bb57		6f 76 65 72			    .text _s
.bb5b						+
=">r"						    _s := ">r" ? ">r" : str(.to_r)
>bb5b		02 51				    .byte len(_s), CO+UF+ST
>bb5d		65 bb 6c 93 81 93		    .word false ? 0 : +, xt_to_r, z_to_r
>bb63		3e 72				    .text _s
.bb65						+
="r>"						    _s := "r>" ? "r>" : str(.r_from)
>bb65		02 41				    .byte len(_s), CO+ST
>bb67		6f bb f0 8e 02 8f		    .word false ? 0 : +, xt_r_from, z_r_from
>bb6d		72 3e				    .text _s
.bb6f						+
="r@"						    _s := "r@" ? "r@" : str(.r_fetch)
>bb6f		02 41				    .byte len(_s), CO+ST
>bb71		79 bb d9 8e ed 8e		    .word false ? 0 : +, xt_r_fetch, z_r_fetch
>bb77		72 40				    .text _s
.bb79						+
="nip"						    _s := "" ? "" : str(.nip)
>bb79		03 10				    .byte len(_s), UF
>bb7b		84 bb 30 8c 3d 8c		    .word false ? 0 : +, xt_nip, z_nip
>bb81		6e 69 70			    .text _s
.bb84						+
="rot"						    _s := "" ? "" : str(.rot)
>bb84		03 10				    .byte len(_s), UF
>bb86		8f bb 91 8f ac 8f		    .word false ? 0 : +, xt_rot, z_rot
>bb8c		72 6f 74			    .text _s
.bb8f						+
="-rot"						    _s := "-rot" ? "-rot" : str(.not_rote)
>bb8f		04 10				    .byte len(_s), UF
>bb91		9b bb 53 9c 6e 9c		    .word false ? 0 : +, xt_not_rote, z_not_rote
>bb97		2d 72 6f 74			    .text _s
.bb9b						+
="tuck"						    _s := "" ? "" : str(.tuck)
>bb9b		04 10				    .byte len(_s), UF
>bb9d		a7 bb 8d 93 a6 93		    .word false ? 0 : +, xt_tuck, z_tuck
>bba3		74 75 63 6b			    .text _s
.bba7						+
=","						    _s := "," ? "," : str(.comma)
>bba7		01 10				    .byte len(_s), UF
>bba9		b0 bb cd 83 db 83		    .word false ? 0 : +, xt_comma, z_comma
>bbaf		2c				    .text _s
.bbb0						+
="c@"						    _s := "c@" ? "c@" : str(.c_fetch)
>bbb0		02 10				    .byte len(_s), UF
>bbb2		ba bb 2d 83 36 83		    .word false ? 0 : +, xt_c_fetch, z_c_fetch
>bbb8		63 40				    .text _s
.bbba						+
="c!"						    _s := "c!" ? "c!" : str(.c_store)
>bbba		02 10				    .byte len(_s), UF
>bbbc		c4 bb 37 83 42 83		    .word false ? 0 : +, xt_c_store, z_c_store
>bbc2		63 21				    .text _s
.bbc4						+
="+!"						    _s := "+!" ? "+!" : str(.plus_store)
>bbc4		02 10				    .byte len(_s), UF
>bbc6		ce bb 66 8e 85 8e		    .word false ? 0 : +, xt_plus_store, z_plus_store
>bbcc		2b 21				    .text _s
.bbce						+
="0"						    _s := "0" ? "0" : str(.zero)
>bbce		01 00				    .byte len(_s), 0
>bbd0		d7 bb cf 9d d5 9d		    .word false ? 0 : +, xt_zero, z_zero
>bbd6		30				    .text _s
.bbd7						+
="1"						    _s := "1" ? "1" : str(.one)
>bbd7		01 00				    .byte len(_s), 0
>bbd9		e0 bb 69 9d 71 9d		    .word false ? 0 : +, xt_one, z_one
>bbdf		31				    .text _s
.bbe0						+
="2"						    _s := "2" ? "2" : str(.two)
>bbe0		01 00				    .byte len(_s), 0
>bbe2		e9 bb 9a 9d a2 9d		    .word false ? 0 : +, xt_two, z_two
>bbe8		32				    .text _s
.bbe9						+
="execute"					    _s := "" ? "" : str(.execute)
>bbe9		07 10				    .byte len(_s), UF
>bbeb		f8 bb 05 88 0b 88		    .word false ? 0 : +, xt_execute, z_execute
>bbf1		65 78 65 63 75 74 65		    .text _s
.bbf8						+
="emit"						    _s := "" ? "" : str(.emit)
>bbf8		04 18				    .byte len(_s), NN+UF
>bbfa		04 bc be 86 c8 86		    .word false ? 0 : +, xt_emit, z_emit
>bc00		65 6d 69 74			    .text _s
.bc04						+
="type"						    _s := "" ? "" : str(.type)
>bc04		04 10				    .byte len(_s), UF
>bc06		10 bc b7 94 e1 94		    .word false ? 0 : +, xt_type, z_type
>bc0c		74 79 70 65			    .text _s
.bc10						+
="."						    _s := "." ? "." : str(.dot)
>bc10		01 10				    .byte len(_s), UF
>bc12		19 bc 30 86 51 86		    .word false ? 0 : +, xt_dot, z_dot
>bc18		2e				    .text _s
.bc19						+
="u."						    _s := "u." ? "u." : str(.u_dot)
>bc19		02 10				    .byte len(_s), UF
>bc1b		23 bc e2 94 ed 94		    .word false ? 0 : +, xt_u_dot, z_u_dot
>bc21		75 2e				    .text _s
.bc23						+
="u.r"						    _s := "u.r" ? "u.r" : str(.u_dot_r)
>bc23		03 10				    .byte len(_s), UF
>bc25		2e bc ee 94 0f 95		    .word false ? 0 : +, xt_u_dot_r, z_u_dot_r
>bc2b		75 2e 72			    .text _s
.bc2e						+
=".r"						    _s := ".r" ? ".r" : str(.dot_r)
>bc2e		02 10				    .byte len(_s), UF
>bc30		38 bc 6c 86 99 86		    .word false ? 0 : +, xt_dot_r, z_dot_r
>bc36		2e 72				    .text _s
.bc38						+
="d."						    _s := "d." ? "d." : str(.d_dot)
>bc38		02 10				    .byte len(_s), UF
>bc3a		42 bc 58 9e 76 9e		    .word false ? 0 : +, xt_d_dot, z_d_dot
>bc40		64 2e				    .text _s
.bc42						+
="d.r"						    _s := "d.r" ? "d.r" : str(.d_dot_r)
>bc42		03 10				    .byte len(_s), UF
>bc44		4d bc 77 9e a1 9e		    .word false ? 0 : +, xt_d_dot_r, z_d_dot_r
>bc4a		64 2e 72			    .text _s
.bc4d						+
="ud."						    _s := "ud." ? "ud." : str(.ud_dot)
>bc4d		03 10				    .byte len(_s), UF
>bc4f		58 bc ee 9e 00 9f		    .word false ? 0 : +, xt_ud_dot, z_ud_dot
>bc55		75 64 2e			    .text _s
.bc58						+
="ud.r"						    _s := "ud.r" ? "ud.r" : str(.ud_dot_r)
>bc58		04 10				    .byte len(_s), UF
>bc5a		64 bc 01 9f 1f 9f		    .word false ? 0 : +, xt_ud_dot_r, z_ud_dot_r
>bc60		75 64 2e 72			    .text _s
.bc64						+
="?"						    _s := "?" ? "?" : str(.question)
>bc64		01 00				    .byte len(_s), 0
>bc66		6d bc fa 98 00 99		    .word false ? 0 : +, xt_question, z_question
>bc6c		3f				    .text _s
.bc6d						+
="false"					    _s := "false" ? "false" : str(.false)
>bc6d		05 00				    .byte len(_s), 0
>bc6f		7a bc cf 9d d5 9d		    .word false ? 0 : +, xt_false, z_false
>bc75		66 61 6c 73 65			    .text _s
.bc7a						+
="true"						    _s := "true" ? "true" : str(.true)
>bc7a		04 00				    .byte len(_s), 0
>bc7c		86 bc 84 93 8c 93		    .word false ? 0 : +, xt_true, z_true
>bc82		74 72 75 65			    .text _s
.bc86						+
="space"					    _s := "" ? "" : str(.space)
>bc86		05 00				    .byte len(_s), 0
>bc88		93 bc cb 91 d0 91		    .word false ? 0 : +, xt_space, z_space
>bc8e		73 70 61 63 65			    .text _s
.bc93						+
="2dup"						    _s := "2dup" ? "2dup" : str(.two_dup)
>bc93		04 10				    .byte len(_s), UF
>bc95		9f bc af 93 c6 93		    .word false ? 0 : +, xt_two_dup, z_two_dup
>bc9b		32 64 75 70			    .text _s
.bc9f						+
="?dup"						    _s := "?dup" ? "?dup" : str(.question_dup)
>bc9f		04 10				    .byte len(_s), UF
>bca1		ab bc c5 8e d8 8e		    .word false ? 0 : +, xt_question_dup, z_question_dup
>bca7		3f 64 75 70			    .text _s
.bcab						+
="+"						    _s := "+" ? "+" : str(.plus)
>bcab		01 10				    .byte len(_s), UF
>bcad		b4 bc 53 8e 65 8e		    .word false ? 0 : +, xt_plus, z_plus
>bcb3		2b				    .text _s
.bcb4						+
="-"						    _s := "-" ? "-" : str(.minus)
>bcb4		01 10				    .byte len(_s), UF
>bcb6		bd bc e4 8b f6 8b		    .word false ? 0 : +, xt_minus, z_minus
>bcbc		2d				    .text _s
.bcbd						+
="1-"						    _s := "1-" ? "1-" : str(.one_minus)
>bcbd		02 10				    .byte len(_s), UF
>bcbf		c7 bc dd 8c e8 8c		    .word false ? 0 : +, xt_one_minus, z_one_minus
>bcc5		31 2d				    .text _s
.bcc7						+
="1+"						    _s := "1+" ? "1+" : str(.one_plus)
>bcc7		02 10				    .byte len(_s), UF
>bcc9		d1 bc e9 8c f2 8c		    .word false ? 0 : +, xt_one_plus, z_one_plus
>bccf		31 2b				    .text _s
.bcd1						+
="2*"						    _s := "2*" ? "2*" : str(.two_star)
>bcd1		02 10				    .byte len(_s), UF
>bcd3		db bc 47 94 4e 94		    .word false ? 0 : +, xt_two_star, z_two_star
>bcd9		32 2a				    .text _s
.bcdb						+
="2/"						    _s := "2/" ? "2/" : str(.two_slash)
>bcdb		02 10				    .byte len(_s), UF
>bcdd		e5 bc 3c 94 46 94		    .word false ? 0 : +, xt_two_slash, z_two_slash
>bce3		32 2f				    .text _s
.bce5						+
="abs"						    _s := "" ? "" : str(.abs)
>bce5		03 10				    .byte len(_s), UF
>bce7		f0 bc cf 80 e3 80		    .word false ? 0 : +, xt_abs, z_abs
>bced		61 62 73			    .text _s
.bcf0						+
="dabs"						    _s := "" ? "" : str(.dabs)
>bcf0		04 10				    .byte len(_s), UF
>bcf2		fc bc 1e 9e 3c 9e		    .word false ? 0 : +, xt_dabs, z_dabs
>bcf8		64 61 62 73			    .text _s
.bcfc						+
="and"						    _s := "" ? "" : str(.and)
>bcfc		03 10				    .byte len(_s), UF
>bcfe		07 bd 90 82 a1 82		    .word false ? 0 : +, xt_and, z_and
>bd04		61 6e 64			    .text _s
.bd07						+
="or"						    _s := "" ? "" : str(.or)
>bd07		02 10				    .byte len(_s), UF
>bd09		11 bd f3 8c 04 8d		    .word false ? 0 : +, xt_or, z_or
>bd0f		6f 72				    .text _s
.bd11						+
="xor"						    _s := "" ? "" : str(.xor)
>bd11		03 10				    .byte len(_s), UF
>bd13		1c bd 62 96 73 96		    .word false ? 0 : +, xt_xor, z_xor
>bd19		78 6f 72			    .text _s
.bd1c						+
="rshift"					    _s := "" ? "" : str(.rshift)
>bd1c		06 10				    .byte len(_s), UF
>bd1e		2a bd ad 8f c0 8f		    .word false ? 0 : +, xt_rshift, z_rshift
>bd24		72 73 68 69 66 74		    .text _s
.bd2a						+
="lshift"					    _s := "" ? "" : str(.lshift)
>bd2a		06 10				    .byte len(_s), UF
>bd2c		38 bd 0d 8b 20 8b		    .word false ? 0 : +, xt_lshift, z_lshift
>bd32		6c 73 68 69 66 74		    .text _s
.bd38						+
="pick"						    _s := "" ? "" : str(.pick)
>bd38		04 00				    .byte len(_s), 0
>bd3a		44 bd 42 8e 52 8e		    .word false ? 0 : +, xt_pick, z_pick
>bd40		70 69 63 6b			    .text _s
.bd44						+
="char"						    _s := "" ? "" : str(.char)
>bd44		04 00				    .byte len(_s), 0
>bd46		50 bd 53 83 69 83		    .word false ? 0 : +, xt_char, z_char
>bd4c		63 68 61 72			    .text _s
.bd50						+
="[char]"					    _s := "[char]" ? "[char]" : str(.bracket_char)
>bd50		06 05				    .byte len(_s), CO+IM
>bd52		5e bd 0d 83 13 83		    .word false ? 0 : +, xt_bracket_char, z_bracket_char
>bd58		5b 63 68 61 72 5d		    .text _s
.bd5e						+
="char+"					    _s := "char+" ? "char+" : str(.char_plus)
>bd5e		05 00				    .byte len(_s), 0
>bd60		6b bd e9 8c f2 8c		    .word false ? 0 : +, xt_char_plus, z_char_plus
>bd66		63 68 61 72 2b			    .text _s
.bd6b						+
="chars"					    _s := "" ? "" : str(.chars)
>bd6b		05 10				    .byte len(_s), UF
>bd6d		78 bd 6a 83 6d 83		    .word false ? 0 : +, xt_chars, z_chars
>bd73		63 68 61 72 73			    .text _s
.bd78						+
="cells"					    _s := "" ? "" : str(.cells)
>bd78		05 00				    .byte len(_s), 0
>bd7a		85 bd 47 94 4e 94		    .word false ? 0 : +, xt_cells, z_cells
>bd80		63 65 6c 6c 73			    .text _s
.bd85						+
="cell+"					    _s := "cell+" ? "cell+" : str(.cell_plus)
>bd85		05 10				    .byte len(_s), UF
>bd87		92 bd 43 83 52 83		    .word false ? 0 : +, xt_cell_plus, z_cell_plus
>bd8d		63 65 6c 6c 2b			    .text _s
.bd92						+
="here"						    _s := "" ? "" : str(.here)
>bd92		04 00				    .byte len(_s), 0
>bd94		9e bd 1b 89 25 89		    .word false ? 0 : +, xt_here, z_here
>bd9a		68 65 72 65			    .text _s
.bd9e						+
="="						    _s := "=" ? "=" : str(.equal)
>bd9e		01 10				    .byte len(_s), UF
>bda0		a7 bd 96 87 b1 87		    .word false ? 0 : +, xt_equal, z_equal
>bda6		3d				    .text _s
.bda7						+
="<>"						    _s := "<>" ? "<>" : str(.not_equals)
>bda7		02 10				    .byte len(_s), UF
>bda9		b1 bd 3e 8c 5b 8c		    .word false ? 0 : +, xt_not_equals, z_not_equals
>bdaf		3c 3e				    .text _s
.bdb1						+
="<"						    _s := "<" ? "<" : str(.less_than)
>bdb1		01 10				    .byte len(_s), UF
>bdb3		ba bd dd 89 f1 89		    .word false ? 0 : +, xt_less_than, z_less_than
>bdb9		3c				    .text _s
.bdba						+
="u<"						    _s := "u<" ? "u<" : str(.u_less_than)
>bdba		02 10				    .byte len(_s), UF
>bdbc		c4 bd 26 95 3b 95		    .word false ? 0 : +, xt_u_less_than, z_u_less_than
>bdc2		75 3c				    .text _s
.bdc4						+
="u>"						    _s := "u>" ? "u>" : str(.u_greater_than)
>bdc4		02 10				    .byte len(_s), UF
>bdc6		ce bd 10 95 25 95		    .word false ? 0 : +, xt_u_greater_than, z_u_greater_than
>bdcc		75 3e				    .text _s
.bdce						+
=">"						    _s := ">" ? ">" : str(.greater_than)
>bdce		01 10				    .byte len(_s), UF
>bdd0		d7 bd 06 89 1a 89		    .word false ? 0 : +, xt_greater_than, z_greater_than
>bdd6		3e				    .text _s
.bdd7						+
="0="						    _s := "0=" ? "0=" : str(.zero_equal)
>bdd7		02 10				    .byte len(_s), UF
>bdd9		e1 bd 74 96 85 96		    .word false ? 0 : +, xt_zero_equal, z_zero_equal
>bddf		30 3d				    .text _s
.bde1						+
="0<>"						    _s := "0<>" ? "0<>" : str(.zero_unequal)
>bde1		03 10				    .byte len(_s), UF
>bde3		ec bd aa 96 b9 96		    .word false ? 0 : +, xt_zero_unequal, z_zero_unequal
>bde9		30 3c 3e			    .text _s
.bdec						+
="0>"						    _s := "0>" ? "0>" : str(.zero_greater)
>bdec		02 10				    .byte len(_s), UF
>bdee		f6 bd 86 96 99 96		    .word false ? 0 : +, xt_zero_greater, z_zero_greater
>bdf4		30 3e				    .text _s
.bdf6						+
="0<"						    _s := "0<" ? "0<" : str(.zero_less)
>bdf6		02 10				    .byte len(_s), UF
>bdf8		00 be 9a 96 a9 96		    .word false ? 0 : +, xt_zero_less, z_zero_less
>bdfe		30 3c				    .text _s
.be00						+
="min"						    _s := "" ? "" : str(.min)
>be00		03 10				    .byte len(_s), UF
>be02		0b be c8 8b e3 8b		    .word false ? 0 : +, xt_min, z_min
>be08		6d 69 6e			    .text _s
.be0b						+
="max"						    _s := "" ? "" : str(.max)
>be0b		03 10				    .byte len(_s), UF
>be0d		16 be ac 8b c7 8b		    .word false ? 0 : +, xt_max, z_max
>be13		6d 61 78			    .text _s
.be16						+
="2drop"					    _s := "2drop" ? "2drop" : str(.two_drop)
>be16		05 10				    .byte len(_s), UF
>be18		23 be a7 93 ae 93		    .word false ? 0 : +, xt_two_drop, z_two_drop
>be1e		32 64 72 6f 70			    .text _s
.be23						+
="2swap"					    _s := "2swap" ? "2swap" : str(.two_swap)
>be23		05 10				    .byte len(_s), UF
>be25		30 be 75 94 98 94		    .word false ? 0 : +, xt_two_swap, z_two_swap
>be2b		32 73 77 61 70			    .text _s
.be30						+
="2over"					    _s := "2over" ? "2over" : str(.two_over)
>be30		05 10				    .byte len(_s), UF
>be32		3d be e9 93 00 94		    .word false ? 0 : +, xt_two_over, z_two_over
>be38		32 6f 76 65 72			    .text _s
.be3d						+
="2!"						    _s := "2!" ? "2!" : str(.two_store)
>be3d		02 10				    .byte len(_s), UF
>be3f		47 be 4f 94 74 94		    .word false ? 0 : +, xt_two_store, z_two_store
>be45		32 21				    .text _s
.be47						+
="2@"						    _s := "2@" ? "2@" : str(.two_fetch)
>be47		02 10				    .byte len(_s), UF
>be49		51 be c7 93 e8 93		    .word false ? 0 : +, xt_two_fetch, z_two_fetch
>be4f		32 40				    .text _s
.be51						+
="2variable"					    _s := "2variable" ? "2variable" : str(.two_variable)
>be51		09 00				    .byte len(_s), 0
>be53		62 be df 9e ed 9e		    .word false ? 0 : +, xt_two_variable, z_two_variable
>be59		32 76 61 72 69 61 62 6c		    .text _s
>be61		65
.be62						+
="2constant"					    _s := "2constant" ? "2constant" : str(.two_constant)
>be62		09 10				    .byte len(_s), UF
>be64		73 be a2 9e c6 9e		    .word false ? 0 : +, xt_two_constant, z_two_constant
>be6a		32 63 6f 6e 73 74 61 6e		    .text _s
>be72		74
.be73						+
="2literal"					    _s := "2literal" ? "2literal" : str(.two_literal)
>be73		08 14				    .byte len(_s), UF+IM
>be75		83 be c7 9e de 9e		    .word false ? 0 : +, xt_two_literal, z_two_literal
>be7b		32 6c 69 74 65 72 61 6c		    .text _s
.be83						+
="2r@"						    _s := "2r@" ? "2r@" : str(.two_r_fetch)
>be83		03 49				    .byte len(_s), CO+NN+ST
>be85		8e be 01 94 1e 94		    .word false ? 0 : +, xt_two_r_fetch, z_two_r_fetch
>be8b		32 72 40			    .text _s
.be8e						+
="2r>"						    _s := "2r>" ? "2r>" : str(.two_r_from)
>be8e		03 41				    .byte len(_s), CO+ST
>be90		99 be 21 94 39 94		    .word false ? 0 : +, xt_two_r_from, z_two_r_from
>be96		32 72 3e			    .text _s
.be99						+
="2>r"						    _s := "2>r" ? "2>r" : str(.two_to_r)
>be99		03 51				    .byte len(_s), CO+UF+ST
>be9b		a4 be 99 94 b4 94		    .word false ? 0 : +, xt_two_to_r, z_two_to_r
>bea1		32 3e 72			    .text _s
.bea4						+
="invert"					    _s := "" ? "" : str(.invert)
>bea4		06 10				    .byte len(_s), UF
>bea6		b2 be 64 89 73 89		    .word false ? 0 : +, xt_invert, z_invert
>beac		69 6e 76 65 72 74		    .text _s
.beb2						+
="negate"					    _s := "" ? "" : str(.negate)
>beb2		06 10				    .byte len(_s), UF
>beb4		c0 be 1f 8c 2f 8c		    .word false ? 0 : +, xt_negate, z_negate
>beba		6e 65 67 61 74 65		    .text _s
.bec0						+
="dnegate"					    _s := "" ? "" : str(.dnegate)
>bec0		07 10				    .byte len(_s), UF
>bec2		cf be 3d 9e 57 9e		    .word false ? 0 : +, xt_dnegate, z_dnegate
>bec8		64 6e 65 67 61 74 65		    .text _s
.becf						+
="c,"						    _s := "c," ? "c," : str(.c_comma)
>becf		02 10				    .byte len(_s), UF
>bed1		d9 be 22 83 2c 83		    .word false ? 0 : +, xt_c_comma, z_c_comma
>bed7		63 2c				    .text _s
.bed9						+
="bounds"					    _s := "" ? "" : str(.bounds)
>bed9		06 10				    .byte len(_s), UF
>bedb		e7 be 0c 9a 24 9a		    .word false ? 0 : +, xt_bounds, z_bounds
>bee1		62 6f 75 6e 64 73		    .text _s
.bee7						+
="spaces"					    _s := "" ? "" : str(.spaces)
>bee7		06 10				    .byte len(_s), UF
>bee9		f5 be d1 91 ea 91		    .word false ? 0 : +, xt_spaces, z_spaces
>beef		73 70 61 63 65 73		    .text _s
.bef5						+
="bl"						    _s := "" ? "" : str(.bl)
>bef5		02 00				    .byte len(_s), 0
>bef7		ff be 04 83 0c 83		    .word false ? 0 : +, xt_bl, z_bl
>befd		62 6c				    .text _s
.beff						+
="-trailing"					    _s := "-trailing" ? "-trailing" : str(.minus_trailing)
>beff		09 10				    .byte len(_s), UF
>bf01		10 bf 14 a0 50 a0		    .word false ? 0 : +, xt_minus_trailing, z_minus_trailing
>bf07		2d 74 72 61 69 6c 69 6e		    .text _s
>bf0f		67
.bf10						+
="-leading"					    _s := "-leading" ? "-leading" : str(.minus_leading)
>bf10		08 10				    .byte len(_s), UF
>bf12		20 bf fb 9f 13 a0		    .word false ? 0 : +, xt_minus_leading, z_minus_leading
>bf18		2d 6c 65 61 64 69 6e 67		    .text _s
.bf20						+
="/string"					    _s := "/string" ? "/string" : str(.slash_string)
>bf20		07 10				    .byte len(_s), UF
>bf22		2f bf f0 a0 0f a1		    .word false ? 0 : +, xt_slash_string, z_slash_string
>bf28		2f 73 74 72 69 6e 67		    .text _s
.bf2f						+
="refill"					    _s := "" ? "" : str(.refill)
>bf2f		06 00				    .byte len(_s), 0
>bf31		3d bf 42 8f 83 8f		    .word false ? 0 : +, xt_refill, z_refill
>bf37		72 65 66 69 6c 6c		    .text _s
.bf3d						+
="accept"					    _s := "" ? "" : str(.accept)
>bf3d		06 18				    .byte len(_s), UF+NN
>bf3f		4b bf e4 80 dc 81		    .word false ? 0 : +, xt_accept, z_accept
>bf45		61 63 63 65 70 74		    .text _s
.bf4b						+
="input>r"					    _s := "input>r" ? "input>r" : str(.input_to_r)
>bf4b		07 08				    .byte len(_s), NN
>bf4d		5a bf 70 9b 85 9b		    .word false ? 0 : +, xt_input_to_r, z_input_to_r
>bf53		69 6e 70 75 74 3e 72		    .text _s
.bf5a						+
="r>input"					    _s := "r>input" ? "r>input" : str(.r_to_input)
>bf5a		07 08				    .byte len(_s), NN
>bf5c		69 bf 7d 9d 94 9d		    .word false ? 0 : +, xt_r_to_input, z_r_to_input
>bf62		72 3e 69 6e 70 75 74		    .text _s
.bf69						+
="unused"					    _s := "" ? "" : str(.unused)
>bf69		06 00				    .byte len(_s), 0
>bf6b		77 bf d8 95 e7 95		    .word false ? 0 : +, xt_unused, z_unused
>bf71		75 6e 75 73 65 64		    .text _s
.bf77						+
="depth"					    _s := "" ? "" : str(.depth)
>bf77		05 00				    .byte len(_s), 0
>bf79		84 bf 52 85 60 85		    .word false ? 0 : +, xt_depth, z_depth
>bf7f		64 65 70 74 68			    .text _s
.bf84						+
="key"						    _s := "" ? "" : str(.key)
>bf84		03 00				    .byte len(_s), 0
>bf86		8f bf a7 89 b0 89		    .word false ? 0 : +, xt_key, z_key
>bf8c		6b 65 79			    .text _s
.bf8f						+
="allot"					    _s := "" ? "" : str(.allot)
>bf8f		05 10				    .byte len(_s), UF
>bf91		9c bf 27 82 8f 82		    .word false ? 0 : +, xt_allot, z_allot
>bf97		61 6c 6c 6f 74			    .text _s
.bf9c						+
="create"					    _s := "" ? "" : str(.create)
>bf9c		06 00				    .byte len(_s), 0
>bf9e		aa bf 40 84 09 85		    .word false ? 0 : +, xt_create, z_create
>bfa4		63 72 65 61 74 65		    .text _s
.bfaa						+
="does>"					    _s := "does>" ? "does>" : str(.does)
>bfaa		05 05				    .byte len(_s), CO+IM
>bfac		b7 bf ef 85 fd 85		    .word false ? 0 : +, xt_does, z_does
>bfb2		64 6f 65 73 3e			    .text _s
.bfb7						+
="variable"					    _s := "" ? "" : str(.variable)
>bfb7		08 00				    .byte len(_s), 0
>bfb9		c7 bf e8 95 00 96		    .word false ? 0 : +, xt_variable, z_variable
>bfbf		76 61 72 69 61 62 6c 65		    .text _s
.bfc7						+
="constant"					    _s := "" ? "" : str(.constant)
>bfc7		08 10				    .byte len(_s), UF
>bfc9		d7 bf e8 83 25 84		    .word false ? 0 : +, xt_constant, z_constant
>bfcf		63 6f 6e 73 74 61 6e 74		    .text _s
.bfd7						+
="value"					    _s := "" ? "" : str(.value)
>bfd7		05 10				    .byte len(_s), UF
>bfd9		e4 bf e8 83 25 84		    .word false ? 0 : +, xt_value, z_value
>bfdf		76 61 6c 75 65			    .text _s
.bfe4						+
="to"						    _s := "" ? "" : str(.to)
>bfe4		02 0c				    .byte len(_s), NN+IM
>bfe6		ee bf 62 92 9d 92		    .word false ? 0 : +, xt_to, z_to
>bfec		74 6f				    .text _s
.bfee						+
="s>d"						    _s := "s>d" ? "s>d" : str(.s_to_d)
>bfee		03 10				    .byte len(_s), UF
>bff0		f9 bf df 90 f0 90		    .word false ? 0 : +, xt_s_to_d, z_s_to_d
>bff6		73 3e 64			    .text _s
.bff9						+
="d>s"						    _s := "d>s" ? "d>s" : str(.d_to_s)
>bff9		03 10				    .byte len(_s), UF
>bffb		04 c0 18 9e 1d 9e		    .word false ? 0 : +, xt_d_to_s, z_d_to_s
>c001		64 3e 73			    .text _s
.c004						+
="d-"						    _s := "d-" ? "d-" : str(.d_minus)
>c004		02 10				    .byte len(_s), UF
>c006		0e c0 d6 9d f6 9d		    .word false ? 0 : +, xt_d_minus, z_d_minus
>c00c		64 2d				    .text _s
.c00e						+
="d+"						    _s := "d+" ? "d+" : str(.d_plus)
>c00e		02 10				    .byte len(_s), UF
>c010		18 c0 f7 9d 17 9e		    .word false ? 0 : +, xt_d_plus, z_d_plus
>c016		64 2b				    .text _s
.c018						+
="erase"					    _s := "" ? "" : str(.erase)
>c018		05 00				    .byte len(_s), 0
>c01a		25 c0 bc 87 04 88		    .word false ? 0 : +, xt_erase, z_erase
>c020		65 72 61 73 65			    .text _s
.c025						+
="blank"					    _s := "" ? "" : str(.blank)
>c025		05 00				    .byte len(_s), 0
>c027		32 c0 b2 87 04 88		    .word false ? 0 : +, xt_blank, z_blank
>c02d		62 6c 61 6e 6b			    .text _s
.c032						+
="fill"						    _s := "" ? "" : str(.fill)
>c032		04 10				    .byte len(_s), UF
>c034		3e c0 c2 87 04 88		    .word false ? 0 : +, xt_fill, z_fill
>c03a		66 69 6c 6c			    .text _s
.c03e						+
="find-name"					    _s := "find-name" ? "find-name" : str(.find_name)
>c03e		09 10				    .byte len(_s), UF
>c040		4f c0 ce 9a 11 9b		    .word false ? 0 : +, xt_find_name, z_find_name
>c046		66 69 6e 64 2d 6e 61 6d		    .text _s
>c04e		65
.c04f						+
="'"						    _s := "'" ? "'" : str(.tick)
>c04f		01 00				    .byte len(_s), 0
>c051		58 c0 42 92 61 92		    .word false ? 0 : +, xt_tick, z_tick
>c057		27				    .text _s
.c058						+
="[']"						    _s := "[']" ? "[']" : str(.bracket_tick)
>c058		03 05				    .byte len(_s), CO+IM
>c05a		63 c0 14 83 1a 83		    .word false ? 0 : +, xt_bracket_tick, z_bracket_tick
>c060		5b 27 5d			    .text _s
.c063						+
="name>int"					    _s := "name>int" ? "name>int" : str(.name_to_int)
>c063		08 10				    .byte len(_s), UF
>c065		73 c0 0c 9c 28 9c		    .word false ? 0 : +, xt_name_to_int, z_name_to_int
>c06b		6e 61 6d 65 3e 69 6e 74		    .text _s
.c073						+
="int>name"					    _s := "int>name" ? "int>name" : str(.int_to_name)
>c073		08 10				    .byte len(_s), UF
>c075		83 c0 86 9b f6 9b		    .word false ? 0 : +, xt_int_to_name, z_int_to_name
>c07b		69 6e 74 3e 6e 61 6d 65		    .text _s
.c083						+
="name>string"					    _s := "name>string" ? "name>string" : str(.name_to_string)
>c083		0b 10				    .byte len(_s), UF
>c085		96 c0 29 9c 3f 9c		    .word false ? 0 : +, xt_name_to_string, z_name_to_string
>c08b		6e 61 6d 65 3e 73 74 72		    .text _s
>c093		69 6e 67
.c096						+
=">body"					    _s := ">body" ? ">body" : str(.to_body)
>c096		05 10				    .byte len(_s), UF
>c098		a3 c0 9e 92 c0 92		    .word false ? 0 : +, xt_to_body, z_to_body
>c09e		3e 62 6f 64 79			    .text _s
.c0a3						+
="defer"					    _s := "" ? "" : str(.defer)
>c0a3		05 00				    .byte len(_s), 0
>c0a5		b0 c0 11 85 43 85		    .word false ? 0 : +, xt_defer, z_defer
>c0ab		64 65 66 65 72			    .text _s
.c0b0						+
="latestxt"					    _s := "" ? "" : str(.latestxt)
>c0b0		08 00				    .byte len(_s), 0
>c0b2		c0 c0 05 9c 0b 9c		    .word false ? 0 : +, xt_latestxt, z_latestxt
>c0b8		6c 61 74 65 73 74 78 74		    .text _s
.c0c0						+
="latestnt"					    _s := "" ? "" : str(.latestnt)
>c0c0		08 00				    .byte len(_s), 0
>c0c2		d0 c0 f7 9b 04 9c		    .word false ? 0 : +, xt_latestnt, z_latestnt
>c0c8		6c 61 74 65 73 74 6e 74		    .text _s
.c0d0						+
="parse-name"					    _s := "parse-name" ? "parse-name" : str(.parse_name)
>c0d0		0a 08				    .byte len(_s), NN
>c0d2		e2 c0 51 8d 41 8e		    .word false ? 0 : +, xt_parse_name, z_parse_name
>c0d8		70 61 72 73 65 2d 6e 61		    .text _s
>c0e0		6d 65
.c0e2						+
="parse"					    _s := "" ? "" : str(.parse)
>c0e2		05 10				    .byte len(_s), UF
>c0e4		ef c0 ac 8d 41 8e		    .word false ? 0 : +, xt_parse, z_parse
>c0ea		70 61 72 73 65			    .text _s
.c0ef						+
="execute-parsing"				    _s := "execute-parsing" ? "execute-parsing" : str(.execute_parsing)
>c0ef		0f 10				    .byte len(_s), UF
>c0f1		06 c1 a7 9a cd 9a		    .word false ? 0 : +, xt_execute_parsing, z_execute_parsing
>c0f7		65 78 65 63 75 74 65 2d		    .text _s
>c0ff		70 61 72 73 69 6e 67
.c106						+
="source"					    _s := "" ? "" : str(.source)
>c106		06 00				    .byte len(_s), 0
>c108		14 c1 ab 91 bf 91		    .word false ? 0 : +, xt_source, z_source
>c10e		73 6f 75 72 63 65		    .text _s
.c114						+
="source-id"					    _s := "source-id" ? "source-id" : str(.source_id)
>c114		09 00				    .byte len(_s), 0
>c116		25 c1 c0 91 ca 91		    .word false ? 0 : +, xt_source_id, z_source_id
>c11c		73 6f 75 72 63 65 2d 69		    .text _s
>c124		64
.c125						+
=":"						    _s := ":" ? ":" : str(.colon)
>c125		01 00				    .byte len(_s), 0
>c127		2e c1 6e 83 b0 83		    .word false ? 0 : +, xt_colon, z_colon
>c12d		3a				    .text _s
.c12e						+
=";"						    _s := ";" ? ";" : str(.semicolon)
>c12e		01 05				    .byte len(_s), CO+IM
>c130		37 c1 f1 90 4f 91		    .word false ? 0 : +, xt_semicolon, z_semicolon
>c136		3b				    .text _s
.c137						+
=":noname"					    _s := ":noname" ? ":noname" : str(.colon_noname)
>c137		07 00				    .byte len(_s), 0
>c139		46 c1 b1 83 cc 83		    .word false ? 0 : +, xt_colon_noname, z_colon_noname
>c13f		3a 6e 6f 6e 61 6d 65		    .text _s
.c146						+
="compile,"					    _s := "compile," ? "compile," : str(.compile_comma)
>c146		08 18				    .byte len(_s), UF+NN
>c148		56 c1 ba 96 58 97		    .word false ? 0 : +, xt_compile_comma, z_compile_comma
>c14e		63 6f 6d 70 69 6c 65 2c		    .text _s
.c156						+
="["						    _s := "[" ? "[" : str(.left_bracket)
>c156		01 05				    .byte len(_s), IM+CO
>c158		5f c1 ca 89 ce 89		    .word false ? 0 : +, xt_left_bracket, z_left_bracket
>c15e		5b				    .text _s
.c15f						+
="]"						    _s := "]" ? "]" : str(.right_bracket)
>c15f		01 04				    .byte len(_s), IM
>c161		68 c1 8a 8f 90 8f		    .word false ? 0 : +, xt_right_bracket, z_right_bracket
>c167		5d				    .text _s
.c168						+
="literal"					    _s := "literal" ? "literal" : str(.literal)
>c168		07 15				    .byte len(_s), IM+CO+UF
>c16a		77 c1 f2 89 2f 8a		    .word false ? 0 : +, xt_literal, z_literal
>c170		6c 69 74 65 72 61 6c		    .text _s
.c177						+
="sliteral"					    _s := "sliteral" ? "sliteral" : str(.sliteral)
>c177		08 15				    .byte len(_s), CO+IM+UF
>c179		87 c1 10 a1 53 a1		    .word false ? 0 : +, xt_sliteral, z_sliteral
>c17f		73 6c 69 74 65 72 61 6c		    .text _s
.c187						+
='."'						    _s := '."' ? '."' : str(.dot_quote)
>c187		02 05				    .byte len(_s), CO+IM
>c189		91 c1 61 86 6b 86		    .word false ? 0 : +, xt_dot_quote, z_dot_quote
>c18f		2e 22				    .text _s
.c191						+
='s"'						    _s := 's"' ? 's"' : str(.s_quote)
>c191		02 0c				    .byte len(_s), IM+NN
>c193		9b c1 da 8f de 90		    .word false ? 0 : +, xt_s_quote, z_s_quote
>c199		73 22				    .text _s
.c19b						+
='s\"'						    _s := 's\"' ? 's\"' : str(.s_backslash_quote)
>c19b		03 04				    .byte len(_s), IM
>c19d		a6 c1 c1 8f ca 8f		    .word false ? 0 : +, xt_s_backslash_quote, z_s_backslash_quote
>c1a3		73 5c 22			    .text _s
.c1a6						+
="postpone"					    _s := "postpone" ? "postpone" : str(.postpone)
>c1a6		08 05				    .byte len(_s), IM+CO
>c1a8		b6 c1 86 8e c4 8e		    .word false ? 0 : +, xt_postpone, z_postpone
>c1ae		70 6f 73 74 70 6f 6e 65		    .text _s
.c1b6						+
="immediate"					    _s := "" ? "" : str(.immediate)
>c1b6		09 00				    .byte len(_s), 0
>c1b8		c7 c1 58 89 63 89		    .word false ? 0 : +, xt_immediate, z_immediate
>c1be		69 6d 6d 65 64 69 61 74		    .text _s
>c1c6		65
.c1c7						+
="compile-only"					    _s := "compile-only" ? "compile-only" : str(.compile_only)
>c1c7		0c 00				    .byte len(_s), 0
>c1c9		db c1 dc 83 e7 83		    .word false ? 0 : +, xt_compile_only, z_compile_only
>c1cf		63 6f 6d 70 69 6c 65 2d		    .text _s
>c1d7		6f 6e 6c 79
.c1db						+
="never-native"					    _s := "never-native" ? "never-native" : str(.never_native)
>c1db		0c 00				    .byte len(_s), 0
>c1dd		ef c1 45 9c 52 9c		    .word false ? 0 : +, xt_never_native, z_never_native
>c1e3		6e 65 76 65 72 2d 6e 61		    .text _s
>c1eb		74 69 76 65
.c1ef						+
="always-native"				    _s := "always-native" ? "always-native" : str(.always_native)
>c1ef		0d 00				    .byte len(_s), 0
>c1f1		04 c2 f8 99 05 9a		    .word false ? 0 : +, xt_always_native, z_always_native
>c1f7		61 6c 77 61 79 73 2d 6e		    .text _s
>c1ff		61 74 69 76 65
.c204						+
="allow-native"					    _s := "allow-native" ? "allow-native" : str(.allow_native)
>c204		0c 00				    .byte len(_s), 0
>c206		18 c2 ec 99 f7 99		    .word false ? 0 : +, xt_allow_native, z_allow_native
>c20c		61 6c 6c 6f 77 2d 6e 61		    .text _s
>c214		74 69 76 65
.c218						+
="nc-limit"					    _s := "nc-limit" ? "nc-limit" : str(.nc_limit)
>c218		08 08				    .byte len(_s), NN
>c21a		28 c2 40 9c 45 9c		    .word false ? 0 : +, xt_nc_limit, z_nc_limit
>c220		6e 63 2d 6c 69 6d 69 74		    .text _s
.c228						+
="strip-underflow"				    _s := "strip-underflow" ? "strip-underflow" : str(.strip_underflow)
>c228		0f 08				    .byte len(_s), NN
>c22a		3f c2 95 9d 9a 9d		    .word false ? 0 : +, xt_strip_underflow, z_strip_underflow
>c230		73 74 72 69 70 2d 75 6e		    .text _s
>c238		64 65 72 66 6c 6f 77
.c23f						+
="abort"					    _s := "" ? "" : str(.abort)
>c23f		05 00				    .byte len(_s), 0
>c241		4c c2 5e 80 af 80		    .word false ? 0 : +, xt_abort, z_abort
>c247		61 62 6f 72 74			    .text _s
.c24c						+
='abort"'					    _s := 'abort"' ? 'abort"' : str(.abort_quote)
>c24c		06 0d				    .byte len(_s), CO+IM+NN
>c24e		5a c2 af 80 b9 80		    .word false ? 0 : +, xt_abort_quote, z_abort_quote
>c254		61 62 6f 72 74 22		    .text _s
.c25a						+
="do"						    _s := "" ? "" : str(.do)
>c25a		02 0d				    .byte len(_s), CO+IM+NN
>c25c		64 c2 8b 85 a4 85		    .word false ? 0 : +, xt_do, z_do
>c262		64 6f				    .text _s
.c264						+
="?do"						    _s := "?do" ? "?do" : str(.question_do)
>c264		03 0d				    .byte len(_s), CO+IM+NN
>c266		6f c2 61 85 a4 85		    .word false ? 0 : +, xt_question_do, z_question_do
>c26c		3f 64 6f			    .text _s
.c26f						+
="i"						    _s := "" ? "" : str(.i)
>c26f		01 01				    .byte len(_s), CO
>c271		78 c2 3f 89 53 89		    .word false ? 0 : +, xt_i, z_i
>c277		69				    .text _s
.c278						+
="j"						    _s := "" ? "" : str(.j)
>c278		01 01				    .byte len(_s), CO
>c27a		81 c2 8d 89 a6 89		    .word false ? 0 : +, xt_j, z_j
>c280		6a				    .text _s
.c281						+
="loop"						    _s := "" ? "" : str(.loop)
>c281		04 05				    .byte len(_s), CO+IM
>c283		8d c2 59 8a d1 8a		    .word false ? 0 : +, xt_loop, z_loop
>c289		6c 6f 6f 70			    .text _s
.c28d						+
="+loop"					    _s := "+loop" ? "+loop" : str(.plus_loop)
>c28d		05 05				    .byte len(_s), CO+IM
>c28f		9a c2 6d 8a d1 8a		    .word false ? 0 : +, xt_plus_loop, z_plus_loop
>c295		2b 6c 6f 6f 70			    .text _s
.c29a						+
="exit"						    _s := "" ? "" : str(.exit)
>c29a		04 03				    .byte len(_s), AN+CO
>c29c		a6 c2 19 88 1a 88		    .word false ? 0 : +, xt_exit, z_exit
>c2a2		65 78 69 74			    .text _s
.c2a6						+
="unloop"					    _s := "" ? "" : str(.unloop)
>c2a6		06 01				    .byte len(_s), CO
>c2a8		b4 c2 c4 95 d3 95		    .word false ? 0 : +, xt_unloop, z_unloop
>c2ae		75 6e 6c 6f 6f 70		    .text _s
.c2b4						+
="leave"					    _s := "" ? "" : str(.leave)
>c2b4		05 05				    .byte len(_s), CO+IM
>c2b6		c1 c2 b4 89 c9 89		    .word false ? 0 : +, xt_leave, z_leave
>c2bc		6c 65 61 76 65			    .text _s
.c2c1						+
="recurse"					    _s := "" ? "" : str(.recurse)
>c2c1		07 0d				    .byte len(_s), CO+IM+NN
>c2c3		d0 c2 05 8f 41 8f		    .word false ? 0 : +, xt_recurse, z_recurse
>c2c9		72 65 63 75 72 73 65		    .text _s
.c2d0						+
="quit"						    _s := "" ? "" : str(.quit)
>c2d0		04 00				    .byte len(_s), 0
>c2d2		dc c2 60 80 af 80		    .word false ? 0 : +, xt_quit, z_quit
>c2d8		71 75 69 74			    .text _s
.c2dc						+
="begin"					    _s := "" ? "" : str(.begin)
>c2dc		05 05				    .byte len(_s), CO+IM
>c2de		e9 c2 1b 89 25 89		    .word false ? 0 : +, xt_begin, z_begin
>c2e4		62 65 67 69 6e			    .text _s
.c2e9						+
="again"					    _s := "" ? "" : str(.again)
>c2e9		05 15				    .byte len(_s), CO+IM+UF
>c2eb		f6 c2 1f 82 25 82		    .word false ? 0 : +, xt_again, z_again
>c2f1		61 67 61 69 6e			    .text _s
.c2f6						+
="state"					    _s := "" ? "" : str(.state)
>c2f6		05 00				    .byte len(_s), 0
>c2f8		03 c3 0d 92 17 92		    .word false ? 0 : +, xt_state, z_state
>c2fe		73 74 61 74 65			    .text _s
.c303						+
="evaluate"					    _s := "" ? "" : str(.evaluate)
>c303		08 10				    .byte len(_s), UF
>c305		13 c3 b2 88 05 89		    .word false ? 0 : +, xt_evaluate, z_evaluate
>c30b		65 76 61 6c 75 61 74 65		    .text _s
.c313						+
="base"						    _s := "" ? "" : str(.base)
>c313		04 00				    .byte len(_s), 0
>c315		1f c3 fb 82 03 83		    .word false ? 0 : +, xt_base, z_base
>c31b		62 61 73 65			    .text _s
.c31f						+
="digit?"					    _s := "digit?" ? "digit?" : str(.digit_question)
>c31f		06 10				    .byte len(_s), UF
>c321		2d c3 72 9a a6 9a		    .word false ? 0 : +, xt_digit_question, z_digit_question
>c327		64 69 67 69 74 3f		    .text _s
.c32d						+
="number"					    _s := "" ? "" : str(.number)
>c32d		06 10				    .byte len(_s), UF
>c32f		3b c3 6f 9c 68 9d		    .word false ? 0 : +, xt_number, z_number
>c335		6e 75 6d 62 65 72		    .text _s
.c33b						+
=">number"					    _s := ">number" ? ">number" : str(.to_number)
>c33b		07 10				    .byte len(_s), UF
>c33d		4a c3 cc 92 6b 93		    .word false ? 0 : +, xt_to_number, z_to_number
>c343		3e 6e 75 6d 62 65 72		    .text _s
.c34a						+
="hex"						    _s := "" ? "" : str(.hex)
>c34a		03 00				    .byte len(_s), 0
>c34c		55 c3 26 89 2c 89		    .word false ? 0 : +, xt_hex, z_hex
>c352		68 65 78			    .text _s
.c355						+
="decimal"					    _s := "" ? "" : str(.decimal)
>c355		07 00				    .byte len(_s), 0
>c357		64 c3 0a 85 10 85		    .word false ? 0 : +, xt_decimal, z_decimal
>c35d		64 65 63 69 6d 61 6c		    .text _s
.c364						+
="count"					    _s := "" ? "" : str(.count)
>c364		05 10				    .byte len(_s), UF
>c366		71 c3 26 84 39 84		    .word false ? 0 : +, xt_count, z_count
>c36c		63 6f 75 6e 74			    .text _s
.c371						+
="m*"						    _s := "m*" ? "m*" : str(.m_star)
>c371		02 10				    .byte len(_s), UF
>c373		7b c3 21 8b 3b 8b		    .word false ? 0 : +, xt_m_star, z_m_star
>c379		6d 2a				    .text _s
.c37b						+
="um*"						    _s := "um*" ? "um*" : str(.um_star)
>c37b		03 10				    .byte len(_s), UF
>c37d		86 c3 7e 95 c3 95		    .word false ? 0 : +, xt_um_star, z_um_star
>c383		75 6d 2a			    .text _s
.c386						+
="*"						    _s := "*" ? "*" : str(.star)
>c386		01 10				    .byte len(_s), UF
>c388		8f c3 eb 91 f3 91		    .word false ? 0 : +, xt_star, z_star
>c38e		2a				    .text _s
.c38f						+
="um/mod"					    _s := "um/mod" ? "um/mod" : str(.um_slash_mod)
>c38f		06 10				    .byte len(_s), UF
>c391		9d c3 3c 95 7d 95		    .word false ? 0 : +, xt_um_slash_mod, z_um_slash_mod
>c397		75 6d 2f 6d 6f 64		    .text _s
.c39d						+
="sm/rem"					    _s := "sm/rem" ? "sm/rem" : str(.sm_slash_rem)
>c39d		06 10				    .byte len(_s), UF
>c39f		ab c3 82 91 aa 91		    .word false ? 0 : +, xt_sm_slash_rem, z_sm_slash_rem
>c3a5		73 6d 2f 72 65 6d		    .text _s
.c3ab						+
="fm/mod"					    _s := "fm/mod" ? "fm/mod" : str(.fm_slash_mod)
>c3ab		06 10				    .byte len(_s), UF
>c3ad		b9 c3 75 88 ab 88		    .word false ? 0 : +, xt_fm_slash_mod, z_fm_slash_mod
>c3b3		66 6d 2f 6d 6f 64		    .text _s
.c3b9						+
="/"						    _s := "/" ? "/" : str(.slash)
>c3b9		01 10				    .byte len(_s), UF
>c3bb		c2 c3 65 91 81 91		    .word false ? 0 : +, xt_slash, z_slash
>c3c1		2f				    .text _s
.c3c2						+
="/mod"						    _s := "/mod" ? "/mod" : str(.slash_mod)
>c3c2		04 10				    .byte len(_s), UF
>c3c4		ce c3 6a 91 81 91		    .word false ? 0 : +, xt_slash_mod, z_slash_mod
>c3ca		2f 6d 6f 64			    .text _s
.c3ce						+
="mod"						    _s := "" ? "" : str(.mod)
>c3ce		03 10				    .byte len(_s), UF
>c3d0		d9 c3 f7 8b ff 8b		    .word false ? 0 : +, xt_mod, z_mod
>c3d6		6d 6f 64			    .text _s
.c3d9						+
="*/mod"					    _s := "*/mod" ? "*/mod" : str(.star_slash_mod)
>c3d9		05 10				    .byte len(_s), UF
>c3db		e6 c3 fd 91 0c 92		    .word false ? 0 : +, xt_star_slash_mod, z_star_slash_mod
>c3e1		2a 2f 6d 6f 64			    .text _s
.c3e6						+
="*/"						    _s := "*/" ? "*/" : str(.star_slash)
>c3e6		02 10				    .byte len(_s), UF
>c3e8		f0 c3 f4 91 fc 91		    .word false ? 0 : +, xt_star_slash, z_star_slash
>c3ee		2a 2f				    .text _s
.c3f0						+
="\"						    _s := "\" ? "\" : str(.backslash)
>c3f0		01 04				    .byte len(_s), IM
>c3f2		f9 c3 d0 82 fa 82		    .word false ? 0 : +, xt_backslash, z_backslash
>c3f8		5c				    .text _s
.c3f9						+
="move"						    _s := "" ? "" : str(.move)
>c3f9		04 18				    .byte len(_s), NN+UF
>c3fb		05 c4 00 8c 1e 8c		    .word false ? 0 : +, xt_move, z_move
>c401		6d 6f 76 65			    .text _s
.c405						+
="cmove>"					    _s := "cmove>" ? "cmove>" : str(.cmove_up)
>c405		06 10				    .byte len(_s), UF
>c407		13 c4 5b 9f 95 9f		    .word false ? 0 : +, xt_cmove_up, z_cmove_up
>c40d		63 6d 6f 76 65 3e		    .text _s
.c413						+
="cmove"					    _s := "" ? "" : str(.cmove)
>c413		05 10				    .byte len(_s), UF
>c415		20 c4 20 9f 5a 9f		    .word false ? 0 : +, xt_cmove, z_cmove
>c41b		63 6d 6f 76 65			    .text _s
.c420						+
="pad"						    _s := "" ? "" : str(.pad)
>c420		03 00				    .byte len(_s), 0
>c422		2b c4 13 8d 22 8d		    .word false ? 0 : +, xt_pad, z_pad
>c428		70 61 64			    .text _s
.c42b						+
="cleave"					    _s := "" ? "" : str(.cleave)
>c42b		06 10				    .byte len(_s), UF
>c42d		39 c4 25 9a 71 9a		    .word false ? 0 : +, xt_cleave, z_cleave
>c433		63 6c 65 61 76 65		    .text _s
.c439						+
="hexstore"					    _s := "" ? "" : str(.hexstore)
>c439		08 10				    .byte len(_s), UF
>c43b		49 c4 12 9b 64 9b		    .word false ? 0 : +, xt_hexstore, z_hexstore
>c441		68 65 78 73 74 6f 72 65		    .text _s
.c449						+
="within"					    _s := "" ? "" : str(.within)
>c449		06 10				    .byte len(_s), UF
>c44b		57 c4 08 96 1d 96		    .word false ? 0 : +, xt_within, z_within
>c451		77 69 74 68 69 6e		    .text _s
.c457						+
=">in"						    _s := ">in" ? ">in" : str(.to_in)
>c457		03 00				    .byte len(_s), 0
>c459		62 c4 c1 92 cb 92		    .word false ? 0 : +, xt_to_in, z_to_in
>c45f		3e 69 6e			    .text _s
.c462						+
="<#"						    _s := "<#" ? "<#" : str(.less_number_sign)
>c462		02 00				    .byte len(_s), 0
>c464		6c c4 cf 89 dc 89		    .word false ? 0 : +, xt_less_number_sign, z_less_number_sign
>c46a		3c 23				    .text _s
.c46c						+
="#"						    _s := "#" ? "#" : str(.number_sign)
>c46c		01 10				    .byte len(_s), UF
>c46e		75 c4 5c 8c 90 8c		    .word false ? 0 : +, xt_number_sign, z_number_sign
>c474		23				    .text _s
.c475						+
="#s"						    _s := "#s" ? "#s" : str(.number_sign_s)
>c475		02 10				    .byte len(_s), UF
>c477		7f c4 b3 8c c3 8c		    .word false ? 0 : +, xt_number_sign_s, z_number_sign_s
>c47d		23 73				    .text _s
.c47f						+
="#>"						    _s := "#>" ? "#>" : str(.number_sign_greater)
>c47f		02 10				    .byte len(_s), UF
>c481		89 c4 91 8c b2 8c		    .word false ? 0 : +, xt_number_sign_greater, z_number_sign_greater
>c487		23 3e				    .text _s
.c489						+
="hold"						    _s := "" ? "" : str(.hold)
>c489		04 10				    .byte len(_s), UF
>c48b		95 c4 2d 89 3e 89		    .word false ? 0 : +, xt_hold, z_hold
>c491		68 6f 6c 64			    .text _s
.c495						+
="sign"						    _s := "" ? "" : str(.sign)
>c495		04 10				    .byte len(_s), UF
>c497		a1 c4 50 91 64 91		    .word false ? 0 : +, xt_sign, z_sign
>c49d		73 69 67 6e			    .text _s
.c4a1						+
="output"					    _s := "" ? "" : str(.output)
>c4a1		06 00				    .byte len(_s), 0
>c4a3		af c4 72 9d 7c 9d		    .word false ? 0 : +, xt_output, z_output
>c4a9		6f 75 74 70 75 74		    .text _s
.c4af						+
="input"					    _s := "" ? "" : str(.input)
>c4af		05 00				    .byte len(_s), 0
>c4b1		bc c4 65 9b 6f 9b		    .word false ? 0 : +, xt_input, z_input
>c4b7		69 6e 70 75 74			    .text _s
.c4bc						+
="cr"						    _s := "" ? "" : str(.cr)
>c4bc		02 00				    .byte len(_s), 0
>c4be		c6 c4 3a 84 3f 84		    .word false ? 0 : +, xt_cr, z_cr
>c4c4		63 72				    .text _s
.c4c6						+
="page"						    _s := "" ? "" : str(.page)
>c4c6		04 00				    .byte len(_s), 0
>c4c8		d2 c4 23 8d 40 8d		    .word false ? 0 : +, xt_page, z_page
>c4ce		70 61 67 65			    .text _s
.c4d2						+
="at-xy"					    _s := "at-xy" ? "at-xy" : str(.at_xy)
>c4d2		05 10				    .byte len(_s), UF
>c4d4		df c4 a2 82 cf 82		    .word false ? 0 : +, xt_at_xy, z_at_xy
>c4da		61 74 2d 78 79			    .text _s
.c4df						+
="marker"					    _s := "" ? "" : str(.marker)
>c4df		06 04				    .byte len(_s), IM
>c4e1		ed c4 3c 8b 76 8b		    .word false ? 0 : +, xt_marker, z_marker
>c4e7		6d 61 72 6b 65 72		    .text _s
.c4ed						+
="words"					    _s := "" ? "" : str(.words)
>c4ed		05 00				    .byte len(_s), 0
>c4ef		fa c4 8f 99 eb 99		    .word false ? 0 : +, xt_words, z_words
>c4f5		77 6f 72 64 73			    .text _s
.c4fa						+
="wordsize"					    _s := "" ? "" : str(.wordsize)
>c4fa		08 10				    .byte len(_s), UF
>c4fc		0a c5 ae 9d ce 9d		    .word false ? 0 : +, xt_wordsize, z_wordsize
>c502		77 6f 72 64 73 69 7a 65		    .text _s
.c50a						+
="aligned"					    _s := "" ? "" : str(.aligned)
>c50a		07 00				    .byte len(_s), 0
>c50c		19 c5 26 82 26 82		    .word false ? 0 : +, xt_aligned, z_aligned
>c512		61 6c 69 67 6e 65 64		    .text _s
.c519						+
="align"					    _s := "" ? "" : str(.align)
>c519		05 00				    .byte len(_s), 0
>c51b		26 c5 26 82 26 82		    .word false ? 0 : +, xt_align, z_align
>c521		61 6c 69 67 6e			    .text _s
.c526						+
="bell"						    _s := "" ? "" : str(.bell)
>c526		04 00				    .byte len(_s), 0
>c528		32 c5 06 9a 0b 9a		    .word false ? 0 : +, xt_bell, z_bell
>c52e		62 65 6c 6c			    .text _s
.c532						+
="dump"						    _s := "" ? "" : str(.dump)
>c532		04 10				    .byte len(_s), UF
>c534		3e c5 7f 98 e5 98		    .word false ? 0 : +, xt_dump, z_dump
>c53a		64 75 6d 70			    .text _s
.c53e						+
=".s"						    _s := ".s" ? ".s" : str(.dot_s)
>c53e		02 00				    .byte len(_s), 0
>c540		48 c5 3b 98 7e 98		    .word false ? 0 : +, xt_dot_s, z_dot_s
>c546		2e 73				    .text _s
.c548						+
="disasm"					    _s := "" ? "" : str(.disasm)
>c548		06 10				    .byte len(_s), UF
>c54a		56 c5 7c a1 82 a1		    .word false ? 0 : +, xt_disasm, z_disasm
>c550		64 69 73 61 73 6d		    .text _s
.c556						+
="compare"					    _s := "" ? "" : str(.compare)
>c556		07 10				    .byte len(_s), UF
>c558		65 c5 96 9f fa 9f		    .word false ? 0 : +, xt_compare, z_compare
>c55e		63 6f 6d 70 61 72 65		    .text _s
.c565						+
="search"					    _s := "" ? "" : str(.search)
>c565		06 18				    .byte len(_s), UF+NN
>c567		73 c5 51 a0 ef a0		    .word false ? 0 : +, xt_search, z_search
>c56d		73 65 61 72 63 68		    .text _s
.c573						+
="environment?"					    _s := "environment?" ? "environment?" : str(.environment_q)
>c573		0c 10				    .byte len(_s), UF
>c575		87 c5 dd 86 59 87		    .word false ? 0 : +, xt_environment_q, z_environment_q
>c57b		65 6e 76 69 72 6f 6e 6d		    .text _s
>c583		65 6e 74 3f
.c587						+
="find"						    _s := "" ? "" : str(.find)
>c587		04 10				    .byte len(_s), UF
>c589		93 c5 2d 88 74 88		    .word false ? 0 : +, xt_find, z_find
>c58f		66 69 6e 64			    .text _s
.c593						+
="word"						    _s := "" ? "" : str(.word)
>c593		04 10				    .byte len(_s), UF
>c595		9f c5 1e 96 61 96		    .word false ? 0 : +, xt_word, z_word
>c59b		77 6f 72 64			    .text _s
.c59f						+
="("						    _s := "(" ? "(" : str(.paren)
>c59f		01 04				    .byte len(_s), IM
>c5a1		a8 c5 41 8d 50 8d		    .word false ? 0 : +, xt_paren, z_paren
>c5a7		28				    .text _s
.c5a8						+
=".("						    _s := ".(" ? ".(" : str(.dot_paren)
>c5a8		02 04				    .byte len(_s), IM
>c5aa		b2 c5 52 86 60 86		    .word false ? 0 : +, xt_dot_paren, z_dot_paren
>c5b0		2e 28				    .text _s
.c5b2						+
="if"						    _s := "" ? "" : str(.if)
>c5b2		02 0d				    .byte len(_s), IM+CO+NN
>c5b4		bc c5 54 89 57 89		    .word false ? 0 : +, xt_if, z_if
>c5ba		69 66				    .text _s
.c5bc						+
="then"						    _s := "" ? "" : str(.then)
>c5bc		04 0d				    .byte len(_s), IM+CO+NN
>c5be		c8 c5 b4 86 bd 86		    .word false ? 0 : +, xt_then, z_then
>c5c4		74 68 65 6e			    .text _s
.c5c8						+
="else"						    _s := "" ? "" : str(.else)
>c5c8		04 0d				    .byte len(_s), IM+CO+NN
>c5ca		d4 c5 ae 86 bd 86		    .word false ? 0 : +, xt_else, z_else
>c5d0		65 6c 73 65			    .text _s
.c5d4						+
="repeat"					    _s := "" ? "" : str(.repeat)
>c5d4		06 0d				    .byte len(_s), IM+CO+NN
>c5d6		e2 c5 84 8f 8a 8f		    .word false ? 0 : +, xt_repeat, z_repeat
>c5dc		72 65 70 65 61 74		    .text _s
.c5e2						+
="until"					    _s := "" ? "" : str(.until)
>c5e2		05 0d				    .byte len(_s), IM+CO+NN
>c5e4		ef c5 d4 95 d7 95		    .word false ? 0 : +, xt_until, z_until
>c5ea		75 6e 74 69 6c			    .text _s
.c5ef						+
="while"					    _s := "" ? "" : str(.while)
>c5ef		05 0d				    .byte len(_s), IM+CO+NN
>c5f1		fc c5 01 96 07 96		    .word false ? 0 : +, xt_while, z_while
>c5f7		77 68 69 6c 65			    .text _s
.c5fc						+
="case"						    _s := "" ? "" : str(.case)
>c5fc		04 0d				    .byte len(_s), IM+CO+NN
>c5fe		08 c6 cf 9d d5 9d		    .word false ? 0 : +, xt_case, z_case
>c604		63 61 73 65			    .text _s
.c608						+
="of"						    _s := "" ? "" : str(.of)
>c608		02 0d				    .byte len(_s), IM+CO+NN
>c60a		12 c6 c4 8c dc 8c		    .word false ? 0 : +, xt_of, z_of
>c610		6f 66				    .text _s
.c612						+
="endof"					    _s := "" ? "" : str(.endof)
>c612		05 0d				    .byte len(_s), IM+CO+NN
>c614		1f c6 ae 86 bd 86		    .word false ? 0 : +, xt_endof, z_endof
>c61a		65 6e 64 6f 66			    .text _s
.c61f						+
="endcase"					    _s := "" ? "" : str(.endcase)
>c61f		07 0d				    .byte len(_s), IM+CO+NN
>c621		2e c6 c8 86 dc 86		    .word false ? 0 : +, xt_endcase, z_endcase
>c627		65 6e 64 63 61 73 65		    .text _s
.c62e						+
="defer@"					    _s := "defer@" ? "defer@" : str(.defer_fetch)
>c62e		06 00				    .byte len(_s), 0
>c630		3c c6 44 85 4a 85		    .word false ? 0 : +, xt_defer_fetch, z_defer_fetch
>c636		64 65 66 65 72 40		    .text _s
.c63c						+
="defer!"					    _s := "defer!" ? "defer!" : str(.defer_store)
>c63c		06 00				    .byte len(_s), 0
>c63e		4a c6 4b 85 51 85		    .word false ? 0 : +, xt_defer_store, z_defer_store
>c644		64 65 66 65 72 21		    .text _s
.c64a						+
="is"						    _s := "is" ? "is" : str(.is)
>c64a		02 04				    .byte len(_s), IM
>c64c		54 c6 74 89 8c 89		    .word false ? 0 : +, xt_is, z_is
>c652		69 73				    .text _s
.c654						+
="action-of"					    _s := "action-of" ? "action-of" : str(.action_of)
>c654		09 04				    .byte len(_s), IM
>c656		65 c6 06 82 1e 82		    .word false ? 0 : +, xt_action_of, z_action_of
>c65c		61 63 74 69 6f 6e 2d 6f		    .text _s
>c664		66
.c665						+
="useraddr"					    _s := "useraddr" ? "useraddr" : str(.useraddr)
>c665		08 00				    .byte len(_s), 0
>c667		75 c6 a3 9d ad 9d		    .word false ? 0 : +, xt_useraddr, z_useraddr
>c66d		75 73 65 72 61 64 64 72		    .text _s
.c675						+
="buffer:"					    _s := "buffer:" ? "buffer:" : str(.buffer_colon)
>c675		07 00				    .byte len(_s), 0
>c677		84 c6 1b 83 21 83		    .word false ? 0 : +, xt_buffer_colon, z_buffer_colon
>c67d		62 75 66 66 65 72 3a		    .text _s
.c684						+
="buffstatus"					    _s := "" ? "" : str(.buffstatus)
>c684		0a 00				    .byte len(_s), 0
>c686		96 c6 ab af b0 af		    .word false ? 0 : +, xt_buffstatus, z_buffstatus
>c68c		62 75 66 66 73 74 61 74		    .text _s
>c694		75 73
.c696						+
="buffblocknum"					    _s := "" ? "" : str(.buffblocknum)
>c696		0c 00				    .byte len(_s), 0
>c698		aa c6 75 af 7a af		    .word false ? 0 : +, xt_buffblocknum, z_buffblocknum
>c69e		62 75 66 66 62 6c 6f 63		    .text _s
>c6a6		6b 6e 75 6d
.c6aa						+
="blkbuffer"					    _s := "" ? "" : str(.blkbuffer)
>c6aa		09 00				    .byte len(_s), 0
>c6ac		bb c6 6b ad 78 ad		    .word false ? 0 : +, xt_blkbuffer, z_blkbuffer
>c6b2		62 6c 6b 62 75 66 66 65		    .text _s
>c6ba		72
.c6bb						+
="scr"						    _s := "" ? "" : str(.scr)
>c6bb		03 08				    .byte len(_s), NN
>c6bd		c6 c6 2d b0 32 b0		    .word false ? 0 : +, xt_scr, z_scr
>c6c3		73 63 72			    .text _s
.c6c6						+
="blk"						    _s := "" ? "" : str(.blk)
>c6c6		03 08				    .byte len(_s), NN
>c6c8		d1 c6 66 ad 6b ad		    .word false ? 0 : +, xt_blk, z_blk
>c6ce		62 6c 6b			    .text _s
.c6d1						+
="block-write"					    _s := "block-write" ? "block-write" : str(.block_write)
>c6d1		0b 08				    .byte len(_s), NN
>c6d3		e4 c6 62 af 70 af		    .word false ? 0 : +, xt_block_write, z_block_write
>c6d9		62 6c 6f 63 6b 2d 77 72		    .text _s
>c6e1		69 74 65
.c6e4						+
="block-write-vector"				    _s := "block-write-vector" ? "block-write-vector" : str(.block_write_vector)
>c6e4		12 08				    .byte len(_s), NN
>c6e6		fe c6 70 af 75 af		    .word false ? 0 : +, xt_block_write_vector, z_block_write_vector
>c6ec		62 6c 6f 63 6b 2d 77 72		    .text _s
>c6f4		69 74 65 2d 76 65 63 74 6f 72
.c6fe						+
="block-read"					    _s := "block-read" ? "block-read" : str(.block_read)
>c6fe		0a 28				    .byte len(_s), HC+NN
>c700		10 c7 4a af 58 af		    .word false ? 0 : +, xt_block_read, z_block_read
>c706		62 6c 6f 63 6b 2d 72 65		    .text _s
>c70e		61 64
.c710						+
="block-read-vector"				    _s := "block-read-vector" ? "block-read-vector" : str(.block_read_vector)
>c710		11 28				    .byte len(_s), HC+NN
>c712		29 c7 58 af 5d af		    .word false ? 0 : +, xt_block_read_vector, z_block_read_vector
>c718		62 6c 6f 63 6b 2d 72 65		    .text _s
>c720		61 64 2d 76 65 63 74 6f 72
.c729						+
="save-buffers"					    _s := "save-buffers" ? "save-buffers" : str(.save_buffers)
>c729		0c 00				    .byte len(_s), 0
>c72b		3d c7 12 b0 2c b0		    .word false ? 0 : +, xt_save_buffers, z_save_buffers
>c731		73 61 76 65 2d 62 75 66		    .text _s
>c739		66 65 72 73
.c73d						+
="block"					    _s := "" ? "" : str(.block)
>c73d		05 00				    .byte len(_s), 0
>c73f		4a c7 79 ad cb ad		    .word false ? 0 : +, xt_block, z_block
>c745		62 6c 6f 63 6b			    .text _s
.c74a						+
="update"					    _s := "" ? "" : str(.update)
>c74a		06 00				    .byte len(_s), 0
>c74c		58 c7 77 b0 7f b0		    .word false ? 0 : +, xt_update, z_update
>c752		75 70 64 61 74 65		    .text _s
.c758						+
="buffer"					    _s := "" ? "" : str(.buffer)
>c758		06 00				    .byte len(_s), 0
>c75a		66 c7 7a af aa af		    .word false ? 0 : +, xt_buffer, z_buffer
>c760		62 75 66 66 65 72		    .text _s
.c766						+
="empty-buffers"				    _s := "empty-buffers" ? "empty-buffers" : str(.empty_buffers)
>c766		0d 00				    .byte len(_s), 0
>c768		7b c7 b0 af b6 af		    .word false ? 0 : +, xt_empty_buffers, z_empty_buffers
>c76e		65 6d 70 74 79 2d 62 75		    .text _s
>c776		66 66 65 72 73
.c77b						+
="flush"					    _s := "" ? "" : str(.flush)
>c77b		05 00				    .byte len(_s), 0
>c77d		88 c7 b7 af c0 af		    .word false ? 0 : +, xt_flush, z_flush
>c783		66 6c 75 73 68			    .text _s
.c788						+
="load"						    _s := "" ? "" : str(.load)
>c788		04 10				    .byte len(_s), UF
>c78a		94 c7 ce af 11 b0		    .word false ? 0 : +, xt_load, z_load
>c790		6c 6f 61 64			    .text _s
.c794						+
="thru"						    _s := "" ? "" : str(.thru)
>c794		04 10				    .byte len(_s), UF
>c796		a0 c7 32 b0 76 b0		    .word false ? 0 : +, xt_thru, z_thru
>c79c		74 68 72 75			    .text _s
.c7a0						+
="list"						    _s := "" ? "" : str(.list)
>c7a0		04 10				    .byte len(_s), UF
>c7a2		ac c7 c1 af cd af		    .word false ? 0 : +, xt_list, z_list
>c7a8		6c 69 73 74			    .text _s
.c7ac						+
="block-c65-init"				    _s := "block-c65-init" ? "block-c65-init" : str(.block_c65_init)
>c7ac		0e 00				    .byte len(_s), 0
>c7ae		c2 c7 cc ad 01 ae		    .word false ? 0 : +, xt_block_c65_init, z_block_c65_init
>c7b4		62 6c 6f 63 6b 2d 63 36		    .text _s
>c7bc		35 2d 69 6e 69 74
.c7c2						+
="block-ramdrive-init"				    _s := "block-ramdrive-init" ? "block-ramdrive-init" : str(.block_ramdrive_init)
>c7c2		13 10				    .byte len(_s), UF
>c7c4		dd c7 24 ae 31 ae		    .word false ? 0 : +, xt_block_ramdrive_init, z_block_ramdrive_init
>c7ca		62 6c 6f 63 6b 2d 72 61		    .text _s
>c7d2		6d 64 72 69 76 65 2d 69 6e 69 74
.c7dd						+
="definitions"					    _s := "" ? "" : str(.definitions)
>c7dd		0b 00				    .byte len(_s), 0
>c7df		f0 c7 b5 b1 bd b1		    .word false ? 0 : +, xt_definitions, z_definitions
>c7e5		64 65 66 69 6e 69 74 69		    .text _s
>c7ed		6f 6e 73
.c7f0						+
="wordlist"					    _s := "" ? "" : str(.wordlist)
>c7f0		08 00				    .byte len(_s), 0
>c7f2		00 c8 20 b3 36 b3		    .word false ? 0 : +, xt_wordlist, z_wordlist
>c7f8		77 6f 72 64 6c 69 73 74		    .text _s
.c800						+
="search-wordlist"				    _s := "search-wordlist" ? "search-wordlist" : str(.search_wordlist)
>c800		0f 10				    .byte len(_s), UF
>c802		17 c8 59 b2 cc b2		    .word false ? 0 : +, xt_search_wordlist, z_search_wordlist
>c808		73 65 61 72 63 68 2d 77		    .text _s
>c810		6f 72 64 6c 69 73 74
.c817						+
="set-current"					    _s := "set-current" ? "set-current" : str(.set_current)
>c817		0b 10				    .byte len(_s), UF
>c819		2a c8 cd b2 d8 b2		    .word false ? 0 : +, xt_set_current, z_set_current
>c81f		73 65 74 2d 63 75 72 72		    .text _s
>c827		65 6e 74
.c82a						+
="get-current"					    _s := "get-current" ? "get-current" : str(.get_current)
>c82a		0b 00				    .byte len(_s), 0
>c82c		3d c8 c5 b1 cf b1		    .word false ? 0 : +, xt_get_current, z_get_current
>c832		67 65 74 2d 63 75 72 72		    .text _s
>c83a		65 6e 74
.c83d						+
="set-order"					    _s := "set-order" ? "set-order" : str(.set_order)
>c83d		09 00				    .byte len(_s), 0
>c83f		4e c8 d9 b2 0c b3		    .word false ? 0 : +, xt_set_order, z_set_order
>c845		73 65 74 2d 6f 72 64 65		    .text _s
>c84d		72
.c84e						+
="get-order"					    _s := "get-order" ? "get-order" : str(.get_order)
>c84e		09 00				    .byte len(_s), 0
>c850		5f c8 d0 b1 f8 b1		    .word false ? 0 : +, xt_get_order, z_get_order
>c856		67 65 74 2d 6f 72 64 65		    .text _s
>c85e		72
.c85f						+
="root-wordlist"				    _s := "root-wordlist" ? "root-wordlist" : str(.root_wordlist)
>c85f		0d 00				    .byte len(_s), 0
>c861		74 c8 50 b2 58 b2		    .word false ? 0 : +, xt_root_wordlist, z_root_wordlist
>c867		72 6f 6f 74 2d 77 6f 72		    .text _s
>c86f		64 6c 69 73 74
.c874						+
="assembler-wordlist"				    _s := "assembler-wordlist" ? "assembler-wordlist" : str(.assembler_wordlist)
>c874		12 00				    .byte len(_s), 0
>c876		8e c8 9a 9d a2 9d		    .word false ? 0 : +, xt_assembler_wordlist, z_assembler_wordlist
>c87c		61 73 73 65 6d 62 6c 65		    .text _s
>c884		72 2d 77 6f 72 64 6c 69 73 74
.c88e						+
="editor-wordlist"				    _s := "editor-wordlist" ? "editor-wordlist" : str(.editor_wordlist)
>c88e		0f 00				    .byte len(_s), 0
>c890		a5 c8 69 9d 71 9d		    .word false ? 0 : +, xt_editor_wordlist, z_editor_wordlist
>c896		65 64 69 74 6f 72 2d 77		    .text _s
>c89e		6f 72 64 6c 69 73 74
.c8a5						+
="forth-wordlist"				    _s := "forth-wordlist" ? "forth-wordlist" : str(.forth_wordlist)
>c8a5		0e 00				    .byte len(_s), 0
>c8a7		bb c8 cf 9d d5 9d		    .word false ? 0 : +, xt_forth_wordlist, z_forth_wordlist
>c8ad		66 6f 72 74 68 2d 77 6f		    .text _s
>c8b5		72 64 6c 69 73 74
.c8bb						+
="only"						    _s := "" ? "" : str(.only)
>c8bb		04 00				    .byte len(_s), 0
>c8bd		c7 c8 f9 b1 ff b1		    .word false ? 0 : +, xt_only, z_only
>c8c3		6f 6e 6c 79			    .text _s
.c8c7						+
="also"						    _s := "" ? "" : str(.also)
>c8c7		04 00				    .byte len(_s), 0
>c8c9		d3 c8 a5 b1 b4 b1		    .word false ? 0 : +, xt_also, z_also
>c8cf		61 6c 73 6f			    .text _s
.c8d3						+
="previous"					    _s := "" ? "" : str(.previous)
>c8d3		08 00				    .byte len(_s), 0
>c8d5		e3 c8 43 b2 4f b2		    .word false ? 0 : +, xt_previous, z_previous
>c8db		70 72 65 76 69 6f 75 73		    .text _s
.c8e3						+
=">order"					    _s := ">order" ? ">order" : str(.to_order)
>c8e3		06 00				    .byte len(_s), 0
>c8e5		f1 c8 0d b3 1f b3		    .word false ? 0 : +, xt_to_order, z_to_order
>c8eb		3e 6f 72 64 65 72		    .text _s
.c8f1						+
="order"					    _s := "" ? "" : str(.order)
>c8f1		05 00				    .byte len(_s), 0
>c8f3		fe c8 00 b2 2a b2		    .word false ? 0 : +, xt_order, z_order
>c8f9		6f 72 64 65 72			    .text _s
.c8fe						+
="forth"					    _s := "" ? "" : str(.forth)
>c8fe		05 00				    .byte len(_s), 0
>c900		0b c9 be b1 c4 b1		    .word false ? 0 : +, xt_forth, z_forth
>c906		66 6f 72 74 68			    .text _s
.c90b						+
="see"						    _s := "" ? "" : str(.see)
>c90b		03 08				    .byte len(_s), NN
>c90d		16 c9 01 99 8e 99		    .word false ? 0 : +, xt_see, z_see
>c913		73 65 65			    .text _s
.c916						+
="ed:"						    _s := "ed:" ? "ed:" : str(.ed)
>c916		03 08				    .byte len(_s), NN
>c918		21 c9 73 a7 76 a7		    .word false ? 0 : +, xt_ed, z_ed
>c91e		65 64 3a			    .text _s
.c921						+
="cold"						    _s := "" ? "" : str(.cold)
>c921		04 00				    .byte len(_s), 0
>c923		2d c9 00 80 af 80		    .word false ? 0 : +, xt_cold, z_cold
>c929		63 6f 6c 64			    .text _s
.c92d						+
="bye"						    _s := "" ? "" : str(.bye)
>c92d		03 00				    .byte len(_s), 0
>c92f		00 00 38 98 3b 98		    .word true ? 0 : +, xt_bye, z_bye
>c935		62 79 65			    .text _s
.c938						root_dictionary_start:
.c938						nt_root_set_order:
>c938		09 00				        .byte 9, 0
>c93a		49 c9 d9 b2 0c b3		        .word nt_root_forth, xt_set_order, z_set_order
>c940		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c948		72
.c949						nt_root_forth:
>c949		05 00				        .byte 5, 0
>c94b		56 c9 be b1 c4 b1		        .word nt_root_forth_wordlist, xt_forth, z_forth
>c951		66 6f 72 74 68			        .text "forth"
.c956						nt_root_forth_wordlist:
>c956		0e 00				        .byte 14, 0
>c958		6c c9 cf 9d d5 9d		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>c95e		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c966		72 64 6c 69 73 74
.c96c						nt_root_words:
>c96c		05 00				        .byte 5, 0
>c96e		00 00 8f 99 eb 99		        .word 0000, xt_words, z_words
>c974		77 6f 72 64 73			        .text "words"
.c979						editor_dictionary_start:
.c979						nt_editor_o:
>c979		01 00				        .byte 1, 0
>c97b		82 c9 5f b1 a4 b1		        .word nt_editor_line, xt_editor_o, z_editor_o
>c981		6f				        .text "o"
.c982						nt_editor_line:
>c982		04 10				        .byte 4, UF
>c984		8e c9 46 b1 5e b1		        .word nt_editor_l, xt_editor_line, z_editor_line
>c98a		6c 69 6e 65			        .text "line"
.c98e						nt_editor_l:
>c98e		01 00				        .byte 1, 0
>c990		97 c9 cc b0 45 b1		        .word nt_editor_el, xt_editor_l, z_editor_l
>c996		6c				        .text "l"
.c997						nt_editor_el:
>c997		02 00				        .byte 2, 0
>c999		a1 c9 ba b0 cb b0		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>c99f		65 6c				        .text "el"
.c9a1						nt_editor_erase_screen:
>c9a1		0c 00				        .byte 12, 0
>c9a3		b5 c9 a8 b0 b9 b0		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>c9a9		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>c9b1		72 65 65 6e
.c9b5						nt_editor_enter_screen:
>c9b5		0c 00				        .byte 12, 0
>c9b7		00 00 8c b0 a7 b0		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>c9bd		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>c9c5		72 65 65 6e
.c9c9						assembler_dictionary_start:
.c9c9						nt_asm_adc_h:
>c9c9		05 0c						.byte 5, IM+NN
>c9cb		d6 c9				                .word nt_asm_adc_x
>c9cd		bd a3 c2 a3					.word xt_asm_adc_h, z_asm_adc_h
>c9d1		61 64 63 2e 23					.text "adc.#"
.c9d6						nt_asm_adc_x:
>c9d6		05 0c						.byte 5, IM+NN
>c9d8		e3 c9				                .word nt_asm_adc_y
>c9da		c2 a3 c7 a3					.word xt_asm_adc_x, z_asm_adc_x
>c9de		61 64 63 2e 78					.text "adc.x"
.c9e3						nt_asm_adc_y:
>c9e3		05 0c						.byte 5, IM+NN
>c9e5		f0 c9				                .word nt_asm_adc_z
>c9e7		c7 a3 cc a3					.word xt_asm_adc_y, z_asm_adc_y
>c9eb		61 64 63 2e 79					.text "adc.y"
.c9f0						nt_asm_adc_z:
>c9f0		05 0c						.byte 5, IM+NN
>c9f2		fd c9				                .word nt_asm_adc_zi
>c9f4		cc a3 d1 a3					.word xt_asm_adc_z, z_asm_adc_z
>c9f8		61 64 63 2e 7a					.text "adc.z"
.c9fd						nt_asm_adc_zi:
>c9fd		06 0c						.byte 6, IM+NN
>c9ff		0b ca				                .word nt_asm_adc_ziy
>ca01		d1 a3 d6 a3					.word xt_asm_adc_zi, z_asm_adc_zi
>ca05		61 64 63 2e 7a 69				.text "adc.zi"
.ca0b						nt_asm_adc_ziy:
>ca0b		07 0c						.byte 7, IM+NN
>ca0d		1a ca				                .word nt_asm_adc_zx
>ca0f		d6 a3 db a3					.word xt_asm_adc_ziy, z_asm_adc_ziy
>ca13		61 64 63 2e 7a 69 79				.text "adc.ziy"
.ca1a						nt_asm_adc_zx:
>ca1a		06 0c						.byte 6, IM+NN
>ca1c		28 ca				                .word nt_asm_adc_zxi
>ca1e		db a3 e0 a3					.word xt_asm_adc_zx, z_asm_adc_zx
>ca22		61 64 63 2e 7a 78				.text "adc.zx"
.ca28						nt_asm_adc_zxi:
>ca28		07 0c						.byte 7, IM+NN
>ca2a		37 ca				                .word nt_asm_and
>ca2c		e0 a3 e5 a3					.word xt_asm_adc_zxi, z_asm_adc_zxi
>ca30		61 64 63 2e 7a 78 69				.text "adc.zxi"
.ca37						nt_asm_and:
>ca37		04 0c						.byte 4, IM+NN
>ca39		43 ca				                .word nt_asm_and_h
>ca3b		e5 a3 ea a3					.word xt_asm_and, z_asm_and
>ca3f		61 6e 64 2e					.text "and."
.ca43						nt_asm_and_h:
>ca43		05 0c						.byte 5, IM+NN
>ca45		50 ca				                .word nt_asm_and_x
>ca47		ea a3 ef a3					.word xt_asm_and_h, z_asm_and_h
>ca4b		61 6e 64 2e 23					.text "and.#"
.ca50						nt_asm_and_x:
>ca50		05 0c						.byte 5, IM+NN
>ca52		5d ca				                .word nt_asm_and_y
>ca54		ef a3 f4 a3					.word xt_asm_and_x, z_asm_and_x
>ca58		61 6e 64 2e 78					.text "and.x"
.ca5d						nt_asm_and_y:
>ca5d		05 0c						.byte 5, IM+NN
>ca5f		6a ca				                .word nt_asm_and_z
>ca61		f4 a3 f9 a3					.word xt_asm_and_y, z_asm_and_y
>ca65		61 6e 64 2e 79					.text "and.y"
.ca6a						nt_asm_and_z:
>ca6a		05 0c						.byte 5, IM+NN
>ca6c		77 ca				                .word nt_asm_and_zi
>ca6e		f9 a3 fe a3					.word xt_asm_and_z, z_asm_and_z
>ca72		61 6e 64 2e 7a					.text "and.z"
.ca77						nt_asm_and_zi:
>ca77		06 0c						.byte 6, IM+NN
>ca79		85 ca				                .word nt_asm_and_ziy
>ca7b		fe a3 03 a4					.word xt_asm_and_zi, z_asm_and_zi
>ca7f		61 6e 64 2e 7a 69				.text "and.zi"
.ca85						nt_asm_and_ziy:
>ca85		07 0c						.byte 7, IM+NN
>ca87		94 ca				                .word nt_asm_and_zx
>ca89		03 a4 08 a4					.word xt_asm_and_ziy, z_asm_and_ziy
>ca8d		61 6e 64 2e 7a 69 79				.text "and.ziy"
.ca94						nt_asm_and_zx:
>ca94		06 0c						.byte 6, IM+NN
>ca96		a2 ca				                .word nt_asm_and_zxi
>ca98		08 a4 0d a4					.word xt_asm_and_zx, z_asm_and_zx
>ca9c		61 6e 64 2e 7a 78				.text "and.zx"
.caa2						nt_asm_and_zxi:
>caa2		07 0c						.byte 7, IM+NN
>caa4		b1 ca				                .word nt_asm_asl
>caa6		0d a4 12 a4					.word xt_asm_and_zxi, z_asm_and_zxi
>caaa		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cab1						nt_asm_asl:
>cab1		03 0c						.byte 3, IM+NN
>cab3		bc ca				                .word nt_asm_asl_a
>cab5		12 a4 17 a4					.word xt_asm_asl, z_asm_asl
>cab9		61 73 6c					.text "asl"
.cabc						nt_asm_asl_a:
>cabc		05 0c						.byte 5, IM+NN
>cabe		c9 ca				                .word nt_asm_asl_x
>cac0		17 a4 1c a4					.word xt_asm_asl_a, z_asm_asl_a
>cac4		61 73 6c 2e 61					.text "asl.a"
.cac9						nt_asm_asl_x:
>cac9		05 0c						.byte 5, IM+NN
>cacb		d6 ca				                .word nt_asm_asl_z
>cacd		1c a4 21 a4					.word xt_asm_asl_x, z_asm_asl_x
>cad1		61 73 6c 2e 78					.text "asl.x"
.cad6						nt_asm_asl_z:
>cad6		05 0c						.byte 5, IM+NN
>cad8		e3 ca				                .word nt_asm_asl_zx
>cada		21 a4 26 a4					.word xt_asm_asl_z, z_asm_asl_z
>cade		61 73 6c 2e 7a					.text "asl.z"
.cae3						nt_asm_asl_zx:
>cae3		06 0c						.byte 6, IM+NN
>cae5		f1 ca				                .word nt_asm_bcc
>cae7		26 a4 2b a4					.word xt_asm_asl_zx, z_asm_asl_zx
>caeb		61 73 6c 2e 7a 78				.text "asl.zx"
.caf1						nt_asm_bcc:
>caf1		03 0c						.byte 3, IM+NN
>caf3		fc ca				                .word nt_asm_bcs
>caf5		2b a4 30 a4					.word xt_asm_bcc, z_asm_bcc
>caf9		62 63 63					.text "bcc"
.cafc						nt_asm_bcs:
>cafc		03 0c						.byte 3, IM+NN
>cafe		07 cb				                .word nt_asm_beq
>cb00		30 a4 37 a4					.word xt_asm_bcs, z_asm_bcs
>cb04		62 63 73					.text "bcs"
.cb07						nt_asm_beq:
>cb07		03 0c						.byte 3, IM+NN
>cb09		12 cb				                .word nt_asm_bit
>cb0b		37 a4 3c a4					.word xt_asm_beq, z_asm_beq
>cb0f		62 65 71					.text "beq"
.cb12						nt_asm_bit:
>cb12		03 0c						.byte 3, IM+NN
>cb14		1d cb				                .word nt_asm_bit_h
>cb16		3c a4 41 a4					.word xt_asm_bit, z_asm_bit
>cb1a		62 69 74					.text "bit"
.cb1d						nt_asm_bit_h:
>cb1d		05 0c						.byte 5, IM+NN
>cb1f		2a cb				                .word nt_asm_bit_x
>cb21		41 a4 46 a4					.word xt_asm_bit_h, z_asm_bit_h
>cb25		62 69 74 2e 23					.text "bit.#"
.cb2a						nt_asm_bit_x:
>cb2a		05 0c						.byte 5, IM+NN
>cb2c		37 cb				                .word nt_asm_bit_z
>cb2e		46 a4 4b a4					.word xt_asm_bit_x, z_asm_bit_x
>cb32		62 69 74 2e 78					.text "bit.x"
.cb37						nt_asm_bit_z:
>cb37		05 0c						.byte 5, IM+NN
>cb39		44 cb				                .word nt_asm_bit_zx
>cb3b		4b a4 50 a4					.word xt_asm_bit_z, z_asm_bit_z
>cb3f		62 69 74 2e 7a					.text "bit.z"
.cb44						nt_asm_bit_zx:
>cb44		06 0c						.byte 6, IM+NN
>cb46		52 cb				                .word nt_asm_bmi
>cb48		50 a4 55 a4					.word xt_asm_bit_zx, z_asm_bit_zx
>cb4c		62 69 74 2e 7a 78				.text "bit.zx"
.cb52						nt_asm_bmi:
>cb52		03 0c						.byte 3, IM+NN
>cb54		5d cb				                .word nt_asm_bne
>cb56		55 a4 5a a4					.word xt_asm_bmi, z_asm_bmi
>cb5a		62 6d 69					.text "bmi"
.cb5d						nt_asm_bne:
>cb5d		03 0c						.byte 3, IM+NN
>cb5f		68 cb				                .word nt_asm_bpl
>cb61		5a a4 5f a4					.word xt_asm_bne, z_asm_bne
>cb65		62 6e 65					.text "bne"
.cb68						nt_asm_bpl:
>cb68		03 0c						.byte 3, IM+NN
>cb6a		73 cb				                .word nt_asm_bra
>cb6c		5f a4 64 a4					.word xt_asm_bpl, z_asm_bpl
>cb70		62 70 6c					.text "bpl"
.cb73						nt_asm_bra:
>cb73		03 0c						.byte 3, IM+NN
>cb75		7e cb				                .word nt_asm_brk
>cb77		64 a4 69 a4					.word xt_asm_bra, z_asm_bra
>cb7b		62 72 61					.text "bra"
.cb7e						nt_asm_brk:
>cb7e		03 0c						.byte 3, IM+NN
>cb80		89 cb				                .word nt_asm_bvc
>cb82		69 a4 6e a4					.word xt_asm_brk, z_asm_brk
>cb86		62 72 6b					.text "brk"
.cb89						nt_asm_bvc:
>cb89		03 0c						.byte 3, IM+NN
>cb8b		94 cb				                .word nt_asm_bvs
>cb8d		6e a4 73 a4					.word xt_asm_bvc, z_asm_bvc
>cb91		62 76 63					.text "bvc"
.cb94						nt_asm_bvs:
>cb94		03 0c						.byte 3, IM+NN
>cb96		9f cb				                .word nt_asm_clc
>cb98		73 a4 78 a4					.word xt_asm_bvs, z_asm_bvs
>cb9c		62 76 73					.text "bvs"
.cb9f						nt_asm_clc:
>cb9f		03 0c						.byte 3, IM+NN
>cba1		aa cb				                .word nt_asm_cld
>cba3		78 a4 7d a4					.word xt_asm_clc, z_asm_clc
>cba7		63 6c 63					.text "clc"
.cbaa						nt_asm_cld:
>cbaa		03 0c						.byte 3, IM+NN
>cbac		b5 cb				                .word nt_asm_cli
>cbae		7d a4 82 a4					.word xt_asm_cld, z_asm_cld
>cbb2		63 6c 64					.text "cld"
.cbb5						nt_asm_cli:
>cbb5		03 0c						.byte 3, IM+NN
>cbb7		c0 cb				                .word nt_asm_clv
>cbb9		82 a4 87 a4					.word xt_asm_cli, z_asm_cli
>cbbd		63 6c 69					.text "cli"
.cbc0						nt_asm_clv:
>cbc0		03 0c						.byte 3, IM+NN
>cbc2		cb cb				                .word nt_asm_cmp
>cbc4		87 a4 8c a4					.word xt_asm_clv, z_asm_clv
>cbc8		63 6c 76					.text "clv"
.cbcb						nt_asm_cmp:
>cbcb		03 0c						.byte 3, IM+NN
>cbcd		d6 cb				                .word nt_asm_cmp_h
>cbcf		8c a4 91 a4					.word xt_asm_cmp, z_asm_cmp
>cbd3		63 6d 70					.text "cmp"
.cbd6						nt_asm_cmp_h:
>cbd6		05 0c						.byte 5, IM+NN
>cbd8		e3 cb				                .word nt_asm_cmp_x
>cbda		91 a4 96 a4					.word xt_asm_cmp_h, z_asm_cmp_h
>cbde		63 6d 70 2e 23					.text "cmp.#"
.cbe3						nt_asm_cmp_x:
>cbe3		05 0c						.byte 5, IM+NN
>cbe5		f0 cb				                .word nt_asm_cmp_y
>cbe7		96 a4 9b a4					.word xt_asm_cmp_x, z_asm_cmp_x
>cbeb		63 6d 70 2e 78					.text "cmp.x"
.cbf0						nt_asm_cmp_y:
>cbf0		05 0c						.byte 5, IM+NN
>cbf2		fd cb				                .word nt_asm_cmp_z
>cbf4		9b a4 a0 a4					.word xt_asm_cmp_y, z_asm_cmp_y
>cbf8		63 6d 70 2e 79					.text "cmp.y"
.cbfd						nt_asm_cmp_z:
>cbfd		05 0c						.byte 5, IM+NN
>cbff		0a cc				                .word nt_asm_cmp_zi
>cc01		a0 a4 a5 a4					.word xt_asm_cmp_z, z_asm_cmp_z
>cc05		63 6d 70 2e 7a					.text "cmp.z"
.cc0a						nt_asm_cmp_zi:
>cc0a		06 0c						.byte 6, IM+NN
>cc0c		18 cc				                .word nt_asm_cmp_ziy
>cc0e		a5 a4 aa a4					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cc12		63 6d 70 2e 7a 69				.text "cmp.zi"
.cc18						nt_asm_cmp_ziy:
>cc18		07 0c						.byte 7, IM+NN
>cc1a		27 cc				                .word nt_asm_cmp_zx
>cc1c		aa a4 af a4					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cc20		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cc27						nt_asm_cmp_zx:
>cc27		06 0c						.byte 6, IM+NN
>cc29		35 cc				                .word nt_asm_cmp_zxi
>cc2b		af a4 b4 a4					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cc2f		63 6d 70 2e 7a 78				.text "cmp.zx"
.cc35						nt_asm_cmp_zxi:
>cc35		07 0c						.byte 7, IM+NN
>cc37		44 cc				                .word nt_asm_cpx
>cc39		b4 a4 b9 a4					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cc3d		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cc44						nt_asm_cpx:
>cc44		03 0c						.byte 3, IM+NN
>cc46		4f cc				                .word nt_asm_cpx_h
>cc48		b9 a4 be a4					.word xt_asm_cpx, z_asm_cpx
>cc4c		63 70 78					.text "cpx"
.cc4f						nt_asm_cpx_h:
>cc4f		05 0c						.byte 5, IM+NN
>cc51		5c cc				                .word nt_asm_cpx_z
>cc53		be a4 c3 a4					.word xt_asm_cpx_h, z_asm_cpx_h
>cc57		63 70 78 2e 23					.text "cpx.#"
.cc5c						nt_asm_cpx_z:
>cc5c		05 0c						.byte 5, IM+NN
>cc5e		69 cc				                .word nt_asm_cpy
>cc60		c3 a4 c8 a4					.word xt_asm_cpx_z, z_asm_cpx_z
>cc64		63 70 78 2e 7a					.text "cpx.z"
.cc69						nt_asm_cpy:
>cc69		03 0c						.byte 3, IM+NN
>cc6b		74 cc				                .word nt_asm_cpy_h
>cc6d		c8 a4 cf a4					.word xt_asm_cpy, z_asm_cpy
>cc71		63 70 79					.text "cpy"
.cc74						nt_asm_cpy_h:
>cc74		05 0c						.byte 5, IM+NN
>cc76		81 cc				                .word nt_asm_cpy_z
>cc78		cf a4 d4 a4					.word xt_asm_cpy_h, z_asm_cpy_h
>cc7c		63 70 79 2e 23					.text "cpy.#"
.cc81						nt_asm_cpy_z:
>cc81		05 0c						.byte 5, IM+NN
>cc83		8e cc				                .word nt_asm_dec
>cc85		d4 a4 d9 a4					.word xt_asm_cpy_z, z_asm_cpy_z
>cc89		63 70 79 2e 7a					.text "cpy.z"
.cc8e						nt_asm_dec:
>cc8e		03 0c						.byte 3, IM+NN
>cc90		99 cc				                .word nt_asm_dec_a
>cc92		d9 a4 de a4					.word xt_asm_dec, z_asm_dec
>cc96		64 65 63					.text "dec"
.cc99						nt_asm_dec_a:
>cc99		05 0c						.byte 5, IM+NN
>cc9b		a6 cc				                .word nt_asm_dec_x
>cc9d		de a4 e3 a4					.word xt_asm_dec_a, z_asm_dec_a
>cca1		64 65 63 2e 61					.text "dec.a"
.cca6						nt_asm_dec_x:
>cca6		05 0c						.byte 5, IM+NN
>cca8		b3 cc				                .word nt_asm_dec_z
>ccaa		e3 a4 e8 a4					.word xt_asm_dec_x, z_asm_dec_x
>ccae		64 65 63 2e 78					.text "dec.x"
.ccb3						nt_asm_dec_z:
>ccb3		05 0c						.byte 5, IM+NN
>ccb5		c0 cc				                .word nt_asm_dec_zx
>ccb7		e8 a4 ed a4					.word xt_asm_dec_z, z_asm_dec_z
>ccbb		64 65 63 2e 7a					.text "dec.z"
.ccc0						nt_asm_dec_zx:
>ccc0		06 0c						.byte 6, IM+NN
>ccc2		ce cc				                .word nt_asm_dex
>ccc4		ed a4 f2 a4					.word xt_asm_dec_zx, z_asm_dec_zx
>ccc8		64 65 63 2e 7a 78				.text "dec.zx"
.ccce						nt_asm_dex:
>ccce		03 0c						.byte 3, IM+NN
>ccd0		d9 cc				                .word nt_asm_dey
>ccd2		f2 a4 f7 a4					.word xt_asm_dex, z_asm_dex
>ccd6		64 65 78					.text "dex"
.ccd9						nt_asm_dey:
>ccd9		03 0c						.byte 3, IM+NN
>ccdb		e4 cc				                .word nt_asm_eor
>ccdd		f7 a4 fc a4					.word xt_asm_dey, z_asm_dey
>cce1		64 65 79					.text "dey"
.cce4						nt_asm_eor:
>cce4		03 0c						.byte 3, IM+NN
>cce6		ef cc				                .word nt_asm_eor_h
>cce8		fc a4 01 a5					.word xt_asm_eor, z_asm_eor
>ccec		65 6f 72					.text "eor"
.ccef						nt_asm_eor_h:
>ccef		05 0c						.byte 5, IM+NN
>ccf1		fc cc				                .word nt_asm_eor_x
>ccf3		01 a5 06 a5					.word xt_asm_eor_h, z_asm_eor_h
>ccf7		65 6f 72 2e 23					.text "eor.#"
.ccfc						nt_asm_eor_x:
>ccfc		05 0c						.byte 5, IM+NN
>ccfe		09 cd				                .word nt_asm_eor_y
>cd00		06 a5 0b a5					.word xt_asm_eor_x, z_asm_eor_x
>cd04		65 6f 72 2e 78					.text "eor.x"
.cd09						nt_asm_eor_y:
>cd09		05 0c						.byte 5, IM+NN
>cd0b		16 cd				                .word nt_asm_eor_z
>cd0d		0b a5 10 a5					.word xt_asm_eor_y, z_asm_eor_y
>cd11		65 6f 72 2e 79					.text "eor.y"
.cd16						nt_asm_eor_z:
>cd16		05 0c						.byte 5, IM+NN
>cd18		23 cd				                .word nt_asm_eor_zi
>cd1a		10 a5 15 a5					.word xt_asm_eor_z, z_asm_eor_z
>cd1e		65 6f 72 2e 7a					.text "eor.z"
.cd23						nt_asm_eor_zi:
>cd23		06 0c						.byte 6, IM+NN
>cd25		31 cd				                .word nt_asm_eor_ziy
>cd27		15 a5 1a a5					.word xt_asm_eor_zi, z_asm_eor_zi
>cd2b		65 6f 72 2e 7a 69				.text "eor.zi"
.cd31						nt_asm_eor_ziy:
>cd31		07 0c						.byte 7, IM+NN
>cd33		40 cd				                .word nt_asm_eor_zx
>cd35		1a a5 1f a5					.word xt_asm_eor_ziy, z_asm_eor_ziy
>cd39		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.cd40						nt_asm_eor_zx:
>cd40		06 0c						.byte 6, IM+NN
>cd42		4e cd				                .word nt_asm_eor_zxi
>cd44		1f a5 24 a5					.word xt_asm_eor_zx, z_asm_eor_zx
>cd48		65 6f 72 2e 7a 78				.text "eor.zx"
.cd4e						nt_asm_eor_zxi:
>cd4e		07 0c						.byte 7, IM+NN
>cd50		5d cd				                .word nt_asm_inc
>cd52		24 a5 29 a5					.word xt_asm_eor_zxi, z_asm_eor_zxi
>cd56		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.cd5d						nt_asm_inc:
>cd5d		03 0c						.byte 3, IM+NN
>cd5f		68 cd				                .word nt_asm_inc_a
>cd61		29 a5 2e a5					.word xt_asm_inc, z_asm_inc
>cd65		69 6e 63					.text "inc"
.cd68						nt_asm_inc_a:
>cd68		05 0c						.byte 5, IM+NN
>cd6a		75 cd				                .word nt_asm_inc_x
>cd6c		2e a5 33 a5					.word xt_asm_inc_a, z_asm_inc_a
>cd70		69 6e 63 2e 61					.text "inc.a"
.cd75						nt_asm_inc_x:
>cd75		05 0c						.byte 5, IM+NN
>cd77		82 cd				                .word nt_asm_inc_z
>cd79		33 a5 38 a5					.word xt_asm_inc_x, z_asm_inc_x
>cd7d		69 6e 63 2e 78					.text "inc.x"
.cd82						nt_asm_inc_z:
>cd82		05 0c						.byte 5, IM+NN
>cd84		8f cd				                .word nt_asm_inc_zx
>cd86		38 a5 3d a5					.word xt_asm_inc_z, z_asm_inc_z
>cd8a		69 6e 63 2e 7a					.text "inc.z"
.cd8f						nt_asm_inc_zx:
>cd8f		06 0c						.byte 6, IM+NN
>cd91		9d cd				                .word nt_asm_inx
>cd93		3d a5 42 a5					.word xt_asm_inc_zx, z_asm_inc_zx
>cd97		69 6e 63 2e 7a 78				.text "inc.zx"
.cd9d						nt_asm_inx:
>cd9d		03 0c						.byte 3, IM+NN
>cd9f		a8 cd				                .word nt_asm_iny
>cda1		42 a5 47 a5					.word xt_asm_inx, z_asm_inx
>cda5		69 6e 78					.text "inx"
.cda8						nt_asm_iny:
>cda8		03 0c						.byte 3, IM+NN
>cdaa		b3 cd				                .word nt_asm_jmp
>cdac		47 a5 4c a5					.word xt_asm_iny, z_asm_iny
>cdb0		69 6e 79					.text "iny"
.cdb3						nt_asm_jmp:
>cdb3		03 0c						.byte 3, IM+NN
>cdb5		be cd				                .word nt_asm_jmp_i
>cdb7		4c a5 51 a5					.word xt_asm_jmp, z_asm_jmp
>cdbb		6a 6d 70					.text "jmp"
.cdbe						nt_asm_jmp_i:
>cdbe		05 0c						.byte 5, IM+NN
>cdc0		cb cd				                .word nt_asm_jmp_xi
>cdc2		51 a5 56 a5					.word xt_asm_jmp_i, z_asm_jmp_i
>cdc6		6a 6d 70 2e 69					.text "jmp.i"
.cdcb						nt_asm_jmp_xi:
>cdcb		06 0c						.byte 6, IM+NN
>cdcd		d9 cd				                .word nt_asm_jsr
>cdcf		56 a5 5b a5					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cdd3		6a 6d 70 2e 78 69				.text "jmp.xi"
.cdd9						nt_asm_jsr:
>cdd9		03 0c						.byte 3, IM+NN
>cddb		e4 cd				                .word nt_asm_lda
>cddd		5b a5 60 a5					.word xt_asm_jsr, z_asm_jsr
>cde1		6a 73 72					.text "jsr"
.cde4						nt_asm_lda:
>cde4		03 0c						.byte 3, IM+NN
>cde6		ef cd				                .word nt_asm_lda_h
>cde8		60 a5 65 a5					.word xt_asm_lda, z_asm_lda
>cdec		6c 64 61					.text "lda"
.cdef						nt_asm_lda_h:
>cdef		05 0c						.byte 5, IM+NN
>cdf1		fc cd				                .word nt_asm_lda_x
>cdf3		65 a5 6a a5					.word xt_asm_lda_h, z_asm_lda_h
>cdf7		6c 64 61 2e 23					.text "lda.#"
.cdfc						nt_asm_lda_x:
>cdfc		05 0c						.byte 5, IM+NN
>cdfe		09 ce				                .word nt_asm_lda_y
>ce00		6a a5 6f a5					.word xt_asm_lda_x, z_asm_lda_x
>ce04		6c 64 61 2e 78					.text "lda.x"
.ce09						nt_asm_lda_y:
>ce09		05 0c						.byte 5, IM+NN
>ce0b		16 ce				                .word nt_asm_lda_z
>ce0d		6f a5 74 a5					.word xt_asm_lda_y, z_asm_lda_y
>ce11		6c 64 61 2e 79					.text "lda.y"
.ce16						nt_asm_lda_z:
>ce16		05 0c						.byte 5, IM+NN
>ce18		23 ce				                .word nt_asm_lda_zi
>ce1a		74 a5 79 a5					.word xt_asm_lda_z, z_asm_lda_z
>ce1e		6c 64 61 2e 7a					.text "lda.z"
.ce23						nt_asm_lda_zi:
>ce23		06 0c						.byte 6, IM+NN
>ce25		31 ce				                .word nt_asm_lda_ziy
>ce27		79 a5 7e a5					.word xt_asm_lda_zi, z_asm_lda_zi
>ce2b		6c 64 61 2e 7a 69				.text "lda.zi"
.ce31						nt_asm_lda_ziy:
>ce31		07 0c						.byte 7, IM+NN
>ce33		40 ce				                .word nt_asm_lda_zx
>ce35		7e a5 83 a5					.word xt_asm_lda_ziy, z_asm_lda_ziy
>ce39		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.ce40						nt_asm_lda_zx:
>ce40		06 0c						.byte 6, IM+NN
>ce42		4e ce				                .word nt_asm_lda_zxi
>ce44		83 a5 88 a5					.word xt_asm_lda_zx, z_asm_lda_zx
>ce48		6c 64 61 2e 7a 78				.text "lda.zx"
.ce4e						nt_asm_lda_zxi:
>ce4e		07 0c						.byte 7, IM+NN
>ce50		5d ce				                .word nt_asm_ldx
>ce52		88 a5 8d a5					.word xt_asm_lda_zxi, z_asm_lda_zxi
>ce56		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.ce5d						nt_asm_ldx:
>ce5d		03 0c						.byte 3, IM+NN
>ce5f		68 ce				                .word nt_asm_ldx_h
>ce61		8d a5 92 a5					.word xt_asm_ldx, z_asm_ldx
>ce65		6c 64 78					.text "ldx"
.ce68						nt_asm_ldx_h:
>ce68		05 0c						.byte 5, IM+NN
>ce6a		75 ce				                .word nt_asm_ldx_y
>ce6c		92 a5 97 a5					.word xt_asm_ldx_h, z_asm_ldx_h
>ce70		6c 64 78 2e 23					.text "ldx.#"
.ce75						nt_asm_ldx_y:
>ce75		05 0c						.byte 5, IM+NN
>ce77		82 ce				                .word nt_asm_ldx_z
>ce79		97 a5 9c a5					.word xt_asm_ldx_y, z_asm_ldx_y
>ce7d		6c 64 78 2e 79					.text "ldx.y"
.ce82						nt_asm_ldx_z:
>ce82		05 0c						.byte 5, IM+NN
>ce84		8f ce				                .word nt_asm_ldx_zy
>ce86		9c a5 a1 a5					.word xt_asm_ldx_z, z_asm_ldx_z
>ce8a		6c 64 78 2e 7a					.text "ldx.z"
.ce8f						nt_asm_ldx_zy:
>ce8f		06 0c						.byte 6, IM+NN
>ce91		9d ce				                .word nt_asm_ldy
>ce93		a1 a5 a6 a5					.word xt_asm_ldx_zy, z_asm_ldx_zy
>ce97		6c 64 78 2e 7a 79				.text "ldx.zy"
.ce9d						nt_asm_ldy:
>ce9d		03 0c						.byte 3, IM+NN
>ce9f		a8 ce				                .word nt_asm_ldy_h
>cea1		a6 a5 ab a5					.word xt_asm_ldy, z_asm_ldy
>cea5		6c 64 79					.text "ldy"
.cea8						nt_asm_ldy_h:
>cea8		05 0c						.byte 5, IM+NN
>ceaa		b5 ce				                .word nt_asm_ldy_x
>ceac		ab a5 b0 a5					.word xt_asm_ldy_h, z_asm_ldy_h
>ceb0		6c 64 79 2e 23					.text "ldy.#"
.ceb5						nt_asm_ldy_x:
>ceb5		05 0c						.byte 5, IM+NN
>ceb7		c2 ce				                .word nt_asm_ldy_z
>ceb9		b0 a5 b5 a5					.word xt_asm_ldy_x, z_asm_ldy_x
>cebd		6c 64 79 2e 78					.text "ldy.x"
.cec2						nt_asm_ldy_z:
>cec2		05 0c						.byte 5, IM+NN
>cec4		cf ce				                .word nt_asm_ldy_zx
>cec6		b5 a5 ba a5					.word xt_asm_ldy_z, z_asm_ldy_z
>ceca		6c 64 79 2e 7a					.text "ldy.z"
.cecf						nt_asm_ldy_zx:
>cecf		06 0c						.byte 6, IM+NN
>ced1		dd ce				                .word nt_asm_lsr
>ced3		ba a5 bf a5					.word xt_asm_ldy_zx, z_asm_ldy_zx
>ced7		6c 64 79 2e 7a 78				.text "ldy.zx"
.cedd						nt_asm_lsr:
>cedd		03 0c						.byte 3, IM+NN
>cedf		e8 ce				                .word nt_asm_lsr_a
>cee1		bf a5 c4 a5					.word xt_asm_lsr, z_asm_lsr
>cee5		6c 73 72					.text "lsr"
.cee8						nt_asm_lsr_a:
>cee8		05 0c						.byte 5, IM+NN
>ceea		f5 ce				                .word nt_asm_lsr_x
>ceec		c4 a5 c9 a5					.word xt_asm_lsr_a, z_asm_lsr_a
>cef0		6c 73 72 2e 61					.text "lsr.a"
.cef5						nt_asm_lsr_x:
>cef5		05 0c						.byte 5, IM+NN
>cef7		02 cf				                .word nt_asm_lsr_z
>cef9		c9 a5 ce a5					.word xt_asm_lsr_x, z_asm_lsr_x
>cefd		6c 73 72 2e 78					.text "lsr.x"
.cf02						nt_asm_lsr_z:
>cf02		05 0c						.byte 5, IM+NN
>cf04		0f cf				                .word nt_asm_lsr_zx
>cf06		ce a5 d3 a5					.word xt_asm_lsr_z, z_asm_lsr_z
>cf0a		6c 73 72 2e 7a					.text "lsr.z"
.cf0f						nt_asm_lsr_zx:
>cf0f		06 0c						.byte 6, IM+NN
>cf11		1d cf				                .word nt_asm_nop
>cf13		d3 a5 d8 a5					.word xt_asm_lsr_zx, z_asm_lsr_zx
>cf17		6c 73 72 2e 7a 78				.text "lsr.zx"
.cf1d						nt_asm_nop:
>cf1d		03 0c						.byte 3, IM+NN
>cf1f		28 cf				                .word nt_asm_ora
>cf21		d8 a5 dd a5					.word xt_asm_nop, z_asm_nop
>cf25		6e 6f 70					.text "nop"
.cf28						nt_asm_ora:
>cf28		03 0c						.byte 3, IM+NN
>cf2a		33 cf				                .word nt_asm_ora_h
>cf2c		dd a5 e2 a5					.word xt_asm_ora, z_asm_ora
>cf30		6f 72 61					.text "ora"
.cf33						nt_asm_ora_h:
>cf33		05 0c						.byte 5, IM+NN
>cf35		40 cf				                .word nt_asm_ora_x
>cf37		e2 a5 e7 a5					.word xt_asm_ora_h, z_asm_ora_h
>cf3b		6f 72 61 2e 23					.text "ora.#"
.cf40						nt_asm_ora_x:
>cf40		05 0c						.byte 5, IM+NN
>cf42		4d cf				                .word nt_asm_ora_y
>cf44		e7 a5 ec a5					.word xt_asm_ora_x, z_asm_ora_x
>cf48		6f 72 61 2e 78					.text "ora.x"
.cf4d						nt_asm_ora_y:
>cf4d		05 0c						.byte 5, IM+NN
>cf4f		5a cf				                .word nt_asm_ora_z
>cf51		ec a5 f1 a5					.word xt_asm_ora_y, z_asm_ora_y
>cf55		6f 72 61 2e 79					.text "ora.y"
.cf5a						nt_asm_ora_z:
>cf5a		05 0c						.byte 5, IM+NN
>cf5c		67 cf				                .word nt_asm_ora_zi
>cf5e		f1 a5 f6 a5					.word xt_asm_ora_z, z_asm_ora_z
>cf62		6f 72 61 2e 7a					.text "ora.z"
.cf67						nt_asm_ora_zi:
>cf67		06 0c						.byte 6, IM+NN
>cf69		75 cf				                .word nt_asm_ora_ziy
>cf6b		f6 a5 fd a5					.word xt_asm_ora_zi, z_asm_ora_zi
>cf6f		6f 72 61 2e 7a 69				.text "ora.zi"
.cf75						nt_asm_ora_ziy:
>cf75		07 0c						.byte 7, IM+NN
>cf77		84 cf				                .word nt_asm_ora_zx
>cf79		fd a5 02 a6					.word xt_asm_ora_ziy, z_asm_ora_ziy
>cf7d		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.cf84						nt_asm_ora_zx:
>cf84		06 0c						.byte 6, IM+NN
>cf86		92 cf				                .word nt_asm_ora_zxi
>cf88		02 a6 07 a6					.word xt_asm_ora_zx, z_asm_ora_zx
>cf8c		6f 72 61 2e 7a 78				.text "ora.zx"
.cf92						nt_asm_ora_zxi:
>cf92		07 0c						.byte 7, IM+NN
>cf94		a1 cf				                .word nt_asm_pha
>cf96		07 a6 0c a6					.word xt_asm_ora_zxi, z_asm_ora_zxi
>cf9a		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.cfa1						nt_asm_pha:
>cfa1		03 0c						.byte 3, IM+NN
>cfa3		ac cf				                .word nt_asm_php
>cfa5		0c a6 11 a6					.word xt_asm_pha, z_asm_pha
>cfa9		70 68 61					.text "pha"
.cfac						nt_asm_php:
>cfac		03 0c						.byte 3, IM+NN
>cfae		b7 cf				                .word nt_asm_phx
>cfb0		11 a6 16 a6					.word xt_asm_php, z_asm_php
>cfb4		70 68 70					.text "php"
.cfb7						nt_asm_phx:
>cfb7		03 0c						.byte 3, IM+NN
>cfb9		c2 cf				                .word nt_asm_phy
>cfbb		16 a6 1b a6					.word xt_asm_phx, z_asm_phx
>cfbf		70 68 78					.text "phx"
.cfc2						nt_asm_phy:
>cfc2		03 0c						.byte 3, IM+NN
>cfc4		cd cf				                .word nt_asm_pla
>cfc6		1b a6 20 a6					.word xt_asm_phy, z_asm_phy
>cfca		70 68 79					.text "phy"
.cfcd						nt_asm_pla:
>cfcd		03 0c						.byte 3, IM+NN
>cfcf		d8 cf				                .word nt_asm_plp
>cfd1		20 a6 25 a6					.word xt_asm_pla, z_asm_pla
>cfd5		70 6c 61					.text "pla"
.cfd8						nt_asm_plp:
>cfd8		03 0c						.byte 3, IM+NN
>cfda		e3 cf				                .word nt_asm_plx
>cfdc		25 a6 2a a6					.word xt_asm_plp, z_asm_plp
>cfe0		70 6c 70					.text "plp"
.cfe3						nt_asm_plx:
>cfe3		03 0c						.byte 3, IM+NN
>cfe5		ee cf				                .word nt_asm_ply
>cfe7		2a a6 2f a6					.word xt_asm_plx, z_asm_plx
>cfeb		70 6c 78					.text "plx"
.cfee						nt_asm_ply:
>cfee		03 0c						.byte 3, IM+NN
>cff0		f9 cf				                .word nt_asm_rol
>cff2		2f a6 34 a6					.word xt_asm_ply, z_asm_ply
>cff6		70 6c 79					.text "ply"
.cff9						nt_asm_rol:
>cff9		03 0c						.byte 3, IM+NN
>cffb		04 d0				                .word nt_asm_rol_a
>cffd		34 a6 39 a6					.word xt_asm_rol, z_asm_rol
>d001		72 6f 6c					.text "rol"
.d004						nt_asm_rol_a:
>d004		05 0c						.byte 5, IM+NN
>d006		11 d0				                .word nt_asm_rol_x
>d008		39 a6 3e a6					.word xt_asm_rol_a, z_asm_rol_a
>d00c		72 6f 6c 2e 61					.text "rol.a"
.d011						nt_asm_rol_x:
>d011		05 0c						.byte 5, IM+NN
>d013		1e d0				                .word nt_asm_rol_z
>d015		3e a6 43 a6					.word xt_asm_rol_x, z_asm_rol_x
>d019		72 6f 6c 2e 78					.text "rol.x"
.d01e						nt_asm_rol_z:
>d01e		05 0c						.byte 5, IM+NN
>d020		2b d0				                .word nt_asm_rol_zx
>d022		43 a6 48 a6					.word xt_asm_rol_z, z_asm_rol_z
>d026		72 6f 6c 2e 7a					.text "rol.z"
.d02b						nt_asm_rol_zx:
>d02b		06 0c						.byte 6, IM+NN
>d02d		39 d0				                .word nt_asm_ror
>d02f		48 a6 4d a6					.word xt_asm_rol_zx, z_asm_rol_zx
>d033		72 6f 6c 2e 7a 78				.text "rol.zx"
.d039						nt_asm_ror:
>d039		03 0c						.byte 3, IM+NN
>d03b		44 d0				                .word nt_asm_ror_a
>d03d		4d a6 52 a6					.word xt_asm_ror, z_asm_ror
>d041		72 6f 72					.text "ror"
.d044						nt_asm_ror_a:
>d044		05 0c						.byte 5, IM+NN
>d046		51 d0				                .word nt_asm_ror_x
>d048		52 a6 57 a6					.word xt_asm_ror_a, z_asm_ror_a
>d04c		72 6f 72 2e 61					.text "ror.a"
.d051						nt_asm_ror_x:
>d051		05 0c						.byte 5, IM+NN
>d053		5e d0				                .word nt_asm_ror_z
>d055		57 a6 5c a6					.word xt_asm_ror_x, z_asm_ror_x
>d059		72 6f 72 2e 78					.text "ror.x"
.d05e						nt_asm_ror_z:
>d05e		05 0c						.byte 5, IM+NN
>d060		6b d0				                .word nt_asm_ror_zx
>d062		5c a6 61 a6					.word xt_asm_ror_z, z_asm_ror_z
>d066		72 6f 72 2e 7a					.text "ror.z"
.d06b						nt_asm_ror_zx:
>d06b		06 0c						.byte 6, IM+NN
>d06d		79 d0				                .word nt_asm_rti
>d06f		61 a6 66 a6					.word xt_asm_ror_zx, z_asm_ror_zx
>d073		72 6f 72 2e 7a 78				.text "ror.zx"
.d079						nt_asm_rti:
>d079		03 0c						.byte 3, IM+NN
>d07b		84 d0				                .word nt_asm_rts
>d07d		66 a6 6b a6					.word xt_asm_rti, z_asm_rti
>d081		72 74 69					.text "rti"
.d084						nt_asm_rts:
>d084		03 0c						.byte 3, IM+NN
>d086		8f d0				                .word nt_asm_sbc
>d088		6b a6 70 a6					.word xt_asm_rts, z_asm_rts
>d08c		72 74 73					.text "rts"
.d08f						nt_asm_sbc:
>d08f		03 0c						.byte 3, IM+NN
>d091		9a d0				                .word nt_asm_sbc_h
>d093		70 a6 75 a6					.word xt_asm_sbc, z_asm_sbc
>d097		73 62 63					.text "sbc"
.d09a						nt_asm_sbc_h:
>d09a		05 0c						.byte 5, IM+NN
>d09c		a7 d0				                .word nt_asm_sbc_x
>d09e		75 a6 7a a6					.word xt_asm_sbc_h, z_asm_sbc_h
>d0a2		73 62 63 2e 23					.text "sbc.#"
.d0a7						nt_asm_sbc_x:
>d0a7		05 0c						.byte 5, IM+NN
>d0a9		b4 d0				                .word nt_asm_sbc_y
>d0ab		7a a6 7f a6					.word xt_asm_sbc_x, z_asm_sbc_x
>d0af		73 62 63 2e 78					.text "sbc.x"
.d0b4						nt_asm_sbc_y:
>d0b4		05 0c						.byte 5, IM+NN
>d0b6		c1 d0				                .word nt_asm_sbc_z
>d0b8		7f a6 84 a6					.word xt_asm_sbc_y, z_asm_sbc_y
>d0bc		73 62 63 2e 79					.text "sbc.y"
.d0c1						nt_asm_sbc_z:
>d0c1		05 0c						.byte 5, IM+NN
>d0c3		ce d0				                .word nt_asm_sbc_zi
>d0c5		84 a6 89 a6					.word xt_asm_sbc_z, z_asm_sbc_z
>d0c9		73 62 63 2e 7a					.text "sbc.z"
.d0ce						nt_asm_sbc_zi:
>d0ce		06 0c						.byte 6, IM+NN
>d0d0		dc d0				                .word nt_asm_sbc_ziy
>d0d2		89 a6 8e a6					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d0d6		73 62 63 2e 7a 69				.text "sbc.zi"
.d0dc						nt_asm_sbc_ziy:
>d0dc		07 0c						.byte 7, IM+NN
>d0de		eb d0				                .word nt_asm_sbc_zx
>d0e0		8e a6 93 a6					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d0e4		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d0eb						nt_asm_sbc_zx:
>d0eb		06 0c						.byte 6, IM+NN
>d0ed		f9 d0				                .word nt_asm_sbc_zxi
>d0ef		93 a6 98 a6					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d0f3		73 62 63 2e 7a 78				.text "sbc.zx"
.d0f9						nt_asm_sbc_zxi:
>d0f9		07 0c						.byte 7, IM+NN
>d0fb		08 d1				                .word nt_asm_sec
>d0fd		98 a6 9c a6					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d101		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d108						nt_asm_sec:
>d108		03 0c						.byte 3, IM+NN
>d10a		13 d1				                .word nt_asm_sed
>d10c		9c a6 a0 a6					.word xt_asm_sec, z_asm_sec
>d110		73 65 63					.text "sec"
.d113						nt_asm_sed:
>d113		03 0c						.byte 3, IM+NN
>d115		1e d1				                .word nt_asm_sei
>d117		a0 a6 a4 a6					.word xt_asm_sed, z_asm_sed
>d11b		73 65 64					.text "sed"
.d11e						nt_asm_sei:
>d11e		03 0c						.byte 3, IM+NN
>d120		29 d1				                .word nt_asm_sta
>d122		a4 a6 a8 a6					.word xt_asm_sei, z_asm_sei
>d126		73 65 69					.text "sei"
.d129						nt_asm_sta:
>d129		03 0c						.byte 3, IM+NN
>d12b		34 d1				                .word nt_asm_sta_x
>d12d		a8 a6 ac a6					.word xt_asm_sta, z_asm_sta
>d131		73 74 61					.text "sta"
.d134						nt_asm_sta_x:
>d134		05 0c						.byte 5, IM+NN
>d136		41 d1				                .word nt_asm_sta_y
>d138		ac a6 b0 a6					.word xt_asm_sta_x, z_asm_sta_x
>d13c		73 74 61 2e 78					.text "sta.x"
.d141						nt_asm_sta_y:
>d141		05 0c						.byte 5, IM+NN
>d143		4e d1				                .word nt_asm_sta_z
>d145		b0 a6 b4 a6					.word xt_asm_sta_y, z_asm_sta_y
>d149		73 74 61 2e 79					.text "sta.y"
.d14e						nt_asm_sta_z:
>d14e		05 0c						.byte 5, IM+NN
>d150		5b d1				                .word nt_asm_sta_zi
>d152		b4 a6 b8 a6					.word xt_asm_sta_z, z_asm_sta_z
>d156		73 74 61 2e 7a					.text "sta.z"
.d15b						nt_asm_sta_zi:
>d15b		06 0c						.byte 6, IM+NN
>d15d		69 d1				                .word nt_asm_sta_ziy
>d15f		b8 a6 bc a6					.word xt_asm_sta_zi, z_asm_sta_zi
>d163		73 74 61 2e 7a 69				.text "sta.zi"
.d169						nt_asm_sta_ziy:
>d169		07 0c						.byte 7, IM+NN
>d16b		78 d1				                .word nt_asm_sta_zx
>d16d		bc a6 c0 a6					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d171		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d178						nt_asm_sta_zx:
>d178		06 0c						.byte 6, IM+NN
>d17a		86 d1				                .word nt_asm_sta_zxi
>d17c		c0 a6 c4 a6					.word xt_asm_sta_zx, z_asm_sta_zx
>d180		73 74 61 2e 7a 78				.text "sta.zx"
.d186						nt_asm_sta_zxi:
>d186		07 0c						.byte 7, IM+NN
>d188		95 d1				                .word nt_asm_stx
>d18a		c4 a6 c8 a6					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d18e		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d195						nt_asm_stx:
>d195		03 0c						.byte 3, IM+NN
>d197		a0 d1				                .word nt_asm_stx_z
>d199		c8 a6 cc a6					.word xt_asm_stx, z_asm_stx
>d19d		73 74 78					.text "stx"
.d1a0						nt_asm_stx_z:
>d1a0		05 0c						.byte 5, IM+NN
>d1a2		ad d1				                .word nt_asm_stx_zy
>d1a4		cc a6 d0 a6					.word xt_asm_stx_z, z_asm_stx_z
>d1a8		73 74 78 2e 7a					.text "stx.z"
.d1ad						nt_asm_stx_zy:
>d1ad		06 0c						.byte 6, IM+NN
>d1af		bb d1				                .word nt_asm_sty
>d1b1		d0 a6 d4 a6					.word xt_asm_stx_zy, z_asm_stx_zy
>d1b5		73 74 78 2e 7a 79				.text "stx.zy"
.d1bb						nt_asm_sty:
>d1bb		03 0c						.byte 3, IM+NN
>d1bd		c6 d1				                .word nt_asm_sty_z
>d1bf		d4 a6 d8 a6					.word xt_asm_sty, z_asm_sty
>d1c3		73 74 79					.text "sty"
.d1c6						nt_asm_sty_z:
>d1c6		05 0c						.byte 5, IM+NN
>d1c8		d3 d1				                .word nt_asm_sty_zx
>d1ca		d8 a6 dc a6					.word xt_asm_sty_z, z_asm_sty_z
>d1ce		73 74 79 2e 7a					.text "sty.z"
.d1d3						nt_asm_sty_zx:
>d1d3		06 0c						.byte 6, IM+NN
>d1d5		e1 d1				                .word nt_asm_stz
>d1d7		dc a6 e0 a6					.word xt_asm_sty_zx, z_asm_sty_zx
>d1db		73 74 79 2e 7a 78				.text "sty.zx"
.d1e1						nt_asm_stz:
>d1e1		03 0c						.byte 3, IM+NN
>d1e3		ec d1				                .word nt_asm_stz_x
>d1e5		e0 a6 e4 a6					.word xt_asm_stz, z_asm_stz
>d1e9		73 74 7a					.text "stz"
.d1ec						nt_asm_stz_x:
>d1ec		05 0c						.byte 5, IM+NN
>d1ee		f9 d1				                .word nt_asm_stz_z
>d1f0		e4 a6 e8 a6					.word xt_asm_stz_x, z_asm_stz_x
>d1f4		73 74 7a 2e 78					.text "stz.x"
.d1f9						nt_asm_stz_z:
>d1f9		05 0c						.byte 5, IM+NN
>d1fb		06 d2				                .word nt_asm_stz_zx
>d1fd		e8 a6 ec a6					.word xt_asm_stz_z, z_asm_stz_z
>d201		73 74 7a 2e 7a					.text "stz.z"
.d206						nt_asm_stz_zx:
>d206		06 0c						.byte 6, IM+NN
>d208		14 d2				                .word nt_asm_tax
>d20a		ec a6 f0 a6					.word xt_asm_stz_zx, z_asm_stz_zx
>d20e		73 74 7a 2e 7a 78				.text "stz.zx"
.d214						nt_asm_tax:
>d214		03 0c						.byte 3, IM+NN
>d216		1f d2				                .word nt_asm_tay
>d218		f0 a6 f4 a6					.word xt_asm_tax, z_asm_tax
>d21c		74 61 78					.text "tax"
.d21f						nt_asm_tay:
>d21f		03 0c						.byte 3, IM+NN
>d221		2a d2				                .word nt_asm_trb
>d223		f4 a6 f8 a6					.word xt_asm_tay, z_asm_tay
>d227		74 61 79					.text "tay"
.d22a						nt_asm_trb:
>d22a		03 0c						.byte 3, IM+NN
>d22c		35 d2				                .word nt_asm_trb_z
>d22e		f8 a6 fc a6					.word xt_asm_trb, z_asm_trb
>d232		74 72 62					.text "trb"
.d235						nt_asm_trb_z:
>d235		05 0c						.byte 5, IM+NN
>d237		42 d2				                .word nt_asm_tsb
>d239		fc a6 00 a7					.word xt_asm_trb_z, z_asm_trb_z
>d23d		74 72 62 2e 7a					.text "trb.z"
.d242						nt_asm_tsb:
>d242		03 0c						.byte 3, IM+NN
>d244		4d d2				                .word nt_asm_tsb_z
>d246		00 a7 04 a7					.word xt_asm_tsb, z_asm_tsb
>d24a		74 73 62					.text "tsb"
.d24d						nt_asm_tsb_z:
>d24d		05 0c						.byte 5, IM+NN
>d24f		5a d2				                .word nt_asm_tsx
>d251		04 a7 08 a7					.word xt_asm_tsb_z, z_asm_tsb_z
>d255		74 73 62 2e 7a					.text "tsb.z"
.d25a						nt_asm_tsx:
>d25a		03 0c						.byte 3, IM+NN
>d25c		65 d2				                .word nt_asm_txa
>d25e		08 a7 0c a7					.word xt_asm_tsx, z_asm_tsx
>d262		74 73 78					.text "tsx"
.d265						nt_asm_txa:
>d265		03 0c						.byte 3, IM+NN
>d267		70 d2				                .word nt_asm_txs
>d269		0c a7 10 a7					.word xt_asm_txa, z_asm_txa
>d26d		74 78 61					.text "txa"
.d270						nt_asm_txs:
>d270		03 0c						.byte 3, IM+NN
>d272		7b d2				                .word nt_asm_tya
>d274		10 a7 14 a7					.word xt_asm_txs, z_asm_txs
>d278		74 78 73					.text "txs"
.d27b						nt_asm_tya:
>d27b		03 0c						.byte 3, IM+NN
>d27d		86 d2				                .word nt_asm_arrow
>d27f		14 a7 18 a7					.word xt_asm_tya, z_asm_tya
>d283		74 79 61					.text "tya"
.d286						nt_asm_arrow:
>d286		03 04				                .byte 3, IM
>d288		91 d2				                .word nt_asm_back_jump
>d28a		1b 89 25 89			                .word xt_asm_arrow, z_asm_arrow
>d28e		2d 2d 3e			                .text "-->"
.d291						nt_asm_back_jump:
>d291		02 04				                .byte 2, IM
>d293		9b d2				                .word nt_asm_back_branch
>d295		69 a7 69 a7			                .word xt_asm_back_jump, z_asm_back_jump
>d299		3c 6a				                .text "<j"
.d29b						nt_asm_back_branch:
>d29b		02 04				                .byte 2, IM
>d29d		a5 d2				                .word nt_asm_push_a
>d29f		6a a7 72 a7			                .word xt_asm_back_branch, z_asm_back_branch
>d2a3		3c 62				                .text "<b"
.d2a5						nt_asm_push_a:
>d2a5		06 0c				                .byte 6, IM+NN
>d2a7		00 00				                .word 0000
>d2a9		52 a7 61 a7			                .word xt_asm_push_a, z_asm_push_a
>d2ad		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix         ; unused?
=1						ix += 1
=1						str_compile        = ix         ; unused?
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix         ; unused?
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_sdc     = ix
=13						ix += 1
=13						str_disasm_lit     = ix
=14						ix += 1
=14						str_disasm_0bra    = ix
=15						ix += 1
=15						str_disasm_loop    = ix
=16						ix += 1
=16						str_disasm_do      = ix
=17						ix += 1
.d2b3						string_table:
>d2b3		d5 d2 d9 d2 e3 d2 ee d2		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d2bb		25 d3 1d d3 12 d3 2c d3		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d2c3		32 d3 4e d3 53 d3 58 d3		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d2cb		69 d3 7c d3 85 d3 8e d3		        .word s_disasm_sdc, s_disasm_lit, s_disasm_0bra, s_disasm_loop, s_disasm_do ; 12-16
>d2d3		94 d3
>d2d5		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d2d9		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d2e1		64 00
>d2e3		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d2eb		64 20 00
>d2ee		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d2f6		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d306		4f 50 51 52 53 54 55 56 57 58 59 5a
>d312		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d31a		72 20 00
>d31d		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d325		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d32c		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d332		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d33a		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d34a		29 3a 20 00
>d34e		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d353		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d358		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d360		63 69 6d 61 6c 29 3a 20 00
>d369		20 53 54 41 43 4b 20 44		s_disasm_sdc: .text " STACK DEPTH CHECK", 0
>d371		45 50 54 48 20 43 48 45 43 4b 00
>d37c		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d384		00
>d385		30 42 52 41 4e 43 48 20		s_disasm_0bra: .text "0BRANCH ",0
>d38d		00
>d38e		4c 4f 4f 50 20 00		s_disasm_loop: .text "LOOP ",0
>d394		44 4f 20 00			s_disasm_do: .text "DO ",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d398						error_table:
>d398		b4 d3 d5 d3 f5 d3 16 d4		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d3a0		33 d4 44 d4 54 d4 82 d4		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d3a8		9a d4 bb d4 d0 d4 ec d4		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d3b0		03 d5 42 d5			        .word es_blockwords, es_returnstack                     ; 12-13
>d3b4		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d3bc		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d3cc		65 20 6d 65 6d 6f 72 79 00
>d3d5		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d3dd		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d3ed		20 52 45 46 49 4c 4c 00
>d3f5		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d3fd		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d40d		6e 6c 79 20 77 6f 72 64 00
>d416		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d41e		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d42e		20 79 65 74 00
>d433		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d43b		20 62 79 20 7a 65 72 6f 00
>d444		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d44c		66 61 69 6c 75 72 65 00
>d454		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d45c		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d46c		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d47c		64 20 2d 31 29 00
>d482		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d48a		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d49a		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d4a2		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d4b2		64 20 6e 75 6d 62 65 72 00
>d4bb		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d4c3		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d4d0		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d4d8		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d4e8		4c 4f 54 00
>d4ec		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d4f4		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d503		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d50b		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d51b		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d52b		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d53b		56 45 43 54 4f 52 00
>d542		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d54a		74 61 63 6b 3a 00
>d550		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d558		44 2d 53 54 52 49 4e 47
>d560		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d566		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d56b		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d573		2d 55 4e 49 54 2d 42 49 54 53
>d57d		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d585		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d58d		52
>d58e		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d594		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d59a		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d5a2		53 54 41 43 4b 2d 43 45 4c 4c 53
>d5ad		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d5b5		45 4c 4c 53
>d5b9		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d5c1		54 53
>d5c3		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d5c9		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d5d0						doconst:
.d5d0		ca		dex		                dex             ; make room for constant
.d5d1		ca		dex		                dex
.d5d2		68		pla		                pla             ; LSB of return address
.d5d3		85 25		sta $25		                sta tmp1
.d5d5		68		pla		                pla             ; MSB of return address
.d5d6		85 26		sta $26		                sta tmp1+1
.d5d8		a0 01		ldy #$01	                ldy #1
.d5da		b1 25		lda ($25),y	                lda (tmp1),y
.d5dc		95 00		sta $00,x	                sta 0,x
.d5de		c8		iny		                iny
.d5df		b1 25		lda ($25),y	                lda (tmp1),y
.d5e1		95 01		sta $01,x	                sta 1,x
.d5e3		60		rts		                rts
.d5e4						dodefer:
.d5e4		68		pla		                pla             ; LSB
.d5e5		85 25		sta $25		                sta tmp1
.d5e7		68		pla		                pla             ; MSB
.d5e8		85 26		sta $26		                sta tmp1+1
.d5ea		a0 01		ldy #$01	                ldy #1
.d5ec		b1 25		lda ($25),y	                lda (tmp1),y
.d5ee		85 27		sta $27		                sta tmp2
.d5f0		c8		iny		                iny
.d5f1		b1 25		lda ($25),y	                lda (tmp1),y
.d5f3		85 28		sta $28		                sta tmp2+1
.d5f5		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d5f8						defer_error:
.d5f8		a9 03		lda #$03	                lda #err_defer
.d5fa		4c 7e d7	jmp $d77e	                jmp error
.d5fd						dodoes:
.d5fd		7a		ply		                ply             ; LSB
.d5fe		68		pla		                pla             ; MSB
.d5ff		c8		iny		                iny
.d600		d0 01		bne $d603	                bne +
.d602		1a		inc a		                ina
.d603						+
.d603		84 27		sty $27		                sty tmp2
.d605		85 28		sta $28		                sta tmp2+1
.d607		ca		dex		                dex
.d608		ca		dex		                dex
.d609		7a		ply		                ply
.d60a		68		pla		                pla
.d60b		c8		iny		                iny
.d60c		d0 01		bne $d60f	                bne +
.d60e		1a		inc a		                ina
.d60f						+
.d60f		94 00		sty $00,x	                sty 0,x         ; LSB
.d611		95 01		sta $01,x	                sta 1,x         ; MSB
.d613		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d616						dovar:
.d616		7a		ply		                ply             ; LSB
.d617		68		pla		                pla             ; MSB
.d618		c8		iny		                iny
.d619		d0 01		bne $d61c	                bne +
.d61b		1a		inc a		                ina
.d61c						+
.d61c		ca		dex		                dex
.d61d		ca		dex		                dex
.d61e		95 01		sta $01,x	                sta 1,x
.d620		98		tya		                tya
.d621		95 00		sta $00,x	                sta 0,x
.d623		60		rts		                rts
.d624						push_upvar_tos:
.d624		ca		dex		                dex
.d625		ca		dex		                dex
.d626		18		clc		                clc
.d627		65 08		adc $08		                adc up
.d629		95 00		sta $00,x	                sta 0,x
.d62b		a5 09		lda $09		                lda up+1
.d62d		90 01		bcc $d630	                bcc +
.d62f		1a		inc a		                ina
.d630						+
.d630		95 01		sta $01,x	                sta 1,x
.d632		60		rts		                rts
.d633						byte_to_ascii:
.d633		48		pha		                pha
.d634		4a		lsr a		                lsr             ; convert high nibble first
.d635		4a		lsr a		                lsr
.d636		4a		lsr a		                lsr
.d637		4a		lsr a		                lsr
.d638		20 3c d6	jsr $d63c	                jsr _nibble_to_ascii
.d63b		68		pla		                pla
.d63c						_nibble_to_ascii:
.d63c		29 0f		and #$0f	                and #$F
.d63e		09 30		ora #$30	                ora #'0'
.d640		c9 3a		cmp #$3a	                cmp #'9'+1
.d642		90 02		bcc $d646	                bcc +
.d644		69 06		adc #$06	                adc #6
.d646		4c c5 86	jmp $86c5	+               jmp emit_a
.d649		60		rts		                rts
.d64a						find_header_name:
.d64a		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d64c		85 27		sta $27		                sta tmp2
.d64e		b5 03		lda $03,x	                lda 3,x
.d650		85 28		sta $28		                sta tmp2+1
.d652						_loop:
.d652		b2 25		lda ($25)	                lda (tmp1)
.d654		d5 00		cmp $00,x	                cmp 0,x
.d656		d0 3a		bne $d692	                bne _next_entry
.d658		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d65a		a0 08		ldy #$08	                ldy #8
.d65c		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d65e		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d660		d0 30		bne $d692	                bne _next_entry ; definitely not equal if any bits differ
.d662		a5 25		lda $25		                lda tmp1
.d664		48		pha		                pha             ; Save original address on the stack
.d665		18		clc		                clc
.d666		69 08		adc #$08	                adc #8
.d668		85 25		sta $25		                sta tmp1
.d66a		a5 26		lda $26		                lda tmp1+1
.d66c		48		pha		                pha
.d66d		90 03		bcc $d672	                bcc +
.d66f		1a		inc a		                ina
.d670		85 26		sta $26		                sta tmp1+1
.d672						+
.d672		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d674		88		dey		                dey
.d675						_next_char:
.d675		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d677		c9 5b		cmp #$5b	                cmp #'Z'+1
.d679		b0 06		bcs $d681	                bcs _check_char
.d67b		c9 41		cmp #$41	                cmp #'A'
.d67d		90 02		bcc $d681	                bcc _check_char
.d67f		09 20		ora #$20	                ora #$20
.d681						_check_char:
.d681		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d683		d0 03		bne $d688	                bne _reset_tmp1
.d685		88		dey		                dey
.d686		10 ed		bpl $d675	                bpl _next_char
.d688						_reset_tmp1:
.d688		68		pla		                pla
.d689		85 26		sta $26		                sta tmp1+1
.d68b		68		pla		                pla
.d68c		85 25		sta $25		                sta tmp1
.d68e		98		tya		                tya             ; leave A = $FF on success
.d68f		c8		iny		                iny             ; if Y was $FF, we succeeded
.d690		f0 11		beq $d6a3	                beq _done
.d692						_next_entry:
.d692		a0 02		ldy #$02	                ldy #2
.d694		b1 25		lda ($25),y	                lda (tmp1),y
.d696		48		pha		                pha
.d697		c8		iny		                iny
.d698		b1 25		lda ($25),y	                lda (tmp1),y
.d69a		85 26		sta $26		                sta tmp1+1
.d69c		68		pla		                pla
.d69d		85 25		sta $25		                sta tmp1
.d69f		05 26		ora $26		                ora tmp1+1
.d6a1		d0 af		bne $d652	                bne _loop
.d6a3		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d6a5		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d6a6						compare_16bit:
.d6a6		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d6a8		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d6aa		f0 08		beq $d6b4	                beq _equal
.d6ac		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6ae		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6b0		70 08		bvs $d6ba	                bvs _overflow
.d6b2		80 08		bra $d6bc	                bra _not_equal
.d6b4						_equal:
.d6b4		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6b6		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6b8		50 04		bvc $d6be	                bvc _done
.d6ba						_overflow:
.d6ba		49 80		eor #$80	                eor #$80                ; complement negative flag
.d6bc						_not_equal:
.d6bc		09 01		ora #$01	                ora #1                  ; set Z=0 since we're not equal
.d6be						_done:
.d6be		60		rts		                rts
.d6bf						current_to_dp:
.d6bf		a0 08		ldy #$08	                ldy #current_offset
.d6c1		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d6c3		0a		asl a		                asl             ; turn it into an offset (in cells)
.d6c4		18		clc		                clc
.d6c5		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d6c7		a8		tay		                tay
.d6c8		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d6ca		85 02		sta $02		                sta dp
.d6cc		c8		iny		                iny
.d6cd		b1 08		lda ($08),y	                lda (up),y
.d6cf		85 03		sta $03		                sta dp+1
.d6d1		60		rts		                rts
.d6d2						dp_to_current:
.d6d2		a0 08		ldy #$08	                ldy #current_offset
.d6d4		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d6d6		0a		asl a		                asl             ; turn it into an offset (in cells)
.d6d7		18		clc		                clc
.d6d8		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d6da		a8		tay		                tay
.d6db		a5 02		lda $02		                lda dp
.d6dd		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d6df		c8		iny		                iny
.d6e0		a5 03		lda $03		                lda dp+1
.d6e2		91 08		sta ($08),y	                sta (up),y
.d6e4		60		rts		                rts
.d6e5						interpret:
.d6e5						_loop:
.d6e5		20 51 8d	jsr $8d51	                jsr xt_parse_name       ; ( "string" -- addr u )
.d6e8		b5 00		lda $00,x	                lda 0,x
.d6ea		15 01		ora $01,x	                ora 1,x
.d6ec		f0 5b		beq $d749	                beq _line_done
.d6ee		20 af 93	jsr $93af	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d6f1		20 ce 9a	jsr $9ace	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d6f4		b5 00		lda $00,x	                lda 0,x
.d6f6		15 01		ora $01,x	                ora 1,x
.d6f8		d0 19		bne $d713	                bne _got_name_token
.d6fa		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d6fb		e8		inx		                inx
.d6fc		20 6f 9c	jsr $9c6f	                jsr xt_number           ; ( addr u -- u|d )
.d6ff		a5 1a		lda $1a		                lda state
.d701		f0 e2		beq $d6e5	                beq _loop
.d703		a9 20		lda #$20	                lda #%00100000
.d705		24 1c		bit $1c		                bit status
.d707		d0 05		bne $d70e	                bne _double_number
.d709		20 f2 89	jsr $89f2	                jsr xt_literal
.d70c		80 d7		bra $d6e5	                bra _loop
.d70e						_double_number:
.d70e		20 c7 9e	jsr $9ec7	                jsr xt_two_literal
.d711		80 d2		bra $d6e5	                bra _loop
.d713						_got_name_token:
.d713		b5 00		lda $00,x	                lda 0,x
.d715		95 04		sta $04,x	                sta 4,x
.d717		b5 01		lda $01,x	                lda 1,x
.d719		95 05		sta $05,x	                sta 5,x
.d71b		e8		inx		                inx
.d71c		e8		inx		                inx
.d71d		e8		inx		                inx
.d71e		e8		inx		                inx                     ; ( nt )
.d71f		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.d722		a1 00		lda ($00,x)	                lda (0,x)
.d724		48		pha		                pha
.d725		20 dd 8c	jsr $8cdd	                jsr xt_one_minus
.d728		20 0c 9c	jsr $9c0c	                jsr xt_name_to_int      ; ( nt - xt )
.d72b		a5 1a		lda $1a		                lda state
.d72d		d0 10		bne $d73f	                bne _compile
.d72f		68		pla		                pla
.d730		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d732		f0 05		beq $d739	                beq _interpret
.d734		a9 02		lda #$02	                lda #err_compileonly
.d736		4c 7e d7	jmp $d77e	                jmp error
.d739						_interpret:
.d739		20 05 88	jsr $8805	                jsr xt_execute
.d73c		4c e5 d6	jmp $d6e5	                jmp _loop
.d73f						_compile:
.d73f		68		pla		                pla
.d740		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d742		d0 f5		bne $d739	                bne _interpret          ; IMMEDIATE word, execute right now
.d744		20 ba 96	jsr $96ba	                jsr xt_compile_comma
.d747		80 9c		bra $d6e5	                bra _loop
.d749						_line_done:
.d749		e8		inx		                inx
.d74a		e8		inx		                inx
.d74b		e8		inx		                inx
.d74c		e8		inx		                inx
.d74d		60		rts		                rts
.d74e						is_printable:
.d74e		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d750		90 08		bcc $d75a	                bcc _done
.d752		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d754		b0 03		bcs $d759	                bcs _failed
.d756		38		sec		                sec
.d757		80 01		bra $d75a	                bra _done
.d759						_failed:
.d759		18		clc		                clc
.d75a						_done:
.d75a		60		rts		                rts
.d75b						is_whitespace:
.d75b		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d75d		90 08		bcc $d767	                bcc _done
.d75f		c9 21		cmp #$21	                cmp #AscSP+1
.d761		b0 03		bcs $d766	                bcs _failed
.d763		38		sec		                sec
.d764		80 01		bra $d767	                bra _done
.d766						_failed:
.d766		18		clc		                clc
.d767						_done:
.d767		60		rts		                rts
.d768						underflow_1:
.d768		e0 77		cpx #$77	                cpx #dsp0-1
.d76a		10 10		bpl $d77c	                bpl underflow_error
.d76c		60		rts		                rts
.d76d						underflow_2:
.d76d		e0 75		cpx #$75	                cpx #dsp0-3
.d76f		10 0b		bpl $d77c	                bpl underflow_error
.d771		60		rts		                rts
.d772						underflow_3:
.d772		e0 73		cpx #$73	                cpx #dsp0-5
.d774		10 06		bpl $d77c	                bpl underflow_error
.d776		60		rts		                rts
.d777						underflow_4:
.d777		e0 71		cpx #$71	                cpx #dsp0-7
.d779		10 01		bpl $d77c	                bpl underflow_error
.d77b		60		rts		                rts
.d77c						underflow_error:
.d77c		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d77e						error:
.d77e		48		pha		                pha                     ; save error
.d77f		20 be d7	jsr $d7be	                jsr print_error
.d782		20 3a 84	jsr $843a	                jsr xt_cr
.d785		68		pla		                pla
.d786		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d788		d0 17		bne $d7a1	                bne _no_underflow
.d78a		a9 0d		lda #$0d	                lda #err_returnstack
.d78c		20 be d7	jsr $d7be	                jsr print_error
.d78f		ba		tsx		                tsx
.d790						-
.d790		e8		inx		                inx
.d791		f0 0b		beq $d79e	                beq +
.d793		20 cb 91	jsr $91cb	                jsr xt_space
.d796		bd 00 01	lda $0100,x	                lda $100,x
.d799		20 33 d6	jsr $d633	                jsr byte_to_ascii
.d79c		80 f2		bra $d790	                bra -
.d79e						+
.d79e		20 3a 84	jsr $843a	                jsr xt_cr
.d7a1						_no_underflow:
.d7a1		4c 5e 80	jmp $805e	                jmp xt_abort            ; no jsr, as we clobber return stack
.d7a4						print_string_no_lf:
.d7a4		0a		asl a		                asl
.d7a5		a8		tay		                tay
.d7a6		b9 b3 d2	lda $d2b3,y	                lda string_table,y
.d7a9		85 29		sta $29		                sta tmp3                ; LSB
.d7ab		c8		iny		                iny
.d7ac		b9 b3 d2	lda $d2b3,y	                lda string_table,y
.d7af		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d7b1						print_common:
.d7b1		a0 00		ldy #$00	                ldy #0
.d7b3						_loop:
.d7b3		b1 29		lda ($29),y	                lda (tmp3),y
.d7b5		f0 06		beq $d7bd	                beq _done               ; strings are zero-terminated
.d7b7		20 c5 86	jsr $86c5	                jsr emit_a              ; allows vectoring via output
.d7ba		c8		iny		                iny
.d7bb		80 f6		bra $d7b3	                bra _loop
.d7bd						_done:
.d7bd		60		rts		                rts
.d7be						print_error:
.d7be		0a		asl a		                asl
.d7bf		a8		tay		                tay
.d7c0		b9 98 d3	lda $d398,y	                lda error_table,y
.d7c3		85 29		sta $29		                sta tmp3                ; LSB
.d7c5		c8		iny		                iny
.d7c6		b9 98 d3	lda $d398,y	                lda error_table,y
.d7c9		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d7cb		20 b1 d7	jsr $d7b1	                jsr print_common
.d7ce		60		rts		                rts
.d7cf						print_string:
.d7cf		20 a4 d7	jsr $d7a4	                jsr print_string_no_lf
.d7d2		4c 3a 84	jmp $843a	                jmp xt_cr               ; JSR/RTS because never compiled
.d7d5						print_u:
.d7d5		20 cf 9d	jsr $9dcf	                jsr xt_zero                     ; 0
.d7d8		20 cf 89	jsr $89cf	                jsr xt_less_number_sign         ; <#
.d7db		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s            ; #S
.d7de		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater      ; #>
.d7e1		4c b7 94	jmp $94b7	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm


;******  Processing file: platform/simulator.asm

=$f000						io_start = $f000
>f000						                .byte ?
>f001						io_putc:        .byte ?     ; $f001     write byte to stdout
>f002						                .word ?
>f004						io_getc:        .byte ?     ; $f004     read byte from stdin
>f005						io_peekc:       .byte ?     ; $f005     non-blocking input
>f006						io_clk_start:   .byte ?     ; $f006     *read* to start cycle counter
>f007						io_clk_stop:    .byte ?     ; $f007     *read* to stop the cycle counter
>f008						io_clk_cycles:  .word ?,?   ; $f008-b   32-bit cycle count in NUXI order
>f00c						                .word ?,?
>f010						io_blk_action:  .byte ?     ; $f010     Write to act (status=0 read=1 write=2)
>f011						io_blk_status:  .byte ?     ; $f011     Read action result (OK=0)
>f012						io_blk_number:  .word ?     ; $f012     Little endian block number 0-ffff
>f014						io_blk_buffer:  .word ?     ; $f014     Little endian memory address
.f016						io_end:
.f016						kernel_init:
.f016		78		sei		                sei             ; Disable interrupts
.f017		a2 00		ldx #$00	                ldx #0
.f019		bd 32 f0	lda $f032,x	-               lda s_kernel_id,x
.f01c		f0 06		beq $f024	                beq _done
.f01e		20 2d f0	jsr $f02d	                jsr kernel_putc
.f021		e8		inx		                inx
.f022		80 f5		bra $f019	                bra -
.f024						_done:
.f024		4c 00 80	jmp $8000	                jmp forth
.f027						kernel_getc:
.f027						_loop:
.f027		ad 04 f0	lda $f004	                lda io_getc
.f02a		f0 fb		beq $f027	                beq _loop
.f02c		60		rts		                rts
.f02d						kernel_putc:
.f02d		8d 01 f0	sta $f001	                sta io_putc
.f030		60		rts		                rts
.f031						kernel_bye:
.f031		00		brk #		                brk

;******  Return to file: platform/platform-py65mon.asm

.f032						s_kernel_id:
>f032		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f03a		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f04a		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f05a		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		16 f0				v_nmi   .word kernel_init
>fffc		16 f0				v_reset .word kernel_init
>fffe		16 f0				v_irq   .word kernel_init

;******  End of listing
