
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Mon Jun 10 08:43:46 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../words/all.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 2d		lda #$2d	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd 44 b3	lda $b344,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad 44 b3	lda $b344	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f						_load_user_vars_loop:
.801f		b9 62 b3	lda $b362,y	                lda cold_user_table,y
.8022		91 08		sta ($08),y	                sta (up),y
.8024		88		dey		                dey
.8025		d0 f8		bne $801f	                bne _load_user_vars_loop
.8027		ad 62 b3	lda $b362	                lda cold_user_table
.802a		92 08		sta ($08)	                sta (up)
.802c		20 3a 84	jsr $843a	                jsr xt_cr
.802f		ca		dex		                dex
.8030		ca		dex		                dex
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		a9 45		lda #$45	                lda #<forth_words_start
.8035		95 02		sta $02,x	                sta 2,x
.8037		a9 ba		lda #$ba	                lda #>forth_words_start
.8039		95 03		sta $03,x	                sta 3,x
.803b		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803d		95 00		sta $00,x	                sta 0,x
.803f		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8041		95 01		sta $01,x	                sta 1,x
.8043		20 b2 88	jsr $88b2	                jsr xt_evaluate
.8046		9c 00 7c	stz $7c00	                stz hist_buff
.8049		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804c		9c 00 7d	stz $7d00	                stz hist_buff+$100
.804f		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8052		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8055		9c 80 7e	stz $7e80	                stz hist_buff+$280
.8058		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805b		9c 80 7f	stz $7f80	                stz hist_buff+$380
.805e						xt_abort:
.805e		a2 78		ldx #$78	                ldx #dsp0
.8060						xt_quit:
.8060		8a		txa		                txa             ; Save the DSP that we just defined
.8061		a2 ff		ldx #$ff	                ldx #rsp0
.8063		9a		txs		                txs
.8064		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8065		64 04		stz $04		                stz ip
.8067		64 05		stz $05		                stz ip+1
.8069		64 0a		stz $0a		                stz insrc
.806b		64 0b		stz $0b		                stz insrc+1
.806d		a9 00		lda #$00	                lda #0
.806f		a0 04		ldy #$04	                ldy #blk_offset
.8071		91 08		sta ($08),y	                sta (up),y
.8073		c8		iny		                iny
.8074		91 08		sta ($08),y	                sta (up),y
.8076		a9 fc		lda #$fc	                lda #(256-4)
.8078		85 1f		sta $1f		                sta loopctrl
.807a		64 1a		stz $1a		                stz state
.807c		64 1b		stz $1b		                stz state+1
.807e						_get_line:
.807e		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8080		85 0c		sta $0c		                sta cib
.8082		a9 02		lda #$02	                lda #>buffer0
.8084		85 0d		sta $0d		                sta cib+1
.8086		64 0e		stz $0e		                stz ciblen
.8088		64 0f		stz $0f		                stz ciblen+1
.808a		20 42 8f	jsr $8f42	                jsr xt_refill           ; ( -- f )
.808d		b5 00		lda $00,x	                lda 0,x
.808f		d0 05		bne $8096	                bne _success
.8091		a9 06		lda #$06	                lda #err_refill
.8093		4c 8b d7	jmp $d78b	                jmp error
.8096						_success:
.8096		e8		inx		                inx                     ; drop
.8097		e8		inx		                inx
.8098		20 f2 d6	jsr $d6f2	                jsr interpret
.809b		e0 78		cpx #$78	                cpx #dsp0
.809d		f0 05		beq $80a4	                beq _stack_ok
.809f		90 03		bcc $80a4	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a1		4c 89 d7	jmp $d789	                jmp underflow_error
.80a4						_stack_ok:
.80a4		a5 1a		lda $1a		                lda state
.80a6		f0 02		beq $80aa	                beq _print
.80a8		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80aa						_print:
.80aa		20 dc d7	jsr $d7dc	                jsr print_string
.80ad		80 cf		bra $807e	                bra _get_line
.80af						z_cold:
.80af						z_abort:
.80af						z_quit:

;******  Processing file: platform/../words/core.asm

.80af						xt_abort_quote:
.80af		20 da 8f	jsr $8fda	                jsr xt_s_quote          ; S"
.80b2		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b4		a9 ba		lda #$ba	                lda #<abort_quote_runtime
.80b6		20 65 97	jsr $9765	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80b9		60		rts		z_abort_quote:  rts
.80ba						abort_quote_runtime:
.80ba		b5 04		lda $04,x	                lda 4,x
.80bc		15 05		ora $05,x	                ora 5,x
.80be		f0 09		beq $80c9	                beq _done       ; if FALSE, we're done
.80c0		20 c4 94	jsr $94c4	                jsr xt_type
.80c3		20 3a 84	jsr $843a	                jsr xt_cr
.80c6		4c 5e 80	jmp $805e	                jmp xt_abort    ; not JSR, so never come back
.80c9						_done:
.80c9		8a		txa		                txa
.80ca		18		clc		                clc
.80cb		69 06		adc #$06	                adc #6
.80cd		aa		tax		                tax
.80ce		60		rts		                rts
.80cf						xt_abs:
.80cf		20 75 d7	jsr $d775	                jsr underflow_1
.80d2		b5 01		lda $01,x	                lda 1,x
.80d4		10 0d		bpl $80e3	                bpl _done       ; positive number, easy money!
.80d6		38		sec		                sec
.80d7		a9 00		lda #$00	                lda #0
.80d9		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80db		95 00		sta $00,x	                sta 0,x
.80dd		a9 00		lda #$00	                lda #0          ; MSB
.80df		f5 01		sbc $01,x	                sbc 1,x
.80e1		95 01		sta $01,x	                sta 1,x
.80e3						_done:
.80e3		60		rts		z_abs:          rts
.80e4						xt_accept:
.80e4		20 7a d7	jsr $d77a	                jsr underflow_2
.80e7		b5 00		lda $00,x	                lda 0,x
.80e9		15 01		ora $01,x	                ora 1,x
.80eb		d0 09		bne $80f6	                bne _not_zero
.80ed		e8		inx		                inx
.80ee		e8		inx		                inx
.80ef		74 00		stz $00,x	                stz 0,x
.80f1		74 01		stz $01,x	                stz 1,x
.80f3		4c c2 81	jmp $81c2	                jmp accept_done
.80f6						_not_zero:
.80f6		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80f8		85 27		sta $27		                sta tmp2
.80fa		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fc		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.80fe		85 25		sta $25		                sta tmp1
.8100		b5 03		lda $03,x	                lda 3,x
.8102		85 26		sta $26		                sta tmp1+1
.8104		e8		inx		                inx
.8105		e8		inx		                inx
.8106		a0 00		ldy #$00	                ldy #0
.8108		a5 1c		lda $1c		                lda status
.810a		29 f7		and #$f7	                and #$F7
.810c		1a		inc a		                ina
.810d		09 08		ora #$08	                ora #%00001000
.810f		85 1c		sta $1c		                sta status
.8111						accept_loop:
.8111		20 b1 89	jsr $89b1	                jsr key_a
.8114		c9 0a		cmp #$0a	                cmp #AscLF
.8116		f0 20		beq $8138	                beq _eol
.8118		c9 0d		cmp #$0d	                cmp #AscCR
.811a		f0 1c		beq $8138	                beq _eol
.811c		c9 08		cmp #$08	                cmp #AscBS
.811e		f0 22		beq $8142	                beq _backspace
.8120		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8122		f0 1e		beq $8142	                beq _backspace
.8124		c9 10		cmp #$10	                cmp #AscCP
.8126		f0 36		beq $815e	                beq _ctrl_p
.8128		c9 0e		cmp #$0e	                cmp #AscCN
.812a		f0 44		beq $8170	                beq _ctrl_n
.812c		91 25		sta ($25),y	                sta (tmp1),y
.812e		c8		iny		                iny
.812f		20 c5 86	jsr $86c5	                jsr emit_a
.8132		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8134		d0 db		bne $8111	                bne accept_loop       ; fall through if buffer limit reached
.8136		80 03		bra $813b	                bra _buffer_full
.8138						_eol:
.8138		20 cb 91	jsr $91cb	                jsr xt_space    ; print final space
.813b						_buffer_full:
.813b		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813d		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.813f		4c c2 81	jmp $81c2	                jmp accept_done
.8142						_backspace:
.8142		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8144		d0 06		bne $814c	                bne +
.8146		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8148		20 c5 86	jsr $86c5	                jsr emit_a
.814b		c8		iny		                iny
.814c						+
.814c		88		dey		                dey
.814d		a9 08		lda #$08	                lda #AscBS      ; move back one
.814f		20 c5 86	jsr $86c5	                jsr emit_a
.8152		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8154		20 c5 86	jsr $86c5	                jsr emit_a
.8157		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8159		20 c5 86	jsr $86c5	                jsr emit_a
.815c		80 b3		bra $8111	                bra accept_loop
.815e						_ctrl_p:
.815e		a5 1c		lda $1c		                lda status
.8160		29 07		and #$07	                and #7
.8162		d0 08		bne $816c	                bne _ctrl_p_dec
.8164		a5 1c		lda $1c		                lda status
.8166		09 07		ora #$07	                ora #7
.8168		85 1c		sta $1c		                sta status
.816a		80 11		bra $817d	                bra _recall_history
.816c						_ctrl_p_dec:
.816c		c6 1c		dec $1c		                dec status
.816e		80 0d		bra $817d	                bra _recall_history
.8170						_ctrl_n:
.8170		a9 08		lda #$08	                lda #$8
.8172		24 1c		bit $1c		                bit status
.8174		d0 07		bne $817d	                bne _recall_history
.8176		a5 1c		lda $1c		                lda status
.8178		29 f7		and #$f7	                and #$F7
.817a		1a		inc a		               ina
.817b		85 1c		sta $1c		                sta status
.817d						_recall_history:
.817d		a9 08		lda #$08	                lda #%00001000
.817f		14 1c		trb $1c		                trb status
.8181		20 dd 81	jsr $81dd	                jsr accept_total_recall
.8184		a9 0d		lda #$0d	                lda #AscCR
.8186		20 c5 86	jsr $86c5	                jsr emit_a
.8189						input_clear:
.8189		c0 00		cpy #$00	                cpy #0
.818b		f0 08		beq $8195	                beq input_cleared
.818d		a9 20		lda #$20	                lda #AscSP
.818f		20 c5 86	jsr $86c5	                jsr emit_a
.8192		88		dey		                dey
.8193		80 f4		bra $8189	                bra input_clear
.8195						input_cleared:
.8195		a9 0d		lda #$0d	                lda #AscCR
.8197		20 c5 86	jsr $86c5	                jsr emit_a
.819a		b1 29		lda ($29),y	                lda (tmp3),y
.819c		85 1d		sta $1d		                sta status+1
.819e		e6 29		inc $29		                inc tmp3
.81a0		d0 02		bne $81a4	                bne +           ; Increment the upper byte on carry.
.81a2		e6 2a		inc $2a		                inc tmp3+1
.81a4						+
.81a4		a9 0d		lda #$0d	                lda #AscCR
.81a6		20 c5 86	jsr $86c5	                jsr emit_a
.81a9						_history_loop:
.81a9		c4 1d		cpy $1d		                cpy status+1
.81ab		d0 03		bne $81b0	                bne +
.81ad		4c 11 81	jmp $8111	                jmp accept_loop       ; Needs a long jump
.81b0						+
.81b0		c4 27		cpy $27		                cpy tmp2
.81b2		f0 0a		beq $81be	                beq _hist_filled_buffer
.81b4		b1 29		lda ($29),y	                lda (tmp3),y
.81b6		91 25		sta ($25),y	                sta (tmp1),y
.81b8		20 c5 86	jsr $86c5	                jsr emit_a
.81bb		c8		iny		                iny
.81bc		80 eb		bra $81a9	                bra _history_loop
.81be						_hist_filled_buffer:
.81be		88		dey		                dey
.81bf		4c 11 81	jmp $8111	                jmp accept_loop
.81c2						accept_done:
.81c2		20 dd 81	jsr $81dd	                jsr accept_total_recall
.81c5		85 1d		sta $1d		                sta status+1
.81c7		a0 00		ldy #$00	                ldy #0
.81c9		91 29		sta ($29),y	                sta (tmp3),y
.81cb		e6 29		inc $29		                inc tmp3
.81cd		d0 02		bne $81d1	                bne +           ; Increment the upper byte on carry.
.81cf		e6 2a		inc $2a		                inc tmp3+1
.81d1						+
.81d1						_save_history_loop:
.81d1		c4 1d		cpy $1d		                cpy status+1
.81d3		f0 07		beq $81dc	                beq _save_history_done
.81d5		b1 25		lda ($25),y	                lda (tmp1),y
.81d7		91 29		sta ($29),y	                sta (tmp3),y
.81d9		c8		iny		                iny
.81da		80 f5		bra $81d1	                bra _save_history_loop
.81dc						_save_history_done:
.81dc						z_accept:
.81dc		60		rts		                rts
.81dd						accept_total_recall:
.81dd		a9 00		lda #$00	                lda #<hist_buff
.81df		85 29		sta $29		                sta tmp3
.81e1		a9 7c		lda #$7c	                lda #>hist_buff
.81e3		85 2a		sta $2a		                sta tmp3+1
.81e5		a5 1c		lda $1c		                lda status
.81e7		6a		ror a		                ror
.81e8		29 03		and #$03	                and #3
.81ea		18		clc		                clc
.81eb		65 2a		adc $2a		                adc tmp3+1
.81ed		85 2a		sta $2a		                sta tmp3+1
.81ef		a5 1c		lda $1c		                lda status
.81f1		6a		ror a		                ror             ; Rotate through carry into msb.
.81f2		6a		ror a		                ror
.81f3		29 80		and #$80	                and #$80
.81f5		18		clc		                clc
.81f6		65 29		adc $29		                adc tmp3
.81f8		85 29		sta $29		                sta tmp3
.81fa		90 02		bcc $81fe	                bcc +           ; Increment the upper byte on carry.
.81fc		e6 2a		inc $2a		                inc tmp3+1
.81fe						+
.81fe		98		tya		                tya
.81ff		c9 80		cmp #$80	                cmp #$80
.8201		90 02		bcc $8205	                bcc +
.8203		a9 7f		lda #$7f	                lda #$7F
.8205						+
.8205		60		rts		                rts
.8206						xt_action_of:
.8206		a5 1a		lda $1a		                lda state
.8208		05 1b		ora $1b		                ora state+1
.820a		f0 0c		beq $8218	                beq _interpreting
.820c		20 14 83	jsr $8314	                jsr xt_bracket_tick
.820f		a0 85		ldy #$85	                ldy #>xt_defer_fetch
.8211		a9 44		lda #$44	                lda #<xt_defer_fetch
.8213		20 65 97	jsr $9765	                jsr cmpl_subroutine
.8216		80 06		bra $821e	                bra _done
.8218						_interpreting:
.8218		20 42 92	jsr $9242	                jsr xt_tick
.821b		20 44 85	jsr $8544	                jsr xt_defer_fetch
.821e						_done:
.821e		60		rts		z_action_of:           rts
.821f						xt_again:
.821f		20 75 d7	jsr $d775	                jsr underflow_1
.8222		20 7e 97	jsr $977e	                jsr cmpl_jump_tos
.8225		60		rts		z_again:        rts
.8226						xt_align:
.8226						xt_aligned:
.8226						z_align:
.8226						z_aligned:
.8226		60		rts		                rts             ; stripped out during native compile
.8227						xt_allot:
.8227		20 75 d7	jsr $d775	                jsr underflow_1
.822a		b5 01		lda $01,x	                lda 1,x
.822c		30 22		bmi $8250	                bmi _release
.822e		18		clc		                clc
.822f		a5 00		lda $00		                lda cp
.8231		75 00		adc $00,x	                adc 0,x
.8233		85 00		sta $00		                sta cp
.8235		a5 01		lda $01		                lda cp+1
.8237		75 01		adc $01,x	                adc 1,x
.8239		85 01		sta $01		                sta cp+1
.823b		a0 00		ldy #$00	                ldy #<cp_end
.823d		c4 00		cpy $00		                cpy cp
.823f		a9 7c		lda #$7c	                lda #>cp_end
.8241		e5 01		sbc $01		                sbc cp+1
.8243		b0 48		bcs $828d	                bcs _done               ; we're fine.
.8245		84 00		sty $00		                sty cp                  ; still #<cp_end
.8247		a9 7c		lda #$7c	                lda #>cp_end
.8249		85 01		sta $01		                sta cp+1
.824b		a9 00		lda #$00	                lda #err_allot
.824d		4c 8b d7	jmp $d78b	                jmp error
.8250						_release:
.8250		ca		dex		                dex
.8251		ca		dex		                dex
.8252		a5 00		lda $00		                lda cp
.8254		95 00		sta $00,x	                sta 0,x
.8256		a5 01		lda $01		                lda cp+1
.8258		95 01		sta $01,x	                sta 1,x
.825a		20 53 8e	jsr $8e53	                jsr xt_plus                     ; new CP is now TOS
.825d		ca		dex		                dex
.825e		ca		dex		                dex                             ; new CP now NOS
.825f		a9 00		lda #$00	                lda #<cp0
.8261		95 00		sta $00,x	                sta 0,x
.8263		a9 03		lda #$03	                lda #>cp0
.8265		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8267		20 b3 d6	jsr $d6b3	                jsr compare_16bit               ; still ( CP CP0 )
.826a		f0 17		beq $8283	                beq _nega_done
.826c		30 15		bmi $8283	                bmi _nega_done
.826e		a9 00		lda #$00	                lda #<cp0
.8270		85 00		sta $00		                sta cp
.8272		a9 03		lda #$03	                lda #>cp0
.8274		85 01		sta $01		                sta cp+1
.8276		a9 27		lda #$27	                lda #<dictionary_start
.8278		85 02		sta $02		                sta dp
.827a		a9 bb		lda #$bb	                lda #>dictionary_start
.827c		85 03		sta $03		                sta dp+1
.827e		a9 0a		lda #$0a	                lda #err_negallot
.8280		4c 8b d7	jmp $d78b	                jmp error
.8283						_nega_done:
.8283		b5 02		lda $02,x	                lda 2,x
.8285		85 00		sta $00		                sta cp
.8287		b5 03		lda $03,x	                lda 3,x
.8289		85 01		sta $01		                sta cp+1
.828b		e8		inx		                inx
.828c		e8		inx		                inx                     ; drop through to _done
.828d						_done:
.828d		e8		inx		                inx
.828e		e8		inx		                inx
.828f						z_allot:
.828f		60		rts		                rts
.8290						xt_and:
.8290		20 7a d7	jsr $d77a	                jsr underflow_2
.8293		b5 00		lda $00,x	                lda 0,x
.8295		35 02		and $02,x	                and 2,x
.8297		95 02		sta $02,x	                sta 2,x
.8299		b5 01		lda $01,x	                lda 1,x
.829b		35 03		and $03,x	                and 3,x
.829d		95 03		sta $03,x	                sta 3,x
.829f		e8		inx		                inx
.82a0		e8		inx		                inx
.82a1		60		rts		z_and:          rts
.82a2						xt_at_xy:
.82a2		20 7a d7	jsr $d77a	                jsr underflow_2
.82a5		a5 18		lda $18		                lda base
.82a7		48		pha		                pha
.82a8		a9 0a		lda #$0a	                lda #10
.82aa		85 18		sta $18		                sta base
.82ac		a9 1b		lda #$1b	                lda #AscESC
.82ae		20 c5 86	jsr $86c5	                jsr emit_a
.82b1		a9 5b		lda #$5b	                lda #'['
.82b3		20 c5 86	jsr $86c5	                jsr emit_a
.82b6		20 e9 8c	jsr $8ce9	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82b9		20 e2 d7	jsr $d7e2	                jsr print_u
.82bc		a9 3b		lda #$3b	                lda #';'
.82be		20 c5 86	jsr $86c5	                jsr emit_a
.82c1		20 e9 8c	jsr $8ce9	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82c4		20 e2 d7	jsr $d7e2	                jsr print_u
.82c7		a9 48		lda #$48	                lda #'H'
.82c9		20 c5 86	jsr $86c5	                jsr emit_a
.82cc		68		pla		                pla
.82cd		85 18		sta $18		                sta base
.82cf		60		rts		z_at_xy:        rts
.82d0						xt_backslash:
.82d0		a0 04		ldy #$04	                ldy #blk_offset
.82d2		b1 08		lda ($08),y	                lda (up),y
.82d4		c8		iny		                iny
.82d5		11 08		ora ($08),y	                ora (up),y
.82d7		f0 19		beq $82f2	                beq backslash_not_block
.82d9		a5 10		lda $10		                lda toin
.82db		29 3f		and #$3f	                and #$3F
.82dd		f0 1b		beq $82fa	                beq z_backslash
.82df		c9 01		cmp #$01	                cmp #$1
.82e1		f0 17		beq $82fa	                beq z_backslash
.82e3		a5 10		lda $10		                lda toin
.82e5		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.82e7		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.82e8		69 40		adc #$40	                adc #$40
.82ea		85 10		sta $10		                sta toin
.82ec		90 0c		bcc $82fa	                bcc z_backslash
.82ee		e6 11		inc $11		                inc toin+1
.82f0		80 08		bra $82fa	                bra z_backslash
.82f2						backslash_not_block:
.82f2		a5 0e		lda $0e		                lda ciblen
.82f4		85 10		sta $10		                sta toin
.82f6		a5 0f		lda $0f		                lda ciblen+1
.82f8		85 11		sta $11		                sta toin+1
.82fa		60		rts		z_backslash:    rts
.82fb						xt_base:
.82fb		ca		dex		                dex
.82fc		ca		dex		                dex
.82fd		a9 18		lda #$18	                lda #<base
.82ff		95 00		sta $00,x	                sta 0,x         ; LSB
.8301		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8303		60		rts		z_base:         rts
.8304						xt_bl:
.8304		ca		dex		                dex
.8305		ca		dex		                dex
.8306		a9 20		lda #$20	                lda #AscSP
.8308		95 00		sta $00,x	                sta 0,x
.830a		74 01		stz $01,x	                stz 1,x
.830c		60		rts		z_bl:           rts
.830d						xt_bracket_char:
.830d		20 53 83	jsr $8353	                jsr xt_char
.8310		20 f2 89	jsr $89f2	                jsr xt_literal
.8313		60		rts		z_bracket_char: rts
.8314						xt_bracket_tick:
.8314		20 42 92	jsr $9242	                jsr xt_tick
.8317		20 f2 89	jsr $89f2	                jsr xt_literal
.831a		60		rts		z_bracket_tick: rts
.831b						xt_buffer_colon:
.831b		20 40 84	jsr $8440	                jsr xt_create
.831e		20 27 82	jsr $8227	                jsr xt_allot
.8321		60		rts		z_buffer_colon: rts
.8322						xt_c_comma:
.8322		20 75 d7	jsr $d775	                jsr underflow_1
.8325		b5 00		lda $00,x	                lda 0,x
.8327		20 75 97	jsr $9775	                jsr cmpl_a
.832a		e8		inx		                inx
.832b		e8		inx		                inx
.832c		60		rts		z_c_comma:      rts
.832d						xt_c_fetch:
.832d		20 75 d7	jsr $d775	                jsr underflow_1
.8330		a1 00		lda ($00,x)	                lda (0,x)
.8332		95 00		sta $00,x	                sta 0,x
.8334		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8336		60		rts		z_c_fetch:      rts
.8337						xt_c_store:
.8337		20 7a d7	jsr $d77a	                jsr underflow_2
.833a		b5 02		lda $02,x	                lda 2,x
.833c		81 00		sta ($00,x)	                sta (0,x)
.833e		e8		inx		                inx
.833f		e8		inx		                inx
.8340		e8		inx		                inx
.8341		e8		inx		                inx
.8342		60		rts		z_c_store:      rts
.8343						xt_cell_plus:
.8343		20 75 d7	jsr $d775	                jsr underflow_1
.8346		f6 00		inc $00,x	                inc 0,x
.8348		d0 02		bne $834c	                bne +
.834a		f6 01		inc $01,x	                inc 1,x
.834c						+
.834c		f6 00		inc $00,x	                inc 0,x
.834e		d0 02		bne $8352	                bne _done
.8350		f6 01		inc $01,x	                inc 1,x
.8352						_done:
.8352		60		rts		z_cell_plus:    rts
.8353						xt_char:
.8353		20 51 8d	jsr $8d51	                jsr xt_parse_name
.8356		b5 00		lda $00,x	                lda 0,x
.8358		15 01		ora $01,x	                ora 1,x
.835a		d0 05		bne $8361	                bne _not_empty
.835c		a9 05		lda #$05	                lda #err_noname
.835e		4c 8b d7	jmp $d78b	                jmp error
.8361						_not_empty:
.8361		e8		inx		                inx             ; drop number of characters, leave addr
.8362		e8		inx		                inx
.8363		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8365		95 00		sta $00,x	                sta 0,x
.8367		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8369		60		rts		z_char:         rts
.836a						xt_chars:
.836a		20 75 d7	jsr $d775	                jsr underflow_1
.836d		60		rts		z_chars:        rts
.836e						xt_colon:
.836e		a5 1a		lda $1a		                lda state
.8370		05 1b		ora $1b		                ora state+1
.8372		f0 05		beq $8379	                beq +
.8374		a9 07		lda #$07	                lda #err_state
.8376		4c 8b d7	jmp $d78b	                jmp error
.8379						+
.8379		c6 1a		dec $1a		                dec state
.837b		c6 1b		dec $1b		                dec state+1
.837d		a9 40		lda #$40	                lda #%01000000
.837f		04 1c		tsb $1c		                tsb status
.8381		20 cc d6	jsr $d6cc	                jsr current_to_dp
.8384		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8386		48		pha		                pha
.8387		a5 02		lda $02		                lda dp
.8389		48		pha		                pha
.838a		a9 80		lda #$80	                lda #%10000000
.838c		04 1c		tsb $1c		                tsb status
.838e		20 40 84	jsr $8440	                jsr xt_create
.8391		20 cc d6	jsr $d6cc	                jsr current_to_dp   ; This might be able to be omitted
.8394		a5 02		lda $02		                lda dp
.8396		85 06		sta $06		                sta workword
.8398		a5 03		lda $03		                lda dp+1
.839a		85 07		sta $07		                sta workword+1
.839c		68		pla		                pla
.839d		85 02		sta $02		                sta dp
.839f		68		pla		                pla
.83a0		85 03		sta $03		                sta dp+1
.83a2		20 df d6	jsr $d6df	                jsr dp_to_current
.83a5		a5 00		lda $00		                lda cp
.83a7		38		sec		                sec
.83a8		e9 03		sbc #$03	                sbc #3
.83aa		85 00		sta $00		                sta cp
.83ac		b0 02		bcs $83b0	                bcs _done
.83ae		c6 01		dec $01		                dec cp+1
.83b0						_done:
.83b0		60		rts		z_colon:        rts
.83b1						xt_colon_noname:
.83b1		a5 1a		lda $1a		                lda state
.83b3		05 1b		ora $1b		                ora state+1
.83b5		f0 05		beq $83bc	                beq +
.83b7		a9 07		lda #$07	                lda #err_state
.83b9		4c 8b d7	jmp $d78b	                jmp error
.83bc						+
.83bc		c6 1a		dec $1a		                dec state
.83be		c6 1b		dec $1b		                dec state+1
.83c0		a9 40		lda #$40	                lda #%01000000
.83c2		14 1c		trb $1c		                trb status
.83c4		a5 00		lda $00		                lda cp
.83c6		85 06		sta $06		                sta workword
.83c8		a5 01		lda $01		                lda cp+1
.83ca		85 07		sta $07		                sta workword+1
.83cc		60		rts		z_colon_noname:        rts
.83cd						xt_comma:
.83cd		20 75 d7	jsr $d775	                jsr underflow_1
.83d0		a0 02		ldy #$02	                ldy #2
.83d2		b5 00		lda $00,x	_twice:         lda 0,x
.83d4		20 75 97	jsr $9775	                jsr cmpl_a
.83d7		e8		inx		                inx
.83d8		88		dey		                dey
.83d9		d0 f7		bne $83d2	                bne _twice
.83db		60		rts		z_comma:        rts
.83dc						xt_compile_only:
.83dc		20 cc d6	jsr $d6cc	                jsr current_to_dp
.83df		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.83e1		b1 02		lda ($02),y	                lda (dp),y
.83e3		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.83e5		91 02		sta ($02),y	                sta (dp),y
.83e7		60		rts		z_compile_only: rts
.83e8						xt_value:
.83e8						xt_constant:
.83e8		20 75 d7	jsr $d775	                jsr underflow_1
.83eb		20 40 84	jsr $8440	                jsr xt_create
.83ee		38		sec		                sec
.83ef		a5 00		lda $00		                lda cp
.83f1		e9 02		sbc #$02	                sbc #2
.83f3		85 25		sta $25		                sta tmp1
.83f5		a5 01		lda $01		                lda cp+1
.83f7		e9 00		sbc #$00	                sbc #0
.83f9		85 26		sta $26		                sta tmp1+1
.83fb		a9 dd		lda #$dd	                lda #<doconst           ; LSB of DOCONST
.83fd		92 25		sta ($25)	                sta (tmp1)
.83ff		a0 01		ldy #$01	                ldy #1
.8401		a9 d5		lda #$d5	                lda #>doconst           ; MSB of DOCONST
.8403		91 25		sta ($25),y	                sta (tmp1),y
.8405		20 cd 83	jsr $83cd	                jsr xt_comma            ; drop through to adjust_z
.8408						adjust_z:
.8408		20 04 9c	jsr $9c04	                jsr xt_latestnt         ; gives us ( -- nt )
.840b		b5 00		lda $00,x	                lda 0,x
.840d		85 25		sta $25		                sta tmp1
.840f		b5 01		lda $01,x	                lda 1,x
.8411		85 26		sta $26		                sta tmp1+1
.8413		a0 06		ldy #$06	                ldy #6
.8415		b1 25		lda ($25),y	                lda (tmp1),y
.8417		18		clc		                clc
.8418		69 02		adc #$02	                adc #2
.841a		91 25		sta ($25),y	                sta (tmp1),y
.841c		c8		iny		                iny
.841d		b1 25		lda ($25),y	                lda (tmp1),y
.841f		69 00		adc #$00	                adc #0                  ; only need carry
.8421		91 25		sta ($25),y	                sta (tmp1),y
.8423		e8		inx		                inx
.8424		e8		inx		                inx
.8425						z_value:
.8425		60		rts		z_constant:     rts
.8426						xt_count:
.8426		20 75 d7	jsr $d775	                jsr underflow_1
.8429		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.842b		a8		tay		                tay
.842c		f6 00		inc $00,x	                inc 0,x         ; LSB
.842e		d0 02		bne $8432	                bne +
.8430		f6 01		inc $01,x	                inc 1,x         ; MSB
.8432		98		tya		+               tya
.8433		ca		dex		                dex
.8434		ca		dex		                dex
.8435		95 00		sta $00,x	                sta 0,x         ; LSB
.8437		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8439		60		rts		z_count:        rts
.843a						xt_cr:
.843a		a9 0a		lda #$0a	                lda #AscLF
.843c		20 c5 86	jsr $86c5	                jsr emit_a
.843f		60		rts		z_cr:           rts
.8440						xt_create:
.8440		20 51 8d	jsr $8d51	                jsr xt_parse_name       ; ( addr u )
.8443		b5 00		lda $00,x	                lda 0,x
.8445		15 01		ora $01,x	                ora 1,x
.8447		d0 05		bne $844e	                bne _got_name
.8449		a9 05		lda #$05	                lda #err_noname
.844b		4c 8b d7	jmp $d78b	                jmp error
.844e						_got_name:
.844e		74 01		stz $01,x	                stz 1,x
.8450		20 af 93	jsr $93af	                jsr xt_two_dup          ; ( addr u addr u )
.8453		20 db 9a	jsr $9adb	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8456		b5 00		lda $00,x	                lda 0,x
.8458		15 01		ora $01,x	                ora 1,x
.845a		f0 1e		beq $847a	                beq _new_name           ; We haven't seen this one before.
.845c		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.845d		e8		inx		                inx
.845e		24 1c		bit $1c		                bit status
.8460		10 08		bpl $846a	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8462		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8464		05 1c		ora $1c		                ora status
.8466		85 1c		sta $1c		                sta status
.8468		80 18		bra $8482	                bra _process_name
.846a						_redefined_name:
.846a		a9 02		lda #$02	                lda #str_redefined
.846c		20 b1 d7	jsr $d7b1	                jsr print_string_no_lf
.846f		20 af 93	jsr $93af	                jsr xt_two_dup           ; ( addr u addr u )
.8472		20 c4 94	jsr $94c4	                jsr xt_type
.8475		20 cb 91	jsr $91cb	                jsr xt_space
.8478		80 08		bra $8482	                bra _process_name
.847a						_new_name:
.847a		e8		inx		                inx                     ; Drop flag (0) from find-name.
.847b		e8		inx		                inx
.847c		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.847e		25 1c		and $1c		                and status
.8480		85 1c		sta $1c		                sta status
.8482						_process_name:
.8482		b5 00		lda $00,x	                lda 0,x
.8484		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.8486		a5 00		lda $00		                lda cp
.8488		85 25		sta $25		                sta tmp1
.848a		a5 01		lda $01		                lda cp+1
.848c		85 26		sta $26		                sta tmp1+1
.848e		b5 00		lda $00,x	                lda 0,x
.8490		18		clc		                clc
.8491		69 08		adc #$08	                adc #8
.8493		85 29		sta $29		                sta tmp3                ; total header length
.8495		95 00		sta $00,x	                sta 0,x
.8497		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.8499		20 27 82	jsr $8227	                jsr xt_allot    ; ( addr )
.849c		20 cc d6	jsr $d6cc	                jsr current_to_dp
.849f		a0 00		ldy #$00	                ldy #0
.84a1		a5 27		lda $27		                lda tmp2
.84a3		91 25		sta ($25),y	                sta (tmp1),y
.84a5		a9 08		lda #$08	                lda #NN
.84a7		09 20		ora #$20	                ora #HC
.84a9		c8		iny		                iny
.84aa		91 25		sta ($25),y	                sta (tmp1),y
.84ac		c8		iny		                iny
.84ad		a5 02		lda $02		                lda dp
.84af		91 25		sta ($25),y	                sta (tmp1),y
.84b1		c8		iny		                iny
.84b2		a5 03		lda $03		                lda dp+1
.84b4		91 25		sta ($25),y	                sta (tmp1),y
.84b6		c8		iny		                iny
.84b7		a5 26		lda $26		                lda tmp1+1
.84b9		85 03		sta $03		                sta dp+1
.84bb		a5 25		lda $25		                lda tmp1
.84bd		85 02		sta $02		                sta dp
.84bf		18		clc		                clc
.84c0		65 29		adc $29		                adc tmp3        ; add total header length
.84c2		91 25		sta ($25),y	                sta (tmp1),y
.84c4		48		pha		                pha             ; we need this in the next step
.84c5		c8		iny		                iny
.84c6		a5 26		lda $26		                lda tmp1+1
.84c8		69 00		adc #$00	                adc #0          ; only need the carry
.84ca		91 25		sta ($25),y	                sta (tmp1),y
.84cc		c8		iny		                iny
.84cd		68		pla		                pla             ; LSB of "z_" address
.84ce		18		clc		                clc
.84cf		69 03		adc #$03	                adc #3
.84d1		91 25		sta ($25),y	                sta (tmp1),y
.84d3		88		dey		                dey             ; get the MSB of xt back
.84d4		b1 25		lda ($25),y	                lda (tmp1),y
.84d6		69 00		adc #$00	                adc #0          ; only need the carry
.84d8		c8		iny		                iny
.84d9		c8		iny		                iny
.84da		91 25		sta ($25),y	                sta (tmp1),y
.84dc		c8		iny		                iny
.84dd		b5 00		lda $00,x	                lda 0,x
.84df		38		sec		                sec
.84e0		e9 08		sbc #$08	                sbc #8
.84e2		85 23		sta $23		                sta tmptos
.84e4		b5 01		lda $01,x	                lda 1,x
.84e6		e9 00		sbc #$00	                sbc #0          ; only need carry
.84e8		85 24		sta $24		                sta tmptos+1
.84ea						_name_loop:
.84ea		b1 23		lda ($23),y	                lda (tmptos),y
.84ec		c9 5b		cmp #$5b	                cmp #'Z'+1
.84ee		b0 06		bcs $84f6	                bcs _store_name
.84f0		c9 41		cmp #$41	                cmp #'A'
.84f2		90 02		bcc $84f6	                bcc _store_name
.84f4		09 20		ora #$20	                ora #$20
.84f6						_store_name:
.84f6		91 25		sta ($25),y	                sta (tmp1),y
.84f8		c8		iny		                iny
.84f9		c6 27		dec $27		                dec tmp2
.84fb		d0 ed		bne $84ea	                bne _name_loop
.84fd		a0 d6		ldy #$d6	                ldy #>dovar
.84ff		a9 23		lda #$23	                lda #<dovar
.8501		20 65 97	jsr $9765	                jsr cmpl_subroutine
.8504		20 df d6	jsr $d6df	                jsr dp_to_current
.8507		e8		inx		                inx
.8508		e8		inx		                inx
.8509		60		rts		z_create:       rts
.850a						xt_decimal:
.850a		a9 0a		lda #$0a	                lda #10
.850c		85 18		sta $18		                sta base
.850e		64 19		stz $19		                stz base+1              ; paranoid
.8510		60		rts		z_decimal:      rts
.8511						xt_defer:
.8511		20 40 84	jsr $8440	                jsr xt_create
.8514		a5 00		lda $00		                lda cp          ; LSB
.8516		38		sec		                sec
.8517		e9 02		sbc #$02	                sbc #2
.8519		85 25		sta $25		                sta tmp1
.851b		a5 01		lda $01		                lda cp+1        ; MSB
.851d		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.851f		85 26		sta $26		                sta tmp1+1
.8521		a0 00		ldy #$00	                ldy #0
.8523		a9 f1		lda #$f1	                lda #<dodefer   ; LSB
.8525		91 25		sta ($25),y	                sta (tmp1),y
.8527		c8		iny		                iny
.8528		a9 d5		lda #$d5	                lda #>dodefer   ; MSB
.852a		91 25		sta ($25),y	                sta (tmp1),y
.852c		a9 05		lda #$05	                lda #<defer_error
.852e		92 00		sta ($00)	                sta (cp)
.8530		e6 00		inc $00		                inc cp
.8532		d0 02		bne $8536	                bne +
.8534		e6 01		inc $01		                inc cp+1
.8536						+
.8536		a9 d6		lda #$d6	                lda #>defer_error
.8538		92 00		sta ($00)	                sta (cp)
.853a		e6 00		inc $00		                inc cp
.853c		d0 02		bne $8540	                bne +
.853e		e6 01		inc $01		                inc cp+1
.8540						+
.8540		20 08 84	jsr $8408	                jsr adjust_z    ; adjust header to correct length
.8543		60		rts		z_defer:        rts
.8544						xt_defer_fetch:
.8544		20 9e 92	jsr $929e	                jsr xt_to_body
.8547		20 1a 88	jsr $881a	                jsr xt_fetch
.854a		60		rts		z_defer_fetch:  rts
.854b						xt_defer_store:
.854b		20 9e 92	jsr $929e	                jsr xt_to_body
.854e		20 18 92	jsr $9218	                jsr xt_store
.8551		60		rts		z_defer_store:  rts
.8552						xt_depth:
.8552		a9 78		lda #$78	                lda #dsp0
.8554		86 1e		stx $1e		                stx tmpdsp
.8556		38		sec		                sec
.8557		e5 1e		sbc $1e		                sbc tmpdsp
.8559		4a		lsr a		                lsr
.855a		ca		dex		                dex
.855b		ca		dex		                dex
.855c		95 00		sta $00,x	                sta 0,x
.855e		74 01		stz $01,x	                stz 1,x
.8560		60		rts		z_depth:        rts
.8561						xt_question_do:
.8561		ca		dex		                dex
.8562		ca		dex		                dex
.8563		a9 a4		lda #$a4	                lda #<question_do_runtime
.8565		95 00		sta $00,x	                sta 0,x
.8567		a9 85		lda #$85	                lda #>question_do_runtime
.8569		95 01		sta $01,x	                sta 1,x
.856b		20 a0 86	jsr $86a0	                jsr xt_dup              ; xt and xt' are the same
.856e		ca		dex		                dex
.856f		ca		dex		                dex
.8570		a9 10		lda #$10	                lda #question_do_runtime_size
.8572		95 00		sta $00,x	                sta 0,x
.8574		74 01		stz $01,x	                stz 1,x
.8576		20 33 97	jsr $9733	                jsr cmpl_by_limit
.8579		90 0b		bcc $8586	                bcc _native
.857b		20 1b 89	jsr $891b	                jsr xt_here
.857e		20 dc 9d	jsr $9ddc	                jsr xt_zero
.8581		20 cd 83	jsr $83cd	                jsr xt_comma
.8584		80 08		bra $858e	                bra do_common
.8586						_native:
.8586		20 86 97	jsr $9786	                jsr cmpl_jump_later
.8589		80 03		bra $858e	                bra do_common
.858b						xt_do:
.858b		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; push 0 TOS
.858e						do_common:
.858e		ca		dex		                dex
.858f		ca		dex		                dex
.8590		a5 21		lda $21		                lda loopleave
.8592		95 00		sta $00,x	                sta 0,x
.8594		a5 22		lda $22		                lda loopleave+1
.8596		95 01		sta $01,x	                sta 1,x
.8598		64 22		stz $22		                stz loopleave+1
.859a		a0 85		ldy #$85	                ldy #>do_runtime
.859c		a9 bc		lda #$bc	                lda #<do_runtime
.859e		20 65 97	jsr $9765	                jsr cmpl_subroutine
.85a1		4c 1b 89	jmp $891b	                jmp xt_here
.85a4						z_question_do:
.85a4						z_do:
.85a4						question_do_runtime:
.85a4		b5 00		lda $00,x	                lda 0,x
.85a6		d5 02		cmp $02,x	                cmp 2,x
.85a8		d0 0d		bne $85b7	                bne _begin
.85aa		b5 01		lda $01,x	                lda 1,x
.85ac		d5 03		cmp $03,x	                cmp 3,x
.85ae		d0 07		bne $85b7	                bne _begin
.85b0		e8		inx		                inx                     ; drop loop limits and skip
.85b1		e8		inx		                inx
.85b2		e8		inx		                inx
.85b3		e8		inx		                inx
=16						question_do_runtime_size = * - question_do_runtime
.85b4		a9 00		lda #$00	                lda #0
>85b6		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.85b7		a9 01		lda #$01	_begin:         lda #1
.85b9		4c 1f 98	jmp $981f	                jmp zbranch_runtime
.85bc						do_runtime:
.85bc		a4 1f		ldy $1f		                ldy loopctrl
.85be		30 05		bmi $85c5	                bmi +                   ; is this the first LCB?
.85c0		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.85c2		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.85c5						+
.85c5		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.85c6		c8		iny		                iny
.85c7		c8		iny		                iny
.85c8		c8		iny		                iny
.85c9		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.85cb		38		sec		                sec
.85cc		a9 00		lda #$00	                lda #0
.85ce		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.85d0		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.85d3		a9 80		lda #$80	                lda #$80
.85d5		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.85d7		99 03 01	sta $0103,y	                sta loopfufa+1,y
.85da		18		clc		                clc
.85db		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.85dd		79 02 01	adc $0102,y	                adc loopfufa,y
.85e0		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.85e2		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.85e4		79 03 01	adc $0103,y	                adc loopfufa+1,y
.85e7		99 01 01	sta $0101,y	                sta loopindex+1,y
.85ea		e8		inx		                inx                 ; clean up the stack
.85eb		e8		inx		                inx
.85ec		e8		inx		                inx
.85ed		e8		inx		                inx
.85ee		60		rts		                rts
.85ef						xt_does:
.85ef		a0 85		ldy #$85	                ldy #>does_runtime
.85f1		a9 fe		lda #$fe	                lda #<does_runtime
.85f3		20 65 97	jsr $9765	                jsr cmpl_subroutine
.85f6		a0 d6		ldy #$d6	                ldy #>dodoes
.85f8		a9 0a		lda #$0a	                lda #<dodoes
.85fa		20 65 97	jsr $9765	                jsr cmpl_subroutine
.85fd		60		rts		z_does:         rts
.85fe						does_runtime:
.85fe		7a		ply		                ply             ; LSB
.85ff		68		pla		                pla             ; MSB
.8600		c8		iny		                iny
.8601		d0 01		bne $8604	                bne +
.8603		1a		inc a		                ina
.8604						+
.8604		84 25		sty $25		                sty tmp1
.8606		85 26		sta $26		                sta tmp1+1
.8608		20 cc d6	jsr $d6cc	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.860b		a5 02		lda $02		                lda dp
.860d		18		clc		                clc
.860e		69 04		adc #$04	                adc #4
.8610		85 27		sta $27		                sta tmp2
.8612		a5 03		lda $03		                lda dp+1
.8614		69 00		adc #$00	                adc #0          ; we only care about the carry
.8616		85 28		sta $28		                sta tmp2+1
.8618		b2 27		lda ($27)	                lda (tmp2)
.861a		18		clc		                clc
.861b		69 01		adc #$01	                adc #1
.861d		85 29		sta $29		                sta tmp3
.861f		a0 01		ldy #$01	                ldy #1
.8621		b1 27		lda ($27),y	                lda (tmp2),y
.8623		69 00		adc #$00	                adc #0          ; we only care about the carry
.8625		85 2a		sta $2a		                sta tmp3+1
.8627		a5 25		lda $25		                lda tmp1        ; LSB
.8629		92 29		sta ($29)	                sta (tmp3)
.862b		a5 26		lda $26		                lda tmp1+1
.862d		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.862f		60		rts		                rts
.8630						xt_dot:
.8630		20 75 d7	jsr $d775	                jsr underflow_1
.8633		20 a0 86	jsr $86a0	                jsr xt_dup                      ; ( n n )
.8636		20 cf 80	jsr $80cf	                jsr xt_abs                      ; ( n u )
.8639		20 dc 9d	jsr $9ddc	                jsr xt_zero                     ; ( n u 0 )
.863c		20 cf 89	jsr $89cf	                jsr xt_less_number_sign         ; ( n u 0 )
.863f		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s            ; ( n ud )
.8642		20 91 8f	jsr $8f91	                jsr xt_rot                      ; ( ud n )
.8645		20 50 91	jsr $9150	                jsr xt_sign                     ; ( ud )
.8648		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater      ; ( addr u )
.864b		20 c4 94	jsr $94c4	                jsr xt_type
.864e		20 cb 91	jsr $91cb	                jsr xt_space
.8651		60		rts		z_dot:          rts
.8652						xt_dot_paren:
.8652		ca		dex		                dex
.8653		ca		dex		                dex
.8654		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8656		95 00		sta $00,x	                sta 0,x
.8658		74 01		stz $01,x	                stz 1,x
.865a		20 ac 8d	jsr $8dac	                jsr xt_parse
.865d		20 c4 94	jsr $94c4	                jsr xt_type
.8660		60		rts		z_dot_paren:    rts
.8661						xt_dot_quote:
.8661		20 da 8f	jsr $8fda	                jsr xt_s_quote
.8664		a0 94		ldy #$94	                ldy #>xt_type
.8666		a9 c4		lda #$c4	                lda #<xt_type
.8668		20 65 97	jsr $9765	                jsr cmpl_subroutine
.866b		60		rts		z_dot_quote:    rts
.866c						xt_dot_r:
.866c		20 7a d7	jsr $d77a	                jsr underflow_2
.866f		20 6c 93	jsr $936c	                jsr xt_to_r
.8672		20 a0 86	jsr $86a0	                jsr xt_dup
.8675		20 cf 80	jsr $80cf	                jsr xt_abs
.8678		20 dc 9d	jsr $9ddc	                jsr xt_zero
.867b		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.867e		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.8681		20 91 8f	jsr $8f91	                jsr xt_rot
.8684		20 50 91	jsr $9150	                jsr xt_sign
.8687		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.868a		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.868d		20 05 8d	jsr $8d05	                jsr xt_over
.8690		20 e4 8b	jsr $8be4	                jsr xt_minus
.8693		20 d1 91	jsr $91d1	                jsr xt_spaces
.8696		20 c4 94	jsr $94c4	                jsr xt_type
.8699		60		rts		z_dot_r:        rts
.869a						xt_drop:
.869a		20 75 d7	jsr $d775	                jsr underflow_1
.869d		e8		inx		                inx
.869e		e8		inx		                inx
.869f		60		rts		z_drop:         rts
.86a0						xt_dup:
.86a0		20 75 d7	jsr $d775	                jsr underflow_1
.86a3		ca		dex		                dex
.86a4		ca		dex		                dex
.86a5		b5 02		lda $02,x	                lda 2,x         ; LSB
.86a7		95 00		sta $00,x	                sta 0,x
.86a9		b5 03		lda $03,x	                lda 3,x         ; MSB
.86ab		95 01		sta $01,x	                sta 1,x
.86ad		60		rts		z_dup:          rts
.86ae						xt_else:
.86ae						xt_endof:
.86ae		20 86 97	jsr $9786	                jsr cmpl_jump_later
.86b1		20 2e 92	jsr $922e	                jsr xt_swap         ; ( target orig )
.86b4						xt_then:
.86b4		20 1b 89	jsr $891b	                jsr xt_here
.86b7		20 2e 92	jsr $922e	                jsr xt_swap
.86ba		20 18 92	jsr $9218	                jsr xt_store
.86bd						z_else:
.86bd						z_endof:
.86bd		60		rts		z_then:         rts
.86be						xt_emit:
.86be		20 75 d7	jsr $d775	                jsr underflow_1
.86c1		b5 00		lda $00,x	                lda 0,x
.86c3		e8		inx		                inx
.86c4		e8		inx		                inx
.86c5						emit_a:
.86c5		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.86c8						z_emit:
.86c8						xt_endcase:
.86c8		a0 86		ldy #$86	                ldy #>xt_drop
.86ca		a9 9a		lda #$9a	                lda #<xt_drop
.86cc		20 65 97	jsr $9765	                jsr cmpl_subroutine
.86cf						_endcase_loop:
.86cf		b5 00		lda $00,x	                lda 0,x
.86d1		15 01		ora $01,x	                ora 1,x
.86d3		f0 05		beq $86da	                beq _done
.86d5		20 b4 86	jsr $86b4	                jsr xt_then
.86d8		80 f5		bra $86cf	                bra _endcase_loop
.86da						_done:
.86da		e8		inx		                inx
.86db		e8		inx		                inx
.86dc		60		rts		z_endcase:      rts
.86dd						xt_environment_q:
.86dd		20 75 d7	jsr $d775	                jsr underflow_1
.86e0		a0 00		ldy #$00	                ldy #00                 ; counter for table
.86e2		5a		phy		                phy
.86e3						_table_loop:
.86e3		20 af 93	jsr $93af	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.86e6		ca		dex		                dex
.86e7		ca		dex		                dex                     ; ( addr u addr u ? )
.86e8		b9 5a 87	lda $875a,y	                lda env_table_single,y
.86eb		95 00		sta $00,x	                sta 0,x
.86ed		c8		iny		                iny
.86ee		b9 5a 87	lda $875a,y	                lda env_table_single,y
.86f1		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.86f3		c8		iny		                iny
.86f4		15 00		ora $00,x	                ora 0,x
.86f6		f0 4d		beq $8745	                beq _table_done
.86f8		5a		phy		                phy                     ; save Y, which is used by COUNT
.86f9		20 26 84	jsr $8426	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.86fc		20 a3 9f	jsr $9fa3	                jsr xt_compare          ; ( addr u f )
.86ff		7a		ply		                ply
.8700		b5 00		lda $00,x	                lda 0,x
.8702		15 01		ora $01,x	                ora 1,x
.8704		f0 04		beq $870a	                beq _got_result
.8706		e8		inx		                inx                     ; DROP, now ( addr u )
.8707		e8		inx		                inx
.8708		80 d9		bra $86e3	                bra _table_loop
.870a						_got_result:
.870a		e8		inx		                inx                     ; drop flag, now ( addr u )
.870b		e8		inx		                inx
.870c		88		dey		                dey                     ; go back to index we had
.870d		88		dey		                dey
.870e		68		pla		                pla
.870f		d0 0d		bne $871e	                bne _double_result
.8711		b9 78 87	lda $8778,y	                lda env_results_single,y
.8714		95 02		sta $02,x	                sta 2,x
.8716		c8		iny		                iny
.8717		b9 78 87	lda $8778,y	                lda env_results_single,y
.871a		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.871c		80 1f		bra $873d	                bra _set_flag
.871e						_double_result:
.871e		ca		dex		                dex                     ; ( addr u ? )
.871f		ca		dex		                dex
.8720		98		tya		                tya
.8721		38		sec		                sec
.8722		e9 18		sbc #$18	                sbc #24
.8724		0a		asl a		                asl
.8725		a8		tay		                tay
.8726		b9 8e 87	lda $878e,y	                lda env_results_double,y
.8729		95 02		sta $02,x	                sta 2,x
.872b		c8		iny		                iny
.872c		b9 8e 87	lda $878e,y	                lda env_results_double,y
.872f		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8731		c8		iny		                iny
.8732		b9 8e 87	lda $878e,y	                lda env_results_double,y
.8735		95 04		sta $04,x	                sta 4,x
.8737		c8		iny		                iny
.8738		b9 8e 87	lda $878e,y	                lda env_results_double,y
.873b		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.873d						_set_flag:
.873d		a9 ff		lda #$ff	                lda #$FF
.873f		95 00		sta $00,x	                sta 0,x
.8741		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8743		80 14		bra $8759	                bra _done
.8745						_table_done:
.8745		68		pla		                pla
.8746		d0 09		bne $8751	                bne _no_match
.8748		1a		inc a		                ina
.8749		48		pha		                pha
.874a		8a		txa		                txa
.874b		18		clc		                clc
.874c		69 06		adc #$06	                adc #6                  ; skip six bytes
.874e		aa		tax		                tax                     ; ( addr u )
.874f		80 92		bra $86e3	                bra _table_loop
.8751						_no_match:
.8751		8a		txa		                txa
.8752		18		clc		                clc
.8753		69 0a		adc #$0a	                adc #10
.8755		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8756		20 dc 9d	jsr $9ddc	                jsr xt_false
.8759						_done:
.8759						z_environment_q:
.8759		60		rts		                rts
.875a						env_table_single:
>875a		5d d5 6d d5 73 d5 78 d5		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8762		8a d5
>8764		92 d5 9b d5 a1 d5 a7 d5		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>876c		ba d5 c6 d5 00 00		        .word envs_sc, envs_wl, 0000
.8772						env_table_double:
>8772		d0 d5 d6 d5 00 00		        .word envs_max_d, envs_max_ud, 0000
.8778						env_results_single:
>8778		ff 00				        .word $00FF     ; /COUNTED-STRING
>877a		ff 00				        .word $00FF     ; /HOLD
>877c		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>877e		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8780		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8782		ff 00				        .word $00FF     ; MAX-CHAR
>8784		ff 7f				        .word $7FFF     ; MAX-N
>8786		ff ff				        .word $FFFF     ; MAX-U
>8788		80 00				        .word $0080     ; RETURN-STACK-CELLS
>878a		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>878c		09 00				        .word $0009     ; WORDLISTS
.878e						env_results_double:
>878e		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8792		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8796						xt_equal:
.8796		20 7a d7	jsr $d77a	                jsr underflow_2
.8799		b5 00		lda $00,x	                lda 0,x                 ; LSB
.879b		d5 02		cmp $02,x	                cmp 2,x
.879d		d0 0a		bne $87a9	                bne _false
.879f		b5 01		lda $01,x	                lda 1,x                 ; MSB
.87a1		d5 03		cmp $03,x	                cmp 3,x
.87a3		d0 04		bne $87a9	                bne _false
.87a5		a9 ff		lda #$ff	                lda #$FF
.87a7		80 02		bra $87ab	                bra _done
.87a9		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.87ab		95 02		sta $02,x	_done:          sta 2,x
.87ad		95 03		sta $03,x	                sta 3,x
.87af		e8		inx		                inx
.87b0		e8		inx		                inx
.87b1		60		rts		z_equal:        rts
.87b2						xt_blank:
.87b2		ca		dex		                dex
.87b3		ca		dex		                dex
.87b4		a9 20		lda #$20	                lda #AscSP
.87b6		95 00		sta $00,x	                sta 0,x
.87b8		74 01		stz $01,x	                stz 1,x
.87ba		80 06		bra $87c2	                bra xt_fill     ; skip over code for ERASE
.87bc						xt_erase:
.87bc		ca		dex		                dex
.87bd		ca		dex		                dex
.87be		74 00		stz $00,x	                stz 0,x
.87c0		74 01		stz $01,x	                stz 1,x
.87c2						xt_fill:
.87c2		20 7f d7	jsr $d77f	                jsr underflow_3
.87c5		b5 04		lda $04,x	                lda 4,x         ; LSB
.87c7		85 25		sta $25		                sta tmp1
.87c9		b5 05		lda $05,x	                lda 5,x
.87cb		85 26		sta $26		                sta tmp1+1
.87cd		b5 02		lda $02,x	                lda 2,x
.87cf		85 27		sta $27		                sta tmp2
.87d1		b5 03		lda $03,x	                lda 3,x
.87d3		85 28		sta $28		                sta tmp2+1
.87d5		b5 00		lda $00,x	                lda 0,x
.87d7		a8		tay		                tay
.87d8						_loop:
.87d8		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.87da		c5 26		cmp $26		                cmp tmp1+1
.87dc		90 21		bcc $87ff	                bcc _done               ; RAM_END < TMP1, so leave
.87de		d0 06		bne $87e6	                bne _check_counter      ; RAM_END is not smaller and not equal
.87e0		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.87e2		c5 25		cmp $25		                cmp tmp1
.87e4		90 19		bcc $87ff	                bcc _done               ; RAM_END < TMP1, so leave
.87e6						_check_counter:
.87e6		a5 27		lda $27		                lda tmp2
.87e8		05 28		ora $28		                ora tmp2+1
.87ea		f0 13		beq $87ff	                beq _done
.87ec		98		tya		                tya
.87ed		92 25		sta ($25)	                sta (tmp1)
.87ef		a5 27		lda $27		                lda tmp2
.87f1		d0 02		bne $87f5	                bne +
.87f3		c6 28		dec $28		                dec tmp2+1
.87f5		c6 27		dec $27		+               dec tmp2
.87f7		e6 25		inc $25		                inc tmp1
.87f9		d0 dd		bne $87d8	                bne _loop
.87fb		e6 26		inc $26		                inc tmp1+1
.87fd		80 d9		bra $87d8	                bra _loop
.87ff						_done:
.87ff		8a		txa		                txa
.8800		18		clc		                clc
.8801		69 06		adc #$06	                adc #6
.8803		aa		tax		                tax
.8804						z_blank:
.8804						z_erase:
.8804		60		rts		z_fill:         rts
.8805						xt_execute:
.8805		20 75 d7	jsr $d775	                jsr underflow_1
.8808		20 0c 88	jsr $880c	                jsr doexecute   ; do not combine to JMP (native coding)
.880b		60		rts		z_execute:      rts
.880c						doexecute:
.880c		b5 00		lda $00,x	                lda 0,x
.880e		85 04		sta $04		                sta ip
.8810		b5 01		lda $01,x	                lda 1,x
.8812		85 05		sta $05		                sta ip+1
.8814		e8		inx		                inx
.8815		e8		inx		                inx
.8816		6c 04 00	jmp ($0004)	                jmp (ip)
.8819						xt_exit:
.8819		60		rts		                rts             ; keep before z_exit
.881a						z_exit:
.881a						xt_fetch:
.881a		20 75 d7	jsr $d775	                jsr underflow_1
.881d		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.881f		a8		tay		                tay
.8820		f6 00		inc $00,x	                inc 0,x
.8822		d0 02		bne $8826	                bne +
.8824		f6 01		inc $01,x	                inc 1,x
.8826						+
.8826		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8828		95 01		sta $01,x	                sta 1,x
.882a		94 00		sty $00,x	                sty 0,x
.882c		60		rts		z_fetch:        rts
.882d						xt_find:
.882d		20 75 d7	jsr $d775	                jsr underflow_1
.8830		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8832		48		pha		                pha
.8833		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8835		48		pha		                pha
.8836		20 26 84	jsr $8426	                jsr xt_count            ; ( caddr -- addr u )
.8839		20 db 9a	jsr $9adb	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.883c		b5 00		lda $00,x	                lda 0,x
.883e		15 01		ora $01,x	                ora 1,x
.8840		d0 0b		bne $884d	                bne _found_word
.8842		20 dc 9d	jsr $9ddc	                jsr xt_false            ; ( 0 0 )
.8845		68		pla		                pla                     ; LSB of address
.8846		95 02		sta $02,x	                sta 2,x
.8848		68		pla		                pla
.8849		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.884b		80 27		bra $8874	                bra _done               ; ( addr 0 )
.884d						_found_word:
.884d		68		pla		                pla
.884e		68		pla		                pla
.884f		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.8852		20 19 9c	jsr $9c19	                jsr xt_name_to_int      ; ( nt xt )
.8855		20 2e 92	jsr $922e	                jsr xt_swap             ; ( xt nt )
.8858		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.885a		f6 00		inc $00,x	                inc 0,x
.885c		d0 02		bne $8860	                bne +
.885e		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8860						+
.8860		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8862		29 04		and #$04	                and #IM
.8864		d0 08		bne $886e	                bne _immediate          ; bit set, we're immediate
.8866		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8868		95 00		sta $00,x	                sta 0,x
.886a		95 01		sta $01,x	                sta 1,x
.886c		80 06		bra $8874	                bra _done
.886e						_immediate:
.886e		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8870		95 00		sta $00,x	                sta 0,x
.8872		74 01		stz $01,x	                stz 1,x
.8874						_done:
.8874		60		rts		z_find:         rts
.8875						xt_fm_slash_mod:
.8875		20 7f d7	jsr $d77f	                jsr underflow_3
.8878		64 27		stz $27		                stz tmp2        ; default: n is positive
.887a		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.887c		10 0e		bpl $888c	                bpl _check_d
.887e		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.8880		20 1f 8c	jsr $8c1f	                jsr xt_negate   ; NEGATE
.8883		20 6c 93	jsr $936c	                jsr xt_to_r     ; >R
.8886		20 4a 9e	jsr $9e4a	                jsr xt_dnegate  ; DNEGATE
.8889		20 f0 8e	jsr $8ef0	                jsr xt_r_from   ; R>
.888c						_check_d:
.888c		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.888e		10 0d		bpl $889d	                bpl _multiply
.8890		18		clc		                clc
.8891		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.8893		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.8895		95 02		sta $02,x	                sta 2,x
.8897		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8899		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.889b		95 03		sta $03,x	                sta 3,x
.889d						_multiply:
.889d		20 49 95	jsr $9549	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.88a0		a5 27		lda $27		                lda tmp2
.88a2		f0 07		beq $88ab	                beq _done
.88a4		e8		inx		                inx             ; pretend that we SWAP
.88a5		e8		inx		                inx
.88a6		20 1f 8c	jsr $8c1f	                jsr xt_negate
.88a9		ca		dex		                dex
.88aa		ca		dex		                dex
.88ab						_done:
.88ab		60		rts		z_fm_slash_mod: rts
.88ac						load_evaluate:
.88ac		a9 ff		lda #$ff	                lda #$FF
.88ae		85 25		sta $25		                sta tmp1
.88b0		80 11		bra $88c3	                bra load_evaluate_start
.88b2						xt_evaluate:
.88b2		20 7a d7	jsr $d77a	                jsr underflow_2
.88b5		64 25		stz $25		                stz tmp1
.88b7		b5 00		lda $00,x	                lda 0,x
.88b9		15 01		ora $01,x	                ora 1,x
.88bb		d0 06		bne $88c3	                bne evaluate_got_work
.88bd		e8		inx		                inx
.88be		e8		inx		                inx
.88bf		e8		inx		                inx
.88c0		e8		inx		                inx
.88c1		80 42		bra $8905	                bra evaluate_done
.88c3						load_evaluate_start:
.88c3						evaluate_got_work:
.88c3		a0 05		ldy #$05	                ldy #blk_offset+1
.88c5		b1 08		lda ($08),y	                lda (up),y
.88c7		48		pha		                pha
.88c8		88		dey		                dey
.88c9		b1 08		lda ($08),y	                lda (up),y
.88cb		48		pha		                pha
.88cc		a5 25		lda $25		                lda tmp1
.88ce		d0 05		bne $88d5	                bne _nozero
.88d0		91 08		sta ($08),y	                sta (up),y
.88d2		c8		iny		                iny
.88d3		91 08		sta ($08),y	                sta (up),y
.88d5						_nozero:
.88d5		20 7d 9b	jsr $9b7d	                jsr xt_input_to_r
.88d8		a9 ff		lda #$ff	                lda #$FF
.88da		85 0a		sta $0a		                sta insrc
.88dc		85 0b		sta $0b		                sta insrc+1
.88de		64 10		stz $10		                stz toin
.88e0		64 11		stz $11		                stz toin+1
.88e2		b5 00		lda $00,x	                lda 0,x
.88e4		85 0e		sta $0e		                sta ciblen
.88e6		b5 01		lda $01,x	                lda 1,x
.88e8		85 0f		sta $0f		                sta ciblen+1
.88ea		b5 02		lda $02,x	                lda 2,x
.88ec		85 0c		sta $0c		                sta cib
.88ee		b5 03		lda $03,x	                lda 3,x
.88f0		85 0d		sta $0d		                sta cib+1
.88f2		e8		inx		                inx             ; A clean stack is a clean mind
.88f3		e8		inx		                inx
.88f4		e8		inx		                inx
.88f5		e8		inx		                inx
.88f6		20 f2 d6	jsr $d6f2	                jsr interpret   ; ( -- )
.88f9		20 8a 9d	jsr $9d8a	                jsr xt_r_to_input
.88fc		a0 04		ldy #$04	                ldy #blk_offset
.88fe		68		pla		                pla
.88ff		91 08		sta ($08),y	                sta (up),y
.8901		c8		iny		                iny
.8902		68		pla		                pla
.8903		91 08		sta ($08),y	                sta (up),y
.8905						evaluate_done:
.8905		60		rts		z_evaluate:     rts
.8906						xt_greater_than:
.8906		20 7a d7	jsr $d77a	                jsr underflow_2
.8909		a0 00		ldy #$00	                ldy #0          ; default false
.890b		20 b3 d6	jsr $d6b3	                jsr compare_16bit
.890e		f0 03		beq $8913	                beq _false
.8910		10 01		bpl $8913	                bpl _false
.8912		88		dey		                dey
.8913						_false:
.8913		98		tya		                tya
.8914		e8		inx		                inx
.8915		e8		inx		                inx
.8916		95 00		sta $00,x	                sta 0,x
.8918		95 01		sta $01,x	                sta 1,x
.891a		60		rts		z_greater_than: rts
.891b						xt_here:
.891b						xt_begin:
.891b						xt_asm_arrow:
.891b		ca		dex		                dex
.891c		ca		dex		                dex
.891d		a5 00		lda $00		                lda cp
.891f		95 00		sta $00,x	                sta 0,x
.8921		a5 01		lda $01		                lda cp+1
.8923		95 01		sta $01,x	                sta 1,x
.8925						z_here:
.8925						z_begin:
.8925						z_asm_arrow:
.8925		60		rts		                rts
.8926						xt_hex:
.8926		a9 10		lda #$10	                lda #16
.8928		85 18		sta $18		                sta base
.892a		64 19		stz $19		                stz base+1              ; paranoid
.892c		60		rts		z_hex:          rts
.892d						xt_hold:
.892d		20 75 d7	jsr $d775	                jsr underflow_1
.8930		a5 2b		lda $2b		                lda tohold
.8932		d0 02		bne $8936	                bne +
.8934		c6 2c		dec $2c		                dec tohold+1
.8936						+
.8936		c6 2b		dec $2b		                dec tohold
.8938		b5 00		lda $00,x	                lda 0,x
.893a		92 2b		sta ($2b)	                sta (tohold)
.893c		e8		inx		                inx
.893d		e8		inx		                inx
.893e		60		rts		z_hold:         rts
.893f						xt_i:
.893f		ca		dex		                dex
.8940		ca		dex		                dex
.8941		a4 1f		ldy $1f		                ldy loopctrl
.8943		38		sec		                sec
.8944		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.8946		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8949		95 00		sta $00,x	                sta 0,x
.894b		b9 01 01	lda $0101,y	                lda loopindex+1,y
.894e		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8951		95 01		sta $01,x	                sta 1,x
.8953		60		rts		z_i:            rts
.8954						xt_if:
.8954		20 a2 97	jsr $97a2	                jsr cmpl_0branch_later
.8957		60		rts		z_if:           rts
.8958						xt_immediate:
.8958		20 cc d6	jsr $d6cc	                jsr current_to_dp
.895b		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.895d		b1 02		lda ($02),y	                lda (dp),y
.895f		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.8961		91 02		sta ($02),y	                sta (dp),y
.8963		60		rts		z_immediate:    rts
.8964						xt_invert:
.8964		20 75 d7	jsr $d775	                jsr underflow_1
.8967		a9 ff		lda #$ff	                lda #$FF
.8969		55 00		eor $00,x	                eor 0,x         ; LSB
.896b		95 00		sta $00,x	                sta 0,x
.896d		a9 ff		lda #$ff	                lda #$FF
.896f		55 01		eor $01,x	                eor 1,x         ; MSB
.8971		95 01		sta $01,x	                sta 1,x
.8973		60		rts		z_invert:       rts
.8974						xt_is:
.8974		a5 1a		lda $1a		                lda state
.8976		05 1b		ora $1b		                ora state+1
.8978		f0 0c		beq $8986	                beq _interpreting
.897a		20 14 83	jsr $8314	                jsr xt_bracket_tick
.897d		a0 85		ldy #$85	                ldy #>xt_defer_store
.897f		a9 4b		lda #$4b	                lda #<xt_defer_store
.8981		20 65 97	jsr $9765	                jsr cmpl_subroutine
.8984		80 06		bra $898c	                bra _done
.8986						_interpreting:
.8986		20 42 92	jsr $9242	                jsr xt_tick
.8989		20 4b 85	jsr $854b	                jsr xt_defer_store
.898c						_done:
.898c		60		rts		z_is:           rts
.898d						xt_j:
.898d		ca		dex		                dex                 ; make space on the stack
.898e		ca		dex		                dex
.898f		a5 1f		lda $1f		                lda loopctrl
.8991		38		sec		                sec
.8992		e9 04		sbc #$04	                sbc #4
.8994		a8		tay		                tay
.8995		38		sec		                sec
.8996		b9 00 01	lda $0100,y	                lda loopindex,y
.8999		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.899c		95 00		sta $00,x	                sta 0,x
.899e		b9 01 01	lda $0101,y	                lda loopindex+1,y
.89a1		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.89a4		95 01		sta $01,x	                sta 1,x
.89a6		60		rts		z_j:            rts
.89a7						xt_key:
.89a7		20 b1 89	jsr $89b1	                jsr key_a               ; returns char in A
.89aa		ca		dex		                dex
.89ab		ca		dex		                dex
.89ac		95 00		sta $00,x	                sta 0,x
.89ae		74 01		stz $01,x	                stz 1,x
.89b0		60		rts		z_key:          rts
.89b1						key_a:
.89b1		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.89b4						xt_leave:
.89b4		a5 21		lda $21		                lda loopleave
.89b6		a4 22		ldy $22		                ldy loopleave+1
.89b8		20 6a 97	jsr $976a	                jsr cmpl_jump   ; emit the JMP chaining prior leave address
.89bb		38		sec		                sec
.89bc		a5 00		lda $00		                lda cp
.89be		e9 02		sbc #$02	                sbc #2
.89c0		85 21		sta $21		                sta loopleave
.89c2		a5 01		lda $01		                lda cp+1
.89c4		b0 01		bcs $89c7	                bcs +
.89c6		3a		dec a		                dea
.89c7		85 22		sta $22		+               sta loopleave+1
.89c9						z_leave:
.89c9		60		rts		                rts
.89ca						xt_left_bracket:
.89ca		64 1a		stz $1a		                stz state
.89cc		64 1b		stz $1b		                stz state+1
.89ce		60		rts		z_left_bracket: rts
.89cf						xt_less_number_sign:
.89cf		20 13 8d	jsr $8d13	                jsr xt_pad      ; ( addr )
.89d2		b5 00		lda $00,x	                lda 0,x
.89d4		85 2b		sta $2b		                sta tohold
.89d6		b5 01		lda $01,x	                lda 1,x
.89d8		85 2c		sta $2c		                sta tohold+1
.89da		e8		inx		                inx
.89db		e8		inx		                inx
.89dc						z_less_number_sign:
.89dc		60		rts		                rts
.89dd						xt_less_than:
.89dd		20 7a d7	jsr $d77a	                jsr underflow_2
.89e0		a0 00		ldy #$00	                ldy #0          ; default false
.89e2		20 b3 d6	jsr $d6b3	                jsr compare_16bit
.89e5		f0 03		beq $89ea	                beq _false
.89e7		30 01		bmi $89ea	                bmi _false
.89e9		88		dey		                dey
.89ea						_false:
.89ea		98		tya		                tya
.89eb		e8		inx		                inx
.89ec		e8		inx		                inx
.89ed		95 00		sta $00,x	                sta 0,x
.89ef		95 01		sta $01,x	                sta 1,x
.89f1		60		rts		z_less_than:    rts
.89f2						xt_literal:
.89f2		20 75 d7	jsr $d775	                jsr underflow_1
.89f5		a9 0a		lda #$0a	                lda #template_push_tos_size
.89f7		20 90 97	jsr $9790	                jsr check_nc_limit
.89fa		90 0c		bcc $8a08	                bcc _inline
.89fc		a0 8a		ldy #$8a	                ldy #>literal_runtime
.89fe		a9 3a		lda #$3a	                lda #<literal_runtime
.8a00		20 65 97	jsr $9765	                jsr cmpl_subroutine
.8a03		20 cd 83	jsr $83cd	                jsr xt_comma
.8a06		80 27		bra $8a2f	                bra z_literal
.8a08						_inline:
.8a08		a0 94		ldy #$94	                ldy #$94        ; STY opcode
.8a0a		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a0c		d0 02		bne $8a10	                bne +
.8a0e		a0 74		ldy #$74	                ldy #$74        ; STZ opcode
.8a10		5a		phy		+               phy
.8a11		b5 00		lda $00,x	                lda 0,x         ; LSB
.8a13		48		pha		                pha
.8a14		a0 02		ldy #$02	                ldy #2
.8a16		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a18		f0 03		beq $8a1d	                beq _copy
.8a1a		a0 00		ldy #$00	                ldy #0
.8a1c		48		pha		                pha
.8a1d		b9 30 8a	lda $8a30,y	_copy:          lda template_push_tos,y
.8a20		c9 ff		cmp #$ff	                cmp #$ff        ; is it a placeholder?
.8a22		d0 01		bne $8a25	                bne +
.8a24		68		pla		                pla
.8a25		20 75 97	jsr $9775	+               jsr cmpl_a
.8a28		c8		iny		                iny
.8a29		c0 0a		cpy #$0a	                cpy #template_push_tos_size
.8a2b		d0 f0		bne $8a1d	                bne _copy
.8a2d		e8		inx		                inx             ; drop the literal
.8a2e		e8		inx		                inx
.8a2f		60		rts		z_literal:      rts
.8a30						template_push_tos:
.8a30		a0 ff		ldy #$ff	                ldy #$ff        ; we'll omit this if MSB is zero
.8a32		a9 ff		lda #$ff	                lda #$ff
.8a34		ca		dex		                dex
.8a35		ca		dex		                dex
.8a36		95 00		sta $00,x	                sta 0,x
>8a38		ff 01				                .byte $ff, 1    ; this will become either sty 1,x or stz 1,x
=10						template_push_tos_size = * - template_push_tos
.8a3a						literal_runtime:
.8a3a		ca		dex		                dex
.8a3b		ca		dex		                dex
.8a3c		68		pla		                pla             ; LSB
.8a3d		85 25		sta $25		                sta tmp1
.8a3f		68		pla		                pla             ; MSB
.8a40		85 26		sta $26		                sta tmp1+1
.8a42		a0 01		ldy #$01	                ldy #1
.8a44		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.8a46		95 00		sta $00,x	                sta 0,x
.8a48		c8		iny		                iny
.8a49		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.8a4b		95 01		sta $01,x	                sta 1,x
.8a4d		98		tya		                tya
.8a4e		18		clc		                clc
.8a4f		65 25		adc $25		                adc tmp1
.8a51		a8		tay		                tay
.8a52		a5 26		lda $26		                lda tmp1+1
.8a54		69 00		adc #$00	                adc #0
.8a56		48		pha		                pha
.8a57		5a		phy		                phy
.8a58		60		rts		                rts
.8a59						xt_loop:
.8a59		ca		dex		                dex
.8a5a		ca		dex		                dex
.8a5b		ca		dex		                dex
.8a5c		ca		dex		                dex
.8a5d		a9 d2		lda #$d2	                lda #<loop_runtime
.8a5f		95 02		sta $02,x	                sta 2,x
.8a61		a9 8a		lda #$8a	                lda #>loop_runtime
.8a63		95 03		sta $03,x	                sta 3,x
.8a65		a9 11		lda #$11	                lda #loop_runtime_size
.8a67		95 00		sta $00,x	                sta 0,x
.8a69		74 01		stz $01,x	                stz 1,x
.8a6b		80 12		bra $8a7f	                bra xt_loop_common
.8a6d						xt_plus_loop:
.8a6d		ca		dex		                dex
.8a6e		ca		dex		                dex
.8a6f		ca		dex		                dex
.8a70		ca		dex		                dex
.8a71		a9 eb		lda #$eb	                lda #<plus_loop_runtime
.8a73		95 02		sta $02,x	                sta 2,x
.8a75		a9 8a		lda #$8a	                lda #>plus_loop_runtime
.8a77		95 03		sta $03,x	                sta 3,x
.8a79		a9 1a		lda #$1a	                lda #plus_loop_runtime_size
.8a7b		95 00		sta $00,x	                sta 0,x
.8a7d		74 01		stz $01,x	                stz 1,x
.8a7f						xt_loop_common:
.8a7f		20 05 8d	jsr $8d05	                jsr xt_over
.8a82		20 2e 92	jsr $922e	                jsr xt_swap             ; xt and xt' are the same
.8a85		20 33 97	jsr $9733	                jsr cmpl_by_limit
.8a88		90 05		bcc $8a8f	                bcc _native
.8a8a		20 cd 83	jsr $83cd	                jsr xt_comma
.8a8d		80 03		bra $8a92	                bra +
.8a8f						_native:
.8a8f		20 7e 97	jsr $977e	                jsr cmpl_jump_tos
.8a92						+
.8a92		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.8a94		f0 19		beq $8aaf	                beq _noleave
.8a96						_next:
.8a96		a0 01		ldy #$01	                ldy #1
.8a98		b1 21		lda ($21),y	                lda (loopleave),y
.8a9a		48		pha		                pha
.8a9b		a5 01		lda $01		                lda cp+1
.8a9d		91 21		sta ($21),y	                sta (loopleave),y
.8a9f		88		dey		                dey
.8aa0		b1 21		lda ($21),y	                lda (loopleave),y
.8aa2		48		pha		                pha
.8aa3		a5 00		lda $00		                lda cp
.8aa5		91 21		sta ($21),y	                sta (loopleave),y
.8aa7		68		pla		                pla
.8aa8		85 21		sta $21		                sta loopleave
.8aaa		68		pla		                pla
.8aab		85 22		sta $22		                sta loopleave+1
.8aad		d0 e7		bne $8a96	                bne _next
.8aaf						_noleave:
.8aaf		b5 00		lda $00,x	                lda 0,x
.8ab1		85 21		sta $21		                sta loopleave
.8ab3		b5 01		lda $01,x	                lda 1,x
.8ab5		85 22		sta $22		                sta loopleave+1
.8ab7		a9 d1		lda #$d1	                lda #<xt_unloop
.8ab9		95 00		sta $00,x	                sta 0,x
.8abb		a9 95		lda #$95	                lda #>xt_unloop
.8abd		95 01		sta $01,x	                sta 1,x
.8abf		20 c7 96	jsr $96c7	                jsr xt_compile_comma
.8ac2		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.8ac4		f0 09		beq $8acf	                beq +
.8ac6		20 1b 89	jsr $891b	                jsr xt_here
.8ac9		20 2e 92	jsr $922e	                jsr xt_swap
.8acc		4c 18 92	jmp $9218	                jmp xt_store            ; write here as ?DO jmp target and return
.8acf		e8		inx		+               inx                     ; drop the ignored word for DO
.8ad0		e8		inx		                inx
.8ad1						z_loop:
.8ad1		60		rts		z_plus_loop:    rts
.8ad2						loop_runtime:
.8ad2		e6 20		inc $20		                inc loopidx0            ; increment the LSB of loopindex
.8ad4		d0 0d		bne $8ae3	                bne _repeat             ; avoid expensive test most of the time
.8ad6		a4 1f		ldy $1f		                ldy loopctrl
.8ad8		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8adb		1a		inc a		                ina
.8adc		c9 80		cmp #$80	                cmp #$80
.8ade		f0 06		beq $8ae6	                beq _done
.8ae0		99 01 01	sta $0101,y	                sta loopindex+1,y
=17						loop_runtime_size = * - loop_runtime
.8ae3						_repeat:
.8ae3		a9 00		lda #$00	                lda #0
>8ae5		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8ae6		a9 01		lda #$01	_done:          lda #1
.8ae8		4c 1f 98	jmp $981f	                jmp zbranch_runtime
.8aeb						plus_loop_runtime:
.8aeb		18		clc		                clc
.8aec		b5 00		lda $00,x	                lda 0,x                 ; LSB of step
.8aee		65 20		adc $20		                adc loopidx0
.8af0		85 20		sta $20		                sta loopidx0
.8af2		e8		inx		                inx                     ; dump step from TOS before MSB test
.8af3		e8		inx		                inx                     ; since we might skip it
.8af4		b5 ff		lda $ff,x	                lda $FF,x               ; MSB of step since 1,x == -1,x+2
.8af6		d0 02		bne $8afa	                bne _chkv               ; if it's non-zero we have to check
.8af8		90 0b		bcc $8b05	                bcc _repeat             ; but if 0 and no carry, we're good
.8afa		b8		clv		_chkv:          clv
.8afb		a4 1f		ldy $1f		                ldy loopctrl            ; get LCB offset
.8afd		79 01 01	adc $0101,y	                adc loopindex+1,y       ; MSB of index
.8b00		99 01 01	sta $0101,y	                sta loopindex+1,y       ; put MSB of index back on stack
.8b03		70 03		bvs $8b08	                bvs _done               ; skip over JMP instruction
=26						plus_loop_runtime_size = * - plus_loop_runtime
.8b05						_repeat:
.8b05		a9 00		lda #$00	                lda #0
>8b07		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8b08		a9 01		lda #$01	_done:          lda #1
.8b0a		4c 1f 98	jmp $981f	                jmp zbranch_runtime
.8b0d						xt_lshift:
.8b0d		20 7a d7	jsr $d77a	                jsr underflow_2
.8b10		b5 00		lda $00,x	                lda 0,x
.8b12		29 0f		and #$0f	                and #%00001111
.8b14		f0 08		beq $8b1e	                beq _done
.8b16		a8		tay		                tay
.8b17						_loop:
.8b17		16 02		asl $02,x	                asl 2,x
.8b19		36 03		rol $03,x	                rol 3,x
.8b1b		88		dey		                dey
.8b1c		d0 f9		bne $8b17	                bne _loop
.8b1e						_done:
.8b1e		e8		inx		                inx
.8b1f		e8		inx		                inx
.8b20		60		rts		z_lshift:       rts
.8b21						xt_m_star:
.8b21		20 7a d7	jsr $d77a	                jsr underflow_2
.8b24		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8b26		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.8b28		48		pha		                pha
.8b29		20 cf 80	jsr $80cf	                jsr xt_abs
.8b2c		20 2e 92	jsr $922e	                jsr xt_swap
.8b2f		20 cf 80	jsr $80cf	                jsr xt_abs
.8b32		20 8b 95	jsr $958b	                jsr xt_um_star          ; ( d )
.8b35		68		pla		                pla
.8b36		10 03		bpl $8b3b	                bpl _done
.8b38		20 4a 9e	jsr $9e4a	                jsr xt_dnegate
.8b3b						_done:
.8b3b		60		rts		z_m_star:       rts
.8b3c						xt_marker:
.8b3c		20 cc d6	jsr $d6cc	                jsr current_to_dp
.8b3f		a5 02		lda $02		                lda dp
.8b41		48		pha		                pha
.8b42		a5 03		lda $03		                lda dp+1
.8b44		48		pha		                pha
.8b45		a5 00		lda $00		                lda cp
.8b47		48		pha		                pha
.8b48		a5 01		lda $01		                lda cp+1
.8b4a		48		pha		                pha
.8b4b		20 40 84	jsr $8440	                jsr xt_create
.8b4e		a5 00		lda $00		                lda cp          ; LSB
.8b50		38		sec		                sec
.8b51		e9 02		sbc #$02	                sbc #2
.8b53		85 00		sta $00		                sta cp
.8b55		b0 02		bcs $8b59	                bcs +
.8b57		c6 01		dec $01		                dec cp+1        ; we only care about the borrow
.8b59						+
.8b59		a0 8b		ldy #$8b	                ldy #>marker_runtime
.8b5b		a9 77		lda #$77	                lda #<marker_runtime
.8b5d		20 71 97	jsr $9771	                jsr cmpl_word
.8b60		7a		ply		                ply                     ; MSB
.8b61		68		pla		                pla                     ; LSB
.8b62		20 71 97	jsr $9771	                jsr cmpl_word
.8b65		7a		ply		                ply                     ; MSB
.8b66		68		pla		                pla                     ; LSB
.8b67		20 71 97	jsr $9771	                jsr cmpl_word
.8b6a		a0 08		ldy #$08	                ldy #marker_start_offset
.8b6c						-
.8b6c		b1 08		lda ($08),y	                lda (up),y
.8b6e		20 75 97	jsr $9775	                jsr cmpl_a
.8b71		c8		iny		                iny
.8b72		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8b74		d0 f6		bne $8b6c	                bne -
.8b76		60		rts		z_marker:       rts
.8b77						marker_runtime:
.8b77		68		pla		                pla
.8b78		85 25		sta $25		                sta tmp1        ; LSB of address
.8b7a		68		pla		                pla
.8b7b		85 26		sta $26		                sta tmp1+1      ; MSB of address
.8b7d		a0 01		ldy #$01	                ldy #1          ; start at 1 due to RTS mechanics
.8b7f		b1 25		lda ($25),y	                lda (tmp1),y
.8b81		85 00		sta $00		                sta cp
.8b83		c8		iny		                iny
.8b84		b1 25		lda ($25),y	                lda (tmp1),y
.8b86		85 01		sta $01		                sta cp+1
.8b88		c8		iny		                iny
.8b89		b1 25		lda ($25),y	                lda (tmp1),y
.8b8b		85 02		sta $02		                sta dp
.8b8d		c8		iny		                iny
.8b8e		b1 25		lda ($25),y	                lda (tmp1),y
.8b90		85 03		sta $03		                sta dp+1
.8b92		38		sec		                sec
.8b93		a5 25		lda $25		                lda tmp1
.8b95		e9 03		sbc #$03	                sbc #marker_start_offset - 5
.8b97		85 25		sta $25		                sta tmp1
.8b99		b0 02		bcs $8b9d	                bcs +
.8b9b		c6 26		dec $26		                dec tmp1+1
.8b9d						+
.8b9d		a0 08		ldy #$08	                ldy #marker_start_offset
.8b9f						-
.8b9f		b1 25		lda ($25),y	                lda (tmp1),y
.8ba1		91 08		sta ($08),y	                sta (up),y
.8ba3		c8		iny		                iny
.8ba4		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8ba6		d0 f7		bne $8b9f	                bne -
.8ba8		20 df d6	jsr $d6df	                jsr dp_to_current       ; Move the CURRENT DP back.
.8bab		60		rts		                rts
.8bac						xt_max:
.8bac		20 7a d7	jsr $d77a	                jsr underflow_2
.8baf		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bb1		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.8bb3		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bb5		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bb7		50 02		bvc $8bbb	                bvc _no_overflow
.8bb9		49 80		eor #$80	                eor #$80        ; complement negative flag
.8bbb						_no_overflow:
.8bbb		30 08		bmi $8bc5	                bmi _keep_nos
.8bbd		b5 00		lda $00,x	                lda 0,x
.8bbf		95 02		sta $02,x	                sta 2,x
.8bc1		b5 01		lda $01,x	                lda 1,x
.8bc3		95 03		sta $03,x	                sta 3,x
.8bc5						_keep_nos:
.8bc5		e8		inx		                inx
.8bc6		e8		inx		                inx
.8bc7		60		rts		z_max:          rts
.8bc8						xt_min:
.8bc8		20 7a d7	jsr $d77a	                jsr underflow_2
.8bcb		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bcd		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.8bcf		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bd1		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bd3		50 02		bvc $8bd7	                bvc _no_overflow
.8bd5		49 80		eor #$80	                eor #$80
.8bd7						_no_overflow:
.8bd7		10 08		bpl $8be1	                bpl _keep_nos
.8bd9		b5 00		lda $00,x	                lda 0,x
.8bdb		95 02		sta $02,x	                sta 2,x
.8bdd		b5 01		lda $01,x	                lda 1,x
.8bdf		95 03		sta $03,x	                sta 3,x
.8be1						_keep_nos:
.8be1		e8		inx		                inx
.8be2		e8		inx		                inx
.8be3		60		rts		z_min:          rts
.8be4						xt_minus:
.8be4		20 7a d7	jsr $d77a	                jsr underflow_2
.8be7		38		sec		                sec
.8be8		b5 02		lda $02,x	                lda 2,x         ; LSB
.8bea		f5 00		sbc $00,x	                sbc 0,x
.8bec		95 02		sta $02,x	                sta 2,x
.8bee		b5 03		lda $03,x	                lda 3,x         ; MSB
.8bf0		f5 01		sbc $01,x	                sbc 1,x
.8bf2		95 03		sta $03,x	                sta 3,x
.8bf4		e8		inx		                inx
.8bf5		e8		inx		                inx
.8bf6		60		rts		z_minus:        rts
.8bf7						xt_mod:
.8bf7		20 7a d7	jsr $d77a	                jsr underflow_2
.8bfa		20 6a 91	jsr $916a	                jsr xt_slash_mod
.8bfd		e8		inx		                inx             ; DROP
.8bfe		e8		inx		                inx
.8bff						z_mod:
.8bff		60		rts		                rts
.8c00						xt_move:
.8c00		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.8c02		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.8c04		f0 05		beq $8c0b	                beq _lsb                ; wasn't helpful, move to LSB
.8c06		b0 0e		bcs $8c16	                bcs _to_move_up         ; we want CMOVE>
.8c08		4c 2d 9f	jmp $9f2d	                jmp xt_cmove            ; JSR/RTS
.8c0b						_lsb:
.8c0b		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.8c0d		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.8c0f		f0 08		beq $8c19	                beq _equal              ; LSB is equal as well
.8c11		b0 03		bcs $8c16	                bcs _to_move_up         ; we want CMOVE>
.8c13		4c 2d 9f	jmp $9f2d	                jmp xt_cmove            ; JSR/RTS
.8c16						_to_move_up:
.8c16		4c 68 9f	jmp $9f68	                jmp xt_cmove_up         ; JSR/RTS
.8c19						_equal:
.8c19		8a		txa		                txa
.8c1a		18		clc		                clc
.8c1b		69 06		adc #$06	                adc #6
.8c1d		aa		tax		                tax
.8c1e		60		rts		z_move:         rts
.8c1f						xt_negate:
.8c1f		20 75 d7	jsr $d775	                jsr underflow_1
.8c22		a9 00		lda #$00	        	lda #0
.8c24		38		sec		                sec
.8c25		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8c27		95 00		sta $00,x	                sta 0,x
.8c29		a9 00		lda #$00	                lda #0
.8c2b		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.8c2d		95 01		sta $01,x	                sta 1,x
.8c2f		60		rts		z_negate:       rts
.8c30						xt_nip:
.8c30		20 7a d7	jsr $d77a	                jsr underflow_2
.8c33		b5 00		lda $00,x	                lda 0,x         ; LSB
.8c35		95 02		sta $02,x	                sta 2,x
.8c37		b5 01		lda $01,x	                lda 1,x         ; MSB
.8c39		95 03		sta $03,x	                sta 3,x
.8c3b		e8		inx		                inx
.8c3c		e8		inx		                inx
.8c3d		60		rts		z_nip:          rts
.8c3e						xt_not_equals:
.8c3e		20 7a d7	jsr $d77a	                jsr underflow_2
.8c41		a0 00		ldy #$00	                ldy #0                  ; default is true
.8c43		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8c45		d5 02		cmp $02,x	                cmp 2,x
.8c47		d0 0a		bne $8c53	                bne _not_equal
.8c49		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8c4b		d5 03		cmp $03,x	                cmp 3,x
.8c4d		d0 04		bne $8c53	                bne _not_equal
.8c4f		a9 ff		lda #$ff	                lda #$FF
.8c51		80 01		bra $8c54	                bra _done
.8c53						_not_equal:
.8c53		88		dey		                dey                     ; drop thru to done
.8c54						_done:
.8c54		98		tya		                tya
.8c55		e8		inx		                inx
.8c56		e8		inx		                inx
.8c57		95 00		sta $00,x	                sta 0,x
.8c59		95 01		sta $01,x	                sta 1,x
.8c5b		60		rts		z_not_equals:   rts
.8c5c						xt_number_sign:
.8c5c		20 7a d7	jsr $d77a	                jsr underflow_2         ; double number
.8c5f		20 fb 82	jsr $82fb	                jsr xt_base
.8c62		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( ud1 base )
.8c65		20 6c 93	jsr $936c	                jsr xt_to_r             ; >r
.8c68		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; 0
.8c6b		20 d9 8e	jsr $8ed9	                jsr xt_r_fetch          ; r@
.8c6e		20 49 95	jsr $9549	                jsr xt_um_slash_mod     ; um/mod
.8c71		20 91 8f	jsr $8f91	                jsr xt_rot              ; rot
.8c74		20 91 8f	jsr $8f91	                jsr xt_rot              ; rot
.8c77		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; r>
.8c7a		20 49 95	jsr $9549	                jsr xt_um_slash_mod     ; um/mod
.8c7d		20 91 8f	jsr $8f91	                jsr xt_rot              ; rot
.8c80		20 91 8f	jsr $8f91	                jsr xt_rot              ; ( ud rem )
.8c83		b5 00		lda $00,x	                lda 0,x
.8c85		a8		tay		                tay
.8c86		b9 fb d2	lda $d2fb,y	                lda s_abc_upper,y
.8c89		95 00		sta $00,x	                sta 0,x
.8c8b		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.8c8d		20 2d 89	jsr $892d	                jsr xt_hold
.8c90						z_number_sign:
.8c90		60		rts		                rts
.8c91						xt_number_sign_greater:
.8c91		20 7a d7	jsr $d77a	                jsr underflow_2         ; double number
.8c94		a5 2b		lda $2b		                lda tohold
.8c96		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.8c98		95 02		sta $02,x	                sta 2,x
.8c9a		a5 2c		lda $2c		                lda tohold+1
.8c9c		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.8c9e		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.8ca0		20 13 8d	jsr $8d13	                jsr xt_pad      ; ( addr addr pad )
.8ca3		38		sec		                sec
.8ca4		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.8ca6		f5 02		sbc $02,x	                sbc 2,x
.8ca8		95 02		sta $02,x	                sta 2,x
.8caa		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.8cac		f5 03		sbc $03,x	                sbc 3,x
.8cae		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.8cb0		e8		inx		                inx
.8cb1		e8		inx		                inx
.8cb2						z_number_sign_greater:
.8cb2		60		rts		                rts
.8cb3						xt_number_sign_s:
.8cb3		20 7a d7	jsr $d77a	                jsr underflow_2
.8cb6						_loop:
.8cb6		20 5c 8c	jsr $8c5c	                jsr xt_number_sign
.8cb9		b5 00		lda $00,x	                lda 0,x
.8cbb		15 01		ora $01,x	                ora 1,x
.8cbd		15 02		ora $02,x	                ora 2,x
.8cbf		15 03		ora $03,x	                ora 3,x
.8cc1		d0 f3		bne $8cb6	                bne _loop
.8cc3						z_number_sign_s:
.8cc3		60		rts		                rts
.8cc4						xt_of:
.8cc4		a0 8d		ldy #$8d	                ldy #>xt_over
.8cc6		a9 05		lda #$05	                lda #<xt_over
.8cc8		20 65 97	jsr $9765	                jsr cmpl_subroutine
.8ccb		a0 87		ldy #$87	                ldy #>xt_equal
.8ccd		a9 96		lda #$96	                lda #<xt_equal
.8ccf		20 65 97	jsr $9765	                jsr cmpl_subroutine
.8cd2		20 54 89	jsr $8954	                jsr xt_if
.8cd5		a0 86		ldy #$86	                ldy #>xt_drop
.8cd7		a9 9a		lda #$9a	                lda #<xt_drop
.8cd9		20 65 97	jsr $9765	                jsr cmpl_subroutine
.8cdc		60		rts		z_of:           rts
.8cdd						xt_one_minus:
.8cdd		20 75 d7	jsr $d775	                jsr underflow_1
.8ce0		b5 00		lda $00,x	                lda 0,x
.8ce2		d0 02		bne $8ce6	                bne +
.8ce4		d6 01		dec $01,x	                dec 1,x
.8ce6						+
.8ce6		d6 00		dec $00,x	                dec 0,x
.8ce8		60		rts		z_one_minus:    rts
.8ce9						xt_char_plus:
.8ce9						xt_one_plus:
.8ce9		20 75 d7	jsr $d775	                jsr underflow_1
.8cec		f6 00		inc $00,x	                inc 0,x
.8cee		d0 02		bne $8cf2	                bne _done
.8cf0		f6 01		inc $01,x	                inc 1,x
.8cf2						_done:
.8cf2						z_char_plus:
.8cf2		60		rts		z_one_plus:     rts
.8cf3						xt_or:
.8cf3		20 7a d7	jsr $d77a	                jsr underflow_2
.8cf6		b5 00		lda $00,x	                lda 0,x
.8cf8		15 02		ora $02,x	                ora 2,x
.8cfa		95 02		sta $02,x	                sta 2,x
.8cfc		b5 01		lda $01,x	                lda 1,x
.8cfe		15 03		ora $03,x	                ora 3,x
.8d00		95 03		sta $03,x	                sta 3,x
.8d02		e8		inx		                inx
.8d03		e8		inx		                inx
.8d04		60		rts		z_or:           rts
.8d05						xt_over:
.8d05		20 7a d7	jsr $d77a	                jsr underflow_2
.8d08		ca		dex		                dex
.8d09		ca		dex		                dex
.8d0a		b5 04		lda $04,x	                lda 4,x         ; LSB
.8d0c		95 00		sta $00,x	                sta 0,x
.8d0e		b5 05		lda $05,x	                lda 5,x         ; MSB
.8d10		95 01		sta $01,x	                sta 1,x
.8d12		60		rts		z_over:         rts
.8d13						xt_pad:
.8d13		ca		dex		                dex
.8d14		ca		dex		                dex
.8d15		a5 00		lda $00		                lda cp
.8d17		18		clc		                clc
.8d18		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.8d1a		95 00		sta $00,x	                sta 0,x
.8d1c		a5 01		lda $01		                lda cp+1
.8d1e		69 00		adc #$00	                adc #0          ; only need carry
.8d20		95 01		sta $01,x	                sta 1,x
.8d22		60		rts		z_pad:          rts
.8d23						xt_page:
.8d23		a9 1b		lda #$1b	                lda #AscESC
.8d25		20 c5 86	jsr $86c5	                jsr emit_a
.8d28		a9 5b		lda #$5b	                lda #'['
.8d2a		20 c5 86	jsr $86c5	                jsr emit_a
.8d2d		a9 32		lda #$32	                lda #'2'
.8d2f		20 c5 86	jsr $86c5	                jsr emit_a
.8d32		a9 4a		lda #$4a	                lda #'J'
.8d34		20 c5 86	jsr $86c5	                jsr emit_a
.8d37		20 dc 9d	jsr $9ddc	                jsr xt_zero
.8d3a		20 dc 9d	jsr $9ddc	                jsr xt_zero
.8d3d		20 a2 82	jsr $82a2	                jsr xt_at_xy
.8d40		60		rts		z_page:         rts
.8d41						xt_paren:
.8d41		ca		dex		                dex
.8d42		ca		dex		                dex
.8d43		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8d45		95 00		sta $00,x	                sta 0,x
.8d47		74 01		stz $01,x	                stz 1,x
.8d49		20 ac 8d	jsr $8dac	                jsr xt_parse
.8d4c		e8		inx		                inx
.8d4d		e8		inx		                inx
.8d4e		e8		inx		                inx
.8d4f		e8		inx		                inx
.8d50		60		rts		z_paren:        rts
.8d51						xt_parse_name:
.8d51		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.8d53		38		sec		                sec
.8d54		e5 10		sbc $10		                sbc toin
.8d56		85 25		sta $25		                sta tmp1
.8d58		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.8d5a		e5 11		sbc $11		                sbc toin+1
.8d5c		85 26		sta $26		                sta tmp1+1
.8d5e		a5 25		lda $25		                lda tmp1
.8d60		05 26		ora $26		                ora tmp1+1
.8d62		f0 28		beq $8d8c	                beq _empty_line
.8d64		a5 0c		lda $0c		                lda cib
.8d66		18		clc		                clc
.8d67		65 10		adc $10		                adc toin
.8d69		85 27		sta $27		                sta tmp2                ; LSB of first character
.8d6b		a5 0d		lda $0d		                lda cib+1
.8d6d		65 11		adc $11		                adc toin+1
.8d6f		85 28		sta $28		                sta tmp2+1              ; MSB
.8d71						_skip_loop:
.8d71		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.8d73		20 68 d7	jsr $d768	                jsr is_whitespace
.8d76		90 1f		bcc $8d97	                bcc _char_found
.8d78		e6 27		inc $27		                inc tmp2
.8d7a		d0 02		bne $8d7e	                bne +
.8d7c		e6 28		inc $28		                inc tmp2+1
.8d7e						+
.8d7e		a5 25		lda $25		                lda tmp1
.8d80		d0 02		bne $8d84	                bne +
.8d82		c6 26		dec $26		                dec tmp1+1
.8d84		c6 25		dec $25		+               dec tmp1
.8d86		a5 25		lda $25		                lda tmp1
.8d88		05 26		ora $26		                ora tmp1+1
.8d8a		d0 e5		bne $8d71	                bne _skip_loop          ; fall through if empty line
.8d8c						_empty_line:
.8d8c		ca		dex		                dex
.8d8d		ca		dex		                dex
.8d8e		ca		dex		                dex
.8d8f		ca		dex		                dex
.8d90		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.8d92		74 01		stz $01,x	                stz 1,x
.8d94		4c 41 8e	jmp $8e41	                jmp z_parse_name        ; skip over PARSE
.8d97						_char_found:
.8d97		a5 27		lda $27		                lda tmp2
.8d99		38		sec		                sec
.8d9a		e5 0c		sbc $0c		                sbc cib
.8d9c		85 10		sta $10		                sta toin
.8d9e		a5 28		lda $28		                lda tmp2+1
.8da0		e5 0d		sbc $0d		                sbc cib+1
.8da2		85 11		sta $11		                sta toin+1
.8da4		ca		dex		                dex
.8da5		ca		dex		                dex
.8da6		a9 20		lda #$20	                lda #AscSP
.8da8		95 00		sta $00,x	                sta 0,x
.8daa		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.8dac						xt_parse:
.8dac		20 75 d7	jsr $d775	                jsr underflow_1
.8daf		a5 0e		lda $0e		                lda ciblen
.8db1		05 0f		ora $0f		                ora ciblen+1
.8db3		f0 0c		beq $8dc1	                beq _abort_parse
.8db5		a5 11		lda $11		                lda toin+1              ; MSB
.8db7		c5 0f		cmp $0f		                cmp ciblen+1
.8db9		90 0e		bcc $8dc9	                bcc _go_parse           ; unsigned comparison
.8dbb		a5 10		lda $10		                lda toin                ; LSB
.8dbd		c5 0e		cmp $0e		                cmp ciblen
.8dbf		90 08		bcc $8dc9	                bcc _go_parse
.8dc1						_abort_parse:
.8dc1		ca		dex		                dex
.8dc2		ca		dex		                dex
.8dc3		74 00		stz $00,x	                stz 0,x
.8dc5		74 01		stz $01,x	                stz 1,x
.8dc7		80 78		bra $8e41	                bra _done
.8dc9						_go_parse:
.8dc9		b5 00		lda $00,x	                lda 0,x
.8dcb		85 23		sta $23		                sta tmptos
.8dcd		ca		dex		                dex
.8dce		ca		dex		                dex
.8dcf		a5 0c		lda $0c		                lda cib
.8dd1		18		clc		                clc
.8dd2		65 10		adc $10		                adc toin        ; LSB
.8dd4		85 25		sta $25		                sta tmp1
.8dd6		85 27		sta $27		                sta tmp2
.8dd8		95 02		sta $02,x	                sta 2,x
.8dda		a5 0d		lda $0d		                lda cib+1
.8ddc		65 11		adc $11		                adc toin+1      ; MSB
.8dde		85 26		sta $26		                sta tmp1+1
.8de0		85 28		sta $28		                sta tmp2+1
.8de2		95 03		sta $03,x	                sta 3,x
.8de4		a5 0c		lda $0c		                lda cib
.8de6		18		clc		                clc
.8de7		65 0e		adc $0e		                adc ciblen
.8de9		85 29		sta $29		                sta tmp3
.8deb		a5 0d		lda $0d		                lda cib+1
.8ded		65 0f		adc $0f		                adc ciblen+1
.8def		85 2a		sta $2a		                sta tmp3+1
.8df1		64 24		stz $24		                stz tmptos+1
.8df3						_loop:
.8df3		a5 27		lda $27		                lda tmp2
.8df5		c5 29		cmp $29		                cmp tmp3
.8df7		d0 06		bne $8dff	                bne _not_empty
.8df9		a5 28		lda $28		                lda tmp2+1
.8dfb		c5 2a		cmp $2a		                cmp tmp3+1
.8dfd		f0 1d		beq $8e1c	                beq _eol
.8dff						_not_empty:
.8dff		b2 27		lda ($27)	                lda (tmp2)
.8e01		a4 23		ldy $23		                ldy tmptos
.8e03		c0 20		cpy #$20	                cpy #AscSP
.8e05		d0 07		bne $8e0e	                bne _not_whitespace
.8e07		20 68 d7	jsr $d768	                jsr is_whitespace
.8e0a		90 02		bcc $8e0e	                bcc _not_whitespace
.8e0c		80 0c		bra $8e1a	                bra _found_delimiter
.8e0e						_not_whitespace:
.8e0e		c5 23		cmp $23		                cmp tmptos
.8e10		f0 08		beq $8e1a	                beq _found_delimiter
.8e12		e6 27		inc $27		                inc tmp2
.8e14		d0 dd		bne $8df3	                bne _loop
.8e16		e6 28		inc $28		                inc tmp2+1
.8e18		80 d9		bra $8df3	                bra _loop
.8e1a						_found_delimiter:
.8e1a		e6 24		inc $24		                inc tmptos+1
.8e1c						_eol:
.8e1c		a5 27		lda $27		                lda tmp2
.8e1e		38		sec		                sec
.8e1f		e5 25		sbc $25		                sbc tmp1
.8e21		95 00		sta $00,x	                sta 0,x
.8e23		a5 28		lda $28		                lda tmp2+1
.8e25		e5 26		sbc $26		                sbc tmp1+1
.8e27		95 01		sta $01,x	                sta 1,x
.8e29		a5 27		lda $27		                lda tmp2
.8e2b		38		sec		                sec
.8e2c		e5 0c		sbc $0c		                sbc cib
.8e2e		85 10		sta $10		                sta toin
.8e30		a5 28		lda $28		                lda tmp2+1
.8e32		e5 0d		sbc $0d		                sbc cib+1
.8e34		85 11		sta $11		                sta toin+1
.8e36		a5 10		lda $10		                lda toin
.8e38		18		clc		                clc
.8e39		65 24		adc $24		                adc tmptos+1
.8e3b		85 10		sta $10		                sta toin
.8e3d		90 02		bcc $8e41	                bcc +
.8e3f		e6 11		inc $11		                inc toin+1
.8e41						+
.8e41						_done:
.8e41						z_parse_name:
.8e41		60		rts		z_parse:        rts
.8e42						xt_pick:
.8e42		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.8e44		8a		txa		                txa
.8e45		75 00		adc $00,x	                adc 0,x
.8e47		a8		tay		                tay
.8e48		b9 02 00	lda $0002,y	                lda 0002,y
.8e4b		95 00		sta $00,x	                sta 0,x
.8e4d		b9 03 00	lda $0003,y	                lda 0003,y
.8e50		95 01		sta $01,x	                sta 1,x
.8e52		60		rts		z_pick:         rts
.8e53						xt_plus:
.8e53		20 7a d7	jsr $d77a	                jsr underflow_2
.8e56		18		clc		                clc
.8e57		b5 00		lda $00,x	                lda 0,x         ; LSB
.8e59		75 02		adc $02,x	                adc 2,x
.8e5b		95 02		sta $02,x	                sta 2,x
.8e5d		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.8e5f		75 03		adc $03,x	                adc 3,x
.8e61		95 03		sta $03,x	                sta 3,x
.8e63		e8		inx		                inx
.8e64		e8		inx		                inx
.8e65		60		rts		z_plus:         rts
.8e66						xt_plus_store:
.8e66		20 7a d7	jsr $d77a	                jsr underflow_2
.8e69		b5 00		lda $00,x	                lda 0,x
.8e6b		85 25		sta $25		                sta tmp1
.8e6d		b5 01		lda $01,x	                lda 1,x
.8e6f		85 26		sta $26		                sta tmp1+1
.8e71		a0 00		ldy #$00	                ldy #0          ; LSB
.8e73		b1 25		lda ($25),y	                lda (tmp1),y
.8e75		18		clc		                clc
.8e76		75 02		adc $02,x	                adc 2,x
.8e78		91 25		sta ($25),y	                sta (tmp1),y
.8e7a		c8		iny		                iny             ; MSB
.8e7b		b1 25		lda ($25),y	                lda (tmp1),y
.8e7d		75 03		adc $03,x	                adc 3,x
.8e7f		91 25		sta ($25),y	                sta (tmp1),y
.8e81		e8		inx		                inx
.8e82		e8		inx		                inx
.8e83		e8		inx		                inx
.8e84		e8		inx		                inx
.8e85		60		rts		z_plus_store:   rts
.8e86						xt_postpone:
.8e86		20 51 8d	jsr $8d51	                jsr xt_parse_name               ; ( -- addr n )
.8e89		b5 00		lda $00,x	                lda 0,x
.8e8b		15 01		ora $01,x	                ora 1,x
.8e8d		d0 05		bne $8e94	                bne +
.8e8f		a9 05		lda #$05	                lda #err_noname
.8e91		4c 8b d7	jmp $d78b	                jmp error
.8e94						+
.8e94		20 db 9a	jsr $9adb	                jsr xt_find_name                ; ( -- nt | 0 )
.8e97		d0 05		bne $8e9e	                bne +
.8e99		a9 05		lda #$05	                lda #err_noname
.8e9b		4c 8b d7	jmp $d78b	                jmp error
.8e9e						+
.8e9e		b5 00		lda $00,x	                lda 0,x
.8ea0		85 25		sta $25		                sta tmp1
.8ea2		b5 01		lda $01,x	                lda 1,x
.8ea4		85 26		sta $26		                sta tmp1+1
.8ea6		20 19 9c	jsr $9c19	                jsr xt_name_to_int              ; ( nt -- xt )
.8ea9		e6 25		inc $25		                inc tmp1
.8eab		d0 02		bne $8eaf	                bne +
.8ead		e6 26		inc $26		                inc tmp1+1
.8eaf						+
.8eaf		b2 25		lda ($25)	                lda (tmp1)
.8eb1		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.8eb3		f0 05		beq $8eba	                beq _not_immediate
.8eb5		20 c7 96	jsr $96c7	                jsr xt_compile_comma
.8eb8		80 0a		bra $8ec4	                bra _done
.8eba						_not_immediate:
.8eba		20 f2 89	jsr $89f2	                jsr xt_literal
.8ebd		a0 96		ldy #$96	                ldy #>xt_compile_comma
.8ebf		a9 c7		lda #$c7	                lda #<xt_compile_comma
.8ec1		20 65 97	jsr $9765	                jsr cmpl_subroutine
.8ec4						_done:
.8ec4		60		rts		z_postpone:     rts
.8ec5						xt_question_dup:
.8ec5		20 75 d7	jsr $d775	                jsr underflow_1
.8ec8		b5 00		lda $00,x	                lda 0,x
.8eca		15 01		ora $01,x	                ora 1,x
.8ecc		f0 0a		beq $8ed8	                beq _done
.8ece		ca		dex		                dex
.8ecf		ca		dex		                dex
.8ed0		b5 02		lda $02,x	                lda 2,x
.8ed2		95 00		sta $00,x	                sta 0,x
.8ed4		b5 03		lda $03,x	                lda 3,x
.8ed6		95 01		sta $01,x	                sta 1,x
.8ed8						_done:
.8ed8		60		rts		z_question_dup: rts
.8ed9						xt_r_fetch:
.8ed9		68		pla		                pla                     ; LSB
.8eda		7a		ply		                ply                     ; MSB
.8edb		1a		inc a		                inc a
.8edc		85 25		sta $25		                sta tmp1                ; LSB
.8ede		d0 01		bne $8ee1	                bne +
.8ee0		c8		iny		                iny
.8ee1						+
.8ee1		84 26		sty $26		                sty tmp1+1              ; MSB
.8ee3		ca		dex		                dex
.8ee4		ca		dex		                dex
.8ee5		7a		ply		                ply             ; LSB
.8ee6		94 00		sty $00,x	                sty 0,x
.8ee8		68		pla		                pla             ; MSB
.8ee9		95 01		sta $01,x	                sta 1,x
.8eeb		48		pha		                pha
.8eec		5a		phy		                phy
.8eed		6c 25 00	jmp ($0025)	z_r_fetch:      jmp (tmp1)
.8ef0						xt_r_from:
.8ef0		68		pla		                pla                     ; LSB
.8ef1		7a		ply		                ply                     ; MSB
.8ef2		1a		inc a		                inc a
.8ef3		85 25		sta $25		                sta tmp1                ; LSB
.8ef5		d0 01		bne $8ef8	                bne +
.8ef7		c8		iny		                iny
.8ef8						+
.8ef8		84 26		sty $26		                sty tmp1+1              ; MSB
.8efa		ca		dex		                dex
.8efb		ca		dex		                dex
.8efc		68		pla		                pla             ; LSB
.8efd		95 00		sta $00,x	                sta 0,x
.8eff		68		pla		                pla             ; MSB
.8f00		95 01		sta $01,x	                sta 1,x
.8f02		6c 25 00	jmp ($0025)	z_r_from:       jmp (tmp1)
.8f05						xt_recurse:
.8f05		a0 00		ldy #$00	                ldy #0
.8f07		a9 20		lda #$20	                lda #OpJSR
.8f09		91 00		sta ($00),y	                sta (cp),y
.8f0b		c8		iny		                iny
.8f0c		24 1c		bit $1c		                bit status
.8f0e		70 0c		bvs $8f1c	                bvs _nt_in_workword
.8f10		a5 06		lda $06		                lda workword
.8f12		91 00		sta ($00),y	                sta (cp),y
.8f14		c8		iny		                iny
.8f15		a5 07		lda $07		                lda workword+1
.8f17		91 00		sta ($00),y	                sta (cp),y
.8f19		c8		iny		                iny
.8f1a		80 1b		bra $8f37	                bra _update_cp
.8f1c						_nt_in_workword:
.8f1c		a5 06		lda $06		                lda workword            ; LSB
.8f1e		18		clc		                clc
.8f1f		69 04		adc #$04	                adc #4
.8f21		85 25		sta $25		                sta tmp1
.8f23		a5 07		lda $07		                lda workword+1          ; MSB
.8f25		69 00		adc #$00	                adc #0
.8f27		85 26		sta $26		                sta tmp1+1
.8f29		b2 25		lda ($25)	                lda (tmp1)
.8f2b		91 00		sta ($00),y	                sta (cp),y
.8f2d		5a		phy		                phy
.8f2e		a0 01		ldy #$01	                ldy #1
.8f30		b1 25		lda ($25),y	                lda (tmp1),y
.8f32		7a		ply		                ply
.8f33		c8		iny		                iny
.8f34		91 00		sta ($00),y	                sta (cp),y
.8f36		c8		iny		                iny
.8f37						_update_cp:
.8f37		98		tya		                tya
.8f38		18		clc		                clc
.8f39		65 00		adc $00		                adc cp
.8f3b		85 00		sta $00		                sta cp
.8f3d		90 02		bcc $8f41	                bcc _done
.8f3f		e6 01		inc $01		                inc cp+1
.8f41						_done:
.8f41		60		rts		z_recurse:      rts
.8f42						xt_refill:
.8f42		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.8f44		d0 2d		bne $8f73	                bne _src_not_kbd
.8f46		ca		dex		                dex
.8f47		ca		dex		                dex
.8f48		ca		dex		                dex
.8f49		ca		dex		                dex
.8f4a		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.8f4c		95 02		sta $02,x	                sta 2,x
.8f4e		a5 0d		lda $0d		                lda cib+1
.8f50		95 03		sta $03,x	                sta 3,x
.8f52		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.8f54		64 0f		stz $0f		                stz ciblen+1
.8f56		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.8f58		95 00		sta $00,x	                sta 0,x
.8f5a		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.8f5c		20 e4 80	jsr $80e4	                jsr xt_accept           ; ( addr n1 -- n2)
.8f5f		b5 00		lda $00,x	                lda 0,x
.8f61		85 0e		sta $0e		                sta ciblen
.8f63		b5 01		lda $01,x	                lda 1,x
.8f65		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.8f67		64 10		stz $10		                stz toin
.8f69		64 11		stz $11		                stz toin+1
.8f6b		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.8f6d		95 00		sta $00,x	                sta 0,x
.8f6f		95 01		sta $01,x	                sta 1,x
.8f71		80 10		bra $8f83	                bra _done
.8f73						_src_not_kbd:
.8f73		1a		inc a		                ina
.8f74		d0 08		bne $8f7e	                bne _src_not_string
.8f76		ca		dex		                dex
.8f77		ca		dex		                dex
.8f78		74 00		stz $00,x	                stz 0,x
.8f7a		74 01		stz $01,x	                stz 1,x
.8f7c		80 05		bra $8f83	                bra z_refill
.8f7e						_src_not_string:
.8f7e		a9 01		lda #$01	                lda #err_badsource
.8f80		4c 8b d7	jmp $d78b	                jmp error
.8f83						_done:
.8f83		60		rts		z_refill:       rts
.8f84						xt_repeat:
.8f84		20 1f 82	jsr $821f	                jsr xt_again
.8f87		4c b4 86	jmp $86b4	                jmp xt_then
.8f8a						z_repeat:
.8f8a						xt_right_bracket:
.8f8a		a9 ff		lda #$ff	                lda #$FF
.8f8c		85 1a		sta $1a		                sta state
.8f8e		85 1b		sta $1b		                sta state+1
.8f90						z_right_bracket:
.8f90		60		rts		                rts
.8f91						xt_rot:
.8f91		20 7f d7	jsr $d77f	                jsr underflow_3
.8f94		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.8f96		b5 03		lda $03,x	                lda 3,x
.8f98		95 05		sta $05,x	                sta 5,x
.8f9a		b5 01		lda $01,x	                lda 1,x
.8f9c		95 03		sta $03,x	                sta 3,x
.8f9e		94 01		sty $01,x	                sty 1,x
.8fa0		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.8fa2		b5 02		lda $02,x	                lda 2,x
.8fa4		95 04		sta $04,x	                sta 4,x
.8fa6		b5 00		lda $00,x	                lda 0,x
.8fa8		95 02		sta $02,x	                sta 2,x
.8faa		94 00		sty $00,x	                sty 0,x
.8fac		60		rts		z_rot:          rts
.8fad						xt_rshift:
.8fad		20 7a d7	jsr $d77a	                jsr underflow_2
.8fb0		b5 00		lda $00,x	                lda 0,x
.8fb2		29 0f		and #$0f	                and #%00001111
.8fb4		f0 08		beq $8fbe	                beq _done               ; if 0 shifts, quit
.8fb6		a8		tay		                tay
.8fb7						_loop:
.8fb7		56 03		lsr $03,x	                lsr 3,x
.8fb9		76 02		ror $02,x	                ror 2,x
.8fbb		88		dey		                dey
.8fbc		d0 f9		bne $8fb7	                bne _loop
.8fbe						_done:
.8fbe		e8		inx		                inx
.8fbf		e8		inx		                inx
.8fc0		60		rts		z_rshift:       rts
.8fc1						xt_s_backslash_quote:
.8fc1		a9 ff		lda #$ff	                lda #$FF
.8fc3		85 27		sta $27		                sta tmp2
.8fc5		64 28		stz $28		                stz tmp2+1
.8fc7		20 de 8f	jsr $8fde	                jsr s_quote_start
.8fca						z_s_backslash_quote:
.8fca		60		rts		                rts
.8fcb						convert_hex_value:
.8fcb		c9 41		cmp #$41	        cmp #'A'
.8fcd		90 07		bcc $8fd6	        bcc _digit
.8fcf		29 df		and #$df	        and #$DF                ; Make it uppercase.
.8fd1		38		sec		        sec
.8fd2		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.8fd4		80 03		bra $8fd9	        bra _done
.8fd6						_digit:
.8fd6		38		sec		        sec
.8fd7		e9 30		sbc #$30	        sbc #'0'
.8fd9						_done:
.8fd9		60		rts		        rts
.8fda						xt_s_quote:
.8fda		64 27		stz $27		                stz tmp2
.8fdc		64 28		stz $28		                stz tmp2+1
.8fde						s_quote_start:
.8fde		20 86 97	jsr $9786	                jsr cmpl_jump_later
.8fe1		20 1b 89	jsr $891b	                jsr xt_here             ; the start of the string
.8fe4						_savechars_loop:
.8fe4		a5 11		lda $11		                lda toin+1              ; MSB
.8fe6		c5 0f		cmp $0f		                cmp ciblen+1
.8fe8		90 2a		bcc $9014	                bcc _input_fine         ; unsigned comparison
.8fea		a5 10		lda $10		                lda toin                ; LSB
.8fec		c5 0e		cmp $0e		                cmp ciblen
.8fee		90 24		bcc $9014	                bcc _input_fine
.8ff0		a5 27		lda $27		                lda tmp2
.8ff2		48		pha		                pha
.8ff3		a5 28		lda $28		                lda tmp2+1
.8ff5		48		pha		                pha
.8ff6		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.8ff8		48		pha		                pha
.8ff9		20 42 8f	jsr $8f42	                jsr xt_refill           ; ( -- f )
.8ffc		68		pla		                pla
.8ffd		85 29		sta $29		                sta tmp3
.8fff		68		pla		                pla
.9000		85 28		sta $28		                sta tmp2+1
.9002		68		pla		                pla
.9003		85 27		sta $27		                sta tmp2
.9005		b5 00		lda $00,x	                lda 0,x
.9007		15 01		ora $01,x	                ora 1,x
.9009		d0 05		bne $9010	                bne _refill_ok
.900b		a9 06		lda #$06	                lda #err_refill
.900d		4c 8b d7	jmp $d78b	                jmp error
.9010						_refill_ok:
.9010		e8		inx		                inx
.9011		e8		inx		                inx
.9012		80 d0		bra $8fe4	                bra _savechars_loop
.9014						_input_fine:
.9014		a5 0c		lda $0c		                lda cib
.9016		18		clc		                clc
.9017		65 10		adc $10		                adc toin        ; LSB
.9019		85 25		sta $25		                sta tmp1
.901b		a5 0d		lda $0d		                lda cib+1
.901d		65 11		adc $11		                adc toin+1      ; MSB
.901f		85 26		sta $26		                sta tmp1+1
.9021		b2 25		lda ($25)	                lda (tmp1)
.9023		24 27		bit $27		                bit tmp2
.9025		30 03		bmi $902a	                bmi _handle_escapes    ; Only checking bit 7
.9027		4c ad 90	jmp $90ad	                jmp _regular_char
.902a						_handle_escapes:
.902a		24 28		bit $28		                bit tmp2+1
.902c		30 03		bmi $9031	                bmi _escaped
.902e		4c a3 90	jmp $90a3	                jmp _not_escaped
.9031						_escaped:
.9031		70 3c		bvs $906f	                bvs _check_esc_chars
.9033		a9 01		lda #$01	                lda #1
.9035		24 28		bit $28		                bit tmp2+1
.9037		d0 10		bne $9049	                bne _esc_x_second_digit
.9039		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.903b		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.903d		20 cb 8f	jsr $8fcb	                jsr convert_hex_value
.9040		0a		asl a		                asl
.9041		0a		asl a		                asl
.9042		0a		asl a		                asl
.9043		0a		asl a		                asl
.9044		85 29		sta $29		                sta tmp3    ; Save it for later.
.9046		4c b4 90	jmp $90b4	                jmp _next_character
.9049						_esc_x_second_digit:
.9049		64 28		stz $28		                stz tmp2+1
.904b		b2 25		lda ($25)	                lda (tmp1)
.904d		20 cb 8f	jsr $8fcb	                jsr convert_hex_value
.9050		05 29		ora $29		                ora tmp3
.9052		4c b1 90	jmp $90b1	                jmp _save_character
.9055						_esc_tr_table:
>9055		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9056		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9057		00 00				    .byte   0,0             ; c, d no escape
>9059		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>905a		0c				    .byte   12              ; f -> FF (ASCII value 12)
>905b		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9060		0a				    .byte   10              ; l -> LF (ASCII value 10)
>9061		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9062		0a				    .byte   10              ; n behaves like l --> lf
>9063		00 00				    .byte   0,0             ; o,p
>9065		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9066		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9067		00				    .byte   0               ; s
>9068		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9069		00				    .byte   0               ; u
>906a		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>906b		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>906e		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.906f						_check_esc_chars:
.906f		64 28		stz $28		                stz tmp2+1
.9071		c9 61		cmp #$61	                cmp #'a'
.9073		30 1a		bmi $908f	                bmi _check_esc_quote
.9075		c9 7b		cmp #$7b	                cmp #'z'+1
.9077		10 16		bpl $908f	                bpl _check_esc_quote
.9079		a8		tay		                tay
.907a		b9 f4 8f	lda $8ff4,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.907d		d0 03		bne $9082	                bne _esc_replace
.907f		98		tya		                tya                     ; revert if no translation
.9080		80 0d		bra $908f	                bra _check_esc_quote
.9082		10 2d		bpl $90b1	_esc_replace:   bpl _save_character     ; simple replacement
.9084		29 7f		and #$7f	                and #$7F                ; clear hi bit
.9086		f0 29		beq $90b1	                beq _save_character     ; NUL we can just output
.9088		20 75 97	jsr $9775	                jsr cmpl_a              ; else output first char (CR)
.908b		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.908d		80 22		bra $90b1	                bra _save_character
.908f						_check_esc_quote:
.908f		c9 22		cmp #$22	                cmp #'"'
.9091		f0 1e		beq $90b1	                beq _save_character
.9093		c9 78		cmp #$78	                cmp #'x'
.9095		d0 06		bne $909d	                bne _check_esc_backslash
.9097		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.9099		85 28		sta $28		                sta tmp2+1
.909b		80 17		bra $90b4	                bra _next_character
.909d						_check_esc_backslash:
.909d		c9 5c		cmp #$5c	                cmp #'\'
.909f		d0 0c		bne $90ad	                bne _regular_char
.90a1		80 0e		bra $90b1	                bra _save_character
.90a3						_not_escaped:
.90a3		c9 5c		cmp #$5c	                cmp #'\'
.90a5		d0 06		bne $90ad	                bne _regular_char
.90a7		a9 ff		lda #$ff	                lda #$FF
.90a9		85 28		sta $28		                sta tmp2+1
.90ab		80 07		bra $90b4	                bra _next_character
.90ad						_regular_char:
.90ad		c9 22		cmp #$22	                cmp #'"'
.90af		f0 0c		beq $90bd	                beq _found_string_end
.90b1						_save_character:
.90b1		20 75 97	jsr $9775	                jsr cmpl_a
.90b4						_next_character:
.90b4		e6 10		inc $10		                inc toin
.90b6		d0 02		bne $90ba	                bne _savechars_loop_longjump
.90b8		e6 11		inc $11		                inc toin+1
.90ba						_savechars_loop_longjump:
.90ba		4c e4 8f	jmp $8fe4	                jmp _savechars_loop
.90bd						_found_string_end:
.90bd		e6 10		inc $10		                inc toin
.90bf		d0 02		bne $90c3	                bne +
.90c1		e6 11		inc $11		                inc toin+1
.90c3						+
.90c3		20 1b 89	jsr $891b	                jsr xt_here
.90c6		20 91 8f	jsr $8f91	                jsr xt_rot
.90c9		20 18 92	jsr $9218	                jsr xt_store    ; Update the jmp target
.90cc		20 1b 89	jsr $891b	                jsr xt_here
.90cf		20 05 8d	jsr $8d05	                jsr xt_over
.90d2		20 e4 8b	jsr $8be4	                jsr xt_minus    ; HERE - addr gives string length
.90d5		a5 1a		lda $1a		                lda state
.90d7		05 1b		ora $1b		                ora state+1             ; paranoid
.90d9		f0 03		beq $90de	                beq _done
.90db		20 47 a1	jsr $a147	                jsr cmpl_sliteral         ; ( addr u -- )
.90de						_done:
.90de		60		rts		z_s_quote:      rts
.90df						xt_s_to_d:
.90df		20 75 d7	jsr $d775	                jsr underflow_1
.90e2		ca		dex		                dex
.90e3		ca		dex		                dex
.90e4		74 00		stz $00,x	                stz 0,x
.90e6		74 01		stz $01,x	                stz 1,x
.90e8		b5 03		lda $03,x	                lda 3,x
.90ea		10 04		bpl $90f0	                bpl _done
.90ec		d6 00		dec $00,x	                dec 0,x
.90ee		d6 01		dec $01,x	                dec 1,x
.90f0						_done:
.90f0		60		rts		z_s_to_d:       rts
.90f1						xt_semicolon:
.90f1		24 1c		bit $1c		                bit status
.90f3		70 11		bvs $9106	                bvs _colonword
.90f5		a9 60		lda #$60	                lda #OpRTS
.90f7		20 75 97	jsr $9775	                jsr cmpl_a
.90fa		ca		dex		                dex
.90fb		ca		dex		                dex
.90fc		a5 06		lda $06		                lda workword
.90fe		95 00		sta $00,x	                sta 0,x
.9100		a5 07		lda $07		                lda workword+1
.9102		95 01		sta $01,x	                sta 1,x
.9104		80 45		bra $914b	                bra _semicolon_done
.9106						_colonword:
.9106		a0 06		ldy #$06	                ldy #6
.9108		a5 00		lda $00		                lda cp
.910a		91 06		sta ($06),y	                sta (workword),y
.910c		c8		iny		                iny
.910d		a5 01		lda $01		                lda cp+1
.910f		91 06		sta ($06),y	                sta (workword),y
.9111		a9 60		lda #$60	                lda #OpRTS
.9113		20 75 97	jsr $9775	                jsr cmpl_a
.9116		24 1c		bit $1c		                bit status
.9118		10 26		bpl $9140	                bpl _new_word   ; Bit 7 is clear = new word
.911a		ca		dex		                dex
.911b		ca		dex		                dex
.911c		ca		dex		                dex
.911d		ca		dex		                dex
.911e		b2 06		lda ($06)	                lda (workword)
.9120		95 00		sta $00,x	                sta 0,x
.9122		74 01		stz $01,x	                stz 1,x
.9124		a5 06		lda $06		                lda workword
.9126		18		clc		                clc
.9127		69 08		adc #$08	                adc #8
.9129		95 02		sta $02,x	                sta 2,x
.912b		a5 07		lda $07		                lda workword+1
.912d		69 00		adc #$00	                adc #0                  ; only want carry
.912f		95 03		sta $03,x	                sta 3,x
.9131		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9133		20 b1 d7	jsr $d7b1	                jsr print_string_no_lf
.9136		20 c4 94	jsr $94c4	                jsr xt_type
.9139		20 cb 91	jsr $91cb	                jsr xt_space
.913c		a9 80		lda #$80	                lda #%10000000
.913e		14 1c		trb $1c		                trb status
.9140						_new_word:
.9140		a5 06		lda $06		                lda workword
.9142		85 02		sta $02		                sta dp
.9144		a5 07		lda $07		                lda workword+1
.9146		85 03		sta $03		                sta dp+1
.9148		20 df d6	jsr $d6df	                jsr dp_to_current       ; Save the updated DP to the
.914b						_semicolon_done:
.914b		64 1a		stz $1a		                stz state
.914d		64 1b		stz $1b		                stz state+1
.914f		60		rts		z_semicolon:    rts
.9150						xt_sign:
.9150		20 75 d7	jsr $d775	                jsr underflow_1
.9153		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9155		30 04		bmi $915b	                bmi _minus
.9157		e8		inx		                inx
.9158		e8		inx		                inx
.9159		80 09		bra $9164	                bra _done
.915b						_minus:
.915b		a9 2d		lda #$2d	                lda #'-'
.915d		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.915f		74 01		stz $01,x	                stz 1,x         ; paranoid
.9161		20 2d 89	jsr $892d	                jsr xt_hold
.9164						_done:
.9164		60		rts		z_sign:         rts
.9165						xt_slash:
.9165		a9 00		lda #$00	                lda #0
.9167		48		pha		                pha
.9168		80 03		bra $916d	                bra slashmod_common
.916a						xt_slash_mod:
.916a		a9 ff		lda #$ff	                lda #$FF
.916c		48		pha		                pha             ; falls through to _common
.916d						slashmod_common:
.916d		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R
.9170		20 df 90	jsr $90df	                jsr xt_s_to_d           ; S>D
.9173		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R>
.9176		20 82 91	jsr $9182	                jsr xt_sm_slash_rem     ; SM/REM
.9179		68		pla		                pla
.917a		d0 05		bne $9181	                bne _done
.917c		20 2e 92	jsr $922e	                jsr xt_swap
.917f		e8		inx		                inx             ; DROP
.9180		e8		inx		                inx
.9181						_done:
.9181						z_slash_mod:
.9181		60		rts		z_slash:        rts
.9182						xt_sm_slash_rem:
.9182		20 7f d7	jsr $d77f	                jsr underflow_3 ; contains double number
.9185		b5 03		lda $03,x	                lda 3,x
.9187		48		pha		                pha
.9188		b5 01		lda $01,x	                lda 1,x
.918a		55 03		eor $03,x	                eor 3,x
.918c		48		pha		                pha
.918d		20 cf 80	jsr $80cf	                jsr xt_abs
.9190		e8		inx		                inx             ; pretend we pushed n1 to R
.9191		e8		inx		                inx
.9192		20 2b 9e	jsr $9e2b	                jsr xt_dabs
.9195		ca		dex		                dex
.9196		ca		dex		                dex
.9197		20 49 95	jsr $9549	                jsr xt_um_slash_mod     ; UM/MOD
.919a		68		pla		                pla
.919b		10 03		bpl $91a0	                bpl +
.919d		20 1f 8c	jsr $8c1f	                jsr xt_negate
.91a0						+
.91a0		68		pla		                pla
.91a1		10 07		bpl $91aa	                bpl _done
.91a3		e8		inx		                inx             ; pretend we pushed quotient to R
.91a4		e8		inx		                inx
.91a5		20 1f 8c	jsr $8c1f	                jsr xt_negate
.91a8		ca		dex		                dex
.91a9		ca		dex		                dex
.91aa						_done:
.91aa		60		rts		z_sm_slash_rem: rts
.91ab						xt_source:
.91ab		ca		dex		                dex
.91ac		ca		dex		                dex
.91ad		a5 0c		lda $0c		                lda cib
.91af		95 00		sta $00,x	                sta 0,x
.91b1		a5 0d		lda $0d		                lda cib+1
.91b3		95 01		sta $01,x	                sta 1,x
.91b5		ca		dex		                dex
.91b6		ca		dex		                dex
.91b7		a5 0e		lda $0e		                lda ciblen
.91b9		95 00		sta $00,x	                sta 0,x
.91bb		a5 0f		lda $0f		                lda ciblen+1
.91bd		95 01		sta $01,x	                sta 1,x
.91bf		60		rts		z_source:       rts
.91c0						xt_source_id:
.91c0		ca		dex		                dex
.91c1		ca		dex		                dex
.91c2		a5 0a		lda $0a		                lda insrc
.91c4		95 00		sta $00,x	                sta 0,x
.91c6		a5 0b		lda $0b		                lda insrc+1
.91c8		95 01		sta $01,x	                sta 1,x
.91ca		60		rts		z_source_id:    rts
.91cb						xt_space:
.91cb		a9 20		lda #$20	                lda #AscSP
.91cd		20 c5 86	jsr $86c5	                jsr emit_a
.91d0		60		rts		z_space:        rts
.91d1						xt_spaces:
.91d1		20 75 d7	jsr $d775	                jsr underflow_1
.91d4		b5 01		lda $01,x	                lda 1,x         ; ANS says this word takes a signed value
.91d6		30 10		bmi $91e8	                bmi _done       ; but prints no spaces for negative values.
.91d8		b4 00		ldy $00,x	                ldy 0,x
.91da		f0 08		beq $91e4	                beq _msb
.91dc						_loop:
.91dc		a9 20		lda #$20	                lda #AscSP
.91de		20 c5 86	jsr $86c5	                jsr emit_a      ; user routine preserves X and Y
.91e1		88		dey		                dey
.91e2		d0 f8		bne $91dc	                bne _loop       ; Y is zero on exit so looping again emits 256 more spaces
.91e4						_msb:
.91e4		d6 01		dec $01,x	                dec 1,x         ; when decrementing MSB goes negative, it was zero so we're done
.91e6		10 f4		bpl $91dc	                bpl _loop       ; otherwise emit another 256 spaces
.91e8		e8		inx		_done:          inx
.91e9		e8		inx		                inx
.91ea		60		rts		z_spaces:       rts
.91eb						xt_star:
.91eb		20 7a d7	jsr $d77a	                jsr underflow_2
.91ee		20 8b 95	jsr $958b	                jsr xt_um_star
.91f1		e8		inx		                inx
.91f2		e8		inx		                inx
.91f3		60		rts		z_star:         rts
.91f4						xt_star_slash:
.91f4		20 fd 91	jsr $91fd	                jsr xt_star_slash_mod
.91f7		20 2e 92	jsr $922e	                jsr xt_swap
.91fa		e8		inx		                inx
.91fb		e8		inx		                inx
.91fc						z_star_slash:
.91fc		60		rts		                rts
.91fd						xt_star_slash_mod:
.91fd		20 7f d7	jsr $d77f	                jsr underflow_3
.9200		20 6c 93	jsr $936c	                jsr xt_to_r
.9203		20 21 8b	jsr $8b21	                jsr xt_m_star
.9206		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.9209		20 82 91	jsr $9182	                jsr xt_sm_slash_rem
.920c						z_star_slash_mod:
.920c		60		rts		                rts
.920d						xt_state:
.920d		ca		dex		                dex
.920e		ca		dex		                dex
.920f		a9 1a		lda #$1a	                lda #<state
.9211		95 00		sta $00,x	                sta 0,x
.9213		a9 00		lda #$00	                lda #>state
.9215		95 01		sta $01,x	                sta 1,x
.9217		60		rts		z_state:        rts
.9218						xt_store:
.9218		20 7a d7	jsr $d77a	                jsr underflow_2
.921b		b5 02		lda $02,x	                lda 2,x         ; LSB
.921d		81 00		sta ($00,x)	                sta (0,x)
.921f		f6 00		inc $00,x	                inc 0,x
.9221		d0 02		bne $9225	                bne +
.9223		f6 01		inc $01,x	                inc 1,x
.9225						+
.9225		b5 03		lda $03,x	                lda 3,x         ; MSB
.9227		81 00		sta ($00,x)	                sta (0,x)
.9229		e8		inx		                inx             ; 2DROP
.922a		e8		inx		                inx
.922b		e8		inx		                inx
.922c		e8		inx		                inx
.922d		60		rts		z_store:        rts
.922e						xt_swap:
.922e		20 7a d7	jsr $d77a	                jsr underflow_2
.9231		b5 00		lda $00,x	                lda 0,x         ; LSB
.9233		b4 02		ldy $02,x	                ldy 2,x
.9235		95 02		sta $02,x	                sta 2,x
.9237		94 00		sty $00,x	                sty 0,x
.9239		b5 01		lda $01,x	                lda 1,x         ; MSB
.923b		b4 03		ldy $03,x	                ldy 3,x
.923d		95 03		sta $03,x	                sta 3,x
.923f		94 01		sty $01,x	                sty 1,x
.9241		60		rts		z_swap:         rts
.9242						xt_tick:
.9242		20 51 8d	jsr $8d51	                jsr xt_parse_name       ; ( -- addr u )
.9245		b5 00		lda $00,x	                lda 0,x
.9247		15 01		ora $01,x	                ora 1,x
.9249		d0 05		bne $9250	                bne +
.924b		a9 05		lda #$05	                lda #err_noname
.924d		4c 8b d7	jmp $d78b	                jmp error
.9250						+
.9250		20 db 9a	jsr $9adb	                jsr xt_find_name        ; ( addr u -- nt )
.9253		b5 00		lda $00,x	                lda 0,x
.9255		15 01		ora $01,x	                ora 1,x
.9257		d0 05		bne $925e	                bne +
.9259		a9 08		lda #$08	                lda #err_syntax
.925b		4c 8b d7	jmp $d78b	                jmp error
.925e						+
.925e		20 19 9c	jsr $9c19	                jsr xt_name_to_int      ; ( nt -- xt )
.9261		60		rts		z_tick:         rts
.9262						xt_to:
.9262		20 42 92	jsr $9242	                jsr xt_tick             ; ( [n] xt )
.9265		b5 00		lda $00,x	                lda 0,x                 ; LSB
.9267		18		clc		                clc
.9268		69 03		adc #$03	                adc #3
.926a		85 25		sta $25		                sta tmp1
.926c		b5 01		lda $01,x	                lda 1,x                 ; MSB
.926e		69 00		adc #$00	                adc #0                  ; we just want the carry
.9270		85 26		sta $26		                sta tmp1+1
.9272		a5 1a		lda $1a		                lda state
.9274		05 1b		ora $1b		                ora state+1
.9276		f0 14		beq $928c	                beq _interpret
.9278		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.927a		95 00		sta $00,x	                sta 0,x
.927c		a5 26		lda $26		                lda tmp1+1
.927e		95 01		sta $01,x	                sta 1,x
.9280		20 f2 89	jsr $89f2	                jsr xt_literal      ; generate the runtime for LITERAL tmp1
.9283		a0 92		ldy #$92	                ldy #>xt_store      ; write the runtime for !
.9285		a9 18		lda #$18	                lda #<xt_store
.9287		20 65 97	jsr $9765	                jsr cmpl_subroutine
.928a		80 11		bra $929d	                bra _done
.928c						_interpret:
.928c		20 7a d7	jsr $d77a	                jsr underflow_2
.928f		e8		inx		                inx
.9290		e8		inx		                inx                     ; leaving just ( n )
.9291		b5 00		lda $00,x	                lda 0,x
.9293		92 25		sta ($25)	                sta (tmp1)              ; LSB
.9295		a0 01		ldy #$01	                ldy #1
.9297		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9299		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.929b		e8		inx		                inx                     ; DROP
.929c		e8		inx		                inx
.929d						_done:
.929d		60		rts		z_to:           rts
.929e						xt_to_body:
.929e		20 75 d7	jsr $d775	                jsr underflow_1
.92a1		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( xt xt )
.92a4		20 93 9b	jsr $9b93	                jsr xt_int_to_name      ; ( xt nt )
.92a7		f6 00		inc $00,x	                inc 0,x
.92a9		d0 02		bne $92ad	                bne +
.92ab		f6 01		inc $01,x	                inc 1,x
.92ad						+
.92ad		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.92af		29 20		and #$20	                and #HC
.92b1		f0 0b		beq $92be	                beq _no_cfa
.92b3		18		clc		                clc
.92b4		b5 02		lda $02,x	                lda 2,x         ; LSB
.92b6		69 03		adc #$03	                adc #3
.92b8		95 02		sta $02,x	                sta 2,x
.92ba		90 02		bcc $92be	                bcc _no_cfa
.92bc		f6 03		inc $03,x	                inc 3,x         ; MSB
.92be						_no_cfa:
.92be		e8		inx		                inx             ; get rid of the nt
.92bf		e8		inx		                inx
.92c0		60		rts		z_to_body:      rts
.92c1						xt_to_in:
.92c1		ca		dex		                dex
.92c2		ca		dex		                dex
.92c3		a9 10		lda #$10	                lda #<toin
.92c5		95 00		sta $00,x	                sta 0,x
.92c7		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.92c9		95 01		sta $01,x	                sta 1,x
.92cb		60		rts		z_to_in:        rts
.92cc						xt_to_number:
.92cc		20 84 d7	jsr $d784	                jsr underflow_4
.92cf		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.92d1		85 2d		sta $2d		                sta scratch
.92d3		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.92d5		85 2e		sta $2e		                sta scratch+1
.92d7		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.92d9		85 2f		sta $2f		                sta scratch+2
.92db		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.92dd		85 30		sta $30		                sta scratch+3
.92df		ca		dex		                dex
.92e0		ca		dex		                dex
.92e1						_loop:
.92e1		a1 04		lda ($04,x)	                lda (4,x)
.92e3		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.92e5		74 01		stz $01,x	                stz 1,x                 ; paranoid
.92e7		20 7f 9a	jsr $9a7f	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.92ea		b5 00		lda $00,x	                lda 0,x
.92ec		d0 04		bne $92f2	                bne _digit_ok
.92ee		e8		inx		                inx
.92ef		e8		inx		                inx
.92f0		80 67		bra $9359	                bra _done       ; ( ud-lo ud-hi addr u char )
.92f2						_digit_ok:
.92f2		b5 02		lda $02,x	                lda 2,x
.92f4		85 31		sta $31		                sta scratch+4
.92f6		b5 03		lda $03,x	                lda 3,x
.92f8		85 32		sta $32		                sta scratch+5
.92fa		a5 2f		lda $2f		                lda scratch+2
.92fc		95 02		sta $02,x	                sta 2,x         ; NOS
.92fe		a5 30		lda $30		                lda scratch+3
.9300		95 03		sta $03,x	                sta 3,x
.9302		a5 18		lda $18		                lda base
.9304		95 00		sta $00,x	                sta 0,x         ; TOS
.9306		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.9308		20 8b 95	jsr $958b	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.930b		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.930d		85 33		sta $33		                sta scratch+6
.930f		b5 03		lda $03,x	                lda 3,x
.9311		85 34		sta $34		                sta scratch+7
.9313		a5 2d		lda $2d		                lda scratch
.9315		95 02		sta $02,x	                sta 2,x
.9317		a5 2e		lda $2e		                lda scratch+1
.9319		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.931b		a5 18		lda $18		                lda base
.931d		95 00		sta $00,x	                sta 0,x
.931f		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.9321		20 8b 95	jsr $958b	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.9324		b5 00		lda $00,x	                lda 0,x
.9326		85 2f		sta $2f		                sta scratch+2
.9328		b5 01		lda $01,x	                lda 1,x
.932a		85 30		sta $30		                sta scratch+3
.932c		b5 02		lda $02,x	                lda 2,x
.932e		85 2d		sta $2d		                sta scratch
.9330		b5 03		lda $03,x	                lda 3,x
.9332		85 2e		sta $2e		                sta scratch+1
.9334		18		clc		                clc
.9335		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.9337		65 31		adc $31		                adc scratch+4   ; n LSB
.9339		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.933b		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.933d		65 32		adc $32		                adc scratch+5   ; n MSB
.933f		85 2e		sta $2e		                sta scratch+1
.9341		a5 2f		lda $2f		                lda scratch+2   ; LSB
.9343		65 33		adc $33		                adc scratch+6
.9345		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.9347		a5 30		lda $30		                lda scratch+3   ; MSB
.9349		65 34		adc $34		                adc scratch+7
.934b		85 30		sta $30		                sta scratch+3
.934d		e8		inx		                inx
.934e		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.934f		f6 04		inc $04,x	                inc 4,x
.9351		d0 02		bne $9355	                bne +
.9353		f6 05		inc $05,x	                inc 5,x
.9355						+
.9355		d6 02		dec $02,x	                dec 2,x
.9357		d0 88		bne $92e1	                bne _loop
.9359						_done:
.9359		e8		inx		                inx
.935a		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.935b		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.935d		95 06		sta $06,x	                sta 6,x
.935f		a5 2e		lda $2e		                lda scratch+1
.9361		95 07		sta $07,x	                sta 7,x
.9363		a5 2f		lda $2f		                lda scratch+2
.9365		95 04		sta $04,x	                sta 4,x
.9367		a5 30		lda $30		                lda scratch+3
.9369		95 05		sta $05,x	                sta 5,x
.936b		60		rts		z_to_number:    rts
.936c						xt_to_r:
.936c		68		pla		                pla                     ; LSB
.936d		7a		ply		                ply                     ; MSB
.936e		1a		inc a		                inc a
.936f		85 25		sta $25		                sta tmp1                ; LSB
.9371		d0 01		bne $9374	                bne +
.9373		c8		iny		                iny
.9374						+
.9374		84 26		sty $26		                sty tmp1+1              ; MSB
.9376		20 75 d7	jsr $d775	                jsr underflow_1
.9379		b5 01		lda $01,x	                lda 1,x         ; MSB
.937b		48		pha		                pha
.937c		b5 00		lda $00,x	                lda 0,x         ; LSB
.937e		48		pha		                pha
.937f		e8		inx		                inx
.9380		e8		inx		                inx
.9381		6c 25 00	jmp ($0025)	z_to_r:         jmp (tmp1)
.9384						xt_true:
.9384		ca		dex		                dex
.9385		ca		dex		                dex
.9386		a9 ff		lda #$ff	                lda #$FF
.9388		95 00		sta $00,x	                sta 0,x
.938a		95 01		sta $01,x	                sta 1,x
.938c		60		rts		z_true:         rts
.938d						xt_tuck:
.938d		20 7a d7	jsr $d77a	                jsr underflow_2
.9390		ca		dex		                dex
.9391		ca		dex		                dex
.9392		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.9394		b5 02		lda $02,x	                lda 2,x
.9396		95 04		sta $04,x	                sta 4,x
.9398		94 02		sty $02,x	                sty 2,x
.939a		95 00		sta $00,x	                sta 0,x
.939c		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.939e		b5 03		lda $03,x	                lda 3,x
.93a0		95 05		sta $05,x	                sta 5,x
.93a2		94 03		sty $03,x	                sty 3,x         ; bba
.93a4		95 01		sta $01,x	                sta 1,x         ; baa
.93a6		60		rts		z_tuck:         rts
.93a7						xt_two_drop:
.93a7		20 7a d7	jsr $d77a	                jsr underflow_2
.93aa		e8		inx		                inx
.93ab		e8		inx		                inx
.93ac		e8		inx		                inx
.93ad		e8		inx		                inx
.93ae		60		rts		z_two_drop:     rts
.93af						xt_two_dup:
.93af		20 7a d7	jsr $d77a	                jsr underflow_2
.93b2		ca		dex		                dex
.93b3		ca		dex		                dex
.93b4		ca		dex		                dex
.93b5		ca		dex		                dex
.93b6		b5 04		lda $04,x	                lda 4,x         ; TOS
.93b8		95 00		sta $00,x	                sta 0,x
.93ba		b5 05		lda $05,x	                lda 5,x
.93bc		95 01		sta $01,x	                sta 1,x
.93be		b5 06		lda $06,x	                lda 6,x         ; NOS
.93c0		95 02		sta $02,x	                sta 2,x
.93c2		b5 07		lda $07,x	                lda 7,x
.93c4		95 03		sta $03,x	                sta 3,x
.93c6		60		rts		z_two_dup:      rts
.93c7						xt_two_fetch:
.93c7		20 75 d7	jsr $d775	                jsr underflow_1
.93ca		b5 00		lda $00,x	                lda 0,x
.93cc		85 25		sta $25		                sta tmp1
.93ce		b4 01		ldy $01,x	                ldy 1,x
.93d0		84 26		sty $26		                sty tmp1+1
.93d2		ca		dex		                dex             ; reuse one stack element
.93d3		ca		dex		                dex
.93d4		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.93d6		95 00		sta $00,x	                sta 0,x
.93d8		a0 01		ldy #$01	                ldy #1          ; copy next
.93da		b1 25		lda ($25),y	                lda (tmp1),y
.93dc		95 01		sta $01,x	                sta 1,x
.93de		c8		iny		                iny             ; copy next
.93df		b1 25		lda ($25),y	                lda (tmp1),y
.93e1		95 02		sta $02,x	                sta 2,x
.93e3		c8		iny		                iny             ; copy next
.93e4		b1 25		lda ($25),y	                lda (tmp1),y
.93e6		95 03		sta $03,x	                sta 3,x
.93e8		60		rts		z_two_fetch:    rts
.93e9						xt_two_over:
.93e9		20 84 d7	jsr $d784	                jsr underflow_4
.93ec		ca		dex		                dex
.93ed		ca		dex		                dex
.93ee		ca		dex		                dex
.93ef		ca		dex		                dex
.93f0		b5 08		lda $08,x	                lda 8,x
.93f2		95 00		sta $00,x	                sta 0,x
.93f4		b5 09		lda $09,x	                lda 9,x
.93f6		95 01		sta $01,x	                sta 1,x
.93f8		b5 0a		lda $0a,x	                lda 10,x
.93fa		95 02		sta $02,x	                sta 2,x
.93fc		b5 0b		lda $0b,x	                lda 11,x
.93fe		95 03		sta $03,x	                sta 3,x
.9400		60		rts		z_two_over:     rts
.9401						xt_two_r_fetch:
.9401		68		pla		                pla                     ; LSB
.9402		7a		ply		                ply                     ; MSB
.9403		1a		inc a		                inc a
.9404		85 25		sta $25		                sta tmp1                ; LSB
.9406		d0 01		bne $9409	                bne +
.9408		c8		iny		                iny
.9409						+
.9409		84 26		sty $26		                sty tmp1+1              ; MSB
.940b		8a		txa		                txa             ; set Y = SP; X -= 4
.940c		ba		tsx		                tsx
.940d		da		phx		                phx
.940e		7a		ply		                ply
.940f		38		sec		                sec
.9410		e9 04		sbc #$04	                sbc #4
.9412		aa		tax		                tax
.9413		b9 01 01	lda $0101,y	                lda $101,y
.9416		95 00		sta $00,x	                sta 0,x
.9418		b9 02 01	lda $0102,y	                lda $102,y
.941b		95 01		sta $01,x	                sta 1,x
.941d		b9 03 01	lda $0103,y	                lda $103,y
.9420		95 02		sta $02,x	                sta 2,x
.9422		b9 04 01	lda $0104,y	                lda $104,y
.9425		95 03		sta $03,x	                sta 3,x
.9427		6c 25 00	jmp ($0025)	z_two_r_fetch:  jmp (tmp1)
.942a						xt_two_r_from:
.942a		68		pla		                pla                     ; LSB
.942b		7a		ply		                ply                     ; MSB
.942c		1a		inc a		                inc a
.942d		85 25		sta $25		                sta tmp1                ; LSB
.942f		d0 01		bne $9432	                bne +
.9431		c8		iny		                iny
.9432						+
.9432		84 26		sty $26		                sty tmp1+1              ; MSB
.9434		ca		dex		                dex
.9435		ca		dex		                dex
.9436		ca		dex		                dex
.9437		ca		dex		                dex
.9438		68		pla		                pla                     ; LSB
.9439		95 00		sta $00,x	                sta 0,x
.943b		68		pla		                pla                     ; MSB
.943c		95 01		sta $01,x	                sta 1,x
.943e		68		pla		                pla                     ; LSB
.943f		95 02		sta $02,x	                sta 2,x
.9441		68		pla		                pla                     ; MSB
.9442		95 03		sta $03,x	                sta 3,x
.9444		6c 25 00	jmp ($0025)	z_two_r_from:   jmp (tmp1)
.9447						xt_two_slash:
.9447		20 75 d7	jsr $d775	                jsr underflow_1
.944a		b5 01		lda $01,x	                lda 1,x
.944c		0a		asl a		                asl                     ; save the sign
.944d		76 01		ror $01,x	                ror 1,x
.944f		76 00		ror $00,x	                ror 0,x
.9451		60		rts		z_two_slash:    rts
.9452						xt_two_star:
.9452						xt_cells:
.9452		20 75 d7	jsr $d775	                jsr underflow_1
.9455		16 00		asl $00,x	                asl 0,x
.9457		36 01		rol $01,x	                rol 1,x
.9459						z_cells:
.9459		60		rts		z_two_star:     rts
.945a						xt_two_store:
.945a		20 7f d7	jsr $d77f	                jsr underflow_3
.945d		b5 00		lda $00,x	                lda 0,x
.945f		85 25		sta $25		                sta tmp1
.9461		b4 01		ldy $01,x	                ldy 1,x
.9463		84 26		sty $26		                sty tmp1+1
.9465		e8		inx		                inx
.9466		e8		inx		                inx
.9467		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.9469		92 25		sta ($25)	                sta (tmp1)
.946b		b5 01		lda $01,x	                lda 1,x         ; copy next
.946d		a0 01		ldy #$01	                ldy #1
.946f		91 25		sta ($25),y	                sta (tmp1),y
.9471		b5 02		lda $02,x	                lda 2,x         ; copy next
.9473		c8		iny		                iny
.9474		91 25		sta ($25),y	                sta (tmp1),y
.9476		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.9478		c8		iny		                iny
.9479		91 25		sta ($25),y	                sta (tmp1),y
.947b		e8		inx		                inx             ; 2DROP
.947c		e8		inx		                inx
.947d		e8		inx		                inx
.947e		e8		inx		                inx
.947f		60		rts		z_two_store:    rts
.9480						xt_two_swap:
.9480		20 84 d7	jsr $d784	                jsr underflow_4
.9483		b5 00		lda $00,x	                lda 0,x
.9485		b4 04		ldy $04,x	                ldy 4,x
.9487		95 04		sta $04,x	                sta 4,x
.9489		94 00		sty $00,x	                sty 0,x
.948b		b5 01		lda $01,x	                lda 1,x
.948d		b4 05		ldy $05,x	                ldy 5,x
.948f		95 05		sta $05,x	                sta 5,x
.9491		94 01		sty $01,x	                sty 1,x
.9493		b5 02		lda $02,x	                lda 2,x
.9495		b4 06		ldy $06,x	                ldy 6,x
.9497		95 06		sta $06,x	                sta 6,x
.9499		94 02		sty $02,x	                sty 2,x
.949b		b5 03		lda $03,x	                lda 3,x
.949d		b4 07		ldy $07,x	                ldy 7,x
.949f		95 07		sta $07,x	                sta 7,x
.94a1		94 03		sty $03,x	                sty 3,x
.94a3		60		rts		z_two_swap:     rts
.94a4						xt_two_to_r:
.94a4		68		pla		                pla                     ; LSB
.94a5		7a		ply		                ply                     ; MSB
.94a6		1a		inc a		                inc a
.94a7		85 25		sta $25		                sta tmp1                ; LSB
.94a9		d0 01		bne $94ac	                bne +
.94ab		c8		iny		                iny
.94ac						+
.94ac		84 26		sty $26		                sty tmp1+1              ; MSB
.94ae		20 7a d7	jsr $d77a	                jsr underflow_2
.94b1		b5 03		lda $03,x	                lda 3,x         ; MSB
.94b3		48		pha		                pha
.94b4		b5 02		lda $02,x	                lda 2,x         ; LSB
.94b6		48		pha		                pha
.94b7		b5 01		lda $01,x	                lda 1,x         ; MSB
.94b9		48		pha		                pha
.94ba		b5 00		lda $00,x	                lda 0,x         ; LSB
.94bc		48		pha		                pha
.94bd		e8		inx		                inx
.94be		e8		inx		                inx
.94bf		e8		inx		                inx
.94c0		e8		inx		                inx
.94c1		6c 25 00	jmp ($0025)	z_two_to_r:     jmp (tmp1)
.94c4						xt_type:
.94c4		20 7a d7	jsr $d77a	                jsr underflow_2
.94c7		b5 02		lda $02,x	                lda 2,x
.94c9		85 25		sta $25		                sta tmp1
.94cb		b5 03		lda $03,x	                lda 3,x
.94cd		85 26		sta $26		                sta tmp1+1
.94cf						_loop:
.94cf		b5 00		lda $00,x	                lda 0,x
.94d1		15 01		ora $01,x	                ora 1,x
.94d3		f0 15		beq $94ea	                beq _done
.94d5		b2 25		lda ($25)	                lda (tmp1)
.94d7		20 c5 86	jsr $86c5	                jsr emit_a      ; avoids stack foolery
.94da		e6 25		inc $25		                inc tmp1
.94dc		d0 02		bne $94e0	                bne +
.94de		e6 26		inc $26		                inc tmp1+1
.94e0						+
.94e0		b5 00		lda $00,x	                lda 0,x
.94e2		d0 02		bne $94e6	                bne +
.94e4		d6 01		dec $01,x	                dec 1,x
.94e6						+
.94e6		d6 00		dec $00,x	                dec 0,x
.94e8		80 e5		bra $94cf	                bra _loop
.94ea						_done:
.94ea		e8		inx		                inx
.94eb		e8		inx		                inx
.94ec		e8		inx		                inx
.94ed		e8		inx		                inx
.94ee		60		rts		z_type:         rts
.94ef						xt_u_dot:
.94ef		20 75 d7	jsr $d775	                jsr underflow_1
.94f2		20 e2 d7	jsr $d7e2	                jsr print_u
.94f5		a9 20		lda #$20	                lda #AscSP
.94f7		20 c5 86	jsr $86c5	                jsr emit_a
.94fa		60		rts		z_u_dot:        rts
.94fb						xt_u_dot_r:
.94fb		20 7a d7	jsr $d77a	                jsr underflow_2
.94fe		20 6c 93	jsr $936c	                jsr xt_to_r
.9501		20 dc 9d	jsr $9ddc	                jsr xt_zero
.9504		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9507		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.950a		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.950d		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.9510		20 05 8d	jsr $8d05	                jsr xt_over
.9513		20 e4 8b	jsr $8be4	                jsr xt_minus
.9516		20 d1 91	jsr $91d1	                jsr xt_spaces
.9519		20 c4 94	jsr $94c4	                jsr xt_type
.951c		60		rts		z_u_dot_r:      rts
.951d						xt_u_greater_than:
.951d		20 7a d7	jsr $d77a	                jsr underflow_2
.9520		b5 00		lda $00,x	                lda 0,x
.9522		d5 02		cmp $02,x	                cmp 2,x
.9524		b5 01		lda $01,x	                lda 1,x
.9526		f5 03		sbc $03,x	                sbc 3,x
.9528		e8		inx		                inx
.9529		e8		inx		                inx
.952a		a9 00		lda #$00	                lda #0
.952c		69 ff		adc #$ff	                adc #$FF
.952e		95 00		sta $00,x	                sta 0,x         ; store flag
.9530		95 01		sta $01,x	                sta 1,x
.9532		60		rts		z_u_greater_than:    rts
.9533						xt_u_less_than:
.9533		20 7a d7	jsr $d77a	                jsr underflow_2
.9536		b5 02		lda $02,x	                lda 2,x
.9538		d5 00		cmp $00,x	                cmp 0,x
.953a		b5 03		lda $03,x	                lda 3,x
.953c		f5 01		sbc $01,x	                sbc 1,x
.953e		e8		inx		                inx
.953f		e8		inx		                inx
.9540		a9 00		lda #$00	                lda #0
.9542		69 ff		adc #$ff	                adc #$FF
.9544		95 00		sta $00,x	                sta 0,x         ; store flag
.9546		95 01		sta $01,x	                sta 1,x
.9548		60		rts		z_u_less_than:    rts
.9549						xt_um_slash_mod:
.9549		20 7f d7	jsr $d77f	                jsr underflow_3
.954c		b5 00		lda $00,x	                lda 0,x
.954e		15 01		ora $01,x	                ora 1,x
.9550		d0 05		bne $9557	                bne _not_zero
.9552		a9 04		lda #$04	                lda #err_divzero
.9554		4c 8b d7	jmp $d78b	                jmp error
.9557						_not_zero:
.9557		a9 11		lda #$11	                lda #17
.9559		85 23		sta $23		                sta tmptos
.955b						_loop:
.955b		36 04		rol $04,x	                rol 4,x
.955d		36 05		rol $05,x	                rol 5,x
.955f		c6 23		dec $23		                dec tmptos
.9561		f0 22		beq $9585	                beq _done
.9563		36 02		rol $02,x	                rol 2,x
.9565		36 03		rol $03,x	                rol 3,x
.9567		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.9569		26 25		rol $25		                rol tmp1
.956b		38		sec		                sec
.956c		b5 02		lda $02,x	                lda 2,x
.956e		f5 00		sbc $00,x	                sbc 0,x
.9570		85 26		sta $26		                sta tmp1+1
.9572		b5 03		lda $03,x	                lda 3,x
.9574		f5 01		sbc $01,x	                sbc 1,x
.9576		a8		tay		                tay
.9577		a5 25		lda $25		                lda tmp1
.9579		e9 00		sbc #$00	                sbc #0
.957b		90 de		bcc $955b	                bcc _loop
.957d		a5 26		lda $26		                lda tmp1+1
.957f		95 02		sta $02,x	                sta 2,x
.9581		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.9583		80 d6		bra $955b	                bra _loop
.9585						_done:
.9585		e8		inx		                inx
.9586		e8		inx		                inx
.9587		20 2e 92	jsr $922e	                jsr xt_swap
.958a		60		rts		z_um_slash_mod: rts
.958b						xt_um_star:
.958b		20 7a d7	jsr $d77a	                jsr underflow_2
.958e		18		clc		                clc
.958f		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.9591		e9 00		sbc #$00	                sbc #0
.9593		85 27		sta $27		                sta tmp2
.9595		b5 01		lda $01,x	                lda 1,x
.9597		e9 00		sbc #$00	                sbc #0
.9599		90 31		bcc $95cc	                bcc _zero       ; is TOS zero?
.959b		85 28		sta $28		                sta tmp2+1
.959d		a9 00		lda #$00	                lda #0
.959f		85 25		sta $25		                sta tmp1
.95a1		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.95a3		ca		dex		                dex
.95a4		ca		dex		                dex
.95a5						_outer_loop:
.95a5		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.95a7		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.95a9						_inner_loop:
.95a9		90 0c		bcc $95b7	                bcc _no_add
.95ab		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.95ad		a5 25		lda $25		                lda tmp1
.95af		65 27		adc $27		                adc tmp2
.95b1		85 25		sta $25		                sta tmp1
.95b3		a5 26		lda $26		                lda tmp1+1
.95b5		65 28		adc $28		                adc tmp2+1
.95b7						_no_add:
.95b7		6a		ror a		                ror
.95b8		66 25		ror $25		                ror tmp1
.95ba		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.95bc		88		dey		                dey
.95bd		d0 ea		bne $95a9	                bne _inner_loop ; go back for one more shift?
.95bf		e8		inx		                inx
.95c0		e4 29		cpx $29		                cpx tmp3
.95c2		d0 e1		bne $95a5	                bne _outer_loop ; go back for eight more shifts?
.95c4		95 01		sta $01,x	                sta 1,x
.95c6		a5 25		lda $25		                lda tmp1
.95c8		95 00		sta $00,x	                sta 0,x
.95ca		80 04		bra $95d0	                bra _done
.95cc						_zero:
.95cc		74 02		stz $02,x	                stz 2,x
.95ce		74 03		stz $03,x	                stz 3,x
.95d0						_done:
.95d0		60		rts		z_um_star:      rts
.95d1						xt_unloop:
.95d1		a4 1f		ldy $1f		                ldy loopctrl
.95d3		88		dey		                dey
.95d4		88		dey		                dey
.95d5		88		dey		                dey
.95d6		88		dey		                dey
.95d7		84 1f		sty $1f		                sty loopctrl
.95d9		30 05		bmi $95e0	                bmi z_unloop            ; no active loops?
.95db		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.95de		85 20		sta $20		                sta loopidx0
.95e0		60		rts		z_unloop:       rts
.95e1						xt_until:
.95e1		20 b7 97	jsr $97b7	                jsr cmpl_0branch_tos
.95e4		60		rts		z_until:        rts
.95e5						xt_unused:
.95e5		ca		dex		                dex
.95e6		ca		dex		                dex
.95e7		a9 00		lda #$00	                lda #<cp_end
.95e9		38		sec		                sec
.95ea		e5 00		sbc $00		                sbc cp
.95ec		95 00		sta $00,x	                sta 0,x
.95ee		a9 7c		lda #$7c	                lda #>cp_end
.95f0		e5 01		sbc $01		                sbc cp+1
.95f2		95 01		sta $01,x	                sta 1,x
.95f4		60		rts		z_unused:       rts
.95f5						xt_variable:
.95f5		20 40 84	jsr $8440	                jsr xt_create
.95f8		a9 00		lda #$00	                lda #0
.95fa		92 00		sta ($00)	                sta (cp)
.95fc		e6 00		inc $00		                inc cp
.95fe		d0 02		bne $9602	                bne +
.9600		e6 01		inc $01		                inc cp+1
.9602						+
.9602		92 00		sta ($00)	                sta (cp)
.9604		e6 00		inc $00		                inc cp
.9606		d0 02		bne $960a	                bne +
.9608		e6 01		inc $01		                inc cp+1
.960a						+
.960a		20 08 84	jsr $8408	                jsr adjust_z
.960d		60		rts		z_variable:     rts
.960e						xt_while:
.960e		20 a2 97	jsr $97a2	                jsr cmpl_0branch_later          ; branch to location we'll determine later
.9611		20 2e 92	jsr $922e	                jsr xt_swap
.9614		60		rts		z_while:        rts
.9615						xt_within:
.9615		20 7f d7	jsr $d77f	                jsr underflow_3
.9618		20 05 8d	jsr $8d05	                jsr xt_over
.961b		20 e4 8b	jsr $8be4	                jsr xt_minus
.961e		20 6c 93	jsr $936c	                jsr xt_to_r
.9621		20 e4 8b	jsr $8be4	                jsr xt_minus
.9624		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.9627		20 33 95	jsr $9533	                jsr xt_u_less_than
.962a		60		rts		z_within:       rts
.962b						xt_word:
.962b		20 75 d7	jsr $d775	                jsr underflow_1
.962e		a4 10		ldy $10		                ldy toin                ; >IN
.9630						_loop:
.9630		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.9632		f0 09		beq $963d	                beq _found_char
.9634		b1 0c		lda ($0c),y	                lda (cib),y
.9636		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.9638		d0 03		bne $963d	                bne _found_char
.963a		c8		iny		                iny
.963b		80 f3		bra $9630	                bra _loop
.963d						_found_char:
.963d		84 10		sty $10		                sty toin
.963f		20 ac 8d	jsr $8dac	                jsr xt_parse            ; Returns ( addr u )
.9642		b5 00		lda $00,x	                lda 0,x
.9644		92 00		sta ($00)	                sta (cp)                ; Save length of string
.9646		48		pha		                pha                     ; Keep copy of length for later
.9647		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr u u )
.964a		a5 00		lda $00		                lda cp
.964c		18		clc		                clc
.964d		69 01		adc #$01	                adc #1
.964f		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.9651		a5 01		lda $01		                lda cp+1
.9653		69 00		adc #$00	                adc #0
.9655		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.9657		20 00 8c	jsr $8c00	                jsr xt_move
.965a		ca		dex		                dex
.965b		ca		dex		                dex
.965c		a5 00		lda $00		                lda cp
.965e		95 00		sta $00,x	                sta 0,x
.9660		a5 01		lda $01		                lda cp+1
.9662		95 01		sta $01,x	                sta 1,x
.9664		68		pla		                pla                     ; length of string
.9665		18		clc		                clc
.9666		65 00		adc $00		                adc cp
.9668		85 00		sta $00		                sta cp
.966a		90 02		bcc $966e	                bcc z_word
.966c		e6 01		inc $01		                inc cp+1
.966e		60		rts		z_word:         rts
.966f						xt_xor:
.966f		20 7a d7	jsr $d77a	                jsr underflow_2
.9672		b5 00		lda $00,x	                lda 0,x
.9674		55 02		eor $02,x	                eor 2,x
.9676		95 02		sta $02,x	                sta 2,x
.9678		b5 01		lda $01,x	                lda 1,x
.967a		55 03		eor $03,x	                eor 3,x
.967c		95 03		sta $03,x	                sta 3,x
.967e		e8		inx		                inx
.967f		e8		inx		                inx
.9680		60		rts		z_xor:          rts
.9681						xt_zero_equal:
.9681		20 75 d7	jsr $d775	                jsr underflow_1
.9684		b5 00		lda $00,x	                lda 0,x
.9686		15 01		ora $01,x	                ora 1,x
.9688		f0 02		beq $968c	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.968a		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.968c						_zero:
.968c		49 ff		eor #$ff	                eor #$FF        ; now just invert:
.968e		95 00		sta $00,x	                sta 0,x
.9690		95 01		sta $01,x	                sta 1,x
.9692		60		rts		z_zero_equal:   rts
.9693						xt_zero_greater:
.9693		20 75 d7	jsr $d775	                jsr underflow_1
.9696		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.9698		b5 01		lda $01,x	                lda 1,x         ; MSB
.969a		30 05		bmi $96a1	                bmi _done       ; TOS is negative, keep FLASE
.969c		15 00		ora $00,x	                ora 0,x
.969e		f0 01		beq $96a1	                beq _done       ; TOS is zero, keep FALSE
.96a0		88		dey		                dey             ; TOS is postive, make true
.96a1						_done:
.96a1		98		tya		                tya
.96a2		95 00		sta $00,x	                sta 0,x
.96a4		95 01		sta $01,x	                sta 1,x
.96a6		60		rts		z_zero_greater: rts
.96a7						xt_zero_less:
.96a7		20 75 d7	jsr $d775	                jsr underflow_1
.96aa		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.96ac		b5 01		lda $01,x	                lda 1,x         ; MSB
.96ae		10 01		bpl $96b1	                bpl _done       ; TOS is positive, so keep FALSE
.96b0		88		dey		                dey             ; TOS is negative, make TRUE
.96b1						_done:
.96b1		98		tya		                tya
.96b2		95 00		sta $00,x	                sta 0,x
.96b4		95 01		sta $01,x	                sta 1,x
.96b6		60		rts		z_zero_less:    rts
.96b7						xt_zero_unequal:
.96b7		20 75 d7	jsr $d775	                jsr underflow_1
.96ba		b5 00		lda $00,x	                lda 0,x
.96bc		15 01		ora $01,x	                ora 1,x
.96be		f0 02		beq $96c2	                beq _zero
.96c0		a9 ff		lda #$ff	                lda #$FF
.96c2						_zero:
.96c2		95 00		sta $00,x	                sta 0,x
.96c4		95 01		sta $01,x	                sta 1,x
.96c6		60		rts		z_zero_unequal: rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/compile.asm

.96c7						xt_compile_comma:
.96c7		20 75 d7	jsr $d775	                jsr underflow_1
.96ca		20 a0 86	jsr $86a0	                jsr xt_dup              ; keep an unadjusted copy of xt
.96cd		20 a0 86	jsr $86a0	                jsr xt_dup              ; plus one to convert to nt
.96d0		20 93 9b	jsr $9b93	                jsr xt_int_to_name
.96d3		b5 00		lda $00,x	                lda 0,x
.96d5		15 01		ora $01,x	                ora 1,x
.96d7		f0 6b		beq $9744	                beq cmpl_as_call        ; No nt so unknown size; must compile as a JSR
.96d9		20 a0 86	jsr $86a0	                jsr xt_dup
.96dc		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; status is at nt+1
.96df		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.96e1		e8		inx		                inx                     ; drop pointer
.96e2		e8		inx		                inx
.96e3		85 29		sta $29		                sta tmp3                ; keep copy of status byte
.96e5		29 08		and #$08	                and #NN
.96e7		d0 5b		bne $9744	                bne cmpl_as_call        ; never native
.96e9		20 bb 9d	jsr $9dbb	                jsr xt_wordsize
.96ec		a5 29		lda $29		                lda tmp3
.96ee		29 40		and #$40	                and #ST
.96f0		f0 16		beq $9708	                beq _check_uf
=10						_strip_sz = 10  ; skip the standard 10 byte header which saves return address + 1 to tmp1
.96f2		18		clc		                clc
.96f3		b5 02		lda $02,x	                lda 2,x
.96f5		69 0a		adc #$0a	                adc #_strip_sz
.96f7		95 02		sta $02,x	                sta 2,x
.96f9		90 02		bcc $96fd	                bcc +
.96fb		f6 03		inc $03,x	                inc 3,x                 ; we just care about the carry
.96fd						+
.96fd		38		sec		                sec
.96fe		b5 00		lda $00,x	                lda 0,x
.9700		e9 0a		sbc #$0a	                sbc #_strip_sz
.9702		95 00		sta $00,x	                sta 0,x
.9704		b0 02		bcs $9708	                bcs +
.9706		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.9708						+
.9708						_check_uf:
.9708		a5 29		lda $29		                lda tmp3
.970a		29 10		and #$10	                and #UF
.970c		f0 1f		beq $972d	                beq _check_limit
.970e		a0 02		ldy #$02	                ldy #uf_strip_offset
.9710		b1 08		lda ($08),y	                lda (up),y
.9712		c8		iny		                iny
.9713		11 08		ora ($08),y	                ora (up),y
.9715		f0 16		beq $972d	                beq _check_limit
.9717		18		clc		                clc
.9718		b5 02		lda $02,x	                lda 2,x
.971a		69 03		adc #$03	                adc #3
.971c		95 02		sta $02,x	                sta 2,x
.971e		90 02		bcc $9722	                bcc +
.9720		f6 03		inc $03,x	                inc 3,x                  ; we just care about the carry
.9722						+
.9722		38		sec		                sec
.9723		b5 00		lda $00,x	                lda 0,x
.9725		e9 03		sbc #$03	                sbc #3
.9727		95 00		sta $00,x	                sta 0,x
.9729		b0 02		bcs $972d	                bcs +
.972b		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.972d						+
.972d						_check_limit:
.972d		a5 29		lda $29		                lda tmp3
.972f		29 02		and #$02	                and #AN                 ; check Always Native (AN) bit
.9731		d0 1e		bne $9751	                bne cmpl_inline         ; always natively compile
.9733						cmpl_by_limit:
.9733		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.9735		b5 01		lda $01,x	                lda 1,x                 ; MSB of word size
.9737		d1 08		cmp ($08),y	                cmp (up),y              ; user-defined limit MSB
.9739		90 16		bcc $9751	                bcc cmpl_inline         ; borrow (C=0) means size < limit
.973b		d0 07		bne $9744	                bne cmpl_as_call        ; else non-zero means size > limit
.973d		88		dey		                dey
.973e		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.9740		d5 00		cmp $00,x	                cmp 0,x
.9742		b0 0d		bcs $9751	                bcs cmpl_inline         ; not bigger, so good to go
.9744						cmpl_as_call:
.9744		20 a7 93	jsr $93a7	                jsr xt_two_drop         ; either way 2drop leaves original xt
.9747		a9 20		lda #$20	                lda #OpJSR
.9749		20 75 97	jsr $9775	                jsr cmpl_a
.974c		20 cd 83	jsr $83cd	                jsr xt_comma
.974f		38		sec		                sec
.9750		60		rts		                rts
.9751						cmpl_inline:
.9751		20 1b 89	jsr $891b	                jsr xt_here
.9754		20 2e 92	jsr $922e	                jsr xt_swap
.9757		20 a0 86	jsr $86a0	                jsr xt_dup
.975a		20 27 82	jsr $8227	                jsr xt_allot            ; allocate space for the word
.975d		20 00 8c	jsr $8c00	                jsr xt_move
.9760		20 9a 86	jsr $869a	                jsr xt_drop             ; drop original xt
.9763		18		clc		                clc
.9764		60		rts		                rts
.9765						z_compile_comma:
.9765						cmpl_subroutine:
.9765		48		pha		                pha             ; save LSB of address
.9766		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR
.9768		80 03		bra $976d	                bra +
.976a						cmpl_jump:
.976a		48		pha		                pha             ; save LSB of address
.976b		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP, fall thru
.976d						+
.976d		20 75 97	jsr $9775	                jsr cmpl_a      ; compile opcode
.9770		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.9771						cmpl_word:
.9771		20 75 97	jsr $9775	                jsr cmpl_a      ; compile LSB of address
.9774		98		tya		                tya             ; fall thru for MSB
.9775						cmpl_a:
.9775		92 00		sta ($00)	                sta (cp)
.9777		e6 00		inc $00		                inc cp
.9779		d0 02		bne $977d	                bne _done
.977b		e6 01		inc $01		                inc cp+1
.977d						_done:
.977d		60		rts		                rts
.977e						cmpl_jump_tos:
.977e		a9 4c		lda #$4c	                lda #OpJMP
.9780		20 75 97	jsr $9775	                jsr cmpl_a
.9783		4c cd 83	jmp $83cd	                jmp xt_comma
.9786						cmpl_jump_later:
.9786		a9 4c		lda #$4c	                lda #OpJMP
.9788		20 75 97	jsr $9775	                jsr cmpl_a
.978b		20 1b 89	jsr $891b	                jsr xt_here
.978e		80 e1		bra $9771	                bra cmpl_word
.9790						check_nc_limit:
.9790		48		pha		                pha
.9791		38		sec		                sec
.9792		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.9794		b1 08		lda ($08),y	                lda (up),y              ; if MSB non zero we're good, leave with C=0
.9796		f0 01		beq $9799	                beq +
.9798		18		clc		                clc
.9799						+
.9799		68		pla		                pla
.979a		90 05		bcc $97a1	                bcc _done
.979c		3a		dec a		                dea                     ; simplify test to A-1 < nc-limit
.979d		88		dey		                dey
.979e		d1 08		cmp ($08),y	                cmp (up),y              ; A-1 < LSB leaves C=0, else C=1
.97a0		1a		inc a		                ina                     ; restore A, preserves carry
.97a1						_done:
.97a1		60		rts		                rts
.97a2						cmpl_0branch_later:
.97a2		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; dummy placeholder, which forces long jmp in native version
.97a5		20 b7 97	jsr $97b7	                jsr cmpl_0branch_tos    ; generate native or subroutine branch code
.97a8		20 1b 89	jsr $891b	                jsr xt_here             ; either way the target address is two bytes before here
.97ab		38		sec		                sec
.97ac		b5 00		lda $00,x	                lda 0,x
.97ae		e9 02		sbc #$02	                sbc #2
.97b0		95 00		sta $00,x	                sta 0,x
.97b2		b0 02		bcs $97b6	                bcs +
.97b4		d6 01		dec $01,x	                dec 1,x
.97b6						+
.97b6		60		rts		                rts
.97b7						cmpl_0branch_tos:
.97b7		a9 0b		lda #$0b	                lda #ztest_runtime_size+5       ; typical size of inline form
.97b9		20 90 97	jsr $9790	                jsr check_nc_limit              ; returns C=0 if we should native compile
.97bc		90 0a		bcc $97c8	                bcc _inline
.97be		a0 98		ldy #$98	                ldy #>zero_branch_runtime
.97c0		a9 19		lda #$19	                lda #<zero_branch_runtime
.97c2		20 65 97	jsr $9765	                jsr cmpl_subroutine             ; call the 0branch runtime
.97c5		4c cd 83	jmp $83cd	                jmp xt_comma                    ; add the payload and return
.97c8						_inline:
.97c8		a0 00		ldy #$00	                ldy #0
.97ca						-
.97ca		b9 19 98	lda $9819,y	                lda ztest_runtime,y
.97cd		20 75 97	jsr $9775	                jsr cmpl_a
.97d0		c8		iny		                iny
.97d1		c0 06		cpy #$06	                cpy #ztest_runtime_size
.97d3		d0 f5		bne $97ca	                bne -
.97d5		b5 00		lda $00,x	                lda 0,x
.97d7		15 01		ora $01,x	                ora 1,x
.97d9		f0 31		beq $980c	                beq _long               ; always use the long form if target is 0
.97db		20 a0 86	jsr $86a0	                jsr xt_dup
.97de		20 1b 89	jsr $891b	                jsr xt_here
.97e1		18		clc		                clc
.97e2		a9 02		lda #$02	                lda #2
.97e4		75 00		adc $00,x	                adc 0,x
.97e6		95 00		sta $00,x	                sta 0,x
.97e8		90 02		bcc $97ec	                bcc +
.97ea		f6 01		inc $01,x	                inc 1,x
.97ec						+
.97ec		20 e4 8b	jsr $8be4	                jsr xt_minus
.97ef		e8		inx		                inx             ; pre-drop offset and use wraparound indexing to preserve flags
.97f0		e8		inx		                inx
.97f1		b5 ff		lda $ff,x	                lda $ff,x
.97f3		a8		tay		                tay             ; Y=MSB of offset
.97f4		b5 fe		lda $fe,x	                lda $fe,x       ; A=LSB, setting N flag to bit 7
.97f6		30 04		bmi $97fc	                bmi _minus
.97f8		c0 00		cpy #$00	                cpy #0          ; if LSB is positive we need MSB = 0
.97fa		80 02		bra $97fe	                bra +
.97fc		c0 ff		cpy #$ff	_minus:         cpy #$ff        ; if LSB is negative we need MSB = ff
.97fe		d0 0c		bne $980c	+               bne _long
.9800		a9 f0		lda #$f0	                lda #OpBEQ
.9802		20 75 97	jsr $9775	                jsr cmpl_a
.9805		b5 fe		lda $fe,x	                lda $fe,x
.9807		e8		inx		                inx             ; drop the original address we used to calc offset
.9808		e8		inx		                inx
.9809		4c 75 97	jmp $9775	                jmp cmpl_a
.980c						_long:
.980c		a9 d0		lda #$d0	                lda #OpBNE
.980e		20 75 97	jsr $9775	                jsr cmpl_a
.9811		a9 03		lda #$03	                lda #3
.9813		20 75 97	jsr $9775	                jsr cmpl_a
.9816		4c 7e 97	jmp $977e	                jmp cmpl_jump_tos
.9819						zero_branch_runtime:
.9819						ztest_runtime:
.9819		e8		inx		                inx
.981a		e8		inx		                inx
.981b		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.981d		15 ff		ora $ff,x	                ora $FF,x
=6						ztest_runtime_size = * - ztest_runtime
.981f						zbranch_runtime:
.981f		7a		ply		                ply
.9820		84 25		sty $25		                sty tmp1
.9822		7a		ply		                ply
.9823		84 26		sty $26		                sty tmp1+1
.9825		a8		tay		                tay             ; test if A = 0 which tells us whether to branch
.9826		f0 0d		beq $9835	                beq _branch
.9828		18		clc		                clc
.9829		a5 25		lda $25		                lda tmp1        ; LSB
.982b		69 03		adc #$03	                adc #3          ; skip two bytes plus the extra for jsr/rts behavior
.982d		85 25		sta $25		                sta tmp1
.982f		90 11		bcc $9842	                bcc _jmp
.9831		e6 26		inc $26		                inc tmp1+1
.9833		80 0d		bra $9842	                bra _jmp
.9835						_branch:
.9835		a0 01		ldy #$01	                ldy #1
.9837		b1 25		lda ($25),y	                lda (tmp1),y
.9839		48		pha		                pha                     ; stash the LSB until we've read the MSB too
.983a		c8		iny		                iny
.983b		b1 25		lda ($25),y	                lda (tmp1),y
.983d		85 26		sta $26		                sta tmp1+1              ; update tmp1 with our branch target
.983f		68		pla		                pla
.9840		85 25		sta $25		                sta tmp1
.9842						_jmp:
.9842		6c 25 00	jmp ($0025)	                jmp (tmp1)

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tools.asm

.9845						xt_bye:
.9845		4c 31 f0	jmp $f031	                jmp kernel_bye
.9848						z_bye:
.9848						xt_dot_s:
.9848		20 52 85	jsr $8552	                jsr xt_depth    ; ( -- u )
.984b		a9 3c		lda #$3c	                lda #'<'
.984d		20 c5 86	jsr $86c5	                jsr emit_a
.9850		b5 00		lda $00,x	                lda 0,x
.9852		48		pha		                pha
.9853		ca		dex		                dex             ; DUP
.9854		ca		dex		                dex
.9855		95 00		sta $00,x	                sta 0,x
.9857		74 01		stz $01,x	                stz 1,x
.9859		20 e2 d7	jsr $d7e2	                jsr print_u
.985c		a9 3e		lda #$3e	                lda #'>'
.985e		20 c5 86	jsr $86c5	                jsr emit_a
.9861		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.9863		20 c5 86	jsr $86c5	                jsr emit_a
.9866		e8		inx		                inx
.9867		e8		inx		                inx
.9868		e0 78		cpx #$78	                cpx #dsp0
.986a		f0 1e		beq $988a	                beq _done
.986c		7a		ply		                ply
.986d		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.986f		85 29		sta $29		                sta tmp3
.9871		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.9873						_loop:
.9873		ca		dex		                dex
.9874		ca		dex		                dex
.9875		b2 29		lda ($29)	                lda (tmp3)
.9877		95 01		sta $01,x	                sta 1,x
.9879		c6 29		dec $29		                dec tmp3
.987b		b2 29		lda ($29)	                lda (tmp3)
.987d		95 00		sta $00,x	                sta 0,x
.987f		c6 29		dec $29		                dec tmp3
.9881		5a		phy		                phy
.9882		20 30 86	jsr $8630	                jsr xt_dot
.9885		7a		ply		                ply
.9886		88		dey		                dey
.9887		d0 ea		bne $9873	                bne _loop
.9889		48		pha		                pha             ; dummy to balance stack
.988a						_done:
.988a		68		pla		                pla
.988b		60		rts		z_dot_s:        rts
.988c						xt_dump:
.988c		20 7a d7	jsr $d77a	                jsr underflow_2
.988f						_row:
.988f		a0 10		ldy #$10	                ldy #16
.9891		64 27		stz $27		                stz tmp2
.9893		20 3a 84	jsr $843a	                jsr xt_cr
.9896		b5 03		lda $03,x	                lda 3,x
.9898		20 40 d6	jsr $d640	                jsr byte_to_ascii
.989b		b5 02		lda $02,x	                lda 2,x
.989d		20 40 d6	jsr $d640	                jsr byte_to_ascii
.98a0		20 cb 91	jsr $91cb	                jsr xt_space
.98a3		20 cb 91	jsr $91cb	                jsr xt_space
.98a6						_loop:
.98a6		b5 00		lda $00,x	                lda 0,x
.98a8		15 01		ora $01,x	                ora 1,x
.98aa		f0 39		beq $98e5	                beq _all_printed
.98ac		a1 02		lda ($02,x)	                lda (2,x)
.98ae		48		pha		                pha                     ; byte_to_ascii destroys A
.98af		20 40 d6	jsr $d640	                jsr byte_to_ascii
.98b2		20 cb 91	jsr $91cb	                jsr xt_space
.98b5		68		pla		                pla
.98b6		20 5b d7	jsr $d75b	                jsr is_printable
.98b9		b0 02		bcs $98bd	                bcs _printable
.98bb		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.98bd						_printable:
.98bd		5a		phy		                phy                     ; save counter
.98be		a4 27		ldy $27		                ldy tmp2
.98c0		91 00		sta ($00),y	                sta (cp),y
.98c2		e6 27		inc $27		                inc tmp2
.98c4		7a		ply		                ply
.98c5		c0 09		cpy #$09	                cpy #9
.98c7		d0 03		bne $98cc	                bne _next_char
.98c9		20 cb 91	jsr $91cb	                jsr xt_space
.98cc						_next_char:
.98cc		f6 02		inc $02,x	                inc 2,x
.98ce		d0 02		bne $98d2	                bne _counter
.98d0		f6 03		inc $03,x	                inc 3,x
.98d2						_counter:
.98d2		b5 00		lda $00,x	                lda 0,x
.98d4		d0 02		bne $98d8	                bne +
.98d6		d6 01		dec $01,x	                dec 1,x
.98d8						+
.98d8		d6 00		dec $00,x	                dec 0,x
.98da		88		dey		                dey
.98db		d0 c9		bne $98a6	                bne _loop               ; next byte
.98dd		20 cb 91	jsr $91cb	                jsr xt_space
.98e0		20 f3 98	jsr $98f3	                jsr dump_print_ascii
.98e3		80 aa		bra $988f	                bra _row                ; new row
.98e5						_all_printed:
.98e5		a5 27		lda $27		                lda tmp2
.98e7		f0 06		beq $98ef	                beq _done
.98e9		20 cb 91	jsr $91cb	                jsr xt_space
.98ec		20 f3 98	jsr $98f3	                jsr dump_print_ascii
.98ef						_done:
.98ef		20 a7 93	jsr $93a7	                jsr xt_two_drop         ; one byte less than 4x INX
.98f2		60		rts		z_dump:         rts
.98f3						dump_print_ascii:
.98f3		a0 00		ldy #$00	                ldy #0
.98f5						_ascii_loop:
.98f5		b1 00		lda ($00),y	                lda (cp),y
.98f7		20 c5 86	jsr $86c5	                jsr emit_a
.98fa		c8		iny		                iny
.98fb		c0 08		cpy #$08	                cpy #8
.98fd		d0 03		bne $9902	                bne +
.98ff		20 cb 91	jsr $91cb	                jsr xt_space
.9902						+
.9902		c6 27		dec $27		                dec tmp2
.9904		d0 ef		bne $98f5	                bne _ascii_loop
.9906		60		rts		                rts
.9907						xt_question:
.9907		20 1a 88	jsr $881a	                jsr xt_fetch
.990a		20 30 86	jsr $8630	                jsr xt_dot
.990d		60		rts		z_question:     rts
.990e						xt_see:
.990e		20 51 8d	jsr $8d51	                jsr xt_parse_name       ; ( addr u )
.9911		20 db 9a	jsr $9adb	                jsr xt_find_name        ; ( nt | 0 )
.9914		b5 00		lda $00,x	                lda 0,x
.9916		15 01		ora $01,x	                ora 1,x
.9918		d0 05		bne $991f	                bne +
.991a		a9 05		lda #$05	                lda #err_noname
.991c		4c 8b d7	jmp $d78b	                jmp error
.991f						+
.991f		20 3a 84	jsr $843a	                jsr xt_cr
.9922		a5 18		lda $18		                lda base
.9924		48		pha		                pha
.9925		20 26 89	jsr $8926	                jsr xt_hex
.9928		a9 09		lda #$09	                lda #str_see_nt
.992a		20 b1 d7	jsr $d7b1	                jsr print_string_no_lf
.992d		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.9930		20 ef 94	jsr $94ef	                jsr xt_u_dot
.9933		20 cb 91	jsr $91cb	                jsr xt_space            ; ( nt )
.9936		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.9939		20 19 9c	jsr $9c19	                jsr xt_name_to_int      ; ( nt xt )
.993c		a9 0a		lda #$0a	                lda #str_see_xt
.993e		20 b1 d7	jsr $d7b1	                jsr print_string_no_lf
.9941		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt xt xt )
.9944		20 ef 94	jsr $94ef	                jsr xt_u_dot
.9947		20 3a 84	jsr $843a	                jsr xt_cr               ; ( nt xt )
.994a		a9 08		lda #$08	                lda #str_see_flags
.994c		20 b1 d7	jsr $d7b1	                jsr print_string_no_lf
.994f		20 05 8d	jsr $8d05	                jsr xt_over             ; ( nt xt nt )
.9952		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9955		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( nt xt flags )
.9958		b5 00		lda $00,x	                lda 0,x
.995a		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.995c						_flag_loop:
.995c		48		pha		                pha
.995d		29 01		and #$01	                and #%00000001
.995f		18		clc		                clc
.9960		69 30		adc #$30	                adc #'0'
.9962		20 c5 86	jsr $86c5	                jsr emit_a
.9965		20 cb 91	jsr $91cb	                jsr xt_space
.9968		68		pla		                pla
.9969		6a		ror a		                ror                     ; Next flag
.996a		88		dey		                dey
.996b		d0 ef		bne $995c	                bne _flag_loop
.996d		20 3a 84	jsr $843a	                jsr xt_cr
.9970		e8		inx		                inx
.9971		e8		inx		                inx                     ; ( nt xt )
.9972		a9 0b		lda #$0b	                lda #str_see_size
.9974		20 b1 d7	jsr $d7b1	                jsr print_string_no_lf
.9977		20 2e 92	jsr $922e	                jsr xt_swap             ; ( xt nt )
.997a		20 bb 9d	jsr $9dbb	                jsr xt_wordsize         ; ( xt u )
.997d		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9980		20 0a 85	jsr $850a	                jsr xt_decimal
.9983		20 ef 94	jsr $94ef	                jsr xt_u_dot            ; ( xt u )
.9986		20 26 89	jsr $8926	                jsr xt_hex
.9989		20 3a 84	jsr $843a	                jsr xt_cr
.998c		20 af 93	jsr $93af	                jsr xt_two_dup          ; ( xt u xt u )
.998f		20 8c 98	jsr $988c	                jsr xt_dump
.9992		20 3a 84	jsr $843a	                jsr xt_cr
.9995		20 89 a1	jsr $a189	                jsr xt_disasm
.9998		68		pla		                pla
.9999		85 18		sta $18		                sta base
.999b		60		rts		z_see:          rts
.999c						xt_words:
.999c		20 3a 84	jsr $843a	                jsr xt_cr
.999f		a9 00		lda #$00	                lda #0
.99a1		48		pha		                pha
.99a2		ca		dex		                dex                     ; Make room on the stack for
.99a3		ca		dex		                dex                     ; a dictionary pointer.
.99a4		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.99a6						_wordlist_loop:
.99a6		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.99a8		a5 29		lda $29		                lda tmp3
.99aa		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.99ac		d0 02		bne $99b0	                bne _have_wordlist
.99ae		80 45		bra $99f5	                bra _words_done
.99b0						_have_wordlist:
.99b0		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.99b1		69 23		adc #$23	                adc #search_order_offset
.99b3		a8		tay		                tay
.99b4		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.99b6		0a		asl a		                asl                     ; Turn offset into cells offset.
.99b7		18		clc		                clc
.99b8		69 0a		adc #$0a	                adc #wordlists_offset
.99ba		a8		tay		                tay
.99bb		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.99bd		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.99bf		c8		iny		                iny
.99c0		b1 08		lda ($08),y	                lda (up),y
.99c2		95 01		sta $01,x	                sta 1,x
.99c4						_loop:
.99c4		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.99c7		20 36 9c	jsr $9c36	                jsr xt_name_to_string   ; ( nt addr u )
.99ca		68		pla		                pla
.99cb		18		clc		                clc
.99cc		75 00		adc $00,x	                adc 0,x
.99ce		1a		inc a		                ina                     ; don't forget the space between words
.99cf		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.99d1		90 06		bcc $99d9	                bcc +
.99d3		20 3a 84	jsr $843a	                jsr xt_cr
.99d6		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.99d8		1a		inc a		                ina                     ; with length of this word.
.99d9						+
.99d9		48		pha		                pha
.99da		20 c4 94	jsr $94c4	                jsr xt_type             ; ( nt )
.99dd		a9 20		lda #$20	                lda #AscSP
.99df		20 c5 86	jsr $86c5	                jsr emit_a
.99e2		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+
.99e5		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+
.99e8		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( nt+1 )
.99eb		b5 00		lda $00,x	                lda 0,x
.99ed		15 01		ora $01,x	                ora 1,x
.99ef		d0 d3		bne $99c4	                bne _loop
.99f1		e6 29		inc $29		                inc tmp3
.99f3		80 b1		bra $99a6	                bra _wordlist_loop
.99f5						_words_done:
.99f5		68		pla		                pla                     ; dump counter
.99f6		e8		inx		                inx
.99f7		e8		inx		                inx
.99f8		60		rts		z_words:        rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tali.asm

.99f9						xt_allow_native:
.99f9		20 cc d6	jsr $d6cc	                jsr current_to_dp
.99fc		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.99fe		b1 02		lda ($02),y	                lda (dp),y
.9a00		29 f5		and #$f5	                and #$FF-NN-AN  ; AN and NN flag is clear.
.9a02		91 02		sta ($02),y	                sta (dp),y
.9a04						z_allow_native:
.9a04		60		rts		                rts
.9a05						xt_always_native:
.9a05		20 cc d6	jsr $d6cc	                jsr current_to_dp
.9a08		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9a0a		b1 02		lda ($02),y	                lda (dp),y
.9a0c		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.9a0e		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.9a10		91 02		sta ($02),y	                sta (dp),y
.9a12						z_always_native:
.9a12		60		rts		                rts
.9a13						xt_bell:
.9a13		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.9a15		20 c5 86	jsr $86c5	                jsr emit_a
.9a18		60		rts		z_bell:         rts
.9a19						xt_bounds:
.9a19		20 7a d7	jsr $d77a	                jsr underflow_2
.9a1c		18		clc		                clc
.9a1d		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.9a1f		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.9a21		75 02		adc $02,x	                adc 2,x
.9a23		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.9a25		94 00		sty $00,x	                sty 0,x
.9a27		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.9a29		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.9a2b		75 03		adc $03,x	                adc 3,x
.9a2d		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.9a2f		94 01		sty $01,x	                sty 1,x
.9a31		60		rts		z_bounds:       rts
.9a32						xt_cleave:
.9a32		20 7a d7	jsr $d77a	                jsr underflow_2
.9a35		20 08 a0	jsr $a008	                jsr xt_minus_leading    ; -LEADING ( addr u )
.9a38		20 7d 9b	jsr $9b7d	                jsr xt_input_to_r       ; save old imput state
.9a3b		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.9a3d		85 0e		sta $0e		                sta ciblen
.9a3f		b5 01		lda $01,x	                lda 1,x
.9a41		85 0f		sta $0f		                sta ciblen+1
.9a43		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.9a45		85 0c		sta $0c		                sta cib
.9a47		b5 03		lda $03,x	                lda 3,x
.9a49		85 0d		sta $0d		                sta cib+1
.9a4b		64 10		stz $10		                stz toin        ; >IN pointer is zero
.9a4d		64 11		stz $11		                stz toin+1
.9a4f		20 51 8d	jsr $8d51	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.9a52		b5 00		lda $00,x	                lda 0,x
.9a54		15 01		ora $01,x	                ora 1,x
.9a56		f0 23		beq $9a7b	                beq _done
.9a58		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.9a5a		38		sec		                sec
.9a5b		f5 00		sbc $00,x	                sbc 0,x
.9a5d		95 04		sta $04,x	                sta 4,x
.9a5f		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.9a61		f5 01		sbc $01,x	                sbc 1,x
.9a63		95 05		sta $05,x	                sta 5,x
.9a65		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.9a67		18		clc		                clc
.9a68		75 00		adc $00,x	                adc 0,x
.9a6a		95 06		sta $06,x	                sta 6,x
.9a6c		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.9a6e		75 01		adc $01,x	                adc 1,x
.9a70		95 07		sta $07,x	                sta 7,x
.9a72		20 80 94	jsr $9480	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.9a75		20 08 a0	jsr $a008	                jsr xt_minus_leading
.9a78		20 80 94	jsr $9480	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.9a7b						_done:
.9a7b		20 8a 9d	jsr $9d8a	                jsr xt_r_to_input
.9a7e		60		rts		z_cleave:       rts
.9a7f						xt_digit_question:
.9a7f		20 75 d7	jsr $d775	                jsr underflow_1
.9a82		ca		dex		                dex
.9a83		ca		dex		                dex
.9a84		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.9a86		74 01		stz $01,x	                stz 1,x
.9a88		74 03		stz $03,x	                stz 3,x                 ; paranoid
.9a8a		b5 02		lda $02,x	                lda 2,x
.9a8c		c9 30		cmp #$30	                cmp #'0'
.9a8e		90 23		bcc $9ab3	                bcc _done               ; failure flag already set
.9a90		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.9a92		90 12		bcc $9aa6	                bcc _checkbase
.9a94		c9 41		cmp #$41	                cmp #'A'
.9a96		90 1b		bcc $9ab3	                bcc _done               ; failure flag is already set
.9a98		c9 61		cmp #$61	                cmp #'a'
.9a9a		90 07		bcc $9aa3	                bcc _case_done          ; not lower case, too low
.9a9c		c9 7b		cmp #$7b	                cmp #'z'+1
.9a9e		b0 03		bcs $9aa3	                bcs _case_done          ; not lower case, too high
.9aa0		18		clc		                clc                     ; just right
.9aa1		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.9aa3						_case_done:
.9aa3		38		sec		                sec
.9aa4		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.9aa6						_checkbase:
.9aa6		38		sec		                sec
.9aa7		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.9aa9		c5 18		cmp $18		                cmp base
.9aab		b0 06		bcs $9ab3	                bcs _done               ; already have false flag
.9aad		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.9aaf		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.9ab1		d6 01		dec $01,x	                dec 1,x
.9ab3						_done:
.9ab3						z_digit_question:
.9ab3		60		rts		                rts
.9ab4						xt_execute_parsing:
.9ab4		20 7f d7	jsr $d77f	                jsr underflow_3
.9ab7		20 7d 9b	jsr $9b7d	                jsr xt_input_to_r       ; save normal input for later
.9aba		20 60 9c	jsr $9c60	                jsr xt_not_rote         ; -ROT ( xt addr u )
.9abd		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.9abf		85 0e		sta $0e		                sta ciblen
.9ac1		b5 01		lda $01,x	                lda 1,x
.9ac3		85 0f		sta $0f		                sta ciblen+1
.9ac5		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.9ac7		85 0c		sta $0c		                sta cib
.9ac9		b5 03		lda $03,x	                lda 3,x
.9acb		85 0d		sta $0d		                sta cib+1
.9acd		64 10		stz $10		                stz toin                ; Set >IN to zero
.9acf		64 11		stz $11		                stz toin+1
.9ad1		20 a7 93	jsr $93a7	                jsr xt_two_drop         ; 2DROP ( xt )
.9ad4		20 05 88	jsr $8805	                jsr xt_execute
.9ad7		20 8a 9d	jsr $9d8a	                jsr xt_r_to_input
.9ada						z_execute_parsing:
.9ada		60		rts		                rts
.9adb						xt_find_name:
.9adb		20 7a d7	jsr $d77a	                jsr underflow_2
.9ade		b5 00		lda $00,x	                lda 0,x
.9ae0		15 01		ora $01,x	                ora 1,x
.9ae2		d0 03		bne $9ae7	                bne _nonempty
.9ae4		4c 18 9b	jmp $9b18	                jmp _fail_done
.9ae7						_nonempty:
.9ae7		64 29		stz $29		                stz tmp3                ; Start at the beginning
.9ae9						_wordlist_loop:
.9ae9		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9aeb		a5 29		lda $29		                lda tmp3
.9aed		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.9aef		f0 27		beq $9b18	                beq _fail_done
.9af1		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9af2		69 23		adc #$23	                adc #search_order_offset
.9af4		a8		tay		                tay
.9af5		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.9af7		0a		asl a		                asl                     ; Turn offset into cells offset.
.9af8		18		clc		                clc
.9af9		69 0a		adc #$0a	                adc #wordlists_offset
.9afb		a8		tay		                tay
.9afc		b1 08		lda ($08),y	                lda (up),y
.9afe		85 25		sta $25		                sta tmp1
.9b00		c8		iny		                iny
.9b01		b1 08		lda ($08),y	                lda (up),y
.9b03		85 26		sta $26		                sta tmp1+1
.9b05		20 57 d6	jsr $d657	                jsr find_header_name
.9b08		d0 04		bne $9b0e	                bne _success
.9b0a		e6 29		inc $29		                inc tmp3
.9b0c		80 db		bra $9ae9	                bra _wordlist_loop
.9b0e						_success:
.9b0e		a5 25		lda $25		                lda tmp1
.9b10		95 02		sta $02,x	                sta 2,x
.9b12		a5 26		lda $26		                lda tmp1+1
.9b14		95 03		sta $03,x	                sta 3,x
.9b16		80 04		bra $9b1c	                bra _done
.9b18						_fail_done:
.9b18		74 02		stz $02,x	                stz 2,x         ; failure flag
.9b1a		74 03		stz $03,x	                stz 3,x
.9b1c						_done:
.9b1c		e8		inx		                inx
.9b1d		e8		inx		                inx
.9b1e		60		rts		z_find_name:    rts
.9b1f						xt_hexstore:
.9b1f		20 7f d7	jsr $d77f	                jsr underflow_3
.9b22		20 a0 86	jsr $86a0	                jsr xt_dup              ; Save copy of original address
.9b25		20 a4 94	jsr $94a4	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b28						_loop:
.9b28		b5 00		lda $00,x	                lda 0,x
.9b2a		15 01		ora $01,x	                ora 1,x
.9b2c		f0 36		beq $9b64	                beq _done
.9b2e		20 32 9a	jsr $9a32	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9b31		20 a4 94	jsr $94a4	                jsr xt_two_to_r
.9b34		20 dc 9d	jsr $9ddc	                jsr xt_zero
.9b37		20 dc 9d	jsr $9ddc	                jsr xt_zero
.9b3a		20 2a 94	jsr $942a	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9b3d		20 cc 92	jsr $92cc	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9b40		b5 00		lda $00,x	                lda 0,x
.9b42		15 01		ora $01,x	                ora 1,x
.9b44		d0 17		bne $9b5d	                bne _have_chars_left
.9b46		20 a7 93	jsr $93a7	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9b49		20 25 9e	jsr $9e25	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9b4c		20 d9 8e	jsr $8ed9	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9b4f		20 37 83	jsr $8337	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b52		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R>
.9b55		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+
.9b58		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9b5b		80 cb		bra $9b28	                bra _loop
.9b5d						_have_chars_left:
.9b5d		8a		txa		                txa
.9b5e		18		clc		                clc
.9b5f		69 08		adc #$08	                adc #8
.9b61		aa		tax		                tax
.9b62		80 c4		bra $9b28	                bra _loop
.9b64						_done:
.9b64		e8		inx		                inx
.9b65		e8		inx		                inx
.9b66		e8		inx		                inx
.9b67		e8		inx		                inx                     ; 2DROP
.9b68		20 2a 94	jsr $942a	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.9b6b		20 2e 92	jsr $922e	                jsr xt_swap
.9b6e		20 e4 8b	jsr $8be4	                jsr xt_minus            ; ( n )
.9b71		60		rts		z_hexstore:     rts
.9b72						xt_input:
.9b72		ca		dex		                dex
.9b73		ca		dex		                dex
.9b74		a9 14		lda #$14	                lda #<input
.9b76		95 00		sta $00,x	                sta 0,x
.9b78		a9 00		lda #$00	                lda #>input
.9b7a		95 01		sta $01,x	                sta 1,x
.9b7c		60		rts		z_input:        rts
.9b7d						xt_input_to_r:
.9b7d		68		pla		                pla
.9b7e		85 25		sta $25		                sta tmp1
.9b80		68		pla		                pla
.9b81		85 26		sta $26		                sta tmp1+1
.9b83		a0 07		ldy #$07	                ldy #7
.9b85						_loop:
.9b85		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9b88		48		pha		                pha
.9b89		88		dey		                dey
.9b8a		10 f9		bpl $9b85	                bpl _loop
.9b8c		a5 26		lda $26		                lda tmp1+1
.9b8e		48		pha		                pha
.9b8f		a5 25		lda $25		                lda tmp1
.9b91		48		pha		                pha
.9b92		60		rts		z_input_to_r: 	rts
.9b93						xt_int_to_name:
.9b93		20 75 d7	jsr $d775	                jsr underflow_1
.9b96		ca		dex		                dex
.9b97		ca		dex		                dex
.9b98		74 00		stz $00,x	                stz 0,x
.9b9a		74 01		stz $01,x	                stz 1,x
.9b9c						_wordlist_loop:
.9b9c		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9b9e		0a		asl a		                asl                     ; Turn offset into cells offset.
.9b9f		18		clc		                clc
.9ba0		69 0a		adc #$0a	                adc #wordlists_offset
.9ba2		a8		tay		                tay
.9ba3		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9ba5		85 27		sta $27		                sta tmp2                ; into tmp2
.9ba7		c8		iny		                iny
.9ba8		b1 08		lda ($08),y	                lda (up),y
.9baa		85 28		sta $28		                sta tmp2+1
.9bac		a5 27		lda $27		                lda tmp2
.9bae		05 28		ora $28		                ora tmp2+1
.9bb0		f0 36		beq $9be8	                beq _next_wordlist
.9bb2		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9bb4		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9bb6		b5 03		lda $03,x	                lda 3,x
.9bb8		85 2a		sta $2a		                sta tmp3+1
.9bba						_loop:
.9bba		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9bbc		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.9bbe		c5 29		cmp $29		                cmp tmp3
.9bc0		d0 07		bne $9bc9	                bne _no_match
.9bc2		c8		iny		                iny
.9bc3		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9bc5		c5 2a		cmp $2a		                cmp tmp3+1
.9bc7		f0 30		beq $9bf9	                beq _match
.9bc9						_no_match:
.9bc9		18		clc		                clc
.9bca		a5 27		lda $27		                lda tmp2
.9bcc		69 02		adc #$02	                adc #2
.9bce		85 27		sta $27		                sta tmp2
.9bd0		90 02		bcc $9bd4	                bcc +
.9bd2		e6 28		inc $28		                inc tmp2+1
.9bd4						+
.9bd4		a0 00		ldy #$00	                ldy #0
.9bd6		b1 27		lda ($27),y	                lda (tmp2),y
.9bd8		48		pha		                pha
.9bd9		c8		iny		                iny
.9bda		11 27		ora ($27),y	                ora (tmp2),y
.9bdc		f0 09		beq $9be7	                beq _zero
.9bde		b1 27		lda ($27),y	                lda (tmp2),y
.9be0		85 28		sta $28		                sta tmp2+1
.9be2		68		pla		                pla
.9be3		85 27		sta $27		                sta tmp2
.9be5		80 d3		bra $9bba	                bra _loop
.9be7						_zero:
.9be7		68		pla		                pla             ; Leftover from above loop
.9be8						_next_wordlist:
.9be8		b5 00		lda $00,x	                lda 0,x
.9bea		1a		inc a		                ina
.9beb		95 00		sta $00,x	                sta 0,x
.9bed		c9 0c		cmp #$0c	                cmp #max_wordlists
.9bef		d0 ab		bne $9b9c	                bne _wordlist_loop
.9bf1		e8		inx		                inx
.9bf2		e8		inx		                inx
.9bf3		74 00		stz $00,x	                stz 0,x
.9bf5		74 01		stz $01,x	                stz 1,x
.9bf7		80 0a		bra $9c03	                bra z_int_to_name
.9bf9						_match:
.9bf9		e8		inx		                inx
.9bfa		e8		inx		                inx
.9bfb		a5 27		lda $27		                lda tmp2
.9bfd		95 00		sta $00,x	                sta 0,x
.9bff		a5 28		lda $28		                lda tmp2+1
.9c01		95 01		sta $01,x	                sta 1,x
.9c03		60		rts		z_int_to_name:  rts
.9c04						xt_latestnt:
.9c04		ca		dex		                dex
.9c05		ca		dex		                dex
.9c06		20 cc d6	jsr $d6cc	                jsr current_to_dp
.9c09		a5 02		lda $02		                lda dp
.9c0b		95 00		sta $00,x	                sta 0,x
.9c0d		a5 03		lda $03		                lda dp+1
.9c0f		95 01		sta $01,x	                sta 1,x
.9c11		60		rts		z_latestnt:     rts
.9c12						xt_latestxt:
.9c12		20 04 9c	jsr $9c04	                jsr xt_latestnt         ; ( nt )
.9c15		20 19 9c	jsr $9c19	                jsr xt_name_to_int      ; ( xt )
.9c18		60		rts		z_latestxt:     rts
.9c19						xt_name_to_int:
.9c19		20 75 d7	jsr $d775	                jsr underflow_1
.9c1c		b5 00		lda $00,x	                lda 0,x
.9c1e		18		clc		                clc
.9c1f		69 04		adc #$04	                adc #4
.9c21		85 29		sta $29		                sta tmp3
.9c23		b5 01		lda $01,x	                lda 1,x
.9c25		90 01		bcc $9c28	                bcc _done
.9c27		1a		inc a		                ina
.9c28						_done:
.9c28		85 2a		sta $2a		                sta tmp3+1
.9c2a		a0 00		ldy #$00	                ldy #0
.9c2c		b1 29		lda ($29),y	                lda (tmp3),y
.9c2e		95 00		sta $00,x	                sta 0,x
.9c30		c8		iny		                iny
.9c31		b1 29		lda ($29),y	                lda (tmp3),y
.9c33		95 01		sta $01,x	                sta 1,x
.9c35		60		rts		z_name_to_int:  rts
.9c36						xt_name_to_string:
.9c36		20 75 d7	jsr $d775	                jsr underflow_1
.9c39		ca		dex		                dex
.9c3a		ca		dex		                dex
.9c3b		a1 02		lda ($02,x)	                lda (2,x)
.9c3d		95 00		sta $00,x	                sta 0,x
.9c3f		74 01		stz $01,x	                stz 1,x
.9c41		b5 02		lda $02,x	                lda 2,x         ; LSB
.9c43		18		clc		                clc
.9c44		69 08		adc #$08	                adc #8
.9c46		95 02		sta $02,x	                sta 2,x
.9c48		90 02		bcc $9c4c	                bcc z_name_to_string
.9c4a		f6 03		inc $03,x	                inc 3,x         ; MSB
.9c4c						z_name_to_string:
.9c4c		60		rts		                rts
.9c4d						xt_nc_limit:
.9c4d		a9 00		lda #$00	                lda #nc_limit_offset
.9c4f		4c 31 d6	jmp $d631	                jmp push_upvar_tos
.9c52						z_nc_limit:
.9c52						xt_never_native:
.9c52		20 cc d6	jsr $d6cc	                jsr current_to_dp
.9c55		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9c57		b1 02		lda ($02),y	                lda (dp),y
.9c59		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9c5b		29 fd		and #$fd	                and #$FF-AN     ; and AN flag is clear.
.9c5d		91 02		sta ($02),y	                sta (dp),y
.9c5f						z_never_native:
.9c5f		60		rts		                rts
.9c60						xt_not_rote:
.9c60		20 7f d7	jsr $d77f	                jsr underflow_3
.9c63		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9c65		b5 03		lda $03,x	                lda 3,x
.9c67		95 01		sta $01,x	                sta 1,x
.9c69		b5 05		lda $05,x	                lda 5,x
.9c6b		95 03		sta $03,x	                sta 3,x
.9c6d		94 05		sty $05,x	                sty 5,x
.9c6f		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9c71		b5 02		lda $02,x	                lda 2,x
.9c73		95 00		sta $00,x	                sta 0,x
.9c75		b5 04		lda $04,x	                lda 4,x
.9c77		95 02		sta $02,x	                sta 2,x
.9c79		94 04		sty $04,x	                sty 4,x
.9c7b		60		rts		z_not_rote:     rts
.9c7c						xt_number:
.9c7c		20 7a d7	jsr $d77a	                jsr underflow_2
.9c7f		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.9c81		a5 18		lda $18		                lda base
.9c83		48		pha		                pha
.9c84		20 af 93	jsr $93af	                jsr xt_two_dup
.9c87		a1 02		lda ($02,x)	                lda (2,x)
.9c89		c9 23		cmp #$23	                cmp #'#'                ; decimal?
.9c8b		d0 04		bne $9c91	                bne _check_hex
.9c8d		a9 0a		lda #$0a	                lda #10
.9c8f		80 42		bra $9cd3	                bra _base_changed
.9c91						_check_hex:
.9c91		c9 24		cmp #$24	                cmp #'$'
.9c93		d0 04		bne $9c99	                bne _check_binary
.9c95		a9 10		lda #$10	                lda #16
.9c97		80 3a		bra $9cd3	                bra _base_changed
.9c99						_check_binary:
.9c99		c9 25		cmp #$25	                cmp #'%'
.9c9b		d0 04		bne $9ca1	                bne _check_char
.9c9d		a9 02		lda #$02	                lda #2
.9c9f		80 32		bra $9cd3	                bra _base_changed
.9ca1						_check_char:
.9ca1		c9 27		cmp #$27	                cmp #"'"
.9ca3		d0 3a		bne $9cdf	                bne _check_minus
.9ca5		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9ca7		c9 03		cmp #$03	                cmp #3
.9ca9		d0 26		bne $9cd1	                bne _not_a_char
.9cab		b5 01		lda $01,x	                lda 1,x
.9cad		d0 22		bne $9cd1	                bne _not_a_char ; No compare needed to check for non-zero.
.9caf		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9cb1		18		clc		                clc
.9cb2		69 02		adc #$02	                adc #2          ; length of string
.9cb4		85 23		sta $23		                sta tmptos
.9cb6		b5 03		lda $03,x	                lda 3,x
.9cb8		69 00		adc #$00	                adc #0          ; only need carry
.9cba		85 24		sta $24		                sta tmptos+1
.9cbc		b2 23		lda ($23)	                lda (tmptos)
.9cbe		c9 27		cmp #$27	                cmp #"'"
.9cc0		d0 0f		bne $9cd1	                bne _not_a_char
.9cc2		f6 02		inc $02,x	                inc 2,x
.9cc4		d0 02		bne $9cc8	                bne +
.9cc6		f6 03		inc $03,x	                inc 3,x
.9cc8						+
.9cc8		a1 02		lda ($02,x)	                lda (2,x)
.9cca		95 02		sta $02,x	                sta 2,x
.9ccc		74 03		stz $03,x	                stz 3,x
.9cce		4c 51 9d	jmp $9d51	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9cd1						_not_a_char:
.9cd1		80 5c		bra $9d2f	                bra _number_error
.9cd3						_base_changed:
.9cd3		85 18		sta $18		                sta base        ; Switch to the new base
.9cd5		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9cd7		d0 02		bne $9cdb	                bne +
.9cd9		f6 03		inc $03,x	                inc 3,x
.9cdb						+
.9cdb		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9cdd		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9cdf						_check_minus:
.9cdf		c9 2d		cmp #$2d	                cmp #'-'
.9ce1		d0 0c		bne $9cef	                bne _check_dot
.9ce3		a9 80		lda #$80	                lda #$80
.9ce5		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.9ce7		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9ce9		d0 02		bne $9ced	                bne +
.9ceb		f6 03		inc $03,x	                inc 3,x
.9ced						+
.9ced		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9cef						_check_dot:
.9cef		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9cf1		18		clc		                clc
.9cf2		75 00		adc $00,x	                adc 0,x         ; length of string
.9cf4		85 23		sta $23		                sta tmptos
.9cf6		b5 03		lda $03,x	                lda 3,x
.9cf8		69 00		adc #$00	                adc #0          ; only need carry
.9cfa		85 24		sta $24		                sta tmptos+1
.9cfc		a5 23		lda $23		                lda tmptos
.9cfe		d0 02		bne $9d02	                bne +
.9d00		c6 24		dec $24		                dec tmptos+1
.9d02						+
.9d02		c6 23		dec $23		                dec tmptos
.9d04		b2 23		lda ($23)	                lda (tmptos)
.9d06		c9 2e		cmp #$2e	                cmp #'.'
.9d08		d0 04		bne $9d0e	                bne _main
.9d0a		e6 1e		inc $1e		                inc tmpdsp
.9d0c		d6 00		dec $00,x	                dec 0,x
.9d0e						_main:
.9d0e		ca		dex		                dex
.9d0f		ca		dex		                dex
.9d10		ca		dex		                dex
.9d11		ca		dex		                dex
.9d12		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9d14		95 00		sta $00,x	                sta 0,x
.9d16		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9d18		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9d1a		95 02		sta $02,x	                sta 2,x
.9d1c		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9d1e		95 03		sta $03,x	                sta 3,x
.9d20		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9d22		74 05		stz $05,x	                stz 5,x
.9d24		74 06		stz $06,x	                stz 6,x
.9d26		74 07		stz $07,x	                stz 7,x
.9d28		20 cc 92	jsr $92cc	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9d2b		b5 00		lda $00,x	                lda 0,x
.9d2d		f0 1e		beq $9d4d	                beq _all_converted
.9d2f						_number_error:
.9d2f		20 a7 93	jsr $93a7	                jsr xt_two_drop ; >NUMBER modified addr u
.9d32		20 a7 93	jsr $93a7	                jsr xt_two_drop ; ud   (partially converted number)
.9d35		a9 3e		lda #$3e	                lda #'>'
.9d37		20 c5 86	jsr $86c5	                jsr emit_a
.9d3a		20 c4 94	jsr $94c4	                jsr xt_type
.9d3d		a9 3c		lda #$3c	                lda #'<'
.9d3f		20 c5 86	jsr $86c5	                jsr emit_a
.9d42		20 cb 91	jsr $91cb	                jsr xt_space
.9d45		68		pla		                pla
.9d46		85 18		sta $18		                sta base
.9d48		a9 08		lda #$08	                lda #err_syntax
.9d4a		4c 8b d7	jmp $d78b	                jmp error
.9d4d						_all_converted:
.9d4d		e8		inx		                inx ; Drop the current addr u
.9d4e		e8		inx		                inx
.9d4f		e8		inx		                inx
.9d50		e8		inx		                inx
.9d51						_drop_original_string:
.9d51		20 80 94	jsr $9480	                jsr xt_two_swap  ; Drop the original addr u
.9d54		20 a7 93	jsr $93a7	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9d57		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9d59		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9d5b		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9d5c		f0 0a		beq $9d68	                beq _single
.9d5e		98		tya		                tya
.9d5f		04 1c		tsb $1c		                tsb status
.9d61		90 0f		bcc $9d72	                bcc _done       ; no minus, all done
.9d63		20 4a 9e	jsr $9e4a	                jsr xt_dnegate
.9d66		80 0a		bra $9d72	                bra _done
.9d68						_single:
.9d68		e8		inx		                inx
.9d69		e8		inx		                inx
.9d6a		98		tya		                tya
.9d6b		14 1c		trb $1c		                trb status
.9d6d		90 03		bcc $9d72	                bcc _done       ; no minus, all done
.9d6f		20 1f 8c	jsr $8c1f	                jsr xt_negate
.9d72						_done:
.9d72		68		pla		                pla
.9d73		85 18		sta $18		                sta base
.9d75		60		rts		z_number:       rts
.9d76						xt_editor_wordlist:
.9d76						xt_one:
.9d76		ca		dex		                dex
.9d77		ca		dex		                dex
.9d78		a9 01		lda #$01	                lda #1
.9d7a		95 00		sta $00,x	                sta 0,x
.9d7c		74 01		stz $01,x	                stz 1,x
.9d7e						z_editor_wordlist:
.9d7e						z_one:
.9d7e		60		rts		                rts
.9d7f						xt_output:
.9d7f		ca		dex		                dex
.9d80		ca		dex		                dex
.9d81		a9 12		lda #$12	                lda #<output
.9d83		95 00		sta $00,x	                sta 0,x
.9d85		a9 00		lda #$00	                lda #>output
.9d87		95 01		sta $01,x	                sta 1,x
.9d89		60		rts		z_output:       rts
.9d8a						xt_r_to_input:
.9d8a		68		pla		                pla
.9d8b		85 25		sta $25		                sta tmp1
.9d8d		68		pla		                pla
.9d8e		85 26		sta $26		                sta tmp1+1
.9d90		a0 00		ldy #$00	                ldy #0
.9d92						_loop:
.9d92		68		pla		                pla
.9d93		99 0a 00	sta $000a,y	                sta insrc,y
.9d96		c8		iny		                iny
.9d97		c0 08		cpy #$08	                cpy #8
.9d99		d0 f7		bne $9d92	                bne _loop
.9d9b		a5 26		lda $26		                lda tmp1+1
.9d9d		48		pha		                pha
.9d9e		a5 25		lda $25		                lda tmp1
.9da0		48		pha		                pha
.9da1		60		rts		z_r_to_input: 	rts
.9da2						xt_strip_underflow:
.9da2		a9 02		lda #$02	                lda #uf_strip_offset
.9da4		4c 31 d6	jmp $d631	                jmp push_upvar_tos
.9da7						z_strip_underflow:
.9da7						xt_assembler_wordlist:
.9da7						xt_two:
.9da7		ca		dex		                dex
.9da8		ca		dex		                dex
.9da9		a9 02		lda #$02	                lda #2
.9dab		95 00		sta $00,x	                sta 0,x
.9dad		74 01		stz $01,x	                stz 1,x
.9daf						z_assembler_wordlist:
.9daf		60		rts		z_two:          rts
.9db0						xt_useraddr:
.9db0		ca		dex		                dex
.9db1		ca		dex		                dex
.9db2		a9 08		lda #$08	                lda #<up
.9db4		95 00		sta $00,x	                sta 0,x
.9db6		a9 00		lda #$00	                lda #>up
.9db8		95 01		sta $01,x	                sta 1,x
.9dba		60		rts		z_useraddr:     rts
.9dbb						xt_wordsize:
.9dbb		20 75 d7	jsr $d775	                jsr underflow_1
.9dbe		b5 00		lda $00,x	                lda 0,x
.9dc0		85 25		sta $25		                sta tmp1
.9dc2		b5 01		lda $01,x	                lda 1,x
.9dc4		85 26		sta $26		                sta tmp1+1
.9dc6		a0 06		ldy #$06	                ldy #6
.9dc8		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.9dca		88		dey		                dey
.9dcb		88		dey		                dey
.9dcc		38		sec		                sec
.9dcd		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.9dcf		95 00		sta $00,x	                sta 0,x
.9dd1		a0 07		ldy #$07	                ldy #7
.9dd3		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.9dd5		88		dey		                dey
.9dd6		88		dey		                dey
.9dd7		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.9dd9		95 01		sta $01,x	                sta 1,x
.9ddb		60		rts		z_wordsize:     rts
.9ddc						xt_case:
.9ddc						xt_false:
.9ddc						xt_forth_wordlist:
.9ddc						xt_zero:
.9ddc		ca		dex		                dex             ; push
.9ddd		ca		dex		                dex
.9dde		74 00		stz $00,x	                stz 0,x
.9de0		74 01		stz $01,x	                stz 1,x
.9de2						z_case:
.9de2						z_false:
.9de2						z_forth_wordlist:
.9de2						z_zero:
.9de2		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/double.asm

.9de3						xt_d_minus:
.9de3		20 84 d7	jsr $d784	                jsr underflow_4 ; two double numbers
.9de6		38		sec		                sec
.9de7		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.9de9		f5 02		sbc $02,x	                sbc 2,x
.9deb		95 06		sta $06,x	                sta 6,x
.9ded		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.9def		f5 03		sbc $03,x	                sbc 3,x
.9df1		95 07		sta $07,x	                sta 7,x
.9df3		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.9df5		f5 00		sbc $00,x	                sbc 0,x
.9df7		95 04		sta $04,x	                sta 4,x
.9df9		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.9dfb		f5 01		sbc $01,x	                sbc 1,x
.9dfd		95 05		sta $05,x	                sta 5,x
.9dff		e8		inx		                inx
.9e00		e8		inx		                inx
.9e01		e8		inx		                inx
.9e02		e8		inx		                inx
.9e03		60		rts		z_d_minus:      rts
.9e04						xt_d_plus:
.9e04		20 84 d7	jsr $d784	                jsr underflow_4 ; two double numbers
.9e07		18		clc		                clc
.9e08		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.9e0a		75 06		adc $06,x	                adc 6,x
.9e0c		95 06		sta $06,x	                sta 6,x
.9e0e		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.9e10		75 07		adc $07,x	                adc 7,x
.9e12		95 07		sta $07,x	                sta 7,x
.9e14		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.9e16		75 04		adc $04,x	                adc 4,x
.9e18		95 04		sta $04,x	                sta 4,x
.9e1a		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.9e1c		75 05		adc $05,x	                adc 5,x
.9e1e		95 05		sta $05,x	                sta 5,x
.9e20		e8		inx		                inx
.9e21		e8		inx		                inx
.9e22		e8		inx		                inx
.9e23		e8		inx		                inx
.9e24		60		rts		z_d_plus:       rts
.9e25						xt_d_to_s:
.9e25		20 7a d7	jsr $d77a	                jsr underflow_2
.9e28		e8		inx		                inx
.9e29		e8		inx		                inx
.9e2a		60		rts		z_d_to_s:       rts
.9e2b						xt_dabs:
.9e2b		20 7a d7	jsr $d77a	                jsr underflow_2 ; double number
.9e2e		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.9e30		10 17		bpl $9e49	                bpl _done       ; positive, we get off light
.9e32		a0 00		ldy #$00	                ldy #0
.9e34		38		sec		                sec
.9e35		98		tya		                tya
.9e36		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e38		95 02		sta $02,x	                sta 2,x
.9e3a		98		tya		                tya
.9e3b		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e3d		95 03		sta $03,x	                sta 3,x
.9e3f		98		tya		                tya
.9e40		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e42		95 00		sta $00,x	                sta 0,x
.9e44		98		tya		                tya
.9e45		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9e47		95 01		sta $01,x	                sta 1,x
.9e49						_done:
.9e49		60		rts		z_dabs:         rts
.9e4a						xt_dnegate:
.9e4a		20 7a d7	jsr $d77a	                jsr underflow_2 ; double number
.9e4d		a0 00		ldy #$00	     		ldy #0
.9e4f		38		sec		                sec
.9e50		98		tya		                tya
.9e51		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e53		95 02		sta $02,x	                sta 2,x
.9e55		98		tya		                tya
.9e56		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e58		95 03		sta $03,x	                sta 3,x
.9e5a		98		tya		                tya
.9e5b		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e5d		95 00		sta $00,x	                sta 0,x
.9e5f		98		tya		                tya
.9e60		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9e62		95 01		sta $01,x	                sta 1,x
.9e64		60		rts		z_dnegate:      rts
.9e65						xt_d_dot:
.9e65		20 7a d7	jsr $d77a	                jsr underflow_2
.9e68		20 8d 93	jsr $938d	                jsr xt_tuck
.9e6b		20 2b 9e	jsr $9e2b	                jsr xt_dabs
.9e6e		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9e71		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.9e74		20 91 8f	jsr $8f91	                jsr xt_rot
.9e77		20 50 91	jsr $9150	                jsr xt_sign
.9e7a		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.9e7d		20 c4 94	jsr $94c4	                jsr xt_type
.9e80		20 cb 91	jsr $91cb	                jsr xt_space
.9e83		60		rts		z_d_dot:        rts
.9e84						xt_d_dot_r:
.9e84		20 7f d7	jsr $d77f	                jsr underflow_3
.9e87		20 6c 93	jsr $936c	                jsr xt_to_r
.9e8a		20 8d 93	jsr $938d	                jsr xt_tuck
.9e8d		20 2b 9e	jsr $9e2b	                jsr xt_dabs
.9e90		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9e93		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.9e96		20 91 8f	jsr $8f91	                jsr xt_rot
.9e99		20 50 91	jsr $9150	                jsr xt_sign
.9e9c		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.9e9f		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.9ea2		20 05 8d	jsr $8d05	                jsr xt_over
.9ea5		20 e4 8b	jsr $8be4	                jsr xt_minus
.9ea8		20 d1 91	jsr $91d1	                jsr xt_spaces
.9eab		20 c4 94	jsr $94c4	                jsr xt_type
.9eae		60		rts		z_d_dot_r:      rts
.9eaf						xt_two_constant:
.9eaf		20 7a d7	jsr $d77a	                jsr underflow_2
.9eb2		20 40 84	jsr $8440	                jsr xt_create
.9eb5		20 2e 92	jsr $922e	                jsr xt_swap
.9eb8		20 cd 83	jsr $83cd	                jsr xt_comma
.9ebb		20 cd 83	jsr $83cd	                jsr xt_comma
.9ebe		20 fe 85	jsr $85fe	                jsr does_runtime    ; does> turns into these two routines.
.9ec1		20 0a d6	jsr $d60a	                jsr dodoes
.9ec4		20 a0 86	jsr $86a0	                jsr xt_dup
.9ec7		20 1a 88	jsr $881a	                jsr xt_fetch
.9eca		20 2e 92	jsr $922e	                jsr xt_swap
.9ecd		20 43 83	jsr $8343	                jsr xt_cell_plus
.9ed0		20 1a 88	jsr $881a	                jsr xt_fetch
.9ed3		60		rts		z_two_constant: rts
.9ed4						xt_two_literal:
.9ed4		20 7a d7	jsr $d77a	                jsr underflow_2 ; double number
.9ed7		a9 0a		lda #$0a	                lda #template_push_tos_size
.9ed9		0a		asl a		                asl
.9eda		20 90 97	jsr $9790	                jsr check_nc_limit
.9edd		b0 09		bcs $9ee8	                bcs _no_inline
.9edf		20 2e 92	jsr $922e	                jsr xt_swap
.9ee2		20 f2 89	jsr $89f2	                jsr xt_literal
.9ee5		4c f2 89	jmp $89f2	                jmp xt_literal
.9ee8						_no_inline:
.9ee8		20 47 a1	jsr $a147	                jsr cmpl_two_literal
.9eeb		60		rts		z_two_literal:  rts
.9eec						xt_two_variable:
.9eec		20 40 84	jsr $8440	                jsr xt_create
.9eef		ca		dex		                dex
.9ef0		ca		dex		                dex
.9ef1		a9 04		lda #$04	                lda #4
.9ef3		95 00		sta $00,x	                sta 0,x
.9ef5		74 01		stz $01,x	                stz 1,x
.9ef7		20 27 82	jsr $8227	                jsr xt_allot
.9efa		60		rts		z_two_variable: rts
.9efb						xt_ud_dot:
.9efb		20 7a d7	jsr $d77a	                jsr underflow_2 ; double number
.9efe		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9f01		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.9f04		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.9f07		20 c4 94	jsr $94c4	                jsr xt_type
.9f0a		20 cb 91	jsr $91cb	                jsr xt_space
.9f0d		60		rts		z_ud_dot:        rts
.9f0e						xt_ud_dot_r:
.9f0e		20 7f d7	jsr $d77f	                jsr underflow_3
.9f11		20 6c 93	jsr $936c	                jsr xt_to_r
.9f14		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9f17		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s
.9f1a		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater
.9f1d		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.9f20		20 05 8d	jsr $8d05	                jsr xt_over
.9f23		20 e4 8b	jsr $8be4	                jsr xt_minus
.9f26		20 d1 91	jsr $91d1	                jsr xt_spaces
.9f29		20 c4 94	jsr $94c4	                jsr xt_type
.9f2c		60		rts		z_ud_dot_r:      rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/string.asm

.9f2d						xt_cmove:
.9f2d		20 7f d7	jsr $d77f	                jsr underflow_3
.9f30		b5 02		lda $02,x	                lda 2,x
.9f32		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9f34		b5 03		lda $03,x	                lda 3,x
.9f36		85 28		sta $28		                sta tmp2+1
.9f38		b5 04		lda $04,x	                lda 4,x
.9f3a		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9f3c		b5 05		lda $05,x	                lda 5,x
.9f3e		85 26		sta $26		                sta tmp1+1
.9f40		a0 00		ldy #$00	                ldy #0
.9f42		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.9f44		f0 0f		beq $9f55	                beq _dopartial
.9f46						_page:
.9f46		b1 25		lda ($25),y	                lda (tmp1),y
.9f48		91 27		sta ($27),y	                sta (tmp2),y
.9f4a		c8		iny		                iny
.9f4b		d0 f9		bne $9f46	                bne _page
.9f4d		e6 26		inc $26		                inc tmp1+1
.9f4f		e6 28		inc $28		                inc tmp2+1
.9f51		d6 01		dec $01,x	                dec 1,x
.9f53		d0 f1		bne $9f46	                bne _page
.9f55						_dopartial:
.9f55		b5 00		lda $00,x	                lda 0,x         ; length of last page
.9f57		f0 09		beq $9f62	                beq _done
.9f59						_partial:
.9f59		b1 25		lda ($25),y	                lda (tmp1),y
.9f5b		91 27		sta ($27),y	                sta (tmp2),y
.9f5d		c8		iny		                iny
.9f5e		d6 00		dec $00,x	                dec 0,x
.9f60		d0 f7		bne $9f59	                bne _partial
.9f62						_done:
.9f62		8a		txa		                txa
.9f63		18		clc		                clc
.9f64		69 06		adc #$06	                adc #6
.9f66		aa		tax		                tax
.9f67		60		rts		z_cmove:        rts
.9f68						xt_cmove_up:
.9f68		20 7f d7	jsr $d77f	                jsr underflow_3
.9f6b		b5 02		lda $02,x	                lda 2,x
.9f6d		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9f6f		b5 03		lda $03,x	                lda 3,x
.9f71		18		clc		                clc
.9f72		75 01		adc $01,x	                adc 1,x
.9f74		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.9f76		b5 04		lda $04,x	                lda 4,x
.9f78		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9f7a		b5 05		lda $05,x	                lda 5,x
.9f7c		18		clc		                clc
.9f7d		75 01		adc $01,x	                adc 1,x
.9f7f		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.9f81		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.9f83		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.9f85		f0 0e		beq $9f95	                beq _nopartial
.9f87						_outerloop:
.9f87		88		dey		                dey
.9f88		f0 07		beq $9f91	                beq _finishpage
.9f8a						_innerloop:
.9f8a		b1 25		lda ($25),y	                lda (tmp1),y
.9f8c		91 27		sta ($27),y	                sta (tmp2),y
.9f8e		88		dey		                dey
.9f8f		d0 f9		bne $9f8a	                bne _innerloop
.9f91						_finishpage:
.9f91		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.9f93		92 27		sta ($27)	                sta (tmp2)
.9f95						_nopartial:
.9f95		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.9f97		c6 28		dec $28		                dec tmp2+1
.9f99		d6 01		dec $01,x	                dec 1,x
.9f9b		d0 ea		bne $9f87	                bne _outerloop
.9f9d		8a		txa		                txa
.9f9e		18		clc		                clc
.9f9f		69 06		adc #$06	                adc #6
.9fa1		aa		tax		                tax
.9fa2		60		rts		z_cmove_up:     rts
.9fa3						xt_compare:
.9fa3		20 84 d7	jsr $d784	                jsr underflow_4
.9fa6		b5 02		lda $02,x	                lda 2,x
.9fa8		85 27		sta $27		                sta tmp2
.9faa		b5 03		lda $03,x	                lda 3,x
.9fac		85 28		sta $28		                sta tmp2+1
.9fae		b5 06		lda $06,x	                lda 6,x
.9fb0		85 25		sta $25		                sta tmp1
.9fb2		b5 07		lda $07,x	                lda 7,x
.9fb4		85 26		sta $26		                sta tmp1+1
.9fb6						_compare_loop:
.9fb6		b5 04		lda $04,x	                lda 4,x
.9fb8		15 05		ora $05,x	                ora 5,x
.9fba		f0 2c		beq $9fe8	                beq _str1_done
.9fbc		b5 00		lda $00,x	                lda 0,x
.9fbe		15 01		ora $01,x	                ora 1,x
.9fc0		f0 3a		beq $9ffc	                beq _greater    ; Str2 empty first
.9fc2		b2 25		lda ($25)	                lda (tmp1)
.9fc4		d2 27		cmp ($27)	                cmp (tmp2)
.9fc6		90 26		bcc $9fee	                bcc _less
.9fc8		d0 32		bne $9ffc	                bne _greater
.9fca		e6 25		inc $25		                inc tmp1
.9fcc		d0 02		bne $9fd0	                bne +
.9fce		e6 26		inc $26		                inc tmp1+1
.9fd0						+
.9fd0		e6 27		inc $27		                inc tmp2
.9fd2		d0 02		bne $9fd6	                bne +
.9fd4		e6 28		inc $28		                inc tmp2+1
.9fd6						+
.9fd6		b5 04		lda $04,x	                lda 4,x
.9fd8		d0 02		bne $9fdc	                bne +
.9fda		d6 05		dec $05,x	                dec 5,x
.9fdc						+
.9fdc		d6 04		dec $04,x	                dec 4,x
.9fde		b5 00		lda $00,x	                lda 0,x
.9fe0		d0 02		bne $9fe4	                bne +
.9fe2		d6 01		dec $01,x	                dec 1,x
.9fe4						+
.9fe4		d6 00		dec $00,x	                dec 0,x
.9fe6		80 ce		bra $9fb6	                bra _compare_loop
.9fe8						_str1_done:
.9fe8		b5 00		lda $00,x	                lda 0,x
.9fea		15 01		ora $01,x	                ora 1,x
.9fec		f0 08		beq $9ff6	                beq _equal      ; Both out of letters
.9fee						_less:
.9fee		a9 ff		lda #$ff	                lda #$FF
.9ff0		95 06		sta $06,x	                sta 6,x
.9ff2		95 07		sta $07,x	                sta 7,x
.9ff4		80 0c		bra $a002	                bra _done
.9ff6						_equal:
.9ff6		74 06		stz $06,x	                stz 6,x
.9ff8		74 07		stz $07,x	                stz 7,x
.9ffa		80 06		bra $a002	                bra _done
.9ffc						_greater:
.9ffc		a9 01		lda #$01	                lda #1
.9ffe		95 06		sta $06,x	                sta 6,x
.a000		74 07		stz $07,x	                stz 7,x
.a002						_done:
.a002		8a		txa		                txa
.a003		18		clc		                clc
.a004		69 06		adc #$06	                adc #6
.a006		aa		tax		                tax
.a007		60		rts		z_compare:      rts
.a008						xt_minus_leading:
.a008		20 7a d7	jsr $d77a	                jsr underflow_2
.a00b						_loop:
.a00b		b5 00		lda $00,x	                lda 0,x
.a00d		15 01		ora $01,x	                ora 1,x
.a00f		f0 0f		beq $a020	                beq _done
.a011		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.a013		20 68 d7	jsr $d768	                jsr is_whitespace
.a016		90 08		bcc $a020	                bcc _done
.a018		20 76 9d	jsr $9d76	                jsr xt_one              ; ( addr u 1 )
.a01b		20 fd a0	jsr $a0fd	                jsr xt_slash_string     ; ( addr+ u-1 )
.a01e		80 eb		bra $a00b	                bra _loop
.a020						_done:
.a020						z_minus_leading:
.a020		60		rts		                rts
.a021						xt_minus_trailing:
.a021		20 7a d7	jsr $d77a	                jsr underflow_2
.a024		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.a026		15 01		ora $01,x	                ora 1,x         ; MSB of n
.a028		f0 33		beq $a05d	                beq _done
.a02a		18		clc		                clc
.a02b		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.a02d		75 00		adc $00,x	                adc 0,x
.a02f		85 25		sta $25		                sta tmp1
.a031		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.a033		75 01		adc $01,x	                adc 1,x
.a035		85 26		sta $26		                sta tmp1+1
.a037		a5 25		lda $25		                lda tmp1
.a039		d0 02		bne $a03d	                bne +
.a03b		c6 26		dec $26		                dec tmp1+1
.a03d						+
.a03d		c6 25		dec $25		                dec tmp1
.a03f						_loop:
.a03f		b2 25		lda ($25)	                lda (tmp1)
.a041		c9 20		cmp #$20	                cmp #AscSP
.a043		d0 18		bne $a05d	                bne _done
.a045		a5 25		lda $25		                lda tmp1
.a047		d0 02		bne $a04b	                bne +
.a049		c6 26		dec $26		                dec tmp1+1
.a04b						+
.a04b		c6 25		dec $25		                dec tmp1
.a04d		b5 00		lda $00,x	                lda 0,x
.a04f		d0 02		bne $a053	                bne +
.a051		d6 01		dec $01,x	                dec 1,x
.a053						+
.a053		d6 00		dec $00,x	                dec 0,x
.a055		b5 00		lda $00,x	                lda 0,x
.a057		15 01		ora $01,x	                ora 1,x
.a059		f0 02		beq $a05d	                beq _done       ; Count has reached zero - we're done!
.a05b		80 e2		bra $a03f	                bra _loop
.a05d						_done:
.a05d						z_minus_trailing:
.a05d		60		rts		                rts
.a05e						xt_search:
.a05e		20 84 d7	jsr $d784	                jsr underflow_4
.a061		b5 00		lda $00,x	                lda 0,x
.a063		15 01		ora $01,x	                ora 1,x
.a065		d0 0b		bne $a072	                bne _start_search
.a067		e8		inx		                inx             ; Remove u2
.a068		e8		inx		                inx
.a069		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.a06b		95 00		sta $00,x	                sta 0,x
.a06d		95 01		sta $01,x	                sta 1,x
.a06f		4c fc a0	jmp $a0fc	                jmp z_search
.a072						_start_search:
.a072		20 dc 9d	jsr $9ddc	                jsr xt_zero
.a075						_search_loop:
.a075		18		clc		                clc
.a076		b5 00		lda $00,x	                lda 0,x
.a078		75 02		adc $02,x	                adc 2,x
.a07a		85 25		sta $25		                sta tmp1
.a07c		b5 01		lda $01,x	                lda 1,x
.a07e		75 03		adc $03,x	                adc 3,x
.a080		d5 07		cmp $07,x	                cmp 7,x
.a082		90 12		bcc $a096	                bcc _init_comparison ; Obviously less
.a084		d0 06		bne $a08c	                bne _not_found
.a086		b5 06		lda $06,x	                lda 6,x
.a088		c5 25		cmp $25		                cmp tmp1
.a08a		b0 0a		bcs $a096	                bcs _init_comparison
.a08c						_not_found:
.a08c		e8		inx		                inx             ; Remove offset
.a08d		e8		inx		                inx
.a08e		e8		inx		                inx             ; Remove u2
.a08f		e8		inx		                inx
.a090		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.a092		74 01		stz $01,x	                stz 1,x
.a094		80 66		bra $a0fc	                bra z_search
.a096						_init_comparison:
.a096		18		clc		                clc
.a097		b5 08		lda $08,x	                lda 8,x
.a099		75 00		adc $00,x	                adc 0,x
.a09b		85 25		sta $25		                sta tmp1
.a09d		b5 09		lda $09,x	                lda 9,x
.a09f		75 01		adc $01,x	                adc 1,x
.a0a1		85 26		sta $26		                sta tmp1+1
.a0a3		b5 04		lda $04,x	                lda 4,x
.a0a5		85 27		sta $27		                sta tmp2
.a0a7		b5 05		lda $05,x	                lda 5,x
.a0a9		85 28		sta $28		                sta tmp2+1
.a0ab		b5 02		lda $02,x	                lda 2,x
.a0ad		85 29		sta $29		                sta tmp3
.a0af		b5 03		lda $03,x	                lda 3,x
.a0b1		85 2a		sta $2a		                sta tmp3+1
.a0b3						_comparison_loop:
.a0b3		b2 25		lda ($25)	                lda (tmp1)
.a0b5		d2 27		cmp ($27)	                cmp (tmp2)
.a0b7		f0 05		beq $a0be	                beq _letters_match
.a0b9		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.a0bc		80 b7		bra $a075	                bra _search_loop
.a0be						_letters_match:
.a0be		e6 25		inc $25		                inc tmp1
.a0c0		d0 02		bne $a0c4	                bne +
.a0c2		e6 26		inc $26		                inc tmp1+1
.a0c4						+
.a0c4		e6 27		inc $27		                inc tmp2
.a0c6		d0 02		bne $a0ca	                bne +
.a0c8		e6 28		inc $28		                inc tmp2+1
.a0ca						+
.a0ca		a5 29		lda $29		                lda tmp3
.a0cc		d0 02		bne $a0d0	                bne +
.a0ce		c6 2a		dec $2a		                dec tmp3+1
.a0d0						+
.a0d0		c6 29		dec $29		                dec tmp3
.a0d2		a5 29		lda $29		                lda tmp3
.a0d4		05 2a		ora $2a		                ora tmp3+1
.a0d6		d0 db		bne $a0b3	                bne _comparison_loop ; Check the next letter
.a0d8		18		clc		                clc
.a0d9		b5 00		lda $00,x	                lda 0,x
.a0db		75 08		adc $08,x	                adc 8,x
.a0dd		95 08		sta $08,x	                sta 8,x
.a0df		b5 01		lda $01,x	                lda 1,x
.a0e1		75 09		adc $09,x	                adc 9,x
.a0e3		95 09		sta $09,x	                sta 9,x
.a0e5		38		sec		                sec
.a0e6		b5 06		lda $06,x	                lda 6,x
.a0e8		f5 00		sbc $00,x	                sbc 0,x
.a0ea		95 06		sta $06,x	                sta 6,x
.a0ec		b5 07		lda $07,x	                lda 7,x
.a0ee		f5 01		sbc $01,x	                sbc 1,x
.a0f0		95 07		sta $07,x	                sta 7,x
.a0f2		e8		inx		                inx             ; drop offset
.a0f3		e8		inx		                inx
.a0f4		e8		inx		                inx             ; drop u2
.a0f5		e8		inx		                inx
.a0f6		a9 ff		lda #$ff	                lda #$FF
.a0f8		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.a0fa		95 01		sta $01,x	                sta 1,x
.a0fc		60		rts		z_search:       rts
.a0fd						xt_slash_string:
.a0fd		20 7f d7	jsr $d77f	                jsr underflow_3
.a100		18		clc		                clc             ; 3OS+TOS
.a101		b5 00		lda $00,x	                lda 0,x
.a103		75 04		adc $04,x	                adc 4,x
.a105		95 04		sta $04,x	                sta 4,x
.a107		b5 01		lda $01,x	                lda 1,x
.a109		75 05		adc $05,x	                adc 5,x
.a10b		95 05		sta $05,x	                sta 5,x
.a10d		38		sec		                sec             ; NOS-TOS
.a10e		b5 02		lda $02,x	                lda 2,x
.a110		f5 00		sbc $00,x	                sbc 0,x
.a112		95 02		sta $02,x	                sta 2,x
.a114		b5 03		lda $03,x	                lda 3,x
.a116		f5 01		sbc $01,x	                sbc 1,x
.a118		95 03		sta $03,x	                sta 3,x
.a11a		e8		inx		                inx
.a11b		e8		inx		                inx
.a11c		60		rts		z_slash_string: rts
.a11d						xt_sliteral:
.a11d		20 7a d7	jsr $d77a	                jsr underflow_2
.a120		20 86 97	jsr $9786	                jsr cmpl_jump_later
.a123		20 6c 93	jsr $936c	                jsr xt_to_r
.a126		20 1b 89	jsr $891b	                jsr xt_here
.a129		20 2e 92	jsr $922e	                jsr xt_swap
.a12c		20 a0 86	jsr $86a0	                jsr xt_dup
.a12f		20 27 82	jsr $8227	                jsr xt_allot            ; reserve u bytes for string
.a132		20 1b 89	jsr $891b	                jsr xt_here
.a135		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.a138		20 18 92	jsr $9218	                jsr xt_store            ; point jmp past string
.a13b		20 af 93	jsr $93af	                jsr xt_two_dup
.a13e		20 a4 94	jsr $94a4	                jsr xt_two_to_r
.a141		20 00 8c	jsr $8c00	                jsr xt_move             ; copy u bytes from addr -> addr'
.a144		20 2a 94	jsr $942a	                jsr xt_two_r_from
.a147						cmpl_sliteral:
.a147						cmpl_two_literal:
.a147		a0 a1		ldy #$a1	                ldy #>sliteral_runtime
.a149		a9 61		lda #$61	                lda #<sliteral_runtime
.a14b		20 65 97	jsr $9765	                jsr cmpl_subroutine
.a14e		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a150		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a152		20 71 97	jsr $9771	                jsr cmpl_word
.a155		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a157		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a159		20 71 97	jsr $9771	                jsr cmpl_word
.a15c		e8		inx		                inx
.a15d		e8		inx		                inx
.a15e		e8		inx		                inx
.a15f		e8		inx		                inx
.a160		60		rts		z_sliteral:     rts
.a161						sliteral_runtime:
.a161		ca		dex		                dex
.a162		ca		dex		                dex
.a163		ca		dex		                dex
.a164		ca		dex		                dex
.a165		68		pla		                pla
.a166		85 25		sta $25		                sta tmp1        ; LSB of address
.a168		7a		ply		                ply
.a169		84 26		sty $26		                sty tmp1+1      ; MSB of address
.a16b		18		clc		                clc
.a16c		69 04		adc #$04	                adc #4
.a16e		90 01		bcc $a171	                bcc +
.a170		c8		iny		                iny
.a171						+
.a171		5a		phy		                phy
.a172		48		pha		                pha
.a173		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a175		b1 25		lda ($25),y	                lda (tmp1),y
.a177		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a179		c8		iny		                iny
.a17a		b1 25		lda ($25),y	                lda (tmp1),y
.a17c		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a17e		c8		iny		                iny
.a17f		b1 25		lda ($25),y	                lda (tmp1),y
.a181		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a183		c8		iny		                iny
.a184		b1 25		lda ($25),y	                lda (tmp1),y
.a186		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a188		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/disasm.asm

.a189						xt_disasm:
.a189		20 7a d7	jsr $d77a	                jsr underflow_2
.a18c		20 90 a1	jsr $a190	                jsr disassembler
.a18f		60		rts		z_disasm:       rts
.a190						disassembler:
.a190		64 32		stz $32		                stz scratch+5   ; flag indicating whether we're arriving at sliteral (vs 2literal)
.a192		20 3a 84	jsr $843a	                jsr xt_cr       ; ( addr u )
.a195						_byte_loop:
.a195		20 05 8d	jsr $8d05	                jsr xt_over     ; ( addr u addr )
.a198		20 ef 94	jsr $94ef	                jsr xt_u_dot    ; ( addr u )
.a19b		20 cb 91	jsr $91cb	                jsr xt_space
.a19e		a9 98		lda #$98	                lda #<oc_index_table
.a1a0		85 27		sta $27		                sta tmp2
.a1a2		a9 b3		lda #$b3	                lda #>oc_index_table
.a1a4		85 28		sta $28		                sta tmp2+1
.a1a6		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.a1a8		85 2d		sta $2d		                sta scratch     ; Save opcode
.a1aa		0a		asl a		                asl             ; multiply by two for offset
.a1ab		90 02		bcc $a1af	                bcc +
.a1ad		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.a1af						+
.a1af		a8		tay		                tay             ; use Y as the index
.a1b0		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a1b2		85 29		sta $29		                sta tmp3
.a1b4		48		pha		                pha
.a1b5		c8		iny		                iny
.a1b6		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a1b8		85 2a		sta $2a		                sta tmp3+1
.a1ba		48		pha		                pha
.a1bb		b2 29		lda ($29)	                lda (tmp3)
.a1bd		a8		tay		                tay                     ; save copy of lengths byte
.a1be		10 3c		bpl $a1fc	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.a1c0		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.a1c3		f6 04		inc $04,x	                inc 4,x
.a1c5		d0 02		bne $a1c9	                bne +
.a1c7		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.a1c9						+
.a1c9		b5 02		lda $02,x	                lda 2,x
.a1cb		d0 02		bne $a1cf	                bne +
.a1cd		d6 03		dec $03,x	                dec 3,x
.a1cf						+
.a1cf		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.a1d1		a1 04		lda ($04,x)	                lda (4,x)
.a1d3		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.a1d5		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.a1d7		98		tya		                tya                     ; retrieve copy of lengths byte
.a1d8		2a		rol a		                rol                     ; shift bit 6 to bit 7
.a1d9		10 14		bpl $a1ef	                bpl _print_operand
.a1db		f6 04		inc $04,x	                inc 4,x
.a1dd		d0 02		bne $a1e1	                bne +
.a1df		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.a1e1						+
.a1e1		b5 02		lda $02,x	                lda 2,x
.a1e3		d0 02		bne $a1e7	                bne +
.a1e5		d6 03		dec $03,x	                dec 3,x
.a1e7						+
.a1e7		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.a1e9		a1 04		lda ($04,x)	                lda (4,x)
.a1eb		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.a1ed		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.a1ef						_print_operand:
.a1ef		ca		dex		                dex
.a1f0		ca		dex		                dex
.a1f1		a9 05		lda #$05	                lda #5
.a1f3		95 00		sta $00,x	                sta 0,x
.a1f5		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.a1f7		20 fb 94	jsr $94fb	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.a1fa		80 0b		bra $a207	                bra _print_mnemonic
.a1fc						_no_operand:
.a1fc		ca		dex		                dex
.a1fd		ca		dex		                dex
.a1fe		a9 05		lda #$05	                lda #5
.a200		95 00		sta $00,x	                sta 0,x
.a202		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.a204		20 d1 91	jsr $91d1	                jsr xt_spaces           ; ( addr u )
.a207						_print_mnemonic:
.a207		20 cb 91	jsr $91cb	                jsr xt_space
.a20a		ca		dex		                dex
.a20b		ca		dex		                dex                     ; ( addr u ? )
.a20c		68		pla		                pla                     ; MSB
.a20d		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.a20f		68		pla		                pla                     ; LSB
.a210		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.a212		20 26 84	jsr $8426	                jsr xt_count            ; ( addr u addr-o u-o )
.a215		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a217		b5 00		lda $00,x	                lda 0,x
.a219		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.a21b		95 00		sta $00,x	                sta 0,x
.a21d		20 c4 94	jsr $94c4	                jsr xt_type             ; ( addr u )
.a220		a5 2d		lda $2d		                lda scratch
.a222		c9 20		cmp #$20	                cmp #OpJSR
.a224		d0 15		bne $a23b	                bne _not_jsr
.a226		ca		dex		                dex
.a227		ca		dex		                dex
.a228		a9 05		lda #$05	                lda #5
.a22a		95 00		sta $00,x	                sta 0,x
.a22c		74 01		stz $01,x	                stz 1,x
.a22e		20 d1 91	jsr $91d1	                jsr xt_spaces
.a231		20 0c a3	jsr $a30c	                jsr disasm_special
.a234		b0 70		bcs $a2a6	                bcs _printing_done
.a236		20 ec a2	jsr $a2ec	                jsr disasm_jsr
.a239		b0 6b		bcs $a2a6	                bcs _printing_done
.a23b						_not_jsr:
.a23b		c9 4c		cmp #$4c	                cmp #OpJMP
.a23d		d0 2d		bne $a26c	                bne _not_jmp
.a23f		a5 2e		lda $2e		                lda scratch+1   ; Copy the pointer.
.a241		85 30		sta $30		                sta scratch+3
.a243		a5 2f		lda $2f		                lda scratch+2
.a245		85 31		sta $31		                sta scratch+4
.a247		b2 30		lda ($30)	                lda (scratch+3)
.a249		c9 20		cmp #$20	                cmp #OpJSR          ; check for JSR
.a24b		d0 59		bne $a2a6	                bne _printing_done
.a24d		e6 30		inc $30		                inc scratch+3
.a24f		d0 02		bne $a253	                bne +
.a251		e6 31		inc $31		                inc scratch+4
.a253						+
.a253		b2 30		lda ($30)	                lda (scratch+3)
.a255		c9 61		cmp #$61	                cmp #<sliteral_runtime
.a257		d0 4d		bne $a2a6	                bne _printing_done
.a259		e6 30		inc $30		                inc scratch+3
.a25b		d0 02		bne $a25f	                bne +
.a25d		e6 31		inc $31		                inc scratch+4
.a25f						+
.a25f		b2 30		lda ($30)	                lda (scratch+3)
.a261		c9 a1		cmp #$a1	                cmp #>sliteral_runtime
.a263		d0 41		bne $a2a6	                bne _printing_done
.a265		c6 32		dec $32		                dec scratch+5                   ; flag for next go round
.a267		20 c2 a2	jsr $a2c2	                jsr disasm_sliteral_jump
.a26a		80 3a		bra $a2a6	                bra _printing_done
.a26c						_not_jmp:
.a26c		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.a26e		f0 06		beq $a276	                beq _is_rel
.a270		29 1f		and #$1f	                and #$1F
.a272		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.a274		d0 30		bne $a2a6	                bne _printing_done
.a276						_is_rel:
.a276		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.a278		ca		dex		                dex
.a279		ca		dex		                dex
.a27a		74 01		stz $01,x	                stz 1,x
.a27c		a5 2e		lda $2e		                lda scratch+1
.a27e		95 00		sta $00,x	                sta 0,x
.a280		10 04		bpl $a286	                bpl +
.a282		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.a284		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.a286		38		sec		+               sec                 ; start counting from address after opcode
.a287		75 04		adc $04,x	                adc 4,x
.a289		95 00		sta $00,x	                sta 0,x
.a28b		b5 01		lda $01,x	                lda 1,x
.a28d		75 05		adc $05,x	                adc 5,x
.a28f		95 01		sta $01,x	                sta 1,x
.a291		5a		phy		                phy                 ; save the direction indicator
.a292		ca		dex		                dex
.a293		ca		dex		                dex
.a294		a9 09		lda #$09	                lda #9
.a296		95 00		sta $00,x	                sta 0,x
.a298		74 01		stz $01,x	                stz 1,x
.a29a		20 fb 94	jsr $94fb	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.a29d		a9 20		lda #$20	                lda #AscSP          ; print space and branch direction indicator
.a29f		20 c5 86	jsr $86c5	                jsr emit_a
.a2a2		68		pla		                pla
.a2a3		20 c5 86	jsr $86c5	                jsr emit_a
.a2a6						_printing_done:
.a2a6		20 3a 84	jsr $843a	                jsr xt_cr
.a2a9		f6 02		inc $02,x	                inc 2,x
.a2ab		d0 02		bne $a2af	                bne +
.a2ad		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.a2af						+
.a2af		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; ( addr+1 u-1 )
.a2b2		b5 00		lda $00,x	                lda 0,x                 ; All done?
.a2b4		15 01		ora $01,x	                ora 1,x
.a2b6		f0 07		beq $a2bf	                beq _done
.a2b8		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.a2ba		30 03		bmi $a2bf	                bmi _done
.a2bc		4c 95 a1	jmp $a195	                jmp _byte_loop          ; out of range for BRA
.a2bf						_done:
.a2bf		4c a7 93	jmp $93a7	                jmp xt_two_drop         ; JSR/RTS
.a2c2						disasm_sliteral_jump:
.a2c2		20 2e 92	jsr $922e	                jsr xt_swap
.a2c5		ca		dex		                dex
.a2c6		ca		dex		                dex
.a2c7		a5 2e		lda $2e		                lda scratch+1
.a2c9		95 00		sta $00,x	                sta 0,x
.a2cb		a5 2f		lda $2f		                lda scratch+2
.a2cd		95 01		sta $01,x	                sta 1,x
.a2cf		20 2e 92	jsr $922e	                jsr xt_swap
.a2d2		20 e4 8b	jsr $8be4	                jsr xt_minus
.a2d5		20 dd 8c	jsr $8cdd	                jsr xt_one_minus
.a2d8		20 e4 8b	jsr $8be4	                jsr xt_minus
.a2db		ca		dex		                dex
.a2dc		ca		dex		                dex
.a2dd		a5 2e		lda $2e		                lda scratch+1
.a2df		95 00		sta $00,x	                sta 0,x
.a2e1		a5 2f		lda $2f		                lda scratch+2
.a2e3		95 01		sta $01,x	                sta 1,x
.a2e5		20 dd 8c	jsr $8cdd	                jsr xt_one_minus
.a2e8		20 2e 92	jsr $922e	                jsr xt_swap ; ( new_addr new_n )
.a2eb		60		rts		                rts
.a2ec						disasm_jsr:
.a2ec		ca		dex		                dex
.a2ed		ca		dex		                dex
.a2ee		a5 2e		lda $2e		                lda scratch+1
.a2f0		95 00		sta $00,x	                sta 0,x
.a2f2		a5 2f		lda $2f		                lda scratch+2
.a2f4		95 01		sta $01,x	                sta 1,x
.a2f6		20 93 9b	jsr $9b93	                jsr xt_int_to_name
.a2f9		b5 00		lda $00,x	                lda 0,x
.a2fb		15 01		ora $01,x	                ora 1,x
.a2fd		f0 08		beq $a307	                beq _no_nt
.a2ff		20 36 9c	jsr $9c36	                jsr xt_name_to_string
.a302		20 c4 94	jsr $94c4	                jsr xt_type
.a305		38		sec		                sec
.a306		60		rts		                rts
.a307						_no_nt:
.a307		20 a7 93	jsr $93a7	                jsr xt_two_drop
.a30a		18		clc		                clc
.a30b		60		rts		                rts
.a30c						disasm_special:
.a30c		a0 2c		ldy #$2c	                ldy #(_end_handlers - _special_handlers - 4)
.a30e		b9 9a a3	lda $a39a,y	_check:         lda _special_handlers,y
.a311		c5 2e		cmp $2e		                cmp scratch+1
.a313		d0 07		bne $a31c	                bne _next
.a315		b9 9b a3	lda $a39b,y	                lda _special_handlers+1,y
.a318		c5 2f		cmp $2f		                cmp scratch+2
.a31a		f0 08		beq $a324	                beq _found_handler
.a31c		88		dey		_next:          dey
.a31d		88		dey		                dey
.a31e		88		dey		                dey
.a31f		88		dey		                dey
.a320		10 ec		bpl $a30e	                bpl _check
.a322		18		clc		                clc
.a323		60		rts		                rts
.a324						_found_handler:
.a324		a5 32		lda $32		                lda scratch+5               ; are we expecting sliteral?
.a326		f0 04		beq $a32c	                beq +
.a328		64 32		stz $32		                stz scratch+5               ; yes, skip 2literal and match again
.a32a		80 f0		bra $a31c	                bra _next
.a32c						+
.a32c		b9 9d a3	lda $a39d,y	                lda _special_handlers+3,y   ; payload + prefix
.a32f		48		pha		                pha                         ; stash a copy for payload later
.a330		4a		lsr a		                lsr
.a331		4a		lsr a		                lsr
.a332		f0 06		beq $a33a	                beq _no_prefix
.a334		18		clc		                clc
.a335		69 20		adc #$20	                adc #32
.a337		20 c5 86	jsr $86c5	                jsr emit_a
.a33a						_no_prefix:
.a33a		b9 9c a3	lda $a39c,y	                lda _special_handlers+2,y   ; string index
.a33d		20 b1 d7	jsr $d7b1	                jsr print_string_no_lf
.a340		68		pla		                pla
.a341		29 03		and #$03	                and #3                      ; payload is 0, 1 or 2 words
.a343		f0 0f		beq $a354	                beq _done
.a345		c9 03		cmp #$03	                cmp #3                      ; but 3 means a double-word
.a347		d0 03		bne $a34c	                bne _show_payload
.a349		4c 6e a3	jmp $a36e	                jmp _print_2literal
.a34c						_show_payload:
.a34c		48		pha		                pha
.a34d		20 56 a3	jsr $a356	                jsr _print_literal
.a350		68		pla		                pla
.a351		3a		dec a		                dea
.a352		d0 f8		bne $a34c	                bne _show_payload
.a354		38		sec		_done:          sec
.a355		60		rts		                rts
.a356						_print_literal:
.a356		20 2e 92	jsr $922e	                jsr xt_swap ; switch to (u addr)
.a359		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.a35c		20 a0 86	jsr $86a0	                jsr xt_dup
.a35f		20 07 99	jsr $9907	                jsr xt_question ; Print the value at the address
.a362		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.a365		20 2e 92	jsr $922e	                jsr xt_swap ; (addr+2 u)
.a368		20 dd 8c	jsr $8cdd	                jsr xt_one_minus
.a36b		4c dd 8c	jmp $8cdd	                jmp xt_one_minus ; (addr+2 u-2)
.a36e						_print_2literal:
.a36e		20 2e 92	jsr $922e	                jsr xt_swap
.a371		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.a374		20 a0 86	jsr $86a0	                jsr xt_dup
.a377		20 c7 93	jsr $93c7	                jsr xt_two_fetch
.a37a		20 2e 92	jsr $922e	                jsr xt_swap             ; 2! / 2@ put MSW first; but 2literal writes LSW first
.a37d		20 65 9e	jsr $9e65	                jsr xt_d_dot
.a380		18		clc		                clc
.a381		b5 00		lda $00,x	                lda 0,x
.a383		69 03		adc #$03	                adc #3
.a385		95 00		sta $00,x	                sta 0,x
.a387		90 02		bcc $a38b	                bcc +
.a389		f6 01		inc $01,x	                inc 1,x
.a38b						+
.a38b		20 2e 92	jsr $922e	                jsr xt_swap ; ( addr+4 u )
.a38e		38		sec		                sec
.a38f		b5 00		lda $00,x	                lda 0,x
.a391		e9 04		sbc #$04	                sbc #4
.a393		95 00		sta $00,x	                sta 0,x
.a395		b0 02		bcs $a399	                bcs +
.a397		d6 01		dec $01,x	                dec 1,x
.a399						+
.a399		60		rts		                rts
.a39a						_special_handlers:
>a39a		75 d7				    .word underflow_1
>a39c		0c 44				        .byte str_disasm_sdc, 0 + ('1'-32)*4
>a39e		7a d7				    .word underflow_2
>a3a0		0c 48				        .byte str_disasm_sdc, 0 + ('2'-32)*4
>a3a2		7f d7				    .word underflow_3
>a3a4		0c 4c				        .byte str_disasm_sdc, 0 + ('3'-32)*4
>a3a6		84 d7				    .word underflow_4
>a3a8		0c 50				        .byte str_disasm_sdc, 0 + ('4'-32)*4
>a3aa		3a 8a				    .word literal_runtime
>a3ac		0d 01				        .byte str_disasm_lit, 1
>a3ae		61 a1				    .word sliteral_runtime
>a3b0		0d ce				        .byte str_disasm_lit, 2 + ('S'-32)*4
>a3b2		61 a1				    .word sliteral_runtime                      ; 2literal and sliteral use the same runtime
>a3b4		0d 4b				        .byte str_disasm_lit, 3 + ('2'-32)*4    ; list is searched in reverse, put 2literal first
>a3b6		19 98				    .word zero_branch_runtime
>a3b8		0e 01				        .byte str_disasm_0bra, 1
>a3ba		d2 8a				    .word loop_runtime
>a3bc		0f 01				        .byte str_disasm_loop, 1
>a3be		eb 8a				    .word plus_loop_runtime
>a3c0		0f 2d				        .byte str_disasm_loop, 1 + ('+'-32)*4
>a3c2		bc 85				    .word do_runtime
>a3c4		10 00				        .byte str_disasm_do, 0
>a3c6		a4 85				    .word question_do_runtime
>a3c8		10 7d				        .byte str_disasm_do, 1 + ('?'-32)*4
.a3ca						_end_handlers:
.a3ca						disassembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/assembler.asm

.a3ca						assembler:
.a3ca						xt_asm_adc_h:
.a3ca		a9 69		lda #$69	                lda #$69
.a3cc		4c 25 a7	jmp $a725	                jmp asm_common
.a3cf						z_asm_adc_h:
.a3cf						xt_asm_adc_x:
.a3cf		a9 7d		lda #$7d	                lda #$7D
.a3d1		4c 25 a7	jmp $a725	                jmp asm_common
.a3d4						z_asm_adc_x:
.a3d4						xt_asm_adc_y:
.a3d4		a9 79		lda #$79	                lda #$79
.a3d6		4c 25 a7	jmp $a725	                jmp asm_common
.a3d9						z_asm_adc_y:
.a3d9						xt_asm_adc_z:
.a3d9		a9 65		lda #$65	                lda #$65
.a3db		4c 25 a7	jmp $a725	                jmp asm_common
.a3de						z_asm_adc_z:
.a3de						xt_asm_adc_zi:
.a3de		a9 72		lda #$72	                lda #$72
.a3e0		4c 25 a7	jmp $a725	                jmp asm_common
.a3e3						z_asm_adc_zi:
.a3e3						xt_asm_adc_ziy:
.a3e3		a9 71		lda #$71	                lda #$71
.a3e5		4c 25 a7	jmp $a725	                jmp asm_common
.a3e8						z_asm_adc_ziy:
.a3e8						xt_asm_adc_zx:
.a3e8		a9 75		lda #$75	                lda #$75
.a3ea		4c 25 a7	jmp $a725	                jmp asm_common
.a3ed						z_asm_adc_zx:
.a3ed						xt_asm_adc_zxi:
.a3ed		a9 61		lda #$61	                lda #$61
.a3ef		4c 25 a7	jmp $a725	                jmp asm_common
.a3f2						z_asm_adc_zxi:
.a3f2						xt_asm_and:
.a3f2		a9 2d		lda #$2d	                lda #$2D
.a3f4		4c 25 a7	jmp $a725	                jmp asm_common
.a3f7						z_asm_and:
.a3f7						xt_asm_and_h:
.a3f7		a9 29		lda #$29	                lda #$29
.a3f9		4c 25 a7	jmp $a725	                jmp asm_common
.a3fc						z_asm_and_h:
.a3fc						xt_asm_and_x:
.a3fc		a9 3d		lda #$3d	                lda #$3D
.a3fe		4c 25 a7	jmp $a725	                jmp asm_common
.a401						z_asm_and_x:
.a401						xt_asm_and_y:
.a401		a9 39		lda #$39	                lda #$39
.a403		4c 25 a7	jmp $a725	                jmp asm_common
.a406						z_asm_and_y:
.a406						xt_asm_and_z:
.a406		a9 25		lda #$25	                lda #$25
.a408		4c 25 a7	jmp $a725	                jmp asm_common
.a40b						z_asm_and_z:
.a40b						xt_asm_and_zi:
.a40b		a9 32		lda #$32	                lda #$32
.a40d		4c 25 a7	jmp $a725	                jmp asm_common
.a410						z_asm_and_zi:
.a410						xt_asm_and_ziy:
.a410		a9 31		lda #$31	                lda #$31
.a412		4c 25 a7	jmp $a725	                jmp asm_common
.a415						z_asm_and_ziy:
.a415						xt_asm_and_zx:
.a415		a9 35		lda #$35	                lda #$35
.a417		4c 25 a7	jmp $a725	                jmp asm_common
.a41a						z_asm_and_zx:
.a41a						xt_asm_and_zxi:
.a41a		a9 21		lda #$21	                lda #$21
.a41c		4c 25 a7	jmp $a725	                jmp asm_common
.a41f						z_asm_and_zxi:
.a41f						xt_asm_asl:
.a41f		a9 0e		lda #$0e	                lda #$0E
.a421		4c 25 a7	jmp $a725	                jmp asm_common
.a424						z_asm_asl:
.a424						xt_asm_asl_a:
.a424		a9 0a		lda #$0a	                lda #$0A
.a426		4c 25 a7	jmp $a725	                jmp asm_common
.a429						z_asm_asl_a:
.a429						xt_asm_asl_x:
.a429		a9 1e		lda #$1e	                lda #$1E
.a42b		4c 25 a7	jmp $a725	                jmp asm_common
.a42e						z_asm_asl_x:
.a42e						xt_asm_asl_z:
.a42e		a9 06		lda #$06	                lda #$06
.a430		4c 25 a7	jmp $a725	                jmp asm_common
.a433						z_asm_asl_z:
.a433						xt_asm_asl_zx:
.a433		a9 16		lda #$16	                lda #$16
.a435		4c 25 a7	jmp $a725	                jmp asm_common
.a438						z_asm_asl_zx:
.a438						xt_asm_bcc:
.a438		a9 90		lda #$90	                lda #$90
.a43a		4c 25 a7	jmp $a725	                jmp asm_common
.a43d						z_asm_bcc:
.a43d						xt_asm_bcs:
.a43d		a9 b0		lda #$b0	                lda #$B0
.a43f		a0 02		ldy #$02	                ldy #2
.a441		4c 25 a7	jmp $a725	                jmp asm_common
.a444						z_asm_bcs:
.a444						xt_asm_beq:
.a444		a9 f0		lda #$f0	                lda #$F0
.a446		4c 25 a7	jmp $a725	                jmp asm_common
.a449						z_asm_beq:
.a449						xt_asm_bit:
.a449		a9 2c		lda #$2c	                lda #$2C
.a44b		4c 25 a7	jmp $a725	                jmp asm_common
.a44e						z_asm_bit:
.a44e						xt_asm_bit_h:
.a44e		a9 89		lda #$89	                lda #$89
.a450		4c 25 a7	jmp $a725	                jmp asm_common
.a453						z_asm_bit_h:
.a453						xt_asm_bit_x:
.a453		a9 3c		lda #$3c	                lda #$3C
.a455		4c 25 a7	jmp $a725	                jmp asm_common
.a458						z_asm_bit_x:
.a458						xt_asm_bit_z:
.a458		a9 24		lda #$24	                lda #$24
.a45a		4c 25 a7	jmp $a725	                jmp asm_common
.a45d						z_asm_bit_z:
.a45d						xt_asm_bit_zx:
.a45d		a9 34		lda #$34	                lda #$34
.a45f		4c 25 a7	jmp $a725	                jmp asm_common
.a462						z_asm_bit_zx:
.a462						xt_asm_bmi:
.a462		a9 30		lda #$30	                lda #$30
.a464		4c 25 a7	jmp $a725	                jmp asm_common
.a467						z_asm_bmi:
.a467						xt_asm_bne:
.a467		a9 d0		lda #$d0	                lda #$D0
.a469		4c 25 a7	jmp $a725	                jmp asm_common
.a46c						z_asm_bne:
.a46c						xt_asm_bpl:
.a46c		a9 10		lda #$10	                lda #$10
.a46e		4c 25 a7	jmp $a725	                jmp asm_common
.a471						z_asm_bpl:
.a471						xt_asm_bra:
.a471		a9 80		lda #$80	                lda #$80
.a473		4c 25 a7	jmp $a725	                jmp asm_common
.a476						z_asm_bra:
.a476						xt_asm_brk:
.a476		a9 00		lda #$00	                lda #$00
.a478		4c 25 a7	jmp $a725	                jmp asm_common
.a47b						z_asm_brk:
.a47b						xt_asm_bvc:
.a47b		a9 50		lda #$50	                lda #$50
.a47d		4c 25 a7	jmp $a725	                jmp asm_common
.a480						z_asm_bvc:
.a480						xt_asm_bvs:
.a480		a9 70		lda #$70	                lda #$70
.a482		4c 25 a7	jmp $a725	                jmp asm_common
.a485						z_asm_bvs:
.a485						xt_asm_clc:
.a485		a9 18		lda #$18	                lda #$18
.a487		4c 25 a7	jmp $a725	                jmp asm_common
.a48a						z_asm_clc:
.a48a						xt_asm_cld:
.a48a		a9 d8		lda #$d8	                lda #$D8
.a48c		4c 25 a7	jmp $a725	                jmp asm_common
.a48f						z_asm_cld:
.a48f						xt_asm_cli:
.a48f		a9 58		lda #$58	                lda #$58
.a491		4c 25 a7	jmp $a725	                jmp asm_common
.a494						z_asm_cli:
.a494						xt_asm_clv:
.a494		a9 b8		lda #$b8	                lda #$B8
.a496		4c 25 a7	jmp $a725	                jmp asm_common
.a499						z_asm_clv:
.a499						xt_asm_cmp:
.a499		a9 cd		lda #$cd	                lda #$CD
.a49b		4c 25 a7	jmp $a725	                jmp asm_common
.a49e						z_asm_cmp:
.a49e						xt_asm_cmp_h:
.a49e		a9 c9		lda #$c9	                lda #$C9
.a4a0		4c 25 a7	jmp $a725	                jmp asm_common
.a4a3						z_asm_cmp_h:
.a4a3						xt_asm_cmp_x:
.a4a3		a9 dd		lda #$dd	                lda #$DD
.a4a5		4c 25 a7	jmp $a725	                jmp asm_common
.a4a8						z_asm_cmp_x:
.a4a8						xt_asm_cmp_y:
.a4a8		a9 d9		lda #$d9	                lda #$D9
.a4aa		4c 25 a7	jmp $a725	                jmp asm_common
.a4ad						z_asm_cmp_y:
.a4ad						xt_asm_cmp_z:
.a4ad		a9 c5		lda #$c5	                lda #$C5
.a4af		4c 25 a7	jmp $a725	                jmp asm_common
.a4b2						z_asm_cmp_z:
.a4b2						xt_asm_cmp_zi:
.a4b2		a9 d2		lda #$d2	                lda #$D2
.a4b4		4c 25 a7	jmp $a725	                jmp asm_common
.a4b7						z_asm_cmp_zi:
.a4b7						xt_asm_cmp_ziy:
.a4b7		a9 d1		lda #$d1	                lda #$D1
.a4b9		4c 25 a7	jmp $a725	                jmp asm_common
.a4bc						z_asm_cmp_ziy:
.a4bc						xt_asm_cmp_zx:
.a4bc		a9 d5		lda #$d5	                lda #$D5
.a4be		4c 25 a7	jmp $a725	                jmp asm_common
.a4c1						z_asm_cmp_zx:
.a4c1						xt_asm_cmp_zxi:
.a4c1		a9 c1		lda #$c1	                lda #$C1
.a4c3		4c 25 a7	jmp $a725	                jmp asm_common
.a4c6						z_asm_cmp_zxi:
.a4c6						xt_asm_cpx:
.a4c6		a9 ec		lda #$ec	                lda #$EC
.a4c8		4c 25 a7	jmp $a725	                jmp asm_common
.a4cb						z_asm_cpx:
.a4cb						xt_asm_cpx_h:
.a4cb		a9 e0		lda #$e0	                lda #$E0
.a4cd		4c 25 a7	jmp $a725	                jmp asm_common
.a4d0						z_asm_cpx_h:
.a4d0						xt_asm_cpx_z:
.a4d0		a9 e4		lda #$e4	                lda #$E4
.a4d2		4c 25 a7	jmp $a725	                jmp asm_common
.a4d5						z_asm_cpx_z:
.a4d5						xt_asm_cpy:
.a4d5		a9 cc		lda #$cc	                lda #$CC
.a4d7		a0 03		ldy #$03	                ldy #3
.a4d9		4c 25 a7	jmp $a725	                jmp asm_common
.a4dc						z_asm_cpy:
.a4dc						xt_asm_cpy_h:
.a4dc		a9 c0		lda #$c0	                lda #$C0
.a4de		4c 25 a7	jmp $a725	                jmp asm_common
.a4e1						z_asm_cpy_h:
.a4e1						xt_asm_cpy_z:
.a4e1		a9 c4		lda #$c4	                lda #$C4
.a4e3		4c 25 a7	jmp $a725	                jmp asm_common
.a4e6						z_asm_cpy_z:
.a4e6						xt_asm_dec:
.a4e6		a9 ce		lda #$ce	                lda #$CE
.a4e8		4c 25 a7	jmp $a725	                jmp asm_common
.a4eb						z_asm_dec:
.a4eb						xt_asm_dec_a:
.a4eb		a9 3a		lda #$3a	                lda #$3A
.a4ed		4c 25 a7	jmp $a725	                jmp asm_common
.a4f0						z_asm_dec_a:
.a4f0						xt_asm_dec_x:
.a4f0		a9 de		lda #$de	                lda #$DE
.a4f2		4c 25 a7	jmp $a725	                jmp asm_common
.a4f5						z_asm_dec_x:
.a4f5						xt_asm_dec_z:
.a4f5		a9 c6		lda #$c6	                lda #$C6
.a4f7		4c 25 a7	jmp $a725	                jmp asm_common
.a4fa						z_asm_dec_z:
.a4fa						xt_asm_dec_zx:
.a4fa		a9 d6		lda #$d6	                lda #$D6
.a4fc		4c 25 a7	jmp $a725	                jmp asm_common
.a4ff						z_asm_dec_zx:
.a4ff						xt_asm_dex:
.a4ff		a9 ca		lda #$ca	                lda #$CA
.a501		4c 25 a7	jmp $a725	                jmp asm_common
.a504						z_asm_dex:
.a504						xt_asm_dey:
.a504		a9 88		lda #$88	                lda #$88
.a506		4c 25 a7	jmp $a725	                jmp asm_common
.a509						z_asm_dey:
.a509						xt_asm_eor:
.a509		a9 4d		lda #$4d	                lda #$4D
.a50b		4c 25 a7	jmp $a725	                jmp asm_common
.a50e						z_asm_eor:
.a50e						xt_asm_eor_h:
.a50e		a9 49		lda #$49	                lda #$49
.a510		4c 25 a7	jmp $a725	                jmp asm_common
.a513						z_asm_eor_h:
.a513						xt_asm_eor_x:
.a513		a9 5d		lda #$5d	                lda #$5D
.a515		4c 25 a7	jmp $a725	                jmp asm_common
.a518						z_asm_eor_x:
.a518						xt_asm_eor_y:
.a518		a9 59		lda #$59	                lda #$59
.a51a		4c 25 a7	jmp $a725	                jmp asm_common
.a51d						z_asm_eor_y:
.a51d						xt_asm_eor_z:
.a51d		a9 45		lda #$45	                lda #$45
.a51f		4c 25 a7	jmp $a725	                jmp asm_common
.a522						z_asm_eor_z:
.a522						xt_asm_eor_zi:
.a522		a9 52		lda #$52	                lda #$52
.a524		4c 25 a7	jmp $a725	                jmp asm_common
.a527						z_asm_eor_zi:
.a527						xt_asm_eor_ziy:
.a527		a9 51		lda #$51	                lda #$51
.a529		4c 25 a7	jmp $a725	                jmp asm_common
.a52c						z_asm_eor_ziy:
.a52c						xt_asm_eor_zx:
.a52c		a9 55		lda #$55	                lda #$55
.a52e		4c 25 a7	jmp $a725	                jmp asm_common
.a531						z_asm_eor_zx:
.a531						xt_asm_eor_zxi:
.a531		a9 41		lda #$41	                lda #$41
.a533		4c 25 a7	jmp $a725	                jmp asm_common
.a536						z_asm_eor_zxi:
.a536						xt_asm_inc:
.a536		a9 ee		lda #$ee	                lda #$EE
.a538		4c 25 a7	jmp $a725	                jmp asm_common
.a53b						z_asm_inc:
.a53b						xt_asm_inc_a:
.a53b		a9 1a		lda #$1a	                lda #$1A
.a53d		4c 25 a7	jmp $a725	                jmp asm_common
.a540						z_asm_inc_a:
.a540						xt_asm_inc_x:
.a540		a9 fe		lda #$fe	                lda #$FE
.a542		4c 25 a7	jmp $a725	                jmp asm_common
.a545						z_asm_inc_x:
.a545						xt_asm_inc_z:
.a545		a9 e6		lda #$e6	                lda #$E6
.a547		4c 25 a7	jmp $a725	                jmp asm_common
.a54a						z_asm_inc_z:
.a54a						xt_asm_inc_zx:
.a54a		a9 f6		lda #$f6	                lda #$F6
.a54c		4c 25 a7	jmp $a725	                jmp asm_common
.a54f						z_asm_inc_zx:
.a54f						xt_asm_inx:
.a54f		a9 e8		lda #$e8	                lda #$E8
.a551		4c 25 a7	jmp $a725	                jmp asm_common
.a554						z_asm_inx:
.a554						xt_asm_iny:
.a554		a9 c8		lda #$c8	                lda #$C8
.a556		4c 25 a7	jmp $a725	                jmp asm_common
.a559						z_asm_iny:
.a559						xt_asm_jmp:
.a559		a9 4c		lda #$4c	                lda #$4C
.a55b		4c 25 a7	jmp $a725	                jmp asm_common
.a55e						z_asm_jmp:
.a55e						xt_asm_jmp_i:
.a55e		a9 6c		lda #$6c	                lda #$6C
.a560		4c 25 a7	jmp $a725	                jmp asm_common
.a563						z_asm_jmp_i:
.a563						xt_asm_jmp_xi:
.a563		a9 7c		lda #$7c	                lda #$7C
.a565		4c 25 a7	jmp $a725	                jmp asm_common
.a568						z_asm_jmp_xi:
.a568						xt_asm_jsr:
.a568		a9 20		lda #$20	                lda #$20
.a56a		4c 25 a7	jmp $a725	                jmp asm_common
.a56d						z_asm_jsr:
.a56d						xt_asm_lda:
.a56d		a9 ad		lda #$ad	                lda #$AD
.a56f		4c 25 a7	jmp $a725	                jmp asm_common
.a572						z_asm_lda:
.a572						xt_asm_lda_h:
.a572		a9 a9		lda #$a9	                lda #$A9
.a574		4c 25 a7	jmp $a725	                jmp asm_common
.a577						z_asm_lda_h:
.a577						xt_asm_lda_x:
.a577		a9 bd		lda #$bd	                lda #$BD
.a579		4c 25 a7	jmp $a725	                jmp asm_common
.a57c						z_asm_lda_x:
.a57c						xt_asm_lda_y:
.a57c		a9 b9		lda #$b9	                lda #$B9
.a57e		4c 25 a7	jmp $a725	                jmp asm_common
.a581						z_asm_lda_y:
.a581						xt_asm_lda_z:
.a581		a9 a5		lda #$a5	                lda #$A5
.a583		4c 25 a7	jmp $a725	                jmp asm_common
.a586						z_asm_lda_z:
.a586						xt_asm_lda_zi:
.a586		a9 b2		lda #$b2	                lda #$B2
.a588		4c 25 a7	jmp $a725	                jmp asm_common
.a58b						z_asm_lda_zi:
.a58b						xt_asm_lda_ziy:
.a58b		a9 b1		lda #$b1	                lda #$B1
.a58d		4c 25 a7	jmp $a725	                jmp asm_common
.a590						z_asm_lda_ziy:
.a590						xt_asm_lda_zx:
.a590		a9 b5		lda #$b5	                lda #$B5
.a592		4c 25 a7	jmp $a725	                jmp asm_common
.a595						z_asm_lda_zx:
.a595						xt_asm_lda_zxi:
.a595		a9 a1		lda #$a1	                lda #$A1
.a597		4c 25 a7	jmp $a725	                jmp asm_common
.a59a						z_asm_lda_zxi:
.a59a						xt_asm_ldx:
.a59a		a9 ae		lda #$ae	                lda #$AE
.a59c		4c 25 a7	jmp $a725	                jmp asm_common
.a59f						z_asm_ldx:
.a59f						xt_asm_ldx_h:
.a59f		a9 a2		lda #$a2	                lda #$A2
.a5a1		4c 25 a7	jmp $a725	                jmp asm_common
.a5a4						z_asm_ldx_h:
.a5a4						xt_asm_ldx_y:
.a5a4		a9 be		lda #$be	                lda #$BE
.a5a6		4c 25 a7	jmp $a725	                jmp asm_common
.a5a9						z_asm_ldx_y:
.a5a9						xt_asm_ldx_z:
.a5a9		a9 a6		lda #$a6	                lda #$A6
.a5ab		4c 25 a7	jmp $a725	                jmp asm_common
.a5ae						z_asm_ldx_z:
.a5ae						xt_asm_ldx_zy:
.a5ae		a9 b6		lda #$b6	                lda #$B6
.a5b0		4c 25 a7	jmp $a725	                jmp asm_common
.a5b3						z_asm_ldx_zy:
.a5b3						xt_asm_ldy:
.a5b3		a9 ac		lda #$ac	                lda #$AC
.a5b5		4c 25 a7	jmp $a725	                jmp asm_common
.a5b8						z_asm_ldy:
.a5b8						xt_asm_ldy_h:
.a5b8		a9 a0		lda #$a0	                lda #$A0
.a5ba		4c 25 a7	jmp $a725	                jmp asm_common
.a5bd						z_asm_ldy_h:
.a5bd						xt_asm_ldy_x:
.a5bd		a9 bc		lda #$bc	                lda #$BC
.a5bf		4c 25 a7	jmp $a725	                jmp asm_common
.a5c2						z_asm_ldy_x:
.a5c2						xt_asm_ldy_z:
.a5c2		a9 a4		lda #$a4	                lda #$A4
.a5c4		4c 25 a7	jmp $a725	                jmp asm_common
.a5c7						z_asm_ldy_z:
.a5c7						xt_asm_ldy_zx:
.a5c7		a9 b4		lda #$b4	                lda #$B4
.a5c9		4c 25 a7	jmp $a725	                jmp asm_common
.a5cc						z_asm_ldy_zx:
.a5cc						xt_asm_lsr:
.a5cc		a9 4e		lda #$4e	                lda #$4E
.a5ce		4c 25 a7	jmp $a725	                jmp asm_common
.a5d1						z_asm_lsr:
.a5d1						xt_asm_lsr_a:
.a5d1		a9 4a		lda #$4a	                lda #$4A
.a5d3		4c 25 a7	jmp $a725	                jmp asm_common
.a5d6						z_asm_lsr_a:
.a5d6						xt_asm_lsr_x:
.a5d6		a9 5e		lda #$5e	                lda #$5E
.a5d8		4c 25 a7	jmp $a725	                jmp asm_common
.a5db						z_asm_lsr_x:
.a5db						xt_asm_lsr_z:
.a5db		a9 46		lda #$46	                lda #$46
.a5dd		4c 25 a7	jmp $a725	                jmp asm_common
.a5e0						z_asm_lsr_z:
.a5e0						xt_asm_lsr_zx:
.a5e0		a9 56		lda #$56	                lda #$56
.a5e2		4c 25 a7	jmp $a725	                jmp asm_common
.a5e5						z_asm_lsr_zx:
.a5e5						xt_asm_nop:
.a5e5		a9 ea		lda #$ea	                lda #$EA
.a5e7		4c 25 a7	jmp $a725	                jmp asm_common
.a5ea						z_asm_nop:
.a5ea						xt_asm_ora:
.a5ea		a9 0d		lda #$0d	                lda #$0D
.a5ec		4c 25 a7	jmp $a725	                jmp asm_common
.a5ef						z_asm_ora:
.a5ef						xt_asm_ora_h:
.a5ef		a9 09		lda #$09	                lda #$09
.a5f1		4c 25 a7	jmp $a725	                jmp asm_common
.a5f4						z_asm_ora_h:
.a5f4						xt_asm_ora_x:
.a5f4		a9 1d		lda #$1d	                lda #$1D
.a5f6		4c 25 a7	jmp $a725	                jmp asm_common
.a5f9						z_asm_ora_x:
.a5f9						xt_asm_ora_y:
.a5f9		a9 19		lda #$19	                lda #$19
.a5fb		4c 25 a7	jmp $a725	                jmp asm_common
.a5fe						z_asm_ora_y:
.a5fe						xt_asm_ora_z:
.a5fe		a9 05		lda #$05	                lda #$05
.a600		4c 25 a7	jmp $a725	                jmp asm_common
.a603						z_asm_ora_z:
.a603						xt_asm_ora_zi:
.a603		a9 12		lda #$12	                lda #$12
.a605		a0 02		ldy #$02	                ldy #2
.a607		4c 25 a7	jmp $a725	                jmp asm_common
.a60a						z_asm_ora_zi:
.a60a						xt_asm_ora_ziy:
.a60a		a9 11		lda #$11	                lda #$11
.a60c		4c 25 a7	jmp $a725	                jmp asm_common
.a60f						z_asm_ora_ziy:
.a60f						xt_asm_ora_zx:
.a60f		a9 15		lda #$15	                lda #$15
.a611		4c 25 a7	jmp $a725	                jmp asm_common
.a614						z_asm_ora_zx:
.a614						xt_asm_ora_zxi:
.a614		a9 01		lda #$01	                lda #$01
.a616		4c 25 a7	jmp $a725	                jmp asm_common
.a619						z_asm_ora_zxi:
.a619						xt_asm_pha:
.a619		a9 48		lda #$48	                lda #$48
.a61b		4c 25 a7	jmp $a725	                jmp asm_common
.a61e						z_asm_pha:
.a61e						xt_asm_php:
.a61e		a9 08		lda #$08	                lda #$08
.a620		4c 25 a7	jmp $a725	                jmp asm_common
.a623						z_asm_php:
.a623						xt_asm_phx:
.a623		a9 da		lda #$da	                lda #$DA
.a625		4c 25 a7	jmp $a725	                jmp asm_common
.a628						z_asm_phx:
.a628						xt_asm_phy:
.a628		a9 5a		lda #$5a	                lda #$5A
.a62a		4c 25 a7	jmp $a725	                jmp asm_common
.a62d						z_asm_phy:
.a62d						xt_asm_pla:
.a62d		a9 68		lda #$68	                lda #$68
.a62f		4c 25 a7	jmp $a725	                jmp asm_common
.a632						z_asm_pla:
.a632						xt_asm_plp:
.a632		a9 28		lda #$28	                lda #$28
.a634		4c 25 a7	jmp $a725	                jmp asm_common
.a637						z_asm_plp:
.a637						xt_asm_plx:
.a637		a9 fa		lda #$fa	                lda #$FA
.a639		4c 25 a7	jmp $a725	                jmp asm_common
.a63c						z_asm_plx:
.a63c						xt_asm_ply:
.a63c		a9 7a		lda #$7a	                lda #$7A
.a63e		4c 25 a7	jmp $a725	                jmp asm_common
.a641						z_asm_ply:
.a641						xt_asm_rol:
.a641		a9 2e		lda #$2e	                lda #$2E
.a643		4c 25 a7	jmp $a725	                jmp asm_common
.a646						z_asm_rol:
.a646						xt_asm_rol_a:
.a646		a9 2a		lda #$2a	                lda #$2A
.a648		4c 25 a7	jmp $a725	                jmp asm_common
.a64b						z_asm_rol_a:
.a64b						xt_asm_rol_x:
.a64b		a9 3e		lda #$3e	                lda #$3E
.a64d		4c 25 a7	jmp $a725	                jmp asm_common
.a650						z_asm_rol_x:
.a650						xt_asm_rol_z:
.a650		a9 26		lda #$26	                lda #$26
.a652		4c 25 a7	jmp $a725	                jmp asm_common
.a655						z_asm_rol_z:
.a655						xt_asm_rol_zx:
.a655		a9 36		lda #$36	                lda #$36
.a657		4c 25 a7	jmp $a725	                jmp asm_common
.a65a						z_asm_rol_zx:
.a65a						xt_asm_ror:
.a65a		a9 6e		lda #$6e	                lda #$6E
.a65c		4c 25 a7	jmp $a725	                jmp asm_common
.a65f						z_asm_ror:
.a65f						xt_asm_ror_a:
.a65f		a9 6a		lda #$6a	                lda #$6A
.a661		4c 25 a7	jmp $a725	                jmp asm_common
.a664						z_asm_ror_a:
.a664						xt_asm_ror_x:
.a664		a9 7e		lda #$7e	                lda #$7E
.a666		4c 25 a7	jmp $a725	                jmp asm_common
.a669						z_asm_ror_x:
.a669						xt_asm_ror_z:
.a669		a9 66		lda #$66	                lda #$66
.a66b		4c 25 a7	jmp $a725	                jmp asm_common
.a66e						z_asm_ror_z:
.a66e						xt_asm_ror_zx:
.a66e		a9 76		lda #$76	                lda #$76
.a670		4c 25 a7	jmp $a725	                jmp asm_common
.a673						z_asm_ror_zx:
.a673						xt_asm_rti:
.a673		a9 40		lda #$40	                lda #$40
.a675		4c 25 a7	jmp $a725	                jmp asm_common
.a678						z_asm_rti:
.a678						xt_asm_rts:
.a678		a9 60		lda #$60	                lda #$60
.a67a		4c 25 a7	jmp $a725	                jmp asm_common
.a67d						z_asm_rts:
.a67d						xt_asm_sbc:
.a67d		a9 ed		lda #$ed	                lda #$ED
.a67f		4c 25 a7	jmp $a725	                jmp asm_common
.a682						z_asm_sbc:
.a682						xt_asm_sbc_h:
.a682		a9 e9		lda #$e9	                lda #$E9
.a684		4c 25 a7	jmp $a725	                jmp asm_common
.a687						z_asm_sbc_h:
.a687						xt_asm_sbc_x:
.a687		a9 fd		lda #$fd	                lda #$FD
.a689		4c 25 a7	jmp $a725	                jmp asm_common
.a68c						z_asm_sbc_x:
.a68c						xt_asm_sbc_y:
.a68c		a9 f9		lda #$f9	                lda #$F9
.a68e		4c 25 a7	jmp $a725	                jmp asm_common
.a691						z_asm_sbc_y:
.a691						xt_asm_sbc_z:
.a691		a9 e5		lda #$e5	                lda #$E5
.a693		4c 25 a7	jmp $a725	                jmp asm_common
.a696						z_asm_sbc_z:
.a696						xt_asm_sbc_zi:
.a696		a9 f2		lda #$f2	                lda #$F2
.a698		4c 25 a7	jmp $a725	                jmp asm_common
.a69b						z_asm_sbc_zi:
.a69b						xt_asm_sbc_ziy:
.a69b		a9 f1		lda #$f1	                lda #$F1
.a69d		4c 25 a7	jmp $a725	                jmp asm_common
.a6a0						z_asm_sbc_ziy:
.a6a0						xt_asm_sbc_zx:
.a6a0		a9 f5		lda #$f5	                lda #$F5
.a6a2		4c 25 a7	jmp $a725	                jmp asm_common
.a6a5						z_asm_sbc_zx:
.a6a5						xt_asm_sbc_zxi:
.a6a5		a9 e1		lda #$e1	                lda #$E1
.a6a7		80 7c		bra $a725	                bra asm_common  ; <-- limit for BRA instead of JMP
.a6a9						z_asm_sbc_zxi:
.a6a9						xt_asm_sec:
.a6a9		a9 38		lda #$38	                lda #$38
.a6ab		80 78		bra $a725	                bra asm_common
.a6ad						z_asm_sec:
.a6ad						xt_asm_sed:
.a6ad		a9 f8		lda #$f8	                lda #$F8
.a6af		80 74		bra $a725	                bra asm_common
.a6b1						z_asm_sed:
.a6b1						xt_asm_sei:
.a6b1		a9 78		lda #$78	                lda #$78
.a6b3		80 70		bra $a725	                bra asm_common
.a6b5						z_asm_sei:
.a6b5						xt_asm_sta:
.a6b5		a9 8d		lda #$8d	                lda #$8D
.a6b7		80 6c		bra $a725	                bra asm_common
.a6b9						z_asm_sta:
.a6b9						xt_asm_sta_x:
.a6b9		a9 9d		lda #$9d	                lda #$9D
.a6bb		80 68		bra $a725	                bra asm_common
.a6bd						z_asm_sta_x:
.a6bd						xt_asm_sta_y:
.a6bd		a9 99		lda #$99	                lda #$99
.a6bf		80 64		bra $a725	                bra asm_common
.a6c1						z_asm_sta_y:
.a6c1						xt_asm_sta_z:
.a6c1		a9 85		lda #$85	                lda #$85
.a6c3		80 60		bra $a725	                bra asm_common
.a6c5						z_asm_sta_z:
.a6c5						xt_asm_sta_zi:
.a6c5		a9 92		lda #$92	                lda #$92
.a6c7		80 5c		bra $a725	                bra asm_common
.a6c9						z_asm_sta_zi:
.a6c9						xt_asm_sta_ziy:
.a6c9		a9 91		lda #$91	                lda #$91
.a6cb		80 58		bra $a725	                bra asm_common
.a6cd						z_asm_sta_ziy:
.a6cd						xt_asm_sta_zx:
.a6cd		a9 95		lda #$95	                lda #$95
.a6cf		80 54		bra $a725	                bra asm_common
.a6d1						z_asm_sta_zx:
.a6d1						xt_asm_sta_zxi:
.a6d1		a9 81		lda #$81	                lda #$81
.a6d3		80 50		bra $a725	                bra asm_common
.a6d5						z_asm_sta_zxi:
.a6d5						xt_asm_stx:
.a6d5		a9 8e		lda #$8e	                lda #$8E
.a6d7		80 4c		bra $a725	                bra asm_common
.a6d9						z_asm_stx:
.a6d9						xt_asm_stx_z:
.a6d9		a9 86		lda #$86	                lda #$86
.a6db		80 48		bra $a725	                bra asm_common
.a6dd						z_asm_stx_z:
.a6dd						xt_asm_stx_zy:
.a6dd		a9 96		lda #$96	                lda #$96
.a6df		80 44		bra $a725	                bra asm_common
.a6e1						z_asm_stx_zy:
.a6e1						xt_asm_sty:
.a6e1		a9 8c		lda #$8c	                lda #$8C
.a6e3		80 40		bra $a725	                bra asm_common
.a6e5						z_asm_sty:
.a6e5						xt_asm_sty_z:
.a6e5		a9 84		lda #$84	                lda #$84
.a6e7		80 3c		bra $a725	                bra asm_common
.a6e9						z_asm_sty_z:
.a6e9						xt_asm_sty_zx:
.a6e9		a9 94		lda #$94	                lda #$94
.a6eb		80 38		bra $a725	                bra asm_common
.a6ed						z_asm_sty_zx:
.a6ed						xt_asm_stz:
.a6ed		a9 9c		lda #$9c	                lda #$9C
.a6ef		80 34		bra $a725	                bra asm_common
.a6f1						z_asm_stz:
.a6f1						xt_asm_stz_x:
.a6f1		a9 9e		lda #$9e	                lda #$9E
.a6f3		80 30		bra $a725	                bra asm_common
.a6f5						z_asm_stz_x:
.a6f5						xt_asm_stz_z:
.a6f5		a9 64		lda #$64	                lda #$64
.a6f7		80 2c		bra $a725	                bra asm_common
.a6f9						z_asm_stz_z:
.a6f9						xt_asm_stz_zx:
.a6f9		a9 74		lda #$74	                lda #$74
.a6fb		80 28		bra $a725	                bra asm_common
.a6fd						z_asm_stz_zx:
.a6fd						xt_asm_tax:
.a6fd		a9 aa		lda #$aa	                lda #$AA
.a6ff		80 24		bra $a725	                bra asm_common
.a701						z_asm_tax:
.a701						xt_asm_tay:
.a701		a9 a8		lda #$a8	                lda #$A8
.a703		80 20		bra $a725	                bra asm_common
.a705						z_asm_tay:
.a705						xt_asm_trb:
.a705		a9 1c		lda #$1c	                lda #$1C
.a707		80 1c		bra $a725	                bra asm_common
.a709						z_asm_trb:
.a709						xt_asm_trb_z:
.a709		a9 14		lda #$14	                lda #$14
.a70b		80 18		bra $a725	                bra asm_common
.a70d						z_asm_trb_z:
.a70d						xt_asm_tsb:
.a70d		a9 0c		lda #$0c	                lda #$0C
.a70f		80 14		bra $a725	                bra asm_common
.a711						z_asm_tsb:
.a711						xt_asm_tsb_z:
.a711		a9 04		lda #$04	                lda #$04
.a713		80 10		bra $a725	                bra asm_common
.a715						z_asm_tsb_z:
.a715						xt_asm_tsx:
.a715		a9 ba		lda #$ba	                lda #$BA
.a717		80 0c		bra $a725	                bra asm_common
.a719						z_asm_tsx:
.a719						xt_asm_txa:
.a719		a9 8a		lda #$8a	                lda #$8A
.a71b		80 08		bra $a725	                bra asm_common
.a71d						z_asm_txa:
.a71d						xt_asm_txs:
.a71d		a9 9a		lda #$9a	                lda #$9A
.a71f		80 04		bra $a725	                bra asm_common
.a721						z_asm_txs:
.a721						xt_asm_tya:
.a721		a9 98		lda #$98	                lda #$98
.a723		80 00		bra $a725	                bra asm_common
.a725						z_asm_tya:
.a725						asm_common:
.a725		a8		tay		                tay
.a726		20 75 97	jsr $9775	                jsr cmpl_a
.a729		a9 98		lda #$98	                lda #<oc_index_table
.a72b		85 27		sta $27		                sta tmp2
.a72d		a9 b3		lda #$b3	                lda #>oc_index_table
.a72f		85 28		sta $28		                sta tmp2+1
.a731		98		tya		                tya             ; retrieve opcode
.a732		0a		asl a		                asl             ; times two for offset
.a733		90 02		bcc $a737	                bcc +
.a735		e6 28		inc $28		                inc tmp2+1
.a737						+
.a737		a8		tay		                tay             ; use Y as the index
.a738		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a73a		85 29		sta $29		                sta tmp3
.a73c		c8		iny		                iny
.a73d		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a73f		85 2a		sta $2a		                sta tmp3+1
.a741		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.a743		2a		rol a		                rol
.a744		2a		rol a		                rol
.a745		2a		rol a		                rol             ; Three times because we go through Carry
.a746		29 03		and #$03	                and #%00000011
.a748		a8		tay		                tay
.a749		88		dey		                dey
.a74a		f0 12		beq $a75e	                beq _done
.a74c		20 75 d7	jsr $d775	                jsr underflow_1
.a74f		b5 00		lda $00,x	                lda 0,x
.a751		20 75 97	jsr $9775	                jsr cmpl_a      ; does not use Y
.a754		88		dey		                dey
.a755		f0 05		beq $a75c	                beq _done_drop
.a757		b5 01		lda $01,x	                lda 1,x
.a759		20 75 97	jsr $9775	                jsr cmpl_a      ; Fall through to _done_drop
.a75c						_done_drop:
.a75c		e8		inx		                inx
.a75d		e8		inx		                inx             ; Fall through to _done
.a75e						_done:
.a75e		60		rts		                rts             ; Returns to original caller
.a75f						xt_asm_push_a:
.a75f		a0 00		ldy #$00	                ldy #0
.a761						_loop:
.a761		b9 6f a7	lda $a76f,y	                lda asm_push_a_data,y
.a764		c9 ff		cmp #$ff	                cmp #$FF
.a766		f0 06		beq $a76e	                beq _done
.a768		20 75 97	jsr $9775	                jsr cmpl_a      ; does not change Y
.a76b		c8		iny		                iny
.a76c		80 f3		bra $a761	                bra _loop
.a76e						_done:
.a76e						z_asm_push_a:
.a76e		60		rts		                rts
.a76f						asm_push_a_data:
>a76f		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>a775		ff				        .byte $FF               ; terminator
.a776						xt_asm_back_jump:
.a776						z_asm_back_jump:
.a776		60		rts		                rts
.a777						xt_asm_back_branch:
.a777		20 1b 89	jsr $891b	                jsr xt_here             ; ( addr-l addr-h )
.a77a		20 e4 8b	jsr $8be4	                jsr xt_minus            ; ( offset )
.a77d		3a		dec a		                dea
.a77e		3a		dec a		                dea
.a77f						z_asm_back_branch:
.a77f		60		rts		                rts
.a780						assembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/ed.asm

.a780						xt_ed:
.a780		20 84 a7	jsr $a784	                jsr ed6502      ; kept in separate file
.a783		60		rts		z_ed:           rts
=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.a784						ed6502:
.a784		a5 18		lda $18		                lda base
.a786		85 3a		sta $3a		                sta ed_base
.a788		a9 0a		lda #$0a	                lda #10
.a78a		85 18		sta $18		                sta base
.a78c		64 35		stz $35		                stz ed_head
.a78e		64 36		stz $36		                stz ed_head+1
.a790		64 37		stz $37		                stz ed_cur
.a792		64 38		stz $38		                stz ed_cur+1
.a794		64 39		stz $39		                stz ed_flags
.a796		20 dc 9d	jsr $9ddc	                jsr xt_zero
.a799		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; ( addr-t u-t )
.a79c		20 3a 84	jsr $843a	                jsr xt_cr
.a79f						ed_input_loop:
.a79f		a9 81		lda #$81	                lda #%10000001
.a7a1		14 39		trb $39		                trb ed_flags
.a7a3		20 7e ac	jsr $ac7e	                jsr ed_get_input
.a7a6		a5 0e		lda $0e		                lda ciblen
.a7a8		d0 1f		bne $a7c9	                bne _command_mode
.a7aa		ca		dex		                dex
.a7ab		ca		dex		                dex                     ; ( addr-t u-t ? )
.a7ac		a5 37		lda $37		                lda ed_cur
.a7ae		95 00		sta $00,x	                sta 0,x
.a7b0		a5 38		lda $38		                lda ed_cur+1
.a7b2		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.a7b4		a9 80		lda #$80	                lda #%10000000
.a7b6		04 39		tsb $39		                tsb ed_flags
.a7b8		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.a7bb		20 9a ac	jsr $ac9a	                jsr ed_is_valid_line
.a7be		b0 03		bcs $a7c3	                bcs +
.a7c0		4c 6e ac	jmp $ac6e	                jmp ed_error_1drop
.a7c3						+
.a7c3		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.a7c6		4c 94 a8	jmp $a894	                jmp _line_number_only_from_external
.a7c9						_command_mode:
.a7c9		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.a7cc		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.a7cf		b2 0c		lda ($0c)	                lda (cib)
.a7d1		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.a7d3		d0 3a		bne $a80f	                bne _prefix_dollar
.a7d5		20 8f ac	jsr $ac8f	                jsr ed_have_text
.a7d8		a5 37		lda $37		                lda ed_cur
.a7da		95 02		sta $02,x	                sta 2,x
.a7dc		a5 38		lda $38		                lda ed_cur+1
.a7de		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a7e0		a9 80		lda #$80	                lda #%10000000
.a7e2		04 39		tsb $39		                tsb ed_flags
.a7e4		a5 0e		lda $0e		                lda ciblen
.a7e6		3a		dec a		                dea                     ; sets Z if A was 1
.a7e7		d0 03		bne $a7ec	                bne +
.a7e9		4c 94 a8	jmp $a894	                jmp _line_number_only_from_external
.a7ec						+
.a7ec		ca		dex		                dex
.a7ed		ca		dex		                dex
.a7ee		ca		dex		                dex
.a7ef		ca		dex		                dex
.a7f0		a5 0c		lda $0c		                lda cib
.a7f2		95 02		sta $02,x	                sta 2,x
.a7f4		a5 0d		lda $0d		                lda cib+1
.a7f6		95 03		sta $03,x	                sta 3,x
.a7f8		a5 0e		lda $0e		                lda ciblen
.a7fa		95 00		sta $00,x	                sta 0,x
.a7fc		a5 0f		lda $0f		                lda ciblen+1
.a7fe		95 01		sta $01,x	                sta 1,x
.a800		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.a803		20 2e 92	jsr $922e	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.a806		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.a809		20 2e 92	jsr $922e	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.a80c		4c ec a8	jmp $a8ec	                jmp _check_for_para2
.a80f						_prefix_dollar:
.a80f		b2 0c		lda ($0c)	                lda (cib)
.a811		c9 24		cmp #$24	                cmp #'$'
.a813		d0 1c		bne $a831	                bne _prefix_percent
.a815		20 8f ac	jsr $ac8f	                jsr ed_have_text
.a818		e8		inx		                inx
.a819		e8		inx		                inx                     ; ( addr-t u-t 0 )
.a81a		20 bc ac	jsr $acbc	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.a81d		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.a820		a9 80		lda #$80	                lda #%10000000
.a822		04 39		tsb $39		                tsb ed_flags
.a824		a5 0e		lda $0e		                lda ciblen
.a826		3a		dec a		                dea                     ; sets Z if A was 1
.a827		d0 03		bne $a82c	                bne +
.a829		4c 94 a8	jmp $a894	                jmp _line_number_only_from_external
.a82c						+
.a82c		a0 01		ldy #$01	                ldy #01
.a82e		4c 68 a9	jmp $a968	                jmp _check_command
.a831						_prefix_percent:
.a831		b2 0c		lda ($0c)	                lda (cib)
.a833		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.a835		f0 04		beq $a83b	                beq _whole_text
.a837		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.a839		d0 17		bne $a852	                bne _prefix_semicolon
.a83b						_whole_text:
.a83b		20 8f ac	jsr $ac8f	                jsr ed_have_text
.a83e		a9 01		lda #$01	                lda #01
.a840		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.a842		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.a844						_semicolon_entry:
.a844		e8		inx		                inx
.a845		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.a846		20 bc ac	jsr $acbc	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a849		a9 80		lda #$80	                lda #%10000000
.a84b		04 39		tsb $39		                tsb ed_flags
.a84d		a0 01		ldy #$01	                ldy #01
.a84f		4c 68 a9	jmp $a968	                jmp _check_command
.a852						_prefix_semicolon:
.a852		b2 0c		lda ($0c)	                lda (cib)
.a854		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.a856		d0 0d		bne $a865	                bne _prefix_number
.a858		20 8f ac	jsr $ac8f	                jsr ed_have_text
.a85b		a5 37		lda $37		                lda ed_cur
.a85d		95 02		sta $02,x	                sta 2,x
.a85f		a5 38		lda $38		                lda ed_cur+1
.a861		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a863		80 df		bra $a844	                bra _semicolon_entry
.a865						_prefix_number:
.a865		20 dc 9d	jsr $9ddc	                jsr xt_zero
.a868		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.a86b		ca		dex		                dex
.a86c		ca		dex		                dex
.a86d		ca		dex		                dex
.a86e		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.a86f		a5 0c		lda $0c		                lda cib
.a871		95 02		sta $02,x	                sta 2,x
.a873		a5 0d		lda $0d		                lda cib+1
.a875		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.a877		a5 0e		lda $0e		                lda ciblen
.a879		95 00		sta $00,x	                sta 0,x
.a87b		a5 0f		lda $0f		                lda ciblen+1
.a87d		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.a87f		20 cc 92	jsr $92cc	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.a882		b5 00		lda $00,x	                lda 0,x
.a884		15 01		ora $01,x	                ora 1,x
.a886		d0 24		bne $a8ac	                bne _have_unconverted_chars
.a888		e8		inx		                inx
.a889		e8		inx		                inx
.a88a		e8		inx		                inx
.a88b		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.a88c		20 25 9e	jsr $9e25	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.a88f		20 60 9c	jsr $9c60	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.a892		e8		inx		                inx
.a893		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.a894						_line_number_only_from_external:
.a894		20 2e 92	jsr $922e	                jsr xt_swap             ; ( addr-t u-t 0 u )
.a897		20 9a ac	jsr $ac9a	                jsr ed_is_valid_line
.a89a		b0 03		bcs $a89f	                bcs +
.a89c		4c 6c ac	jmp $ac6c	                jmp ed_error_2drop
.a89f						+
.a89f		20 2e 92	jsr $922e	                jsr xt_swap             ; ( addr-t u-t u 0 )
.a8a2		20 29 ad	jsr $ad29	                jsr ed_para1_to_cur
.a8a5		a9 80		lda #$80	                lda #%10000000
.a8a7		04 39		tsb $39		                tsb ed_flags
.a8a9		4c 47 ab	jmp $ab47	                jmp ed_cmd_p_from_external
.a8ac						_have_unconverted_chars:
.a8ac		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.a8af		ca		dex		                dex
.a8b0		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.a8b1		a5 0e		lda $0e		                lda ciblen
.a8b3		95 00		sta $00,x	                sta 0,x
.a8b5		a5 0f		lda $0f		                lda ciblen+1
.a8b7		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.a8b9		20 96 87	jsr $8796	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.a8bc		b5 00		lda $00,x	                lda 0,x
.a8be		15 01		ora $01,x	                ora 1,x
.a8c0		f0 0e		beq $a8d0	                beq _no_command_yet
.a8c2		8a		txa		                txa
.a8c3		18		clc		                clc
.a8c4		69 0a		adc #$0a	                adc #10
.a8c6		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.a8c7		a9 80		lda #$80	                lda #%10000000
.a8c9		14 39		trb $39		                trb ed_flags
.a8cb		a0 00		ldy #$00	                ldy #00
.a8cd		4c 68 a9	jmp $a968	                jmp _check_command
.a8d0						_no_command_yet:
.a8d0		e8		inx		                inx
.a8d1		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.a8d2		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.a8d5		20 60 9c	jsr $9c60	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.a8d8		20 25 9e	jsr $9e25	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.a8db		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a8dd		95 06		sta $06,x	                sta 6,x
.a8df		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a8e1		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.a8e3		e8		inx		                inx
.a8e4		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.a8e5		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.a8e8		a9 80		lda #$80	                lda #%10000000
.a8ea		04 39		tsb $39		                tsb ed_flags
.a8ec						_check_for_para2:
.a8ec		a1 02		lda ($02,x)	                lda (2,x)
.a8ee		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.a8f0		f0 0d		beq $a8ff	                beq _got_comma
.a8f2		38		sec		                sec
.a8f3		a5 0e		lda $0e		                lda ciblen
.a8f5		f5 00		sbc $00,x	                sbc 0,x
.a8f7		a8		tay		                tay
.a8f8		e8		inx		                inx
.a8f9		e8		inx		                inx
.a8fa		e8		inx		                inx
.a8fb		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.a8fc		4c 68 a9	jmp $a968	                jmp _check_command
.a8ff						_got_comma:
.a8ff		f6 02		inc $02,x	                inc 2,x
.a901		d0 02		bne $a905	                bne +
.a903		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.a905						+
.a905		b5 01		lda $01,x	                lda 1,x
.a907		f0 02		beq $a90b	                beq +
.a909		d6 01		dec $01,x	                dec 1,x
.a90b						+
.a90b		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.a90d		a1 02		lda ($02,x)	                lda (2,x)
.a90f		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.a911		d0 14		bne $a927	                bne _para2_not_dollar
.a913		38		sec		                sec
.a914		a5 0e		lda $0e		                lda ciblen
.a916		f5 02		sbc $02,x	                sbc 2,x
.a918		a8		tay		                tay
.a919		c8		iny		                iny
.a91a		5a		phy		                phy
.a91b		8a		txa		                txa
.a91c		18		clc		                clc
.a91d		69 06		adc #$06	                adc #06
.a91f		aa		tax		                tax                     ; ( addr-t u-t para1 )
.a920		20 bc ac	jsr $acbc	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a923		7a		ply		                ply
.a924		4c 68 a9	jmp $a968	                jmp _check_command
.a927						_para2_not_dollar:
.a927		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.a92a		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.a92d		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.a930		20 91 8f	jsr $8f91	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.a933		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.a936		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.a939		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.a93c		20 cc 92	jsr $92cc	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.a93f		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.a942		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.a945		20 96 87	jsr $8796	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.a948		b5 00		lda $00,x	                lda 0,x
.a94a		15 01		ora $01,x	                ora 1,x
.a94c		f0 08		beq $a956	                beq _second_number
.a94e		8a		txa		                txa
.a94f		18		clc		                clc
.a950		69 0c		adc #$0c	                adc #12
.a952		aa		tax		                tax                     ; back to ( addr-t u-t )
.a953		4c 70 ac	jmp $ac70	                jmp ed_error
.a956						_second_number:
.a956		e8		inx		                inx
.a957		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.a958		38		sec		                sec
.a959		a5 0e		lda $0e		                lda ciblen
.a95b		f5 00		sbc $00,x	                sbc 0,x
.a95d		48		pha		                pha
.a95e		20 a7 93	jsr $93a7	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.a961		20 25 9e	jsr $9e25	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.a964		20 30 8c	jsr $8c30	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.a967		7a		ply		                ply
.a968						_check_command:
.a968		24 39		bit $39		                bit ed_flags
.a96a		30 08		bmi $a974	                bmi _check_command_have_arg
.a96c		a5 37		lda $37		                lda ed_cur
.a96e		95 02		sta $02,x	                sta 2,x
.a970		a5 38		lda $38		                lda ed_cur+1
.a972		95 03		sta $03,x	                sta 3,x
.a974						_check_command_have_arg:
.a974		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.a976		85 25		sta $25		                sta tmp1
.a978		da		phx		                phx
.a979		a2 00		ldx #$00	                ldx #00
.a97b						_cmd_loop:
.a97b		bd 54 ad	lda $ad54,x	                lda ed_cmd_list,x
.a97e		f0 07		beq $a987	                beq _illegal_command    ; zero marks end of list
.a980		c5 25		cmp $25		                cmp tmp1
.a982		f0 07		beq $a98b	                beq _found_cmd
.a984		e8		inx		                inx
.a985		80 f4		bra $a97b	                bra _cmd_loop
.a987						_illegal_command:
.a987		fa		plx		                plx
.a988		4c 6c ac	jmp $ac6c	                jmp ed_error_2drop
.a98b						_found_cmd:
.a98b		8a		txa		                txa
.a98c		0a		asl a		                asl
.a98d		aa		tax		                tax                     ; X * 2 for table
.a98e		7c 5f ad	jmp ($ad5f,x)	                jmp (ed_cmd_table,x)
.a991						ed_next_command:
.a991		e8		inx		                inx
.a992		e8		inx		                inx
.a993		e8		inx		                inx
.a994		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.a995		4c 9f a7	jmp $a79f	                jmp ed_input_loop
.a998						ed_all_done:
.a998		64 0e		stz $0e		                stz ciblen
.a99a		64 0f		stz $0f		                stz ciblen+1
.a99c		20 a7 93	jsr $93a7	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.a99f		a5 3a		lda $3a		                lda ed_base
.a9a1		85 18		sta $18		                sta base
.a9a3		60		rts		                rts
.a9a4						ed_cmd_a:
.a9a4		fa		plx		                plx
.a9a5		e8		inx		                inx
.a9a6		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.a9a7						ed_entry_cmd_i:
.a9a7		20 f2 ac	jsr $acf2	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.a9aa		20 3a 84	jsr $843a	                jsr xt_cr
.a9ad						_next_string_loop:
.a9ad		20 7e ac	jsr $ac7e	                jsr ed_get_input
.a9b0		b2 0c		lda ($0c)	                lda (cib)
.a9b2		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.a9b4		d0 16		bne $a9cc	                bne _add_line
.a9b6		a4 0e		ldy $0e		                ldy ciblen
.a9b8		c0 01		cpy #$01	                cpy #01
.a9ba		d0 10		bne $a9cc	                bne _add_line
.a9bc		a4 0f		ldy $0f		                ldy ciblen+1
.a9be		d0 0c		bne $a9cc	                bne _add_line
.a9c0		e8		inx		                inx
.a9c1		e8		inx		                inx
.a9c2		a9 40		lda #$40	                lda #%01000000
.a9c4		04 39		tsb $39		                tsb ed_flags
.a9c6		20 3a 84	jsr $843a	                jsr xt_cr
.a9c9		4c 9f a7	jmp $a79f	                jmp ed_input_loop
.a9cc						_add_line:
.a9cc		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.a9cf		20 1b 89	jsr $891b	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.a9d2		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.a9d5		20 1a 88	jsr $881a	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.a9d8		20 cd 83	jsr $83cd	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.a9db		20 8d 93	jsr $938d	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.a9de		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.a9e1		20 18 92	jsr $9218	                jsr xt_store            ; ! ( addr-t u-t here )
.a9e4		20 1b 89	jsr $891b	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.a9e7		a5 00		lda $00		                lda cp
.a9e9		18		clc		                clc
.a9ea		69 04		adc #$04	                adc #04
.a9ec		85 00		sta $00		                sta cp
.a9ee		90 02		bcc $a9f2	                bcc +
.a9f0		e6 01		inc $01		                inc cp+1
.a9f2						+
.a9f2		e6 37		inc $37		                inc ed_cur
.a9f4		d0 02		bne $a9f8	                bne +
.a9f6		e6 38		inc $38		                inc ed_cur+1
.a9f8						+
.a9f8		20 1b 89	jsr $891b	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.a9fb		20 a0 86	jsr $86a0	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.a9fe		ca		dex		                dex
.a9ff		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.aa00		a5 0c		lda $0c		                lda cib
.aa02		95 00		sta $00,x	                sta 0,x
.aa04		a5 0d		lda $0d		                lda cib+1
.aa06		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.aa08		20 2e 92	jsr $922e	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.aa0b		ca		dex		                dex
.aa0c		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.aa0d		a5 0e		lda $0e		                lda ciblen
.aa0f		95 00		sta $00,x	                sta 0,x
.aa11		a5 0f		lda $0f		                lda ciblen+1
.aa13		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.aa15		20 00 8c	jsr $8c00	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.aa18		18		clc		                clc
.aa19		a5 00		lda $00		                lda cp
.aa1b		65 0e		adc $0e		                adc ciblen
.aa1d		85 00		sta $00		                sta cp
.aa1f		90 06		bcc $aa27	                bcc +
.aa21		a5 01		lda $01		                lda cp+1
.aa23		65 0f		adc $0f		                adc ciblen+1
.aa25		85 01		sta $01		                sta cp+1
.aa27						+
.aa27		20 05 8d	jsr $8d05	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.aa2a		20 18 92	jsr $9218	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.aa2d		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+
.aa30		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.aa33		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.aa36		a5 0e		lda $0e		                lda ciblen
.aa38		95 02		sta $02,x	                sta 2,x
.aa3a		a5 0f		lda $0f		                lda ciblen+1
.aa3c		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.aa3e		20 18 92	jsr $9218	                jsr xt_store            ; ! ( addr-t u-t here )
.aa41		20 3a 84	jsr $843a	                jsr xt_cr
.aa44		4c ad a9	jmp $a9ad	                jmp _next_string_loop
.aa47						ed_cmd_d:
.aa47		fa		plx		                plx
.aa48		20 8f ac	jsr $ac8f	                jsr ed_have_text
.aa4b		20 e4 ac	jsr $ace4	                jsr ed_no_line_zero
.aa4e		b5 00		lda $00,x	                lda 0,x
.aa50		15 01		ora $01,x	                ora 1,x
.aa52		d0 08		bne $aa5c	                bne +
.aa54		20 05 8d	jsr $8d05	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.aa57		20 99 aa	jsr $aa99	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.aa5a		80 33		bra $aa8f	                bra _cmd_d_done
.aa5c						+
.aa5c		20 9a ac	jsr $ac9a	                jsr ed_is_valid_line      ; result is in C flag
.aa5f		b0 03		bcs $aa64	                bcs _cmd_d_loop
.aa61		4c 6c ac	jmp $ac6c	                jmp ed_error_2drop
.aa64						_cmd_d_loop:
.aa64		20 af 93	jsr $93af	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.aa67		20 06 89	jsr $8906	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.aa6a		b5 00		lda $00,x	                lda 0,x
.aa6c		15 01		ora $01,x	                ora 1,x
.aa6e		d0 0d		bne $aa7d	                bne _cmd_d_done_with_flag
.aa70		e8		inx		                inx
.aa71		e8		inx		                inx                     ; Get rid of the flag from >
.aa72		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.aa75		20 99 aa	jsr $aa99	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.aa78		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.aa7b		80 e7		bra $aa64	                bra _cmd_d_loop
.aa7d						_cmd_d_done_with_flag:
.aa7d		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.aa7e		e8		inx		                inx
.aa7f		b5 02		lda $02,x	                lda 2,x
.aa81		d0 02		bne $aa85	                bne +
.aa83		d6 03		dec $03,x	                dec 3,x
.aa85						+
.aa85		d6 02		dec $02,x	                dec 2,x
.aa87		b5 02		lda $02,x	                lda 2,x
.aa89		85 37		sta $37		                sta ed_cur
.aa8b		b5 03		lda $03,x	                lda 3,x
.aa8d		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.aa8f						_cmd_d_done:
.aa8f		a9 40		lda #$40	                lda #%01000000
.aa91		04 39		tsb $39		                tsb ed_flags
.aa93		20 3a 84	jsr $843a	                jsr xt_cr
.aa96		4c 91 a9	jmp $a991	                jmp ed_next_command
.aa99						_cmd_d_common:
.aa99		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.aa9c		20 f2 ac	jsr $acf2	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.aa9f		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.aaa2		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.aaa5		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.aaa8		20 f2 ac	jsr $acf2	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.aaab		20 18 92	jsr $9218	                jsr xt_store            ; ! ( addr-t u-t )
.aaae		60		rts		                rts
.aaaf						ed_cmd_equ:
.aaaf		fa		plx		                plx
.aab0		a5 35		lda $35		                lda ed_head
.aab2		05 36		ora $36		                ora ed_head+1
.aab4		d0 08		bne $aabe	                bne _cmd_equ_have_text
.aab6		ca		dex		                dex
.aab7		ca		dex		                dex
.aab8		74 00		stz $00,x	                stz 0,x
.aaba		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.aabc		80 21		bra $aadf	                bra _cmd_equ_done
.aabe						_cmd_equ_have_text:
.aabe		20 e4 ac	jsr $ace4	                jsr ed_no_line_zero
.aac1		24 39		bit $39		                bit ed_flags
.aac3		30 0c		bmi $aad1	                bmi _cmd_equ_have_para
.aac5		ca		dex		                dex
.aac6		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.aac7		a5 37		lda $37		                lda ed_cur
.aac9		95 00		sta $00,x	                sta 0,x
.aacb		a5 38		lda $38		                lda ed_cur+1
.aacd		95 01		sta $01,x	                sta 1,x
.aacf		80 0e		bra $aadf	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.aad1						_cmd_equ_have_para:
.aad1		b5 00		lda $00,x	                lda 0,x
.aad3		15 01		ora $01,x	                ora 1,x
.aad5		d0 05		bne $aadc	                bne _cmd_equ_two_paras
.aad7		20 05 8d	jsr $8d05	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.aada		80 03		bra $aadf	                bra _cmd_equ_done
.aadc						_cmd_equ_two_paras:
.aadc		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.aadf						_cmd_equ_done:
.aadf		20 3a 84	jsr $843a	                jsr xt_cr               ; number goes on new line
.aae2		20 ef 94	jsr $94ef	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.aae5		20 3a 84	jsr $843a	                jsr xt_cr
.aae8		4c 91 a9	jmp $a991	                jmp ed_next_command
.aaeb						ed_cmd_f:
.aaeb		fa		plx		                plx
.aaec		24 39		bit $39		                bit ed_flags
.aaee		30 17		bmi $ab07	                bmi _cmd_f_have_para
.aaf0		20 3a 84	jsr $843a	                jsr xt_cr
.aaf3		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.aaf6		20 91 8f	jsr $8f91	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.aaf9		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.aafc		20 ef 94	jsr $94ef	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.aaff		20 60 9c	jsr $9c60	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.ab02		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.ab05		80 11		bra $ab18	                bra _cmd_f_done
.ab07						_cmd_f_have_para:
.ab07		20 05 8d	jsr $8d05	                jsr xt_over
.ab0a		20 3a 84	jsr $843a	                jsr xt_cr
.ab0d		20 ef 94	jsr $94ef	                jsr xt_u_dot
.ab10		b5 02		lda $02,x	                lda 2,x
.ab12		95 06		sta $06,x	                sta 6,x
.ab14		b5 03		lda $03,x	                lda 3,x
.ab16		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.ab18						_cmd_f_done:
.ab18		20 3a 84	jsr $843a	                jsr xt_cr
.ab1b		4c 91 a9	jmp $a991	                jmp ed_next_command
.ab1e						ed_cmd_i:
.ab1e		fa		plx		                plx
.ab1f		e8		inx		                inx
.ab20		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.ab21		24 39		bit $39		                bit ed_flags
.ab23		30 08		bmi $ab2d	                bmi _cmd_i_have_para
.ab25		a5 37		lda $37		                lda ed_cur
.ab27		95 00		sta $00,x	                sta 0,x
.ab29		a5 38		lda $38		                lda ed_cur+1
.ab2b		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.ab2d						_cmd_i_have_para:
.ab2d		b5 00		lda $00,x	                lda 0,x
.ab2f		15 01		ora $01,x	                ora 1,x
.ab31		f0 09		beq $ab3c	                beq _cmd_i_done
.ab33		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.ab36		20 dc 9d	jsr $9ddc	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.ab39		20 ac 8b	jsr $8bac	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.ab3c						_cmd_i_done:
.ab3c		4c a7 a9	jmp $a9a7	                jmp ed_entry_cmd_i
.ab3f						ed_cmd_n:
.ab3f		fa		plx		                plx
.ab40		a9 01		lda #$01	                lda #%00000001
.ab42		04 39		tsb $39		                tsb ed_flags
.ab44		80 05		bra $ab4b	                bra ed_cmd_p_entry_for_cmd_n
.ab46						ed_cmd_p:
.ab46		fa		plx		                plx
.ab47						ed_cmd_p_from_external:
.ab47		a9 01		lda #$01	                lda #%00000001
.ab49		14 39		trb $39		                trb ed_flags
.ab4b						ed_cmd_p_entry_for_cmd_n:
.ab4b		20 8f ac	jsr $ac8f	                jsr ed_have_text
.ab4e		20 e4 ac	jsr $ace4	                jsr ed_no_line_zero
.ab51		20 3a 84	jsr $843a	                jsr xt_cr
.ab54		b5 00		lda $00,x	                lda 0,x
.ab56		15 01		ora $01,x	                ora 1,x
.ab58		d0 10		bne $ab6a	                bne _cmd_p_loop
.ab5a		b5 02		lda $02,x	                lda 2,x
.ab5c		85 37		sta $37		                sta ed_cur
.ab5e		b5 03		lda $03,x	                lda 3,x
.ab60		85 38		sta $38		                sta ed_cur+1
.ab62		20 05 8d	jsr $8d05	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.ab65		20 93 ab	jsr $ab93	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ab68		80 26		bra $ab90	                bra _cmd_p_all_done
.ab6a						_cmd_p_loop:
.ab6a		20 af 93	jsr $93af	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ab6d		20 06 89	jsr $8906	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.ab70		b5 00		lda $00,x	                lda 0,x
.ab72		15 01		ora $01,x	                ora 1,x
.ab74		d0 10		bne $ab86	                bne _cmd_p_done
.ab76		e8		inx		                inx
.ab77		e8		inx		                inx                     ; Get rid of the flag from >
.ab78		20 05 8d	jsr $8d05	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.ab7b		20 93 ab	jsr $ab93	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ab7e		f6 02		inc $02,x	                inc 2,x
.ab80		d0 02		bne $ab84	                bne +
.ab82		f6 03		inc $03,x	                inc 3,x
.ab84						+
.ab84		80 e4		bra $ab6a	                bra _cmd_p_loop
.ab86						_cmd_p_done:
.ab86		e8		inx		                inx
.ab87		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.ab88		b5 00		lda $00,x	                lda 0,x
.ab8a		85 37		sta $37		                sta ed_cur
.ab8c		b5 01		lda $01,x	                lda 1,x
.ab8e		85 38		sta $38		                sta ed_cur+1
.ab90						_cmd_p_all_done:
.ab90		4c 91 a9	jmp $a991	                jmp ed_next_command
.ab93						_cmd_p_common:
.ab93		a5 39		lda $39		                lda ed_flags
.ab95		4a		lsr a		                lsr                     ; bit 0 now in carry
.ab96		90 0b		bcc $aba3	                bcc _cmd_p_common_no_num
.ab98		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.ab9b		20 ef 94	jsr $94ef	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.ab9e		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.aba0		20 c5 86	jsr $86c5	                jsr emit_a
.aba3						_cmd_p_common_no_num:
.aba3		20 f2 ac	jsr $acf2	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.aba6		20 32 ad	jsr $ad32	                jsr ed_print_addr
.aba9		60		rts		                rts
.abaa						ed_cmd_q:
.abaa		fa		plx		                plx
.abab		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.abad		50 03		bvc $abb2	                bvc +
.abaf		4c 6c ac	jmp $ac6c	                jmp ed_error_2drop
.abb2						+
.abb2		4c 98 a9	jmp $a998	                jmp ed_all_done            ; can't fall thru because of PLX
.abb5						ed_cmd_qq:
.abb5		fa		plx		                plx
.abb6		4c 98 a9	jmp $a998	                jmp ed_all_done
.abb9						ed_cmd_w:
.abb9		fa		plx		                plx
.abba		20 8f ac	jsr $ac8f	                jsr ed_have_text
.abbd		24 39		bit $39		                bit ed_flags
.abbf		30 13		bmi $abd4	                bmi _cmd_w_have_para
.abc1		b5 06		lda $06,x	                lda 6,x
.abc3		15 07		ora $07,x	                ora 7,x
.abc5		d0 03		bne $abca	                bne +
.abc7		4c 6c ac	jmp $ac6c	                jmp ed_error_2drop
.abca						+
.abca		b5 06		lda $06,x	                lda 6,x
.abcc		95 02		sta $02,x	                sta 2,x
.abce		b5 07		lda $07,x	                lda 7,x
.abd0		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.abd2		80 08		bra $abdc	                bra _cmd_w_para_ready
.abd4						_cmd_w_have_para:
.abd4		b5 02		lda $02,x	                lda 2,x
.abd6		95 06		sta $06,x	                sta 6,x
.abd8		b5 03		lda $03,x	                lda 3,x
.abda		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.abdc						_cmd_w_para_ready:
.abdc		a9 35		lda #$35	                lda #<ed_head
.abde		95 00		sta $00,x	                sta 0,x
.abe0		a9 00		lda #$00	                lda #>ed_head
.abe2		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.abe4		20 05 8d	jsr $8d05	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.abe7		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.abea						_cmd_w_loop:
.abea		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.abed		b5 00		lda $00,x	                lda 0,x
.abef		15 01		ora $01,x	                ora 1,x
.abf1		f0 55		beq $ac48	                beq _cmd_w_eol
.abf3		20 af 93	jsr $93af	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.abf6		20 a4 94	jsr $94a4	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.abf9		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.abfc		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.abff		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ac02		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ac05		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ac08		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ac0b		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ac0e		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ac11		20 60 9c	jsr $9c60	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ac14		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ac17		20 91 8f	jsr $8f91	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ac1a		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ac1d		20 6c 93	jsr $936c	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ac20		20 00 8c	jsr $8c00	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ac23		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ac26		20 2a 94	jsr $942a	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ac29		20 60 9c	jsr $9c60	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ac2c		20 53 8e	jsr $8e53	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ac2f		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ac32		ca		dex		                dex
.ac33		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ac34		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ac36		95 00		sta $00,x	                sta 0,x
.ac38		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ac3a		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ac3d		20 18 92	jsr $9218	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ac40		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ac43		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ac46		80 a2		bra $abea	                bra _cmd_w_loop
.ac48						_cmd_w_eol:
.ac48		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ac4b		20 f0 8e	jsr $8ef0	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ac4e		20 e4 8b	jsr $8be4	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ac51		b5 00		lda $00,x	                lda 0,x
.ac53		95 04		sta $04,x	                sta 4,x
.ac55		b5 01		lda $01,x	                lda 1,x
.ac57		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ac59		20 3a 84	jsr $843a	                jsr xt_cr
.ac5c		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ac5f		20 ef 94	jsr $94ef	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ac62		20 3a 84	jsr $843a	                jsr xt_cr
.ac65		a9 40		lda #$40	                lda #%01000000
.ac67		14 39		trb $39		                trb ed_flags
.ac69		4c 91 a9	jmp $a991	                jmp ed_next_command
.ac6c						ed_error_2drop:
.ac6c		e8		inx		                inx
.ac6d		e8		inx		                inx                     ; drop through to _error_1drop
.ac6e						ed_error_1drop:
.ac6e		e8		inx		                inx
.ac6f		e8		inx		                inx                     ; drop through to _error
.ac70						ed_error:
.ac70		20 3a 84	jsr $843a	                jsr xt_cr
.ac73		a9 3f		lda #$3f	                lda #'?'
.ac75		20 c5 86	jsr $86c5	                jsr emit_a
.ac78		20 3a 84	jsr $843a	                jsr xt_cr
.ac7b		4c 9f a7	jmp $a79f	                jmp ed_input_loop
.ac7e						ed_get_input:
.ac7e		20 42 8f	jsr $8f42	                jsr xt_refill           ;  ( addr-t u-t f )
.ac81		b5 00		lda $00,x	                lda 0,x
.ac83		15 01		ora $01,x	                ora 1,x
.ac85		d0 05		bne $ac8c	                bne +
.ac87		7a		ply		                ply
.ac88		7a		ply		                ply
.ac89		4c 6e ac	jmp $ac6e	                jmp ed_error_1drop
.ac8c						+
.ac8c		e8		inx		                inx
.ac8d		e8		inx		                inx
.ac8e		60		rts		                rts
.ac8f						ed_have_text:
.ac8f		a5 35		lda $35		                lda ed_head
.ac91		05 36		ora $36		                ora ed_head+1
.ac93		d0 04		bne $ac99	                bne +
.ac95		7a		ply		                ply
.ac96		7a		ply		                ply
.ac97		80 d7		bra $ac70	                bra ed_error
.ac99						+
.ac99		60		rts		                rts
.ac9a						ed_is_valid_line:
.ac9a		38		sec		                sec                             ; default is legal line number
.ac9b		b5 00		lda $00,x	                lda 0,x
.ac9d		15 01		ora $01,x	                ora 1,x
.ac9f		f0 19		beq $acba	                beq _is_valid_line_nope_zero    ; ( n )
.aca1		20 a0 86	jsr $86a0	                jsr xt_dup                      ; DUP ( n n )
.aca4		20 bc ac	jsr $acbc	                jsr ed_last_line                  ; ( n n last )
.aca7		20 2e 92	jsr $922e	                jsr xt_swap                     ; SWAP ( n last n )
.acaa		20 dd 89	jsr $89dd	                jsr xt_less_than                ; < ( n f )
.acad		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.acaf		15 01		ora $01,x	                ora 1,x
.acb1		d0 05		bne $acb8	                bne _is_valid_line_too_small
.acb3		e8		inx		                inx
.acb4		e8		inx		                inx                     ; DROP flag ( n )
.acb5		38		sec		                sec                     ; Who knows what's happened to C by now
.acb6		80 03		bra $acbb	                bra _is_valid_line_done ; only one exit from this routine
.acb8						_is_valid_line_too_small:
.acb8		e8		inx		                inx
.acb9		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.acba						_is_valid_line_nope_zero:
.acba		18		clc		                clc                     ; drop through to _is_valid_line_done
.acbb						_is_valid_line_done:
.acbb		60		rts		                rts
.acbc						ed_last_line:
.acbc		64 25		stz $25		                stz tmp1
.acbe		64 26		stz $26		                stz tmp1+1
.acc0		ca		dex		                dex
.acc1		ca		dex		                dex                     ; ( ? )
.acc2		a9 35		lda #$35	                lda #<ed_head
.acc4		95 00		sta $00,x	                sta 0,x
.acc6		a9 00		lda #$00	                lda #>ed_head
.acc8		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.acca						_last_line_loop:
.acca		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( addr | 0 )
.accd		b5 00		lda $00,x	                lda 0,x
.accf		15 01		ora $01,x	                ora 1,x
.acd1		f0 08		beq $acdb	                beq _last_line_done
.acd3		e6 25		inc $25		                inc tmp1
.acd5		d0 02		bne $acd9	                bne +
.acd7		e6 26		inc $26		                inc tmp1+1
.acd9						+
.acd9		80 ef		bra $acca	                bra _last_line_loop
.acdb						_last_line_done:
.acdb		a5 25		lda $25		                lda tmp1
.acdd		95 00		sta $00,x	                sta 0,x
.acdf		a5 26		lda $26		                lda tmp1+1
.ace1		95 01		sta $01,x	                sta 1,x                 ; ( u )
.ace3		60		rts		                rts
.ace4						ed_no_line_zero:
.ace4		b5 02		lda $02,x	                lda 2,x
.ace6		15 03		ora $03,x	                ora 3,x
.ace8		d0 07		bne $acf1	                bne _no_line_zero_done
.acea		24 39		bit $39		                bit ed_flags
.acec		10 03		bpl $acf1	                bpl _no_line_zero_done
.acee		4c 6c ac	jmp $ac6c	                jmp ed_error_2drop
.acf1						_no_line_zero_done:
.acf1		60		rts		                rts
.acf2						ed_num_to_addr:
.acf2		ca		dex		                dex
.acf3		ca		dex		                dex                     ; ( u ? )
.acf4		a9 35		lda #$35	                lda #<ed_head
.acf6		95 00		sta $00,x	                sta 0,x
.acf8		a9 00		lda #$00	                lda #>ed_head
.acfa		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.acfc		b5 02		lda $02,x	                lda 2,x
.acfe		15 03		ora $03,x	                ora 3,x
.ad00		d0 05		bne $ad07	                bne _num_to_addr_loop
.ad02		20 30 8c	jsr $8c30	                jsr xt_nip              ; ( addr-h )
.ad05		80 21		bra $ad28	                bra _num_to_addr_done
.ad07						_num_to_addr_loop:
.ad07		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( u addr1 )
.ad0a		b5 00		lda $00,x	                lda 0,x
.ad0c		15 01		ora $01,x	                ora 1,x
.ad0e		d0 05		bne $ad15	                bne +
.ad10		20 30 8c	jsr $8c30	                jsr xt_nip              ; NIP ( addr1 )
.ad13		80 13		bra $ad28	                bra _num_to_addr_done
.ad15						+
.ad15		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( addr1 u )
.ad18		20 dd 8c	jsr $8cdd	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.ad1b		b5 00		lda $00,x	                lda 0,x
.ad1d		15 01		ora $01,x	                ora 1,x
.ad1f		f0 05		beq $ad26	                beq _num_to_addr_finished
.ad21		20 2e 92	jsr $922e	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.ad24		80 e1		bra $ad07	                bra _num_to_addr_loop
.ad26						_num_to_addr_finished:
.ad26		e8		inx		                inx
.ad27		e8		inx		                inx                     ; ( addr )
.ad28						_num_to_addr_done:
.ad28		60		rts		                rts
.ad29						ed_para1_to_cur:
.ad29		b5 02		lda $02,x	                lda 2,x
.ad2b		85 37		sta $37		                sta ed_cur
.ad2d		b5 03		lda $03,x	                lda 3,x
.ad2f		85 38		sta $38		                sta ed_cur+1
.ad31		60		rts		                rts
.ad32						ed_print_addr:
.ad32		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.ad35		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; ( addr+2 )
.ad38		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr+2 addr+2 )
.ad3b		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.ad3e		20 e9 8c	jsr $8ce9	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.ad41		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( addr+2 u-s )
.ad44		20 2e 92	jsr $922e	                jsr xt_swap             ; ( u-s addr+2 )
.ad47		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( u-s addr-s )
.ad4a		20 2e 92	jsr $922e	                jsr xt_swap             ; ( addr-s u-s )
.ad4d		20 c4 94	jsr $94c4	                jsr xt_type
.ad50		20 3a 84	jsr $843a	                jsr xt_cr
.ad53		60		rts		                rts
>ad54		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>ad5c		71 51 00
.ad5f						ed_cmd_table:
>ad5f		a4 a9 eb aa 1e ab 47 aa		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>ad67		46 ab 3f ab
>ad6b		af aa b9 ab aa ab b5 ab		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ad73						ed6502_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/block.asm

.ad73						xt_blk:
.ad73		a9 04		lda #$04	                lda #blk_offset
.ad75		4c 31 d6	jmp $d631	                jmp push_upvar_tos
.ad78						z_blk:
.ad78						xt_blkbuffer:
.ad78		ca		dex		                dex
.ad79		ca		dex		                dex
.ad7a		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ad7c		b1 08		lda ($08),y	                lda (up),y
.ad7e		95 00		sta $00,x	                sta 0,x
.ad80		c8		iny		                iny             ; Move along to the next byte
.ad81		b1 08		lda ($08),y	                lda (up),y
.ad83		95 01		sta $01,x	                sta 1,x
.ad85		60		rts		z_blkbuffer:    rts
.ad86						xt_block:
.ad86		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ad88		b1 08		lda ($08),y	                lda (up),y
.ad8a		d5 00		cmp $00,x	                cmp 0,x
.ad8c		d0 0f		bne $ad9d	                bne _not_in_buffer
.ad8e		c8		iny		                iny
.ad8f		b1 08		lda ($08),y	                lda (up),y
.ad91		d5 01		cmp $01,x	                cmp 1,x
.ad93		d0 08		bne $ad9d	                bne _not_in_buffer
.ad95		a0 30		ldy #$30	                ldy #buffstatus_offset
.ad97		b1 08		lda ($08),y	                lda (up),y
.ad99		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.ad9b		d0 30		bne $adcd	                bne _done       ; It's already in the buffer and in use.
.ad9d						_not_in_buffer:
.ad9d		a0 30		ldy #$30	                ldy #buffstatus_offset
.ad9f		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.ada1		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.ada3		d0 0c		bne $adb1	                bne _buffer_available ; Unused or not dirty = available
.ada5		20 78 ad	jsr $ad78	                jsr xt_blkbuffer
.ada8		20 82 af	jsr $af82	                jsr xt_buffblocknum
.adab		20 1a 88	jsr $881a	                jsr xt_fetch
.adae		20 6f af	jsr $af6f	                jsr xt_block_write
.adb1						_buffer_available:
.adb1		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.adb3		b5 00		lda $00,x	                lda 0,x
.adb5		91 08		sta ($08),y	                sta (up),y
.adb7		c8		iny		                iny
.adb8		b5 01		lda $01,x	                lda 1,x
.adba		91 08		sta ($08),y	                sta (up),y
.adbc		20 78 ad	jsr $ad78	                jsr xt_blkbuffer
.adbf		20 2e 92	jsr $922e	                jsr xt_swap
.adc2		20 57 af	jsr $af57	                jsr xt_block_read
.adc5		a9 01		lda #$01	                lda #1
.adc7		a0 30		ldy #$30	                ldy #buffstatus_offset
.adc9		91 08		sta ($08),y	                sta (up),y
.adcb		ca		dex		                dex
.adcc		ca		dex		                dex
.adcd						_done:
.adcd		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.adcf		b1 08		lda ($08),y	                lda (up),y
.add1		95 00		sta $00,x	                sta 0,x
.add3		c8		iny		                iny
.add4		b1 08		lda ($08),y	                lda (up),y
.add6		95 01		sta $01,x	                sta 1,x
.add8		60		rts		z_block:        rts
.add9						xt_block_c65_init:
=0						io_blk_status = 0
=0						io_blk_action = 0
=0						io_blk_number = 0
=0						io_blk_buffer = 0
.add9		a9 ff		lda #$ff	                lda #$ff
.addb		8d 11 f0	sta $f011	                sta io_blk_status
.adde		a9 00		lda #$00	                lda #$0
.ade0		8d 10 f0	sta $f010	                sta io_blk_action
.ade3		ad 11 f0	lda $f011	                lda io_blk_status      ; $0 if OK, $ff otherwise
.ade6		49 ff		eor #$ff	                eor #$ff            ; invert to forth true/false
.ade8		ca		dex		                dex
.ade9		ca		dex		                dex
.adea		95 00		sta $00,x	                sta 0,x             ; true ($ff) if OK, false (0) otherwise
.adec		95 01		sta $01,x	                sta 1,x
.adee		ca		dex		                dex
.adef		ca		dex		                dex
.adf0		a9 13		lda #$13	                lda #<c65_blk_read
.adf2		95 00		sta $00,x	                sta 0,x
.adf4		a9 ae		lda #$ae	                lda #>c65_blk_read
.adf6		95 01		sta $01,x	                sta 1,x
.adf8		20 65 af	jsr $af65	                jsr xt_block_read_vector
.adfb		20 18 92	jsr $9218	                jsr xt_store
.adfe		ca		dex		                dex
.adff		ca		dex		                dex
.ae00		a9 0f		lda #$0f	                lda #<c65_blk_write
.ae02		95 00		sta $00,x	                sta 0,x
.ae04		a9 ae		lda #$ae	                lda #>c65_blk_write
.ae06		95 01		sta $01,x	                sta 1,x
.ae08		20 7d af	jsr $af7d	                jsr xt_block_write_vector
.ae0b		20 18 92	jsr $9218	                jsr xt_store
.ae0e						z_block_c65_init:
.ae0e		60		rts		                rts
.ae0f		a0 02		ldy #$02	c65_blk_write:  ldy #2
.ae11		80 02		bra $ae15	                bra c65_blk_rw
.ae13		a0 01		ldy #$01	c65_blk_read:   ldy #1
.ae15		b5 00		lda $00,x	c65_blk_rw:     lda 0,x                 ; ( addr blk# )
.ae17		8d 12 f0	sta $f012	                sta io_blk_number
.ae1a		b5 01		lda $01,x	                lda 1,x
.ae1c		8d 13 f0	sta $f013	                sta io_blk_number+1
.ae1f		b5 02		lda $02,x	                lda 2,x
.ae21		8d 14 f0	sta $f014	                sta io_blk_buffer
.ae24		b5 03		lda $03,x	                lda 3,x
.ae26		8d 15 f0	sta $f015	                sta io_blk_buffer+1
.ae29		8c 10 f0	sty $f010	                sty io_blk_action       ; trigger the r/w
.ae2c		e8		inx		                inx                     ; clean up stack
.ae2d		e8		inx		                inx
.ae2e		e8		inx		                inx
.ae2f		e8		inx		                inx
.ae30		60		rts		                rts
.ae31						xt_block_ramdrive_init:
.ae31		20 75 d7	jsr $d775	                jsr underflow_1
.ae34		20 61 a1	jsr $a161	                jsr sliteral_runtime
>ae37		3f ae 18 01			                .word ramdrive_code, ramdrive_code_end-ramdrive_code
.ae3b		20 b2 88	jsr $88b2	                jsr xt_evaluate
.ae3e						z_block_ramdrive_init:
.ae3e		60		rts		                rts
.ae3f						ramdrive_code:
>ae3f		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>ae47		77 61 70 20 64 65 63 69 6d 61 6c
>ae52		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>ae59		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>ae5d		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>ae65		20 72 61 6d 64 72 69 76 65
>ae6e		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>ae76		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>ae84		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>ae8c		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>ae9c		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>aeac		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>aeb4		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>aec3		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>aecb		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>aedb		31 30 32 34 20 6d 6f 76 65 20 3b
>aee6		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>aeee		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>aefe		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>af0e		20 21
>af10		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>af18		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>af28		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>af38		6f 72 20 21
>af3c		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>af44		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>af54		65 20 21
.af57						ramdrive_code_end:
.af57						xt_block_read:
.af57		a0 32		ldy #$32	                ldy #blockread_offset
.af59		b1 08		lda ($08),y	                lda (up),y
.af5b		85 25		sta $25		                sta tmp1
.af5d		c8		iny		                iny
.af5e		b1 08		lda ($08),y	                lda (up),y
.af60		85 26		sta $26		                sta tmp1+1
.af62		6c 25 00	jmp ($0025)	                jmp (tmp1)
.af65						z_block_read:
.af65						xt_block_read_vector:
.af65		a9 32		lda #$32	                lda #blockread_offset
.af67		4c 31 d6	jmp $d631	                jmp push_upvar_tos
.af6a						z_block_read_vector:
.af6a						xt_block_word_error:
.af6a		a9 0c		lda #$0c	                lda #err_blockwords
.af6c		4c 8b d7	jmp $d78b	                jmp error       ; no RTS needed
.af6f						xt_block_write:
.af6f		a0 34		ldy #$34	                ldy #blockwrite_offset
.af71		b1 08		lda ($08),y	                lda (up),y
.af73		85 25		sta $25		                sta tmp1
.af75		c8		iny		                iny
.af76		b1 08		lda ($08),y	                lda (up),y
.af78		85 26		sta $26		                sta tmp1+1
.af7a		6c 25 00	jmp ($0025)	                jmp (tmp1)
.af7d						z_block_write:
.af7d						xt_block_write_vector:
.af7d		a9 34		lda #$34	                lda #blockwrite_offset
.af7f		4c 31 d6	jmp $d631	                jmp push_upvar_tos
.af82						z_block_write_vector:
.af82						xt_buffblocknum:
.af82		a9 2e		lda #$2e	                lda #buffblocknum_offset
.af84		4c 31 d6	jmp $d631	                jmp push_upvar_tos
.af87						z_buffblocknum:
.af87						xt_buffer:
.af87		a0 30		ldy #$30	                ldy #buffstatus_offset
.af89		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.af8b		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.af8d		d0 0c		bne $af9b	                bne _buffer_available ; Unused or not dirty = available
.af8f		20 78 ad	jsr $ad78	                jsr xt_blkbuffer
.af92		20 82 af	jsr $af82	                jsr xt_buffblocknum
.af95		20 1a 88	jsr $881a	                jsr xt_fetch
.af98		20 6f af	jsr $af6f	                jsr xt_block_write
.af9b						_buffer_available:
.af9b		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.af9d		b5 00		lda $00,x	                lda 0,x
.af9f		91 08		sta ($08),y	                sta (up),y
.afa1		c8		iny		                iny
.afa2		b5 01		lda $01,x	                lda 1,x
.afa4		91 08		sta ($08),y	                sta (up),y
.afa6		a9 01		lda #$01	                lda #1
.afa8		a0 30		ldy #$30	                ldy #buffstatus_offset
.afaa		91 08		sta ($08),y	                sta (up),y
.afac		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.afae		b1 08		lda ($08),y	                lda (up),y
.afb0		95 00		sta $00,x	                sta 0,x
.afb2		c8		iny		                iny
.afb3		b1 08		lda ($08),y	                lda (up),y
.afb5		95 01		sta $01,x	                sta 1,x
.afb7		60		rts		z_buffer:       rts
.afb8						xt_buffstatus:
.afb8		a9 30		lda #$30	                lda #buffstatus_offset
.afba		4c 31 d6	jmp $d631	                jmp push_upvar_tos
.afbd						z_buffstatus:
.afbd						xt_empty_buffers:
.afbd		a0 30		ldy #$30	                ldy #buffstatus_offset
.afbf		a9 00		lda #$00	                lda #0
.afc1		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.afc3						z_empty_buffers:
.afc3		60		rts		                rts
.afc4						xt_flush:
.afc4		20 1f b0	jsr $b01f	                jsr xt_save_buffers
.afc7		a0 30		ldy #$30	                ldy #buffstatus_offset
.afc9		a9 00		lda #$00	                lda #0
.afcb		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.afcd						z_flush:
.afcd		60		rts		                rts
.afce						xt_list:
.afce		20 75 d7	jsr $d775	                jsr underflow_1
.afd1		20 3a b0	jsr $b03a	                jsr xt_scr
.afd4		20 18 92	jsr $9218	                jsr xt_store
.afd7		20 d9 b0	jsr $b0d9	                jsr xt_editor_l
.afda		60		rts		z_list:         rts
.afdb						xt_load:
.afdb		20 75 d7	jsr $d775	                jsr underflow_1
.afde		a0 05		ldy #$05	                ldy #blk_offset+1
.afe0		b1 08		lda ($08),y	                lda (up),y
.afe2		48		pha		                pha
.afe3		88		dey		                dey
.afe4		b1 08		lda ($08),y	                lda (up),y
.afe6		48		pha		                pha
.afe7		b5 00		lda $00,x	                lda 0,x
.afe9		91 08		sta ($08),y	                sta (up),y
.afeb		c8		iny		                iny
.afec		b5 01		lda $01,x	                lda 1,x
.afee		91 08		sta ($08),y	                sta (up),y
.aff0		20 86 ad	jsr $ad86	                jsr xt_block
.aff3		ca		dex		                dex
.aff4		ca		dex		                dex
.aff5		a9 04		lda #$04	                lda #4
.aff7		95 01		sta $01,x	                sta 1,x
.aff9		74 00		stz $00,x	                stz 0,x
.affb		20 ac 88	jsr $88ac	                jsr load_evaluate
.affe		a0 04		ldy #$04	                ldy #blk_offset
.b000		68		pla		                pla
.b001		91 08		sta ($08),y	                sta (up),y
.b003		c8		iny		                iny
.b004		68		pla		                pla
.b005		91 08		sta ($08),y	                sta (up),y
.b007		88		dey		                dey
.b008		11 08		ora ($08),y	                ora (up),y
.b00a		f0 12		beq $b01e	                beq _done
.b00c		ca		dex		                dex
.b00d		ca		dex		                dex
.b00e		a0 04		ldy #$04	                ldy #blk_offset
.b010		b1 08		lda ($08),y	                lda (up),y
.b012		95 00		sta $00,x	                sta 0,x
.b014		c8		iny		                iny
.b015		b1 08		lda ($08),y	                lda (up),y
.b017		95 01		sta $01,x	                sta 1,x
.b019		20 86 ad	jsr $ad86	                jsr xt_block
.b01c		e8		inx		                inx
.b01d		e8		inx		                inx
.b01e						_done:
.b01e		60		rts		z_load:         rts
.b01f						xt_save_buffers:
.b01f		a0 30		ldy #$30	                ldy #buffstatus_offset
.b021		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b023		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b025		d0 12		bne $b039	                bne _done       ; Either not used or not dirty = done!
.b027		20 78 ad	jsr $ad78	                jsr xt_blkbuffer
.b02a		20 82 af	jsr $af82	                jsr xt_buffblocknum
.b02d		20 1a 88	jsr $881a	                jsr xt_fetch
.b030		20 6f af	jsr $af6f	                jsr xt_block_write
.b033		a9 01		lda #$01	                lda #1
.b035		a0 30		ldy #$30	                ldy #buffstatus_offset
.b037		91 08		sta ($08),y	                sta (up),y
.b039						_done:
.b039		60		rts		z_save_buffers: rts
.b03a						xt_scr:
.b03a		a9 06		lda #$06	                lda #scr_offset
.b03c		4c 31 d6	jmp $d631	                jmp push_upvar_tos
.b03f						z_scr:
.b03f						xt_thru:
.b03f		20 7a d7	jsr $d77a	                jsr underflow_2
.b042		b5 01		lda $01,x	                lda 1,x
.b044		48		pha		                pha
.b045		b5 00		lda $00,x	                lda 0,x
.b047		48		pha		                pha
.b048		e8		inx		                inx
.b049		e8		inx		                inx
.b04a						_thru_loop:
.b04a		b5 01		lda $01,x	                lda 1,x
.b04c		48		pha		                pha
.b04d		b5 00		lda $00,x	                lda 0,x
.b04f		48		pha		                pha
.b050		20 db af	jsr $afdb	                jsr xt_load
.b053		68		pla		                pla
.b054		85 25		sta $25		                sta tmp1
.b056		68		pla		                pla
.b057		85 26		sta $26		                sta tmp1+1
.b059		68		pla		                pla
.b05a		85 27		sta $27		                sta tmp2
.b05c		68		pla		                pla
.b05d		85 28		sta $28		                sta tmp2+1
.b05f		c5 26		cmp $26		                cmp tmp1+1
.b061		d0 08		bne $b06b	                bne _next_screen
.b063		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.b065		c5 25		cmp $25		                cmp tmp1
.b067		d0 02		bne $b06b	                bne _next_screen
.b069		80 18		bra $b083	                bra _done       ; We just did the last screen.
.b06b						_next_screen:
.b06b		a5 28		lda $28		                lda tmp2+1
.b06d		48		pha		                pha
.b06e		a5 27		lda $27		                lda tmp2
.b070		48		pha		                pha
.b071		e6 25		inc $25		                inc tmp1
.b073		d0 02		bne $b077	                bne +
.b075		e6 26		inc $26		                inc tmp1+1
.b077						+
.b077		ca		dex		                dex
.b078		ca		dex		                dex
.b079		a5 25		lda $25		                lda tmp1
.b07b		95 00		sta $00,x	                sta 0,x
.b07d		a5 26		lda $26		                lda tmp1+1
.b07f		95 01		sta $01,x	                sta 1,x
.b081		80 c7		bra $b04a	                bra _thru_loop
.b083						_done:
.b083		60		rts		z_thru:         rts
.b084						xt_update:
.b084		a0 30		ldy #$30	                ldy #buffstatus_offset
.b086		b1 08		lda ($08),y	                lda (up),y
.b088		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.b08a		91 08		sta ($08),y	                sta (up),y
.b08c		60		rts		z_update:       rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/editor.asm

.b08d						xt_editor_screen_helper:
.b08d		20 a0 86	jsr $86a0	                jsr xt_dup
.b090		20 3a b0	jsr $b03a	                jsr xt_scr
.b093		20 18 92	jsr $9218	                jsr xt_store
.b096		4c 87 af	jmp $af87	                jmp xt_buffer
.b099						xt_editor_enter_screen:
.b099		20 8d b0	jsr $b08d	                jsr xt_editor_screen_helper
.b09c		20 9a 86	jsr $869a	                jsr xt_drop
.b09f		64 35		stz $35		                stz ed_head
.b0a1						_prompt_loop:
.b0a1		ca		dex		                dex
.b0a2		ca		dex		                dex
.b0a3		a5 35		lda $35		                lda ed_head
.b0a5		95 00		sta $00,x	                sta 0,x
.b0a7		74 01		stz $01,x	                stz 1,x
.b0a9		20 6c b1	jsr $b16c	                jsr xt_editor_o
.b0ac		e6 35		inc $35		                inc ed_head
.b0ae		a9 10		lda #$10	                lda #16
.b0b0		c5 35		cmp $35		                cmp ed_head
.b0b2		d0 ed		bne $b0a1	                bne _prompt_loop
.b0b4						z_editor_enter_screen:
.b0b4		60		rts		                rts
.b0b5						xt_editor_erase_screen:
.b0b5		20 8d b0	jsr $b08d	                jsr xt_editor_screen_helper
.b0b8		ca		dex		                dex
.b0b9		ca		dex		                dex
.b0ba		74 00		stz $00,x	                stz 0,x
.b0bc		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.b0be		95 01		sta $01,x	                sta 1,x
.b0c0		20 b2 87	jsr $87b2	                jsr xt_blank
.b0c3		20 84 b0	jsr $b084	                jsr xt_update
.b0c6						z_editor_erase_screen:
.b0c6		60		rts		                rts
.b0c7						xt_editor_el:
.b0c7		20 53 b1	jsr $b153	                jsr xt_editor_line
.b0ca		ca		dex		                dex
.b0cb		ca		dex		                dex
.b0cc		a9 40		lda #$40	                lda #64
.b0ce		95 00		sta $00,x	                sta 0,x
.b0d0		74 01		stz $01,x	                stz 1,x
.b0d2		20 b2 87	jsr $87b2	                jsr xt_blank
.b0d5		20 84 b0	jsr $b084	                jsr xt_update
.b0d8		60		rts		z_editor_el:    rts
.b0d9						xt_editor_l:
.b0d9		ca		dex		                dex             ; Put SCR on the stack.
.b0da		ca		dex		                dex
.b0db		a0 06		ldy #$06	                ldy #scr_offset
.b0dd		b1 08		lda ($08),y	                lda (up),y
.b0df		95 00		sta $00,x	                sta 0,x
.b0e1		c8		iny		                iny
.b0e2		b1 08		lda ($08),y	                lda (up),y
.b0e4		95 01		sta $01,x	                sta 1,x
.b0e6		20 86 ad	jsr $ad86	                jsr xt_block    ; Get the current screen.
.b0e9		20 3a 84	jsr $843a	                jsr xt_cr
.b0ec		80 08		bra $b0f6	                bra _after_screen_msg
.b0ee						_screen_msg:
>b0ee		53 63 72 65 65 6e 20 23		                .text "Screen #"
.b0f6						_after_screen_msg:
.b0f6		20 61 a1	jsr $a161	                jsr sliteral_runtime
>b0f9		ee b0 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.b0fd		20 c4 94	jsr $94c4	                jsr xt_type
.b100		20 3a b0	jsr $b03a	                jsr xt_scr
.b103		20 1a 88	jsr $881a	                jsr xt_fetch
.b106		ca		dex		                dex
.b107		ca		dex		                dex
.b108		a9 04		lda #$04	                lda #4          ; four spaces
.b10a		95 00		sta $00,x	                sta 0,x
.b10c		74 01		stz $01,x	                stz 1,x
.b10e		20 fb 94	jsr $94fb	                jsr xt_u_dot_r
.b111		64 29		stz $29		                stz tmp3
.b113						_line_loop:
.b113		20 3a 84	jsr $843a	                jsr xt_cr
.b116		ca		dex		                dex
.b117		ca		dex		                dex
.b118		ca		dex		                dex
.b119		ca		dex		                dex
.b11a		74 03		stz $03,x	                stz 3,x
.b11c		a5 29		lda $29		                lda tmp3
.b11e		95 02		sta $02,x	                sta 2,x
.b120		74 01		stz $01,x	                stz 1,x
.b122		a9 02		lda #$02	                lda #2
.b124		95 00		sta $00,x	                sta 0,x
.b126		20 fb 94	jsr $94fb	                jsr xt_u_dot_r
.b129		20 cb 91	jsr $91cb	                jsr xt_space
.b12c		20 a0 86	jsr $86a0	                jsr xt_dup
.b12f		ca		dex		                dex
.b130		ca		dex		                dex
.b131		a9 40		lda #$40	                lda #64
.b133		95 00		sta $00,x	                sta 0,x
.b135		74 01		stz $01,x	                stz 1,x
.b137		20 c4 94	jsr $94c4	                jsr xt_type
.b13a		18		clc		                clc
.b13b		a9 40		lda #$40	                lda #64
.b13d		75 00		adc $00,x	                adc 0,x
.b13f		95 00		sta $00,x	                sta 0,x
.b141		90 02		bcc $b145	                bcc +
.b143		f6 01		inc $01,x	                inc 1,x
.b145						+
.b145		e6 29		inc $29		                inc tmp3
.b147		a5 29		lda $29		                lda tmp3
.b149		c9 10		cmp #$10	                cmp #16
.b14b		d0 c6		bne $b113	                bne _line_loop
.b14d		20 3a 84	jsr $843a	                jsr xt_cr
.b150		e8		inx		                inx
.b151		e8		inx		                inx
.b152		60		rts		z_editor_l:            rts
.b153						xt_editor_line:
.b153		20 75 d7	jsr $d775	                jsr underflow_1
.b156		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.b158						_shift_tos_left:
.b158		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.b15a		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.b15c		88		dey		                dey
.b15d		d0 f9		bne $b158	                bne _shift_tos_left
.b15f		20 3a b0	jsr $b03a	                jsr xt_scr
.b162		20 1a 88	jsr $881a	                jsr xt_fetch
.b165		20 86 ad	jsr $ad86	                jsr xt_block
.b168		20 53 8e	jsr $8e53	                jsr xt_plus
.b16b		60		rts		z_editor_line:  rts
.b16c						xt_editor_o:
.b16c		20 3a 84	jsr $843a	                jsr xt_cr
.b16f		20 a0 86	jsr $86a0	                jsr xt_dup
.b172		20 a7 9d	jsr $9da7	                jsr xt_two
.b175		20 fb 94	jsr $94fb	                jsr xt_u_dot_r
.b178		20 cb 91	jsr $91cb	                jsr xt_space
.b17b		a9 2a		lda #$2a	                lda #'*'
.b17d		20 c5 86	jsr $86c5	                jsr emit_a
.b180		20 cb 91	jsr $91cb	                jsr xt_space
.b183		20 53 b1	jsr $b153	                jsr xt_editor_line
.b186		20 a0 86	jsr $86a0	                jsr xt_dup      ; Save a copy of the line address for later.
.b189		ca		dex		                dex
.b18a		ca		dex		                dex
.b18b		a9 40		lda #$40	                lda #64         ; chars/line
.b18d		95 00		sta $00,x	                sta 0,x
.b18f		74 01		stz $01,x	                stz 1,x
.b191		20 e4 80	jsr $80e4	                jsr xt_accept
.b194		20 a0 86	jsr $86a0	                jsr xt_dup
.b197		20 60 9c	jsr $9c60	                jsr xt_not_rote ; -rot
.b19a		20 53 8e	jsr $8e53	                jsr xt_plus
.b19d		ca		dex		                dex
.b19e		ca		dex		                dex
.b19f		a9 40		lda #$40	                lda #64         ; chars/line
.b1a1		95 00		sta $00,x	                sta 0,x
.b1a3		74 01		stz $01,x	                stz 1,x
.b1a5		20 91 8f	jsr $8f91	                jsr xt_rot
.b1a8		20 e4 8b	jsr $8be4	                jsr xt_minus
.b1ab		20 b2 87	jsr $87b2	                jsr xt_blank
.b1ae		20 84 b0	jsr $b084	                jsr xt_update
.b1b1		60		rts		z_editor_o:     rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/wordlist.asm

.b1b2						xt_also:
.b1b2		20 dd b1	jsr $b1dd	                jsr xt_get_order
.b1b5		20 05 8d	jsr $8d05	                jsr xt_over
.b1b8		20 2e 92	jsr $922e	                jsr xt_swap
.b1bb		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.b1be		20 e6 b2	jsr $b2e6	                jsr xt_set_order
.b1c1		60		rts		z_also:         rts
.b1c2						xt_definitions:
.b1c2		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.b1c4		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.b1c6		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.b1c8		91 08		sta ($08),y	                sta (up),y
.b1ca		60		rts		z_definitions:  rts
.b1cb						xt_forth:
.b1cb		a0 23		ldy #$23	                ldy #search_order_offset
.b1cd		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.b1cf		91 08		sta ($08),y	                sta (up),y
.b1d1						z_forth:
.b1d1		60		rts		                rts
.b1d2						xt_get_current:
.b1d2		ca		dex		                dex
.b1d3		ca		dex		                dex
.b1d4		a0 08		ldy #$08	                ldy #current_offset
.b1d6		b1 08		lda ($08),y	                lda (up),y
.b1d8		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.b1da		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.b1dc		60		rts		z_get_current:  rts
.b1dd						xt_get_order:
.b1dd		a0 22		ldy #$22	                ldy #num_order_offset
.b1df		b1 08		lda ($08),y	                lda (up),y
.b1e1		85 25		sta $25		                sta tmp1
.b1e3		f0 16		beq $b1fb	                beq _done       ; If zero, there are no wordlists.
.b1e5						_loop:
.b1e5		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.b1e7		a9 23		lda #$23	                lda #search_order_offset
.b1e9		18		clc		                clc
.b1ea		65 25		adc $25		                adc tmp1
.b1ec		a8		tay		                tay
.b1ed		ca		dex		                dex
.b1ee		ca		dex		                dex
.b1ef		b1 08		lda ($08),y	                lda (up),y
.b1f1		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.b1f3		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.b1f5		a9 00		lda #$00	                lda #0
.b1f7		c5 25		cmp $25		                cmp tmp1
.b1f9		d0 ea		bne $b1e5	                bne _loop
.b1fb						_done:
.b1fb		ca		dex		                dex
.b1fc		ca		dex		                dex
.b1fd		a0 22		ldy #$22	                ldy #num_order_offset
.b1ff		b1 08		lda ($08),y	                lda (up),y
.b201		95 00		sta $00,x	                sta 0,x
.b203		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.b205		60		rts		z_get_order:    rts
.b206						xt_only:
.b206		20 84 93	jsr $9384	                jsr xt_true
.b209		20 e6 b2	jsr $b2e6	                jsr xt_set_order
.b20c		60		rts		z_only:         rts
.b20d						xt_order:
.b20d		20 3a 84	jsr $843a	                jsr xt_cr
.b210		20 dd b1	jsr $b1dd	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.b213		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.b215		f0 1e		beq $b235	                beq _drop_done
.b217		a8		tay		                tay
.b218						_loop:
.b218		e8		inx		                inx
.b219		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.b21a		b5 00		lda $00,x	                lda 0,x
.b21c		5a		phy		                phy
.b21d		20 38 b2	jsr $b238	                jsr order_print_wid_string   ; internal helper function
.b220		7a		ply		                ply
.b221		88		dey		                dey
.b222		d0 f4		bne $b218	                bne _loop
.b224		20 cb 91	jsr $91cb	                jsr xt_space
.b227		20 cb 91	jsr $91cb	                jsr xt_space
.b22a		20 d2 b1	jsr $b1d2	                jsr xt_get_current      ; ( wid )
.b22d		b5 00		lda $00,x	                lda 0,x
.b22f		20 38 b2	jsr $b238	                jsr order_print_wid_string
.b232		20 3a 84	jsr $843a	                jsr xt_cr
.b235						_drop_done:
.b235		e8		inx		                inx
.b236		e8		inx		                inx
.b237						z_order:
.b237		60		rts		                rts
.b238						order_print_wid_string:
.b238		c9 04		cmp #$04	                cmp #4
.b23a		90 09		bcc $b245	                bcc _output_string      ; less than 4, print a real string
.b23c		ca		dex		                dex
.b23d		ca		dex		                dex
.b23e		95 00		sta $00,x	                sta 0,x
.b240		74 01		stz $01,x	                stz 1,x
.b242		4c ef 94	jmp $94ef	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.b245						_output_string:
.b245		a8		tay		                tay
.b246		b9 4c b2	lda $b24c,y	                lda _wid_data,y
.b249		4c b1 d7	jmp $d7b1	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.b24c						_wid_data:
>b24c		04				        .byte str_wid_forth            ; WID 0: "Forth"
>b24d		05				        .byte str_wid_editor           ; WID 1: "Editor"
>b24e		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>b24f		07				        .byte str_wid_root             ; WID 3: "Root"
.b250						xt_previous:
.b250		20 dd b1	jsr $b1dd	                jsr xt_get_order
.b253		20 30 8c	jsr $8c30	                jsr xt_nip
.b256		20 dd 8c	jsr $8cdd	                jsr xt_one_minus
.b259		20 e6 b2	jsr $b2e6	                jsr xt_set_order
.b25c		60		rts		z_previous:     rts
.b25d						xt_root_wordlist:
.b25d		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.b25e		ca		dex		                dex
.b25f		a9 03		lda #$03	                lda #3
.b261		95 00		sta $00,x	                sta 0,x
.b263		74 01		stz $01,x	                stz 1,x
.b265						z_root_wordlist:
.b265		60		rts		                rts
.b266						xt_search_wordlist:
.b266		20 7f d7	jsr $d77f	                jsr underflow_3
.b269		a5 08		lda $08		                lda up
.b26b		18		clc		                clc
.b26c		69 0a		adc #$0a	                adc #wordlists_offset
.b26e		85 27		sta $27		                sta tmp2
.b270		a5 09		lda $09		                lda up+1
.b272		69 00		adc #$00	                adc #0          ; Adding carry
.b274		85 28		sta $28		                sta tmp2+1
.b276		b5 00		lda $00,x	                lda 0,x
.b278		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.b279		65 27		adc $27		                adc tmp2
.b27b		85 27		sta $27		                sta tmp2
.b27d		90 02		bcc $b281	                bcc +
.b27f		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.b281						+
.b281		e8		inx		                inx
.b282		e8		inx		                inx
.b283		b5 00		lda $00,x	                lda 0,x
.b285		15 01		ora $01,x	                ora 1,x
.b287		f0 4e		beq $b2d7	                beq _done
.b289		a5 27		lda $27		                lda tmp2
.b28b		05 28		ora $28		                ora tmp2+1
.b28d		f0 48		beq $b2d7	                beq _done
.b28f		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.b291		85 25		sta $25		                sta tmp1
.b293		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.b295		d0 02		bne $b299	                bne +
.b297		e6 28		inc $28		                inc tmp2+1
.b299						+
.b299		b2 27		lda ($27)	                lda (tmp2)
.b29b		85 26		sta $26		                sta tmp1+1
.b29d		20 57 d6	jsr $d657	                jsr find_header_name
.b2a0		f0 31		beq $b2d3	                beq _fail_done
.b2a2		e8		inx		                inx
.b2a3		e8		inx		                inx
.b2a4		a5 25		lda $25		                lda tmp1
.b2a6		95 00		sta $00,x	                sta 0,x
.b2a8		a5 26		lda $26		                lda tmp1+1
.b2aa		95 01		sta $01,x	                sta 1,x
.b2ac		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.b2af		20 19 9c	jsr $9c19	                jsr xt_name_to_int      ; ( nt xt )
.b2b2		20 2e 92	jsr $922e	                jsr xt_swap             ; ( xt nt )
.b2b5		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.b2b7		f6 00		inc $00,x	                inc 0,x
.b2b9		d0 02		bne $b2bd	                bne +
.b2bb		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.b2bd						+
.b2bd		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.b2bf		29 04		and #$04	                and #IM
.b2c1		d0 08		bne $b2cb	                bne _immediate          ; bit set, we're immediate
.b2c3		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.b2c5		95 00		sta $00,x	                sta 0,x
.b2c7		95 01		sta $01,x	                sta 1,x
.b2c9		80 0e		bra $b2d9	                bra _done_nodrop
.b2cb						_immediate:
.b2cb		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.b2cd		95 00		sta $00,x	                sta 0,x
.b2cf		74 01		stz $01,x	                stz 1,x
.b2d1		80 06		bra $b2d9	                bra _done_nodrop
.b2d3						_fail_done:
.b2d3		74 02		stz $02,x	                stz 2,x         ; failure flag
.b2d5		74 03		stz $03,x	                stz 3,x
.b2d7						_done:
.b2d7		e8		inx		                inx
.b2d8		e8		inx		                inx
.b2d9						_done_nodrop:
.b2d9						z_search_wordlist:
.b2d9		60		rts		                rts
.b2da						xt_set_current:
.b2da		20 75 d7	jsr $d775	                jsr underflow_1
.b2dd		a0 08		ldy #$08	                ldy #current_offset
.b2df		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.b2e1		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.b2e3		e8		inx		                inx
.b2e4		e8		inx		                inx
.b2e5		60		rts		z_set_current:  rts
.b2e6						xt_set_order:
.b2e6		a9 ff		lda #$ff	                lda #$FF
.b2e8		d5 01		cmp $01,x	                cmp 1,x
.b2ea		d0 12		bne $b2fe	                bne _start
.b2ec		d5 00		cmp $00,x	                cmp 0,x
.b2ee		d0 0e		bne $b2fe	                bne _start
.b2f0		ca		dex		                dex             ; Make room for the count.
.b2f1		ca		dex		                dex
.b2f2		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.b2f4		a9 03		lda #$03	                lda #3
.b2f6		95 02		sta $02,x	                sta 2,x
.b2f8		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.b2fa		a9 01		lda #$01	                lda #1
.b2fc		95 00		sta $00,x	                sta 0,x
.b2fe						_start:
.b2fe		a0 22		ldy #$22	                ldy #num_order_offset
.b300		b5 00		lda $00,x	                lda 0,x
.b302		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.b304		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.b306		e8		inx		                inx             ; Drop the count off the data stack.
.b307		e8		inx		                inx
.b308		a5 25		lda $25		                lda tmp1
.b30a		f0 0d		beq $b319	                beq _done       ; If zero, there are no wordlists.
.b30c		a0 23		ldy #$23	                ldy #search_order_offset
.b30e						_loop:
.b30e		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.b310		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.b312		c8		iny		                iny
.b313		e8		inx		                inx
.b314		e8		inx		                inx
.b315		c6 25		dec $25		                dec tmp1
.b317		d0 f5		bne $b30e	                bne _loop
.b319						_done:
.b319		60		rts		z_set_order:    rts
.b31a						xt_to_order:
.b31a		20 6c 93	jsr $936c	                jsr xt_to_r
.b31d		20 dd b1	jsr $b1dd	                jsr xt_get_order
.b320		20 f0 8e	jsr $8ef0	                jsr xt_r_from
.b323		20 2e 92	jsr $922e	                jsr xt_swap
.b326		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.b329		20 e6 b2	jsr $b2e6	                jsr xt_set_order
.b32c		60		rts		z_to_order:     rts
.b32d						xt_wordlist:
.b32d		a0 09		ldy #$09	                ldy #num_wordlists_offset
.b32f		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.b331		c9 0c		cmp #$0c	                cmp #max_wordlists
.b333		d0 05		bne $b33a	                bne _ok
.b335		a9 0b		lda #$0b	                lda #err_wordlist
.b337		4c 8b d7	jmp $d78b	                jmp error
.b33a						_ok:
.b33a		1a		inc a		                ina             ; Increment the wordlist#
.b33b		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.b33d		ca		dex		                dex             ; and put it on the stack.
.b33e		ca		dex		                dex
.b33f		95 00		sta $00,x	                sta 0,x
.b341		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.b343		60		rts		z_wordlist:     rts

;******  Return to file: platform/../words/all.asm


;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.b344						cold_zp_table:
>b344	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>b346	0002	27 bb				dp:         .word dictionary_start  ; Dictionary Pointer
>b348	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>b34a	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>b34c	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>b34e	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>b350	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>b352	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>b354	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>b356	0012	2d f0				output:     .word kernel_putc       ; vector for EMIT
>b358	0014	27 f0				input:      .word kernel_getc       ; vector for KEY
>b35a	0016	00 00				havekey:    .word 0                 ; vector for KEY?  (unused see https://github.com/SamCoVT/TaliForth2/issues/62)
>b35c	0018	0a 00				base:       .word 10                ; number radix, default decimal
>b35e	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>b360	001c	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>b362	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>b363	001f					loopctrl:   .byte ?         ; Offset and flags for DO/LOOP/+LOOP control.
>b364	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$100						lcbstack = $100
=256						loopindex = lcbstack+0      ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack+2      ; loop control block offset for limit fudge factor
>b365	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>b367	0023					tmptos:     .word ?         ; temporary TOS storage
>b369	0025					tmp1:       .word ?         ; temporary storage
>b36b	0027					tmp2:       .word ?         ; temporary storage
>b36d	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>b36f	002b					tohold:     .word ?         ; pointer for formatted output
>b371	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>b379	0035					tmped:      .word ?,?,?     ; temporary for editors
.b362						cold_zp_table_end:
.b362						cold_user_table:
>b362	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>b364	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>b366	0004	00 00				blk_offset:             .word 0         ; BLK
>b368	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
.b36a	0008					marker_start_offset:
>b36a	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>b36b	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.b36c	000a					wordlists_offset:
>b36c	000a	27 bb				    .word dictionary_start              ; FORTH-WORDLIST
>b36e	000c	86 c9				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>b370	000e	d6 c9				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>b372	0010	45 c9				    .word root_dictionary_start         ; ROOT-WORDLIST
>b374	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>b37c	001a	00 00 00 00 00 00 00 00
>b384	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.b385	0023					search_order_offset:
>b385	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>b38d	002b	00
.b38e	002c					marker_end_offset:
>b38e	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>b390	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>b392	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>b394	0032	6a af				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>b396	0034	6a af				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.b398						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$d0						OpBNE   = $D0
=$f0						OpBEQ   = $F0
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=64						ST = 64 ; Includes stack juggling stripped for native compile
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../opcodes.asm

.b398						oc_index_table:
>b398		98 b5 9c b5 43 ba 43 ba		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc07
>b3a0		a4 b5 aa b5 b0 b5 b6 b5
>b3a8		bd b5 c1 b5 c7 b5 43 ba		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>b3b0		cd b5 d1 b5 d5 b5 d9 b5
>b3b8		de b5 e2 b5 ea b5 43 ba		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>b3c0		f1 b5 f7 b5 fe b5 05 b6
>b3c8		0c b6 10 b6 16 b6 43 ba		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc1E, oc1F
>b3d0		1c b6 20 b6 26 b6 2c b6
>b3d8		31 b6 35 b6 43 ba 43 ba		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>b3e0		3d b6 43 b6 49 b6 4f b6
>b3e8		56 b6 5a b6 60 b6 43 ba		        .word oc28, oc29, oc2A, oc__, oc2C, oc2D, oc2E, oc2F
>b3f0		66 b6 6a b6 6f b6 73 b6
>b3f8		78 b6 7c b6 84 b6 43 ba		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>b400		8b b6 93 b6 9a b6 a1 b6
>b408		a8 b6 ac b6 b2 b6 43 ba		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc3F
>b410		b8 b6 be b6 c4 b6 ca b6
>b418		cf b6 d3 b6 43 ba 43 ba		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>b420		43 ba db b6 e1 b6 e7 b6
>b428		ee b6 f2 b6 f8 b6 43 ba		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>b430		fe b6 02 b7 06 b7 0a b7
>b438		0f b7 13 b7 1b b7 43 ba		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>b440		43 ba 22 b7 29 b7 30 b7
>b448		37 b7 3b b7 41 b7 43 ba		        .word oc58, oc59, oc5A, oc__, oc__, oc5D, oc5E, oc5F
>b450		43 ba 45 b7 4b b7 51 b7
>b458		56 b7 5a b7 43 ba 43 ba		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b460		62 b7 68 b7 6e b7 74 b7
>b468		7b b7 7f b7 85 b7 43 ba		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>b470		8b b7 91 b7 95 b7 99 b7
>b478		9e b7 a2 b7 aa b7 43 ba		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b480		b1 b7 b8 b7 bf b7 c6 b7
>b488		cd b7 d1 b7 d7 b7 43 ba		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>b490		db b7 e2 b7 e8 b7 ee b7
>b498		f3 b7 f7 b7 43 ba 43 ba		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc87
>b4a0		ff b7 05 b8 0b b8 11 b8
>b4a8		18 b8 1c b8 22 b8 43 ba		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>b4b0		26 b8 2a b8 2e b8 32 b8
>b4b8		37 b8 3b b8 43 b8 43 ba		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b4c0		4a b8 51 b8 58 b8 5f b8
>b4c8		66 b8 6a b8 70 b8 43 ba		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>b4d0		74 b8 78 b8 7e b8 84 b8
>b4d8		89 b8 8f b8 97 b8 43 ba		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>b4e0		9d b8 a3 b8 a9 b8 af b8
>b4e8		b6 b8 ba b8 c0 b8 43 ba		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>b4f0		c4 b8 c8 b8 cc b8 d0 b8
>b4f8		d5 b8 d9 b8 e1 b8 43 ba		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>b500		e8 b8 ef b8 f6 b8 fd b8
>b508		04 b9 08 b9 0e b9 43 ba		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>b510		12 b9 18 b9 1e b9 24 b9
>b518		29 b9 2f b9 43 ba 43 ba		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>b520		37 b9 3d b9 43 b9 49 b9
>b528		50 b9 54 b9 5a b9 43 ba		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>b530		5e b9 62 b9 66 b9 6a b9
>b538		6f b9 73 b9 7b b9 43 ba		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>b540		43 ba 82 b9 89 b9 90 b9
>b548		97 b9 9b b9 a1 b9 43 ba		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>b550		43 ba a5 b9 ab b9 b1 b9
>b558		b6 b9 bc b9 43 ba 43 ba		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>b560		c4 b9 ca b9 d0 b9 d6 b9
>b568		dd b9 e1 b9 e7 b9 43 ba		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>b570		eb b9 ef b9 f3 b9 f7 b9
>b578		fc b9 00 ba 08 ba 43 ba		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>b580		43 ba 0f ba 16 ba 1d ba
>b588		24 ba 28 ba 2e ba 43 ba		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>b590		43 ba 32 ba 38 ba 3e ba
>b598		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b59c		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b5a4		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b5aa		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b5b0		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b5b6		86 72 6d 62 30 2e 7a			oc07:	.text 2*64+6, "rmb0.z"
>b5bd		43 70 68 70				oc08:	.text 1*64+3, "php"
>b5c1		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b5c7		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>b5cd		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>b5d1		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>b5d5		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>b5d9		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>b5de		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b5e2		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b5ea		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b5f1		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b5f7		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b5fe		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b605		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b60c		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b610		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b616		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b61c		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b620		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b626		c5 61 73 6c 2e 78			oc1E:	.text 3*64+5, "asl.x"
>b62c		c4 62 62 72 31				oc1F:	.text 3*64+4, "bbr1"
>b631		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b635		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b63d		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b643		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b649		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b64f		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b656		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b65a		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b660		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b666		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b66a		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b66f		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b673		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b678		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b67c		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b684		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b68b		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b693		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b69a		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b6a1		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b6a8		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b6ac		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b6b2		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b6b8		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b6be		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b6c4		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b6ca		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b6cf		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b6d3		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b6db		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b6e1		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b6e7		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b6ee		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b6f2		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b6f8		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b6fe		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b702		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b706		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b70a		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b70f		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b713		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b71b		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b722		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b729		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b730		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b737		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b73b		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b741		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b745		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b74b		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b751		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b756		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b75a		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b762		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b768		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b76e		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b774		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b77b		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b77f		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b785		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b78b		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b791		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b795		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b799		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b79e		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b7a2		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b7aa		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b7b1		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b7b8		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b7bf		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b7c6		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b7cd		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b7d1		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b7d7		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b7db		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b7e2		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b7e8		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b7ee		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b7f3		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b7f7		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b7ff		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b805		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b80b		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b811		86 73 6d 62 30 2e 7a			oc87:	.text 2*64+6, "smb0.z"
>b818		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b81c		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b822		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b826		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b82a		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b82e		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b832		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b837		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b83b		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b843		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b84a		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b851		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b858		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b85f		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b866		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b86a		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b870		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b874		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b878		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b87e		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b884		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b889		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b88f		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b897		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b89d		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b8a3		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b8a9		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b8af		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b8b6		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b8ba		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b8c0		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b8c4		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b8c8		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b8cc		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b8d0		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b8d5		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b8d9		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b8e1		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b8e8		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b8ef		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b8f6		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b8fd		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b904		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b908		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b90e		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>b912		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>b918		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>b91e		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>b924		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>b929		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>b92f		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>b937		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>b93d		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>b943		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>b949		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>b950		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>b954		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>b95a		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>b95e		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>b962		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>b966		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>b96a		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>b96f		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>b973		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>b97b		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>b982		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>b989		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>b990		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>b997		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>b99b		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>b9a1		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>b9a5		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>b9ab		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>b9b1		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>b9b6		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>b9bc		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>b9c4		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>b9ca		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>b9d0		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>b9d6		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>b9dd		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>b9e1		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>b9e7		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>b9eb		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>b9ef		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>b9f3		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>b9f7		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>b9fc		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>ba00		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>ba08		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>ba0f		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>ba16		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>ba1d		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>ba24		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>ba28		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>ba2e		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>ba32		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>ba38		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>ba3e		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>ba43		01 3f					oc__:	.text 1, "?"

;******  Return to file: platform/../taliforth.asm

.ba45						forth_words_start:
>ba45		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>ba4d		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>ba5d		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>ba6d		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>ba7d		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>ba8d		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>ba9d		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>baad		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>babd		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>bacd		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>badd		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>baed		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>bafd		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bb0d		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bb1d		78 69 74 29 20 63 72 20
.bb25						forth_words_end:
.bb25						user_words_start:
>bb25		20 20				.binary "user_words.asc"
.bb27						user_words_end:

;******  Processing file: platform/../words/headers.asm

.bb27						dictionary_start:
="drop"						    _s := "" ? "" : str(.drop)
>bb27		04 10				    .byte len(_s), UF
>bb29		33 bb 9a 86 9f 86		    .word false ? 0 : +, xt_drop, z_drop
>bb2f		64 72 6f 70			    .text _s
.bb33						+
="dup"						    _s := "" ? "" : str(.dup)
>bb33		03 10				    .byte len(_s), UF
>bb35		3e bb a0 86 ad 86		    .word false ? 0 : +, xt_dup, z_dup
>bb3b		64 75 70			    .text _s
.bb3e						+
="swap"						    _s := "" ? "" : str(.swap)
>bb3e		04 10				    .byte len(_s), UF
>bb40		4a bb 2e 92 41 92		    .word false ? 0 : +, xt_swap, z_swap
>bb46		73 77 61 70			    .text _s
.bb4a						+
="!"						    _s := "!" ? "!" : str(.store)
>bb4a		01 10				    .byte len(_s), UF
>bb4c		53 bb 18 92 2d 92		    .word false ? 0 : +, xt_store, z_store
>bb52		21				    .text _s
.bb53						+
="@"						    _s := "@" ? "@" : str(.fetch)
>bb53		01 10				    .byte len(_s), UF
>bb55		5c bb 1a 88 2c 88		    .word false ? 0 : +, xt_fetch, z_fetch
>bb5b		40				    .text _s
.bb5c						+
="over"						    _s := "" ? "" : str(.over)
>bb5c		04 10				    .byte len(_s), UF
>bb5e		68 bb 05 8d 12 8d		    .word false ? 0 : +, xt_over, z_over
>bb64		6f 76 65 72			    .text _s
.bb68						+
=">r"						    _s := ">r" ? ">r" : str(.to_r)
>bb68		02 51				    .byte len(_s), CO+UF+ST
>bb6a		72 bb 6c 93 81 93		    .word false ? 0 : +, xt_to_r, z_to_r
>bb70		3e 72				    .text _s
.bb72						+
="r>"						    _s := "r>" ? "r>" : str(.r_from)
>bb72		02 41				    .byte len(_s), CO+ST
>bb74		7c bb f0 8e 02 8f		    .word false ? 0 : +, xt_r_from, z_r_from
>bb7a		72 3e				    .text _s
.bb7c						+
="r@"						    _s := "r@" ? "r@" : str(.r_fetch)
>bb7c		02 41				    .byte len(_s), CO+ST
>bb7e		86 bb d9 8e ed 8e		    .word false ? 0 : +, xt_r_fetch, z_r_fetch
>bb84		72 40				    .text _s
.bb86						+
="nip"						    _s := "" ? "" : str(.nip)
>bb86		03 10				    .byte len(_s), UF
>bb88		91 bb 30 8c 3d 8c		    .word false ? 0 : +, xt_nip, z_nip
>bb8e		6e 69 70			    .text _s
.bb91						+
="rot"						    _s := "" ? "" : str(.rot)
>bb91		03 10				    .byte len(_s), UF
>bb93		9c bb 91 8f ac 8f		    .word false ? 0 : +, xt_rot, z_rot
>bb99		72 6f 74			    .text _s
.bb9c						+
="-rot"						    _s := "-rot" ? "-rot" : str(.not_rote)
>bb9c		04 10				    .byte len(_s), UF
>bb9e		a8 bb 60 9c 7b 9c		    .word false ? 0 : +, xt_not_rote, z_not_rote
>bba4		2d 72 6f 74			    .text _s
.bba8						+
="tuck"						    _s := "" ? "" : str(.tuck)
>bba8		04 10				    .byte len(_s), UF
>bbaa		b4 bb 8d 93 a6 93		    .word false ? 0 : +, xt_tuck, z_tuck
>bbb0		74 75 63 6b			    .text _s
.bbb4						+
=","						    _s := "," ? "," : str(.comma)
>bbb4		01 10				    .byte len(_s), UF
>bbb6		bd bb cd 83 db 83		    .word false ? 0 : +, xt_comma, z_comma
>bbbc		2c				    .text _s
.bbbd						+
="c@"						    _s := "c@" ? "c@" : str(.c_fetch)
>bbbd		02 10				    .byte len(_s), UF
>bbbf		c7 bb 2d 83 36 83		    .word false ? 0 : +, xt_c_fetch, z_c_fetch
>bbc5		63 40				    .text _s
.bbc7						+
="c!"						    _s := "c!" ? "c!" : str(.c_store)
>bbc7		02 10				    .byte len(_s), UF
>bbc9		d1 bb 37 83 42 83		    .word false ? 0 : +, xt_c_store, z_c_store
>bbcf		63 21				    .text _s
.bbd1						+
="+!"						    _s := "+!" ? "+!" : str(.plus_store)
>bbd1		02 10				    .byte len(_s), UF
>bbd3		db bb 66 8e 85 8e		    .word false ? 0 : +, xt_plus_store, z_plus_store
>bbd9		2b 21				    .text _s
.bbdb						+
="0"						    _s := "0" ? "0" : str(.zero)
>bbdb		01 00				    .byte len(_s), 0
>bbdd		e4 bb dc 9d e2 9d		    .word false ? 0 : +, xt_zero, z_zero
>bbe3		30				    .text _s
.bbe4						+
="1"						    _s := "1" ? "1" : str(.one)
>bbe4		01 00				    .byte len(_s), 0
>bbe6		ed bb 76 9d 7e 9d		    .word false ? 0 : +, xt_one, z_one
>bbec		31				    .text _s
.bbed						+
="2"						    _s := "2" ? "2" : str(.two)
>bbed		01 00				    .byte len(_s), 0
>bbef		f6 bb a7 9d af 9d		    .word false ? 0 : +, xt_two, z_two
>bbf5		32				    .text _s
.bbf6						+
="execute"					    _s := "" ? "" : str(.execute)
>bbf6		07 10				    .byte len(_s), UF
>bbf8		05 bc 05 88 0b 88		    .word false ? 0 : +, xt_execute, z_execute
>bbfe		65 78 65 63 75 74 65		    .text _s
.bc05						+
="emit"						    _s := "" ? "" : str(.emit)
>bc05		04 18				    .byte len(_s), NN+UF
>bc07		11 bc be 86 c8 86		    .word false ? 0 : +, xt_emit, z_emit
>bc0d		65 6d 69 74			    .text _s
.bc11						+
="type"						    _s := "" ? "" : str(.type)
>bc11		04 10				    .byte len(_s), UF
>bc13		1d bc c4 94 ee 94		    .word false ? 0 : +, xt_type, z_type
>bc19		74 79 70 65			    .text _s
.bc1d						+
="."						    _s := "." ? "." : str(.dot)
>bc1d		01 10				    .byte len(_s), UF
>bc1f		26 bc 30 86 51 86		    .word false ? 0 : +, xt_dot, z_dot
>bc25		2e				    .text _s
.bc26						+
="u."						    _s := "u." ? "u." : str(.u_dot)
>bc26		02 10				    .byte len(_s), UF
>bc28		30 bc ef 94 fa 94		    .word false ? 0 : +, xt_u_dot, z_u_dot
>bc2e		75 2e				    .text _s
.bc30						+
="u.r"						    _s := "u.r" ? "u.r" : str(.u_dot_r)
>bc30		03 10				    .byte len(_s), UF
>bc32		3b bc fb 94 1c 95		    .word false ? 0 : +, xt_u_dot_r, z_u_dot_r
>bc38		75 2e 72			    .text _s
.bc3b						+
=".r"						    _s := ".r" ? ".r" : str(.dot_r)
>bc3b		02 10				    .byte len(_s), UF
>bc3d		45 bc 6c 86 99 86		    .word false ? 0 : +, xt_dot_r, z_dot_r
>bc43		2e 72				    .text _s
.bc45						+
="d."						    _s := "d." ? "d." : str(.d_dot)
>bc45		02 10				    .byte len(_s), UF
>bc47		4f bc 65 9e 83 9e		    .word false ? 0 : +, xt_d_dot, z_d_dot
>bc4d		64 2e				    .text _s
.bc4f						+
="d.r"						    _s := "d.r" ? "d.r" : str(.d_dot_r)
>bc4f		03 10				    .byte len(_s), UF
>bc51		5a bc 84 9e ae 9e		    .word false ? 0 : +, xt_d_dot_r, z_d_dot_r
>bc57		64 2e 72			    .text _s
.bc5a						+
="ud."						    _s := "ud." ? "ud." : str(.ud_dot)
>bc5a		03 10				    .byte len(_s), UF
>bc5c		65 bc fb 9e 0d 9f		    .word false ? 0 : +, xt_ud_dot, z_ud_dot
>bc62		75 64 2e			    .text _s
.bc65						+
="ud.r"						    _s := "ud.r" ? "ud.r" : str(.ud_dot_r)
>bc65		04 10				    .byte len(_s), UF
>bc67		71 bc 0e 9f 2c 9f		    .word false ? 0 : +, xt_ud_dot_r, z_ud_dot_r
>bc6d		75 64 2e 72			    .text _s
.bc71						+
="?"						    _s := "?" ? "?" : str(.question)
>bc71		01 00				    .byte len(_s), 0
>bc73		7a bc 07 99 0d 99		    .word false ? 0 : +, xt_question, z_question
>bc79		3f				    .text _s
.bc7a						+
="false"					    _s := "false" ? "false" : str(.false)
>bc7a		05 00				    .byte len(_s), 0
>bc7c		87 bc dc 9d e2 9d		    .word false ? 0 : +, xt_false, z_false
>bc82		66 61 6c 73 65			    .text _s
.bc87						+
="true"						    _s := "true" ? "true" : str(.true)
>bc87		04 00				    .byte len(_s), 0
>bc89		93 bc 84 93 8c 93		    .word false ? 0 : +, xt_true, z_true
>bc8f		74 72 75 65			    .text _s
.bc93						+
="space"					    _s := "" ? "" : str(.space)
>bc93		05 00				    .byte len(_s), 0
>bc95		a0 bc cb 91 d0 91		    .word false ? 0 : +, xt_space, z_space
>bc9b		73 70 61 63 65			    .text _s
.bca0						+
="2dup"						    _s := "2dup" ? "2dup" : str(.two_dup)
>bca0		04 10				    .byte len(_s), UF
>bca2		ac bc af 93 c6 93		    .word false ? 0 : +, xt_two_dup, z_two_dup
>bca8		32 64 75 70			    .text _s
.bcac						+
="?dup"						    _s := "?dup" ? "?dup" : str(.question_dup)
>bcac		04 10				    .byte len(_s), UF
>bcae		b8 bc c5 8e d8 8e		    .word false ? 0 : +, xt_question_dup, z_question_dup
>bcb4		3f 64 75 70			    .text _s
.bcb8						+
="+"						    _s := "+" ? "+" : str(.plus)
>bcb8		01 10				    .byte len(_s), UF
>bcba		c1 bc 53 8e 65 8e		    .word false ? 0 : +, xt_plus, z_plus
>bcc0		2b				    .text _s
.bcc1						+
="-"						    _s := "-" ? "-" : str(.minus)
>bcc1		01 10				    .byte len(_s), UF
>bcc3		ca bc e4 8b f6 8b		    .word false ? 0 : +, xt_minus, z_minus
>bcc9		2d				    .text _s
.bcca						+
="1-"						    _s := "1-" ? "1-" : str(.one_minus)
>bcca		02 10				    .byte len(_s), UF
>bccc		d4 bc dd 8c e8 8c		    .word false ? 0 : +, xt_one_minus, z_one_minus
>bcd2		31 2d				    .text _s
.bcd4						+
="1+"						    _s := "1+" ? "1+" : str(.one_plus)
>bcd4		02 10				    .byte len(_s), UF
>bcd6		de bc e9 8c f2 8c		    .word false ? 0 : +, xt_one_plus, z_one_plus
>bcdc		31 2b				    .text _s
.bcde						+
="2*"						    _s := "2*" ? "2*" : str(.two_star)
>bcde		02 10				    .byte len(_s), UF
>bce0		e8 bc 52 94 59 94		    .word false ? 0 : +, xt_two_star, z_two_star
>bce6		32 2a				    .text _s
.bce8						+
="2/"						    _s := "2/" ? "2/" : str(.two_slash)
>bce8		02 10				    .byte len(_s), UF
>bcea		f2 bc 47 94 51 94		    .word false ? 0 : +, xt_two_slash, z_two_slash
>bcf0		32 2f				    .text _s
.bcf2						+
="abs"						    _s := "" ? "" : str(.abs)
>bcf2		03 10				    .byte len(_s), UF
>bcf4		fd bc cf 80 e3 80		    .word false ? 0 : +, xt_abs, z_abs
>bcfa		61 62 73			    .text _s
.bcfd						+
="dabs"						    _s := "" ? "" : str(.dabs)
>bcfd		04 10				    .byte len(_s), UF
>bcff		09 bd 2b 9e 49 9e		    .word false ? 0 : +, xt_dabs, z_dabs
>bd05		64 61 62 73			    .text _s
.bd09						+
="and"						    _s := "" ? "" : str(.and)
>bd09		03 10				    .byte len(_s), UF
>bd0b		14 bd 90 82 a1 82		    .word false ? 0 : +, xt_and, z_and
>bd11		61 6e 64			    .text _s
.bd14						+
="or"						    _s := "" ? "" : str(.or)
>bd14		02 10				    .byte len(_s), UF
>bd16		1e bd f3 8c 04 8d		    .word false ? 0 : +, xt_or, z_or
>bd1c		6f 72				    .text _s
.bd1e						+
="xor"						    _s := "" ? "" : str(.xor)
>bd1e		03 10				    .byte len(_s), UF
>bd20		29 bd 6f 96 80 96		    .word false ? 0 : +, xt_xor, z_xor
>bd26		78 6f 72			    .text _s
.bd29						+
="rshift"					    _s := "" ? "" : str(.rshift)
>bd29		06 10				    .byte len(_s), UF
>bd2b		37 bd ad 8f c0 8f		    .word false ? 0 : +, xt_rshift, z_rshift
>bd31		72 73 68 69 66 74		    .text _s
.bd37						+
="lshift"					    _s := "" ? "" : str(.lshift)
>bd37		06 10				    .byte len(_s), UF
>bd39		45 bd 0d 8b 20 8b		    .word false ? 0 : +, xt_lshift, z_lshift
>bd3f		6c 73 68 69 66 74		    .text _s
.bd45						+
="pick"						    _s := "" ? "" : str(.pick)
>bd45		04 00				    .byte len(_s), 0
>bd47		51 bd 42 8e 52 8e		    .word false ? 0 : +, xt_pick, z_pick
>bd4d		70 69 63 6b			    .text _s
.bd51						+
="char"						    _s := "" ? "" : str(.char)
>bd51		04 00				    .byte len(_s), 0
>bd53		5d bd 53 83 69 83		    .word false ? 0 : +, xt_char, z_char
>bd59		63 68 61 72			    .text _s
.bd5d						+
="[char]"					    _s := "[char]" ? "[char]" : str(.bracket_char)
>bd5d		06 05				    .byte len(_s), CO+IM
>bd5f		6b bd 0d 83 13 83		    .word false ? 0 : +, xt_bracket_char, z_bracket_char
>bd65		5b 63 68 61 72 5d		    .text _s
.bd6b						+
="char+"					    _s := "char+" ? "char+" : str(.char_plus)
>bd6b		05 00				    .byte len(_s), 0
>bd6d		78 bd e9 8c f2 8c		    .word false ? 0 : +, xt_char_plus, z_char_plus
>bd73		63 68 61 72 2b			    .text _s
.bd78						+
="chars"					    _s := "" ? "" : str(.chars)
>bd78		05 10				    .byte len(_s), UF
>bd7a		85 bd 6a 83 6d 83		    .word false ? 0 : +, xt_chars, z_chars
>bd80		63 68 61 72 73			    .text _s
.bd85						+
="cells"					    _s := "" ? "" : str(.cells)
>bd85		05 00				    .byte len(_s), 0
>bd87		92 bd 52 94 59 94		    .word false ? 0 : +, xt_cells, z_cells
>bd8d		63 65 6c 6c 73			    .text _s
.bd92						+
="cell+"					    _s := "cell+" ? "cell+" : str(.cell_plus)
>bd92		05 10				    .byte len(_s), UF
>bd94		9f bd 43 83 52 83		    .word false ? 0 : +, xt_cell_plus, z_cell_plus
>bd9a		63 65 6c 6c 2b			    .text _s
.bd9f						+
="here"						    _s := "" ? "" : str(.here)
>bd9f		04 00				    .byte len(_s), 0
>bda1		ab bd 1b 89 25 89		    .word false ? 0 : +, xt_here, z_here
>bda7		68 65 72 65			    .text _s
.bdab						+
="="						    _s := "=" ? "=" : str(.equal)
>bdab		01 10				    .byte len(_s), UF
>bdad		b4 bd 96 87 b1 87		    .word false ? 0 : +, xt_equal, z_equal
>bdb3		3d				    .text _s
.bdb4						+
="<>"						    _s := "<>" ? "<>" : str(.not_equals)
>bdb4		02 10				    .byte len(_s), UF
>bdb6		be bd 3e 8c 5b 8c		    .word false ? 0 : +, xt_not_equals, z_not_equals
>bdbc		3c 3e				    .text _s
.bdbe						+
="<"						    _s := "<" ? "<" : str(.less_than)
>bdbe		01 10				    .byte len(_s), UF
>bdc0		c7 bd dd 89 f1 89		    .word false ? 0 : +, xt_less_than, z_less_than
>bdc6		3c				    .text _s
.bdc7						+
="u<"						    _s := "u<" ? "u<" : str(.u_less_than)
>bdc7		02 10				    .byte len(_s), UF
>bdc9		d1 bd 33 95 48 95		    .word false ? 0 : +, xt_u_less_than, z_u_less_than
>bdcf		75 3c				    .text _s
.bdd1						+
="u>"						    _s := "u>" ? "u>" : str(.u_greater_than)
>bdd1		02 10				    .byte len(_s), UF
>bdd3		db bd 1d 95 32 95		    .word false ? 0 : +, xt_u_greater_than, z_u_greater_than
>bdd9		75 3e				    .text _s
.bddb						+
=">"						    _s := ">" ? ">" : str(.greater_than)
>bddb		01 10				    .byte len(_s), UF
>bddd		e4 bd 06 89 1a 89		    .word false ? 0 : +, xt_greater_than, z_greater_than
>bde3		3e				    .text _s
.bde4						+
="0="						    _s := "0=" ? "0=" : str(.zero_equal)
>bde4		02 10				    .byte len(_s), UF
>bde6		ee bd 81 96 92 96		    .word false ? 0 : +, xt_zero_equal, z_zero_equal
>bdec		30 3d				    .text _s
.bdee						+
="0<>"						    _s := "0<>" ? "0<>" : str(.zero_unequal)
>bdee		03 10				    .byte len(_s), UF
>bdf0		f9 bd b7 96 c6 96		    .word false ? 0 : +, xt_zero_unequal, z_zero_unequal
>bdf6		30 3c 3e			    .text _s
.bdf9						+
="0>"						    _s := "0>" ? "0>" : str(.zero_greater)
>bdf9		02 10				    .byte len(_s), UF
>bdfb		03 be 93 96 a6 96		    .word false ? 0 : +, xt_zero_greater, z_zero_greater
>be01		30 3e				    .text _s
.be03						+
="0<"						    _s := "0<" ? "0<" : str(.zero_less)
>be03		02 10				    .byte len(_s), UF
>be05		0d be a7 96 b6 96		    .word false ? 0 : +, xt_zero_less, z_zero_less
>be0b		30 3c				    .text _s
.be0d						+
="min"						    _s := "" ? "" : str(.min)
>be0d		03 10				    .byte len(_s), UF
>be0f		18 be c8 8b e3 8b		    .word false ? 0 : +, xt_min, z_min
>be15		6d 69 6e			    .text _s
.be18						+
="max"						    _s := "" ? "" : str(.max)
>be18		03 10				    .byte len(_s), UF
>be1a		23 be ac 8b c7 8b		    .word false ? 0 : +, xt_max, z_max
>be20		6d 61 78			    .text _s
.be23						+
="2drop"					    _s := "2drop" ? "2drop" : str(.two_drop)
>be23		05 10				    .byte len(_s), UF
>be25		30 be a7 93 ae 93		    .word false ? 0 : +, xt_two_drop, z_two_drop
>be2b		32 64 72 6f 70			    .text _s
.be30						+
="2swap"					    _s := "2swap" ? "2swap" : str(.two_swap)
>be30		05 10				    .byte len(_s), UF
>be32		3d be 80 94 a3 94		    .word false ? 0 : +, xt_two_swap, z_two_swap
>be38		32 73 77 61 70			    .text _s
.be3d						+
="2over"					    _s := "2over" ? "2over" : str(.two_over)
>be3d		05 10				    .byte len(_s), UF
>be3f		4a be e9 93 00 94		    .word false ? 0 : +, xt_two_over, z_two_over
>be45		32 6f 76 65 72			    .text _s
.be4a						+
="2!"						    _s := "2!" ? "2!" : str(.two_store)
>be4a		02 10				    .byte len(_s), UF
>be4c		54 be 5a 94 7f 94		    .word false ? 0 : +, xt_two_store, z_two_store
>be52		32 21				    .text _s
.be54						+
="2@"						    _s := "2@" ? "2@" : str(.two_fetch)
>be54		02 10				    .byte len(_s), UF
>be56		5e be c7 93 e8 93		    .word false ? 0 : +, xt_two_fetch, z_two_fetch
>be5c		32 40				    .text _s
.be5e						+
="2variable"					    _s := "2variable" ? "2variable" : str(.two_variable)
>be5e		09 00				    .byte len(_s), 0
>be60		6f be ec 9e fa 9e		    .word false ? 0 : +, xt_two_variable, z_two_variable
>be66		32 76 61 72 69 61 62 6c		    .text _s
>be6e		65
.be6f						+
="2constant"					    _s := "2constant" ? "2constant" : str(.two_constant)
>be6f		09 10				    .byte len(_s), UF
>be71		80 be af 9e d3 9e		    .word false ? 0 : +, xt_two_constant, z_two_constant
>be77		32 63 6f 6e 73 74 61 6e		    .text _s
>be7f		74
.be80						+
="2literal"					    _s := "2literal" ? "2literal" : str(.two_literal)
>be80		08 14				    .byte len(_s), UF+IM
>be82		90 be d4 9e eb 9e		    .word false ? 0 : +, xt_two_literal, z_two_literal
>be88		32 6c 69 74 65 72 61 6c		    .text _s
.be90						+
="2r@"						    _s := "2r@" ? "2r@" : str(.two_r_fetch)
>be90		03 49				    .byte len(_s), CO+NN+ST
>be92		9b be 01 94 27 94		    .word false ? 0 : +, xt_two_r_fetch, z_two_r_fetch
>be98		32 72 40			    .text _s
.be9b						+
="2r>"						    _s := "2r>" ? "2r>" : str(.two_r_from)
>be9b		03 41				    .byte len(_s), CO+ST
>be9d		a6 be 2a 94 44 94		    .word false ? 0 : +, xt_two_r_from, z_two_r_from
>bea3		32 72 3e			    .text _s
.bea6						+
="2>r"						    _s := "2>r" ? "2>r" : str(.two_to_r)
>bea6		03 51				    .byte len(_s), CO+UF+ST
>bea8		b1 be a4 94 c1 94		    .word false ? 0 : +, xt_two_to_r, z_two_to_r
>beae		32 3e 72			    .text _s
.beb1						+
="invert"					    _s := "" ? "" : str(.invert)
>beb1		06 10				    .byte len(_s), UF
>beb3		bf be 64 89 73 89		    .word false ? 0 : +, xt_invert, z_invert
>beb9		69 6e 76 65 72 74		    .text _s
.bebf						+
="negate"					    _s := "" ? "" : str(.negate)
>bebf		06 10				    .byte len(_s), UF
>bec1		cd be 1f 8c 2f 8c		    .word false ? 0 : +, xt_negate, z_negate
>bec7		6e 65 67 61 74 65		    .text _s
.becd						+
="dnegate"					    _s := "" ? "" : str(.dnegate)
>becd		07 10				    .byte len(_s), UF
>becf		dc be 4a 9e 64 9e		    .word false ? 0 : +, xt_dnegate, z_dnegate
>bed5		64 6e 65 67 61 74 65		    .text _s
.bedc						+
="c,"						    _s := "c," ? "c," : str(.c_comma)
>bedc		02 10				    .byte len(_s), UF
>bede		e6 be 22 83 2c 83		    .word false ? 0 : +, xt_c_comma, z_c_comma
>bee4		63 2c				    .text _s
.bee6						+
="bounds"					    _s := "" ? "" : str(.bounds)
>bee6		06 10				    .byte len(_s), UF
>bee8		f4 be 19 9a 31 9a		    .word false ? 0 : +, xt_bounds, z_bounds
>beee		62 6f 75 6e 64 73		    .text _s
.bef4						+
="spaces"					    _s := "" ? "" : str(.spaces)
>bef4		06 10				    .byte len(_s), UF
>bef6		02 bf d1 91 ea 91		    .word false ? 0 : +, xt_spaces, z_spaces
>befc		73 70 61 63 65 73		    .text _s
.bf02						+
="bl"						    _s := "" ? "" : str(.bl)
>bf02		02 00				    .byte len(_s), 0
>bf04		0c bf 04 83 0c 83		    .word false ? 0 : +, xt_bl, z_bl
>bf0a		62 6c				    .text _s
.bf0c						+
="-trailing"					    _s := "-trailing" ? "-trailing" : str(.minus_trailing)
>bf0c		09 10				    .byte len(_s), UF
>bf0e		1d bf 21 a0 5d a0		    .word false ? 0 : +, xt_minus_trailing, z_minus_trailing
>bf14		2d 74 72 61 69 6c 69 6e		    .text _s
>bf1c		67
.bf1d						+
="-leading"					    _s := "-leading" ? "-leading" : str(.minus_leading)
>bf1d		08 10				    .byte len(_s), UF
>bf1f		2d bf 08 a0 20 a0		    .word false ? 0 : +, xt_minus_leading, z_minus_leading
>bf25		2d 6c 65 61 64 69 6e 67		    .text _s
.bf2d						+
="/string"					    _s := "/string" ? "/string" : str(.slash_string)
>bf2d		07 10				    .byte len(_s), UF
>bf2f		3c bf fd a0 1c a1		    .word false ? 0 : +, xt_slash_string, z_slash_string
>bf35		2f 73 74 72 69 6e 67		    .text _s
.bf3c						+
="refill"					    _s := "" ? "" : str(.refill)
>bf3c		06 00				    .byte len(_s), 0
>bf3e		4a bf 42 8f 83 8f		    .word false ? 0 : +, xt_refill, z_refill
>bf44		72 65 66 69 6c 6c		    .text _s
.bf4a						+
="accept"					    _s := "" ? "" : str(.accept)
>bf4a		06 18				    .byte len(_s), UF+NN
>bf4c		58 bf e4 80 dc 81		    .word false ? 0 : +, xt_accept, z_accept
>bf52		61 63 63 65 70 74		    .text _s
.bf58						+
="input>r"					    _s := "input>r" ? "input>r" : str(.input_to_r)
>bf58		07 08				    .byte len(_s), NN
>bf5a		67 bf 7d 9b 92 9b		    .word false ? 0 : +, xt_input_to_r, z_input_to_r
>bf60		69 6e 70 75 74 3e 72		    .text _s
.bf67						+
="r>input"					    _s := "r>input" ? "r>input" : str(.r_to_input)
>bf67		07 08				    .byte len(_s), NN
>bf69		76 bf 8a 9d a1 9d		    .word false ? 0 : +, xt_r_to_input, z_r_to_input
>bf6f		72 3e 69 6e 70 75 74		    .text _s
.bf76						+
="unused"					    _s := "" ? "" : str(.unused)
>bf76		06 00				    .byte len(_s), 0
>bf78		84 bf e5 95 f4 95		    .word false ? 0 : +, xt_unused, z_unused
>bf7e		75 6e 75 73 65 64		    .text _s
.bf84						+
="depth"					    _s := "" ? "" : str(.depth)
>bf84		05 00				    .byte len(_s), 0
>bf86		91 bf 52 85 60 85		    .word false ? 0 : +, xt_depth, z_depth
>bf8c		64 65 70 74 68			    .text _s
.bf91						+
="key"						    _s := "" ? "" : str(.key)
>bf91		03 00				    .byte len(_s), 0
>bf93		9c bf a7 89 b0 89		    .word false ? 0 : +, xt_key, z_key
>bf99		6b 65 79			    .text _s
.bf9c						+
="allot"					    _s := "" ? "" : str(.allot)
>bf9c		05 10				    .byte len(_s), UF
>bf9e		a9 bf 27 82 8f 82		    .word false ? 0 : +, xt_allot, z_allot
>bfa4		61 6c 6c 6f 74			    .text _s
.bfa9						+
="create"					    _s := "" ? "" : str(.create)
>bfa9		06 00				    .byte len(_s), 0
>bfab		b7 bf 40 84 09 85		    .word false ? 0 : +, xt_create, z_create
>bfb1		63 72 65 61 74 65		    .text _s
.bfb7						+
="does>"					    _s := "does>" ? "does>" : str(.does)
>bfb7		05 05				    .byte len(_s), CO+IM
>bfb9		c4 bf ef 85 fd 85		    .word false ? 0 : +, xt_does, z_does
>bfbf		64 6f 65 73 3e			    .text _s
.bfc4						+
="variable"					    _s := "" ? "" : str(.variable)
>bfc4		08 00				    .byte len(_s), 0
>bfc6		d4 bf f5 95 0d 96		    .word false ? 0 : +, xt_variable, z_variable
>bfcc		76 61 72 69 61 62 6c 65		    .text _s
.bfd4						+
="constant"					    _s := "" ? "" : str(.constant)
>bfd4		08 10				    .byte len(_s), UF
>bfd6		e4 bf e8 83 25 84		    .word false ? 0 : +, xt_constant, z_constant
>bfdc		63 6f 6e 73 74 61 6e 74		    .text _s
.bfe4						+
="value"					    _s := "" ? "" : str(.value)
>bfe4		05 10				    .byte len(_s), UF
>bfe6		f1 bf e8 83 25 84		    .word false ? 0 : +, xt_value, z_value
>bfec		76 61 6c 75 65			    .text _s
.bff1						+
="to"						    _s := "" ? "" : str(.to)
>bff1		02 0c				    .byte len(_s), NN+IM
>bff3		fb bf 62 92 9d 92		    .word false ? 0 : +, xt_to, z_to
>bff9		74 6f				    .text _s
.bffb						+
="s>d"						    _s := "s>d" ? "s>d" : str(.s_to_d)
>bffb		03 10				    .byte len(_s), UF
>bffd		06 c0 df 90 f0 90		    .word false ? 0 : +, xt_s_to_d, z_s_to_d
>c003		73 3e 64			    .text _s
.c006						+
="d>s"						    _s := "d>s" ? "d>s" : str(.d_to_s)
>c006		03 10				    .byte len(_s), UF
>c008		11 c0 25 9e 2a 9e		    .word false ? 0 : +, xt_d_to_s, z_d_to_s
>c00e		64 3e 73			    .text _s
.c011						+
="d-"						    _s := "d-" ? "d-" : str(.d_minus)
>c011		02 10				    .byte len(_s), UF
>c013		1b c0 e3 9d 03 9e		    .word false ? 0 : +, xt_d_minus, z_d_minus
>c019		64 2d				    .text _s
.c01b						+
="d+"						    _s := "d+" ? "d+" : str(.d_plus)
>c01b		02 10				    .byte len(_s), UF
>c01d		25 c0 04 9e 24 9e		    .word false ? 0 : +, xt_d_plus, z_d_plus
>c023		64 2b				    .text _s
.c025						+
="erase"					    _s := "" ? "" : str(.erase)
>c025		05 00				    .byte len(_s), 0
>c027		32 c0 bc 87 04 88		    .word false ? 0 : +, xt_erase, z_erase
>c02d		65 72 61 73 65			    .text _s
.c032						+
="blank"					    _s := "" ? "" : str(.blank)
>c032		05 00				    .byte len(_s), 0
>c034		3f c0 b2 87 04 88		    .word false ? 0 : +, xt_blank, z_blank
>c03a		62 6c 61 6e 6b			    .text _s
.c03f						+
="fill"						    _s := "" ? "" : str(.fill)
>c03f		04 10				    .byte len(_s), UF
>c041		4b c0 c2 87 04 88		    .word false ? 0 : +, xt_fill, z_fill
>c047		66 69 6c 6c			    .text _s
.c04b						+
="find-name"					    _s := "find-name" ? "find-name" : str(.find_name)
>c04b		09 10				    .byte len(_s), UF
>c04d		5c c0 db 9a 1e 9b		    .word false ? 0 : +, xt_find_name, z_find_name
>c053		66 69 6e 64 2d 6e 61 6d		    .text _s
>c05b		65
.c05c						+
="'"						    _s := "'" ? "'" : str(.tick)
>c05c		01 00				    .byte len(_s), 0
>c05e		65 c0 42 92 61 92		    .word false ? 0 : +, xt_tick, z_tick
>c064		27				    .text _s
.c065						+
="[']"						    _s := "[']" ? "[']" : str(.bracket_tick)
>c065		03 05				    .byte len(_s), CO+IM
>c067		70 c0 14 83 1a 83		    .word false ? 0 : +, xt_bracket_tick, z_bracket_tick
>c06d		5b 27 5d			    .text _s
.c070						+
="name>int"					    _s := "name>int" ? "name>int" : str(.name_to_int)
>c070		08 10				    .byte len(_s), UF
>c072		80 c0 19 9c 35 9c		    .word false ? 0 : +, xt_name_to_int, z_name_to_int
>c078		6e 61 6d 65 3e 69 6e 74		    .text _s
.c080						+
="int>name"					    _s := "int>name" ? "int>name" : str(.int_to_name)
>c080		08 10				    .byte len(_s), UF
>c082		90 c0 93 9b 03 9c		    .word false ? 0 : +, xt_int_to_name, z_int_to_name
>c088		69 6e 74 3e 6e 61 6d 65		    .text _s
.c090						+
="name>string"					    _s := "name>string" ? "name>string" : str(.name_to_string)
>c090		0b 10				    .byte len(_s), UF
>c092		a3 c0 36 9c 4c 9c		    .word false ? 0 : +, xt_name_to_string, z_name_to_string
>c098		6e 61 6d 65 3e 73 74 72		    .text _s
>c0a0		69 6e 67
.c0a3						+
=">body"					    _s := ">body" ? ">body" : str(.to_body)
>c0a3		05 10				    .byte len(_s), UF
>c0a5		b0 c0 9e 92 c0 92		    .word false ? 0 : +, xt_to_body, z_to_body
>c0ab		3e 62 6f 64 79			    .text _s
.c0b0						+
="defer"					    _s := "" ? "" : str(.defer)
>c0b0		05 00				    .byte len(_s), 0
>c0b2		bd c0 11 85 43 85		    .word false ? 0 : +, xt_defer, z_defer
>c0b8		64 65 66 65 72			    .text _s
.c0bd						+
="latestxt"					    _s := "" ? "" : str(.latestxt)
>c0bd		08 00				    .byte len(_s), 0
>c0bf		cd c0 12 9c 18 9c		    .word false ? 0 : +, xt_latestxt, z_latestxt
>c0c5		6c 61 74 65 73 74 78 74		    .text _s
.c0cd						+
="latestnt"					    _s := "" ? "" : str(.latestnt)
>c0cd		08 00				    .byte len(_s), 0
>c0cf		dd c0 04 9c 11 9c		    .word false ? 0 : +, xt_latestnt, z_latestnt
>c0d5		6c 61 74 65 73 74 6e 74		    .text _s
.c0dd						+
="parse-name"					    _s := "parse-name" ? "parse-name" : str(.parse_name)
>c0dd		0a 08				    .byte len(_s), NN
>c0df		ef c0 51 8d 41 8e		    .word false ? 0 : +, xt_parse_name, z_parse_name
>c0e5		70 61 72 73 65 2d 6e 61		    .text _s
>c0ed		6d 65
.c0ef						+
="parse"					    _s := "" ? "" : str(.parse)
>c0ef		05 10				    .byte len(_s), UF
>c0f1		fc c0 ac 8d 41 8e		    .word false ? 0 : +, xt_parse, z_parse
>c0f7		70 61 72 73 65			    .text _s
.c0fc						+
="execute-parsing"				    _s := "execute-parsing" ? "execute-parsing" : str(.execute_parsing)
>c0fc		0f 10				    .byte len(_s), UF
>c0fe		13 c1 b4 9a da 9a		    .word false ? 0 : +, xt_execute_parsing, z_execute_parsing
>c104		65 78 65 63 75 74 65 2d		    .text _s
>c10c		70 61 72 73 69 6e 67
.c113						+
="source"					    _s := "" ? "" : str(.source)
>c113		06 00				    .byte len(_s), 0
>c115		21 c1 ab 91 bf 91		    .word false ? 0 : +, xt_source, z_source
>c11b		73 6f 75 72 63 65		    .text _s
.c121						+
="source-id"					    _s := "source-id" ? "source-id" : str(.source_id)
>c121		09 00				    .byte len(_s), 0
>c123		32 c1 c0 91 ca 91		    .word false ? 0 : +, xt_source_id, z_source_id
>c129		73 6f 75 72 63 65 2d 69		    .text _s
>c131		64
.c132						+
=":"						    _s := ":" ? ":" : str(.colon)
>c132		01 00				    .byte len(_s), 0
>c134		3b c1 6e 83 b0 83		    .word false ? 0 : +, xt_colon, z_colon
>c13a		3a				    .text _s
.c13b						+
=";"						    _s := ";" ? ";" : str(.semicolon)
>c13b		01 05				    .byte len(_s), CO+IM
>c13d		44 c1 f1 90 4f 91		    .word false ? 0 : +, xt_semicolon, z_semicolon
>c143		3b				    .text _s
.c144						+
=":noname"					    _s := ":noname" ? ":noname" : str(.colon_noname)
>c144		07 00				    .byte len(_s), 0
>c146		53 c1 b1 83 cc 83		    .word false ? 0 : +, xt_colon_noname, z_colon_noname
>c14c		3a 6e 6f 6e 61 6d 65		    .text _s
.c153						+
="compile,"					    _s := "compile," ? "compile," : str(.compile_comma)
>c153		08 18				    .byte len(_s), UF+NN
>c155		63 c1 c7 96 65 97		    .word false ? 0 : +, xt_compile_comma, z_compile_comma
>c15b		63 6f 6d 70 69 6c 65 2c		    .text _s
.c163						+
="["						    _s := "[" ? "[" : str(.left_bracket)
>c163		01 05				    .byte len(_s), IM+CO
>c165		6c c1 ca 89 ce 89		    .word false ? 0 : +, xt_left_bracket, z_left_bracket
>c16b		5b				    .text _s
.c16c						+
="]"						    _s := "]" ? "]" : str(.right_bracket)
>c16c		01 04				    .byte len(_s), IM
>c16e		75 c1 8a 8f 90 8f		    .word false ? 0 : +, xt_right_bracket, z_right_bracket
>c174		5d				    .text _s
.c175						+
="literal"					    _s := "literal" ? "literal" : str(.literal)
>c175		07 15				    .byte len(_s), IM+CO+UF
>c177		84 c1 f2 89 2f 8a		    .word false ? 0 : +, xt_literal, z_literal
>c17d		6c 69 74 65 72 61 6c		    .text _s
.c184						+
="sliteral"					    _s := "sliteral" ? "sliteral" : str(.sliteral)
>c184		08 15				    .byte len(_s), CO+IM+UF
>c186		94 c1 1d a1 60 a1		    .word false ? 0 : +, xt_sliteral, z_sliteral
>c18c		73 6c 69 74 65 72 61 6c		    .text _s
.c194						+
='."'						    _s := '."' ? '."' : str(.dot_quote)
>c194		02 05				    .byte len(_s), CO+IM
>c196		9e c1 61 86 6b 86		    .word false ? 0 : +, xt_dot_quote, z_dot_quote
>c19c		2e 22				    .text _s
.c19e						+
='s"'						    _s := 's"' ? 's"' : str(.s_quote)
>c19e		02 0c				    .byte len(_s), IM+NN
>c1a0		a8 c1 da 8f de 90		    .word false ? 0 : +, xt_s_quote, z_s_quote
>c1a6		73 22				    .text _s
.c1a8						+
='s\"'						    _s := 's\"' ? 's\"' : str(.s_backslash_quote)
>c1a8		03 04				    .byte len(_s), IM
>c1aa		b3 c1 c1 8f ca 8f		    .word false ? 0 : +, xt_s_backslash_quote, z_s_backslash_quote
>c1b0		73 5c 22			    .text _s
.c1b3						+
="postpone"					    _s := "postpone" ? "postpone" : str(.postpone)
>c1b3		08 05				    .byte len(_s), IM+CO
>c1b5		c3 c1 86 8e c4 8e		    .word false ? 0 : +, xt_postpone, z_postpone
>c1bb		70 6f 73 74 70 6f 6e 65		    .text _s
.c1c3						+
="immediate"					    _s := "" ? "" : str(.immediate)
>c1c3		09 00				    .byte len(_s), 0
>c1c5		d4 c1 58 89 63 89		    .word false ? 0 : +, xt_immediate, z_immediate
>c1cb		69 6d 6d 65 64 69 61 74		    .text _s
>c1d3		65
.c1d4						+
="compile-only"					    _s := "compile-only" ? "compile-only" : str(.compile_only)
>c1d4		0c 00				    .byte len(_s), 0
>c1d6		e8 c1 dc 83 e7 83		    .word false ? 0 : +, xt_compile_only, z_compile_only
>c1dc		63 6f 6d 70 69 6c 65 2d		    .text _s
>c1e4		6f 6e 6c 79
.c1e8						+
="never-native"					    _s := "never-native" ? "never-native" : str(.never_native)
>c1e8		0c 00				    .byte len(_s), 0
>c1ea		fc c1 52 9c 5f 9c		    .word false ? 0 : +, xt_never_native, z_never_native
>c1f0		6e 65 76 65 72 2d 6e 61		    .text _s
>c1f8		74 69 76 65
.c1fc						+
="always-native"				    _s := "always-native" ? "always-native" : str(.always_native)
>c1fc		0d 00				    .byte len(_s), 0
>c1fe		11 c2 05 9a 12 9a		    .word false ? 0 : +, xt_always_native, z_always_native
>c204		61 6c 77 61 79 73 2d 6e		    .text _s
>c20c		61 74 69 76 65
.c211						+
="allow-native"					    _s := "allow-native" ? "allow-native" : str(.allow_native)
>c211		0c 00				    .byte len(_s), 0
>c213		25 c2 f9 99 04 9a		    .word false ? 0 : +, xt_allow_native, z_allow_native
>c219		61 6c 6c 6f 77 2d 6e 61		    .text _s
>c221		74 69 76 65
.c225						+
="nc-limit"					    _s := "nc-limit" ? "nc-limit" : str(.nc_limit)
>c225		08 08				    .byte len(_s), NN
>c227		35 c2 4d 9c 52 9c		    .word false ? 0 : +, xt_nc_limit, z_nc_limit
>c22d		6e 63 2d 6c 69 6d 69 74		    .text _s
.c235						+
="strip-underflow"				    _s := "strip-underflow" ? "strip-underflow" : str(.strip_underflow)
>c235		0f 08				    .byte len(_s), NN
>c237		4c c2 a2 9d a7 9d		    .word false ? 0 : +, xt_strip_underflow, z_strip_underflow
>c23d		73 74 72 69 70 2d 75 6e		    .text _s
>c245		64 65 72 66 6c 6f 77
.c24c						+
="abort"					    _s := "" ? "" : str(.abort)
>c24c		05 00				    .byte len(_s), 0
>c24e		59 c2 5e 80 af 80		    .word false ? 0 : +, xt_abort, z_abort
>c254		61 62 6f 72 74			    .text _s
.c259						+
='abort"'					    _s := 'abort"' ? 'abort"' : str(.abort_quote)
>c259		06 0d				    .byte len(_s), CO+IM+NN
>c25b		67 c2 af 80 b9 80		    .word false ? 0 : +, xt_abort_quote, z_abort_quote
>c261		61 62 6f 72 74 22		    .text _s
.c267						+
="do"						    _s := "" ? "" : str(.do)
>c267		02 0d				    .byte len(_s), CO+IM+NN
>c269		71 c2 8b 85 a4 85		    .word false ? 0 : +, xt_do, z_do
>c26f		64 6f				    .text _s
.c271						+
="?do"						    _s := "?do" ? "?do" : str(.question_do)
>c271		03 0d				    .byte len(_s), CO+IM+NN
>c273		7c c2 61 85 a4 85		    .word false ? 0 : +, xt_question_do, z_question_do
>c279		3f 64 6f			    .text _s
.c27c						+
="i"						    _s := "" ? "" : str(.i)
>c27c		01 01				    .byte len(_s), CO
>c27e		85 c2 3f 89 53 89		    .word false ? 0 : +, xt_i, z_i
>c284		69				    .text _s
.c285						+
="j"						    _s := "" ? "" : str(.j)
>c285		01 01				    .byte len(_s), CO
>c287		8e c2 8d 89 a6 89		    .word false ? 0 : +, xt_j, z_j
>c28d		6a				    .text _s
.c28e						+
="loop"						    _s := "" ? "" : str(.loop)
>c28e		04 05				    .byte len(_s), CO+IM
>c290		9a c2 59 8a d1 8a		    .word false ? 0 : +, xt_loop, z_loop
>c296		6c 6f 6f 70			    .text _s
.c29a						+
="+loop"					    _s := "+loop" ? "+loop" : str(.plus_loop)
>c29a		05 05				    .byte len(_s), CO+IM
>c29c		a7 c2 6d 8a d1 8a		    .word false ? 0 : +, xt_plus_loop, z_plus_loop
>c2a2		2b 6c 6f 6f 70			    .text _s
.c2a7						+
="exit"						    _s := "" ? "" : str(.exit)
>c2a7		04 03				    .byte len(_s), AN+CO
>c2a9		b3 c2 19 88 1a 88		    .word false ? 0 : +, xt_exit, z_exit
>c2af		65 78 69 74			    .text _s
.c2b3						+
="unloop"					    _s := "" ? "" : str(.unloop)
>c2b3		06 01				    .byte len(_s), CO
>c2b5		c1 c2 d1 95 e0 95		    .word false ? 0 : +, xt_unloop, z_unloop
>c2bb		75 6e 6c 6f 6f 70		    .text _s
.c2c1						+
="leave"					    _s := "" ? "" : str(.leave)
>c2c1		05 05				    .byte len(_s), CO+IM
>c2c3		ce c2 b4 89 c9 89		    .word false ? 0 : +, xt_leave, z_leave
>c2c9		6c 65 61 76 65			    .text _s
.c2ce						+
="recurse"					    _s := "" ? "" : str(.recurse)
>c2ce		07 0d				    .byte len(_s), CO+IM+NN
>c2d0		dd c2 05 8f 41 8f		    .word false ? 0 : +, xt_recurse, z_recurse
>c2d6		72 65 63 75 72 73 65		    .text _s
.c2dd						+
="quit"						    _s := "" ? "" : str(.quit)
>c2dd		04 00				    .byte len(_s), 0
>c2df		e9 c2 60 80 af 80		    .word false ? 0 : +, xt_quit, z_quit
>c2e5		71 75 69 74			    .text _s
.c2e9						+
="begin"					    _s := "" ? "" : str(.begin)
>c2e9		05 05				    .byte len(_s), CO+IM
>c2eb		f6 c2 1b 89 25 89		    .word false ? 0 : +, xt_begin, z_begin
>c2f1		62 65 67 69 6e			    .text _s
.c2f6						+
="again"					    _s := "" ? "" : str(.again)
>c2f6		05 15				    .byte len(_s), CO+IM+UF
>c2f8		03 c3 1f 82 25 82		    .word false ? 0 : +, xt_again, z_again
>c2fe		61 67 61 69 6e			    .text _s
.c303						+
="state"					    _s := "" ? "" : str(.state)
>c303		05 00				    .byte len(_s), 0
>c305		10 c3 0d 92 17 92		    .word false ? 0 : +, xt_state, z_state
>c30b		73 74 61 74 65			    .text _s
.c310						+
="evaluate"					    _s := "" ? "" : str(.evaluate)
>c310		08 10				    .byte len(_s), UF
>c312		20 c3 b2 88 05 89		    .word false ? 0 : +, xt_evaluate, z_evaluate
>c318		65 76 61 6c 75 61 74 65		    .text _s
.c320						+
="base"						    _s := "" ? "" : str(.base)
>c320		04 00				    .byte len(_s), 0
>c322		2c c3 fb 82 03 83		    .word false ? 0 : +, xt_base, z_base
>c328		62 61 73 65			    .text _s
.c32c						+
="digit?"					    _s := "digit?" ? "digit?" : str(.digit_question)
>c32c		06 10				    .byte len(_s), UF
>c32e		3a c3 7f 9a b3 9a		    .word false ? 0 : +, xt_digit_question, z_digit_question
>c334		64 69 67 69 74 3f		    .text _s
.c33a						+
="number"					    _s := "" ? "" : str(.number)
>c33a		06 10				    .byte len(_s), UF
>c33c		48 c3 7c 9c 75 9d		    .word false ? 0 : +, xt_number, z_number
>c342		6e 75 6d 62 65 72		    .text _s
.c348						+
=">number"					    _s := ">number" ? ">number" : str(.to_number)
>c348		07 10				    .byte len(_s), UF
>c34a		57 c3 cc 92 6b 93		    .word false ? 0 : +, xt_to_number, z_to_number
>c350		3e 6e 75 6d 62 65 72		    .text _s
.c357						+
="hex"						    _s := "" ? "" : str(.hex)
>c357		03 00				    .byte len(_s), 0
>c359		62 c3 26 89 2c 89		    .word false ? 0 : +, xt_hex, z_hex
>c35f		68 65 78			    .text _s
.c362						+
="decimal"					    _s := "" ? "" : str(.decimal)
>c362		07 00				    .byte len(_s), 0
>c364		71 c3 0a 85 10 85		    .word false ? 0 : +, xt_decimal, z_decimal
>c36a		64 65 63 69 6d 61 6c		    .text _s
.c371						+
="count"					    _s := "" ? "" : str(.count)
>c371		05 10				    .byte len(_s), UF
>c373		7e c3 26 84 39 84		    .word false ? 0 : +, xt_count, z_count
>c379		63 6f 75 6e 74			    .text _s
.c37e						+
="m*"						    _s := "m*" ? "m*" : str(.m_star)
>c37e		02 10				    .byte len(_s), UF
>c380		88 c3 21 8b 3b 8b		    .word false ? 0 : +, xt_m_star, z_m_star
>c386		6d 2a				    .text _s
.c388						+
="um*"						    _s := "um*" ? "um*" : str(.um_star)
>c388		03 10				    .byte len(_s), UF
>c38a		93 c3 8b 95 d0 95		    .word false ? 0 : +, xt_um_star, z_um_star
>c390		75 6d 2a			    .text _s
.c393						+
="*"						    _s := "*" ? "*" : str(.star)
>c393		01 10				    .byte len(_s), UF
>c395		9c c3 eb 91 f3 91		    .word false ? 0 : +, xt_star, z_star
>c39b		2a				    .text _s
.c39c						+
="um/mod"					    _s := "um/mod" ? "um/mod" : str(.um_slash_mod)
>c39c		06 10				    .byte len(_s), UF
>c39e		aa c3 49 95 8a 95		    .word false ? 0 : +, xt_um_slash_mod, z_um_slash_mod
>c3a4		75 6d 2f 6d 6f 64		    .text _s
.c3aa						+
="sm/rem"					    _s := "sm/rem" ? "sm/rem" : str(.sm_slash_rem)
>c3aa		06 10				    .byte len(_s), UF
>c3ac		b8 c3 82 91 aa 91		    .word false ? 0 : +, xt_sm_slash_rem, z_sm_slash_rem
>c3b2		73 6d 2f 72 65 6d		    .text _s
.c3b8						+
="fm/mod"					    _s := "fm/mod" ? "fm/mod" : str(.fm_slash_mod)
>c3b8		06 10				    .byte len(_s), UF
>c3ba		c6 c3 75 88 ab 88		    .word false ? 0 : +, xt_fm_slash_mod, z_fm_slash_mod
>c3c0		66 6d 2f 6d 6f 64		    .text _s
.c3c6						+
="/"						    _s := "/" ? "/" : str(.slash)
>c3c6		01 10				    .byte len(_s), UF
>c3c8		cf c3 65 91 81 91		    .word false ? 0 : +, xt_slash, z_slash
>c3ce		2f				    .text _s
.c3cf						+
="/mod"						    _s := "/mod" ? "/mod" : str(.slash_mod)
>c3cf		04 10				    .byte len(_s), UF
>c3d1		db c3 6a 91 81 91		    .word false ? 0 : +, xt_slash_mod, z_slash_mod
>c3d7		2f 6d 6f 64			    .text _s
.c3db						+
="mod"						    _s := "" ? "" : str(.mod)
>c3db		03 10				    .byte len(_s), UF
>c3dd		e6 c3 f7 8b ff 8b		    .word false ? 0 : +, xt_mod, z_mod
>c3e3		6d 6f 64			    .text _s
.c3e6						+
="*/mod"					    _s := "*/mod" ? "*/mod" : str(.star_slash_mod)
>c3e6		05 10				    .byte len(_s), UF
>c3e8		f3 c3 fd 91 0c 92		    .word false ? 0 : +, xt_star_slash_mod, z_star_slash_mod
>c3ee		2a 2f 6d 6f 64			    .text _s
.c3f3						+
="*/"						    _s := "*/" ? "*/" : str(.star_slash)
>c3f3		02 10				    .byte len(_s), UF
>c3f5		fd c3 f4 91 fc 91		    .word false ? 0 : +, xt_star_slash, z_star_slash
>c3fb		2a 2f				    .text _s
.c3fd						+
="\"						    _s := "\" ? "\" : str(.backslash)
>c3fd		01 04				    .byte len(_s), IM
>c3ff		06 c4 d0 82 fa 82		    .word false ? 0 : +, xt_backslash, z_backslash
>c405		5c				    .text _s
.c406						+
="move"						    _s := "" ? "" : str(.move)
>c406		04 18				    .byte len(_s), NN+UF
>c408		12 c4 00 8c 1e 8c		    .word false ? 0 : +, xt_move, z_move
>c40e		6d 6f 76 65			    .text _s
.c412						+
="cmove>"					    _s := "cmove>" ? "cmove>" : str(.cmove_up)
>c412		06 10				    .byte len(_s), UF
>c414		20 c4 68 9f a2 9f		    .word false ? 0 : +, xt_cmove_up, z_cmove_up
>c41a		63 6d 6f 76 65 3e		    .text _s
.c420						+
="cmove"					    _s := "" ? "" : str(.cmove)
>c420		05 10				    .byte len(_s), UF
>c422		2d c4 2d 9f 67 9f		    .word false ? 0 : +, xt_cmove, z_cmove
>c428		63 6d 6f 76 65			    .text _s
.c42d						+
="pad"						    _s := "" ? "" : str(.pad)
>c42d		03 00				    .byte len(_s), 0
>c42f		38 c4 13 8d 22 8d		    .word false ? 0 : +, xt_pad, z_pad
>c435		70 61 64			    .text _s
.c438						+
="cleave"					    _s := "" ? "" : str(.cleave)
>c438		06 10				    .byte len(_s), UF
>c43a		46 c4 32 9a 7e 9a		    .word false ? 0 : +, xt_cleave, z_cleave
>c440		63 6c 65 61 76 65		    .text _s
.c446						+
="hexstore"					    _s := "" ? "" : str(.hexstore)
>c446		08 10				    .byte len(_s), UF
>c448		56 c4 1f 9b 71 9b		    .word false ? 0 : +, xt_hexstore, z_hexstore
>c44e		68 65 78 73 74 6f 72 65		    .text _s
.c456						+
="within"					    _s := "" ? "" : str(.within)
>c456		06 10				    .byte len(_s), UF
>c458		64 c4 15 96 2a 96		    .word false ? 0 : +, xt_within, z_within
>c45e		77 69 74 68 69 6e		    .text _s
.c464						+
=">in"						    _s := ">in" ? ">in" : str(.to_in)
>c464		03 00				    .byte len(_s), 0
>c466		6f c4 c1 92 cb 92		    .word false ? 0 : +, xt_to_in, z_to_in
>c46c		3e 69 6e			    .text _s
.c46f						+
="<#"						    _s := "<#" ? "<#" : str(.less_number_sign)
>c46f		02 00				    .byte len(_s), 0
>c471		79 c4 cf 89 dc 89		    .word false ? 0 : +, xt_less_number_sign, z_less_number_sign
>c477		3c 23				    .text _s
.c479						+
="#"						    _s := "#" ? "#" : str(.number_sign)
>c479		01 10				    .byte len(_s), UF
>c47b		82 c4 5c 8c 90 8c		    .word false ? 0 : +, xt_number_sign, z_number_sign
>c481		23				    .text _s
.c482						+
="#s"						    _s := "#s" ? "#s" : str(.number_sign_s)
>c482		02 10				    .byte len(_s), UF
>c484		8c c4 b3 8c c3 8c		    .word false ? 0 : +, xt_number_sign_s, z_number_sign_s
>c48a		23 73				    .text _s
.c48c						+
="#>"						    _s := "#>" ? "#>" : str(.number_sign_greater)
>c48c		02 10				    .byte len(_s), UF
>c48e		96 c4 91 8c b2 8c		    .word false ? 0 : +, xt_number_sign_greater, z_number_sign_greater
>c494		23 3e				    .text _s
.c496						+
="hold"						    _s := "" ? "" : str(.hold)
>c496		04 10				    .byte len(_s), UF
>c498		a2 c4 2d 89 3e 89		    .word false ? 0 : +, xt_hold, z_hold
>c49e		68 6f 6c 64			    .text _s
.c4a2						+
="sign"						    _s := "" ? "" : str(.sign)
>c4a2		04 10				    .byte len(_s), UF
>c4a4		ae c4 50 91 64 91		    .word false ? 0 : +, xt_sign, z_sign
>c4aa		73 69 67 6e			    .text _s
.c4ae						+
="output"					    _s := "" ? "" : str(.output)
>c4ae		06 00				    .byte len(_s), 0
>c4b0		bc c4 7f 9d 89 9d		    .word false ? 0 : +, xt_output, z_output
>c4b6		6f 75 74 70 75 74		    .text _s
.c4bc						+
="input"					    _s := "" ? "" : str(.input)
>c4bc		05 00				    .byte len(_s), 0
>c4be		c9 c4 72 9b 7c 9b		    .word false ? 0 : +, xt_input, z_input
>c4c4		69 6e 70 75 74			    .text _s
.c4c9						+
="cr"						    _s := "" ? "" : str(.cr)
>c4c9		02 00				    .byte len(_s), 0
>c4cb		d3 c4 3a 84 3f 84		    .word false ? 0 : +, xt_cr, z_cr
>c4d1		63 72				    .text _s
.c4d3						+
="page"						    _s := "" ? "" : str(.page)
>c4d3		04 00				    .byte len(_s), 0
>c4d5		df c4 23 8d 40 8d		    .word false ? 0 : +, xt_page, z_page
>c4db		70 61 67 65			    .text _s
.c4df						+
="at-xy"					    _s := "at-xy" ? "at-xy" : str(.at_xy)
>c4df		05 10				    .byte len(_s), UF
>c4e1		ec c4 a2 82 cf 82		    .word false ? 0 : +, xt_at_xy, z_at_xy
>c4e7		61 74 2d 78 79			    .text _s
.c4ec						+
="marker"					    _s := "" ? "" : str(.marker)
>c4ec		06 04				    .byte len(_s), IM
>c4ee		fa c4 3c 8b 76 8b		    .word false ? 0 : +, xt_marker, z_marker
>c4f4		6d 61 72 6b 65 72		    .text _s
.c4fa						+
="words"					    _s := "" ? "" : str(.words)
>c4fa		05 00				    .byte len(_s), 0
>c4fc		07 c5 9c 99 f8 99		    .word false ? 0 : +, xt_words, z_words
>c502		77 6f 72 64 73			    .text _s
.c507						+
="wordsize"					    _s := "" ? "" : str(.wordsize)
>c507		08 10				    .byte len(_s), UF
>c509		17 c5 bb 9d db 9d		    .word false ? 0 : +, xt_wordsize, z_wordsize
>c50f		77 6f 72 64 73 69 7a 65		    .text _s
.c517						+
="aligned"					    _s := "" ? "" : str(.aligned)
>c517		07 00				    .byte len(_s), 0
>c519		26 c5 26 82 26 82		    .word false ? 0 : +, xt_aligned, z_aligned
>c51f		61 6c 69 67 6e 65 64		    .text _s
.c526						+
="align"					    _s := "" ? "" : str(.align)
>c526		05 00				    .byte len(_s), 0
>c528		33 c5 26 82 26 82		    .word false ? 0 : +, xt_align, z_align
>c52e		61 6c 69 67 6e			    .text _s
.c533						+
="bell"						    _s := "" ? "" : str(.bell)
>c533		04 00				    .byte len(_s), 0
>c535		3f c5 13 9a 18 9a		    .word false ? 0 : +, xt_bell, z_bell
>c53b		62 65 6c 6c			    .text _s
.c53f						+
="dump"						    _s := "" ? "" : str(.dump)
>c53f		04 10				    .byte len(_s), UF
>c541		4b c5 8c 98 f2 98		    .word false ? 0 : +, xt_dump, z_dump
>c547		64 75 6d 70			    .text _s
.c54b						+
=".s"						    _s := ".s" ? ".s" : str(.dot_s)
>c54b		02 00				    .byte len(_s), 0
>c54d		55 c5 48 98 8b 98		    .word false ? 0 : +, xt_dot_s, z_dot_s
>c553		2e 73				    .text _s
.c555						+
="disasm"					    _s := "" ? "" : str(.disasm)
>c555		06 10				    .byte len(_s), UF
>c557		63 c5 89 a1 8f a1		    .word false ? 0 : +, xt_disasm, z_disasm
>c55d		64 69 73 61 73 6d		    .text _s
.c563						+
="compare"					    _s := "" ? "" : str(.compare)
>c563		07 10				    .byte len(_s), UF
>c565		72 c5 a3 9f 07 a0		    .word false ? 0 : +, xt_compare, z_compare
>c56b		63 6f 6d 70 61 72 65		    .text _s
.c572						+
="search"					    _s := "" ? "" : str(.search)
>c572		06 18				    .byte len(_s), UF+NN
>c574		80 c5 5e a0 fc a0		    .word false ? 0 : +, xt_search, z_search
>c57a		73 65 61 72 63 68		    .text _s
.c580						+
="environment?"					    _s := "environment?" ? "environment?" : str(.environment_q)
>c580		0c 10				    .byte len(_s), UF
>c582		94 c5 dd 86 59 87		    .word false ? 0 : +, xt_environment_q, z_environment_q
>c588		65 6e 76 69 72 6f 6e 6d		    .text _s
>c590		65 6e 74 3f
.c594						+
="find"						    _s := "" ? "" : str(.find)
>c594		04 10				    .byte len(_s), UF
>c596		a0 c5 2d 88 74 88		    .word false ? 0 : +, xt_find, z_find
>c59c		66 69 6e 64			    .text _s
.c5a0						+
="word"						    _s := "" ? "" : str(.word)
>c5a0		04 10				    .byte len(_s), UF
>c5a2		ac c5 2b 96 6e 96		    .word false ? 0 : +, xt_word, z_word
>c5a8		77 6f 72 64			    .text _s
.c5ac						+
="("						    _s := "(" ? "(" : str(.paren)
>c5ac		01 04				    .byte len(_s), IM
>c5ae		b5 c5 41 8d 50 8d		    .word false ? 0 : +, xt_paren, z_paren
>c5b4		28				    .text _s
.c5b5						+
=".("						    _s := ".(" ? ".(" : str(.dot_paren)
>c5b5		02 04				    .byte len(_s), IM
>c5b7		bf c5 52 86 60 86		    .word false ? 0 : +, xt_dot_paren, z_dot_paren
>c5bd		2e 28				    .text _s
.c5bf						+
="if"						    _s := "" ? "" : str(.if)
>c5bf		02 0d				    .byte len(_s), IM+CO+NN
>c5c1		c9 c5 54 89 57 89		    .word false ? 0 : +, xt_if, z_if
>c5c7		69 66				    .text _s
.c5c9						+
="then"						    _s := "" ? "" : str(.then)
>c5c9		04 0d				    .byte len(_s), IM+CO+NN
>c5cb		d5 c5 b4 86 bd 86		    .word false ? 0 : +, xt_then, z_then
>c5d1		74 68 65 6e			    .text _s
.c5d5						+
="else"						    _s := "" ? "" : str(.else)
>c5d5		04 0d				    .byte len(_s), IM+CO+NN
>c5d7		e1 c5 ae 86 bd 86		    .word false ? 0 : +, xt_else, z_else
>c5dd		65 6c 73 65			    .text _s
.c5e1						+
="repeat"					    _s := "" ? "" : str(.repeat)
>c5e1		06 0d				    .byte len(_s), IM+CO+NN
>c5e3		ef c5 84 8f 8a 8f		    .word false ? 0 : +, xt_repeat, z_repeat
>c5e9		72 65 70 65 61 74		    .text _s
.c5ef						+
="until"					    _s := "" ? "" : str(.until)
>c5ef		05 0d				    .byte len(_s), IM+CO+NN
>c5f1		fc c5 e1 95 e4 95		    .word false ? 0 : +, xt_until, z_until
>c5f7		75 6e 74 69 6c			    .text _s
.c5fc						+
="while"					    _s := "" ? "" : str(.while)
>c5fc		05 0d				    .byte len(_s), IM+CO+NN
>c5fe		09 c6 0e 96 14 96		    .word false ? 0 : +, xt_while, z_while
>c604		77 68 69 6c 65			    .text _s
.c609						+
="case"						    _s := "" ? "" : str(.case)
>c609		04 0d				    .byte len(_s), IM+CO+NN
>c60b		15 c6 dc 9d e2 9d		    .word false ? 0 : +, xt_case, z_case
>c611		63 61 73 65			    .text _s
.c615						+
="of"						    _s := "" ? "" : str(.of)
>c615		02 0d				    .byte len(_s), IM+CO+NN
>c617		1f c6 c4 8c dc 8c		    .word false ? 0 : +, xt_of, z_of
>c61d		6f 66				    .text _s
.c61f						+
="endof"					    _s := "" ? "" : str(.endof)
>c61f		05 0d				    .byte len(_s), IM+CO+NN
>c621		2c c6 ae 86 bd 86		    .word false ? 0 : +, xt_endof, z_endof
>c627		65 6e 64 6f 66			    .text _s
.c62c						+
="endcase"					    _s := "" ? "" : str(.endcase)
>c62c		07 0d				    .byte len(_s), IM+CO+NN
>c62e		3b c6 c8 86 dc 86		    .word false ? 0 : +, xt_endcase, z_endcase
>c634		65 6e 64 63 61 73 65		    .text _s
.c63b						+
="defer@"					    _s := "defer@" ? "defer@" : str(.defer_fetch)
>c63b		06 00				    .byte len(_s), 0
>c63d		49 c6 44 85 4a 85		    .word false ? 0 : +, xt_defer_fetch, z_defer_fetch
>c643		64 65 66 65 72 40		    .text _s
.c649						+
="defer!"					    _s := "defer!" ? "defer!" : str(.defer_store)
>c649		06 00				    .byte len(_s), 0
>c64b		57 c6 4b 85 51 85		    .word false ? 0 : +, xt_defer_store, z_defer_store
>c651		64 65 66 65 72 21		    .text _s
.c657						+
="is"						    _s := "is" ? "is" : str(.is)
>c657		02 04				    .byte len(_s), IM
>c659		61 c6 74 89 8c 89		    .word false ? 0 : +, xt_is, z_is
>c65f		69 73				    .text _s
.c661						+
="action-of"					    _s := "action-of" ? "action-of" : str(.action_of)
>c661		09 04				    .byte len(_s), IM
>c663		72 c6 06 82 1e 82		    .word false ? 0 : +, xt_action_of, z_action_of
>c669		61 63 74 69 6f 6e 2d 6f		    .text _s
>c671		66
.c672						+
="useraddr"					    _s := "useraddr" ? "useraddr" : str(.useraddr)
>c672		08 00				    .byte len(_s), 0
>c674		82 c6 b0 9d ba 9d		    .word false ? 0 : +, xt_useraddr, z_useraddr
>c67a		75 73 65 72 61 64 64 72		    .text _s
.c682						+
="buffer:"					    _s := "buffer:" ? "buffer:" : str(.buffer_colon)
>c682		07 00				    .byte len(_s), 0
>c684		91 c6 1b 83 21 83		    .word false ? 0 : +, xt_buffer_colon, z_buffer_colon
>c68a		62 75 66 66 65 72 3a		    .text _s
.c691						+
="buffstatus"					    _s := "" ? "" : str(.buffstatus)
>c691		0a 00				    .byte len(_s), 0
>c693		a3 c6 b8 af bd af		    .word false ? 0 : +, xt_buffstatus, z_buffstatus
>c699		62 75 66 66 73 74 61 74		    .text _s
>c6a1		75 73
.c6a3						+
="buffblocknum"					    _s := "" ? "" : str(.buffblocknum)
>c6a3		0c 00				    .byte len(_s), 0
>c6a5		b7 c6 82 af 87 af		    .word false ? 0 : +, xt_buffblocknum, z_buffblocknum
>c6ab		62 75 66 66 62 6c 6f 63		    .text _s
>c6b3		6b 6e 75 6d
.c6b7						+
="blkbuffer"					    _s := "" ? "" : str(.blkbuffer)
>c6b7		09 00				    .byte len(_s), 0
>c6b9		c8 c6 78 ad 85 ad		    .word false ? 0 : +, xt_blkbuffer, z_blkbuffer
>c6bf		62 6c 6b 62 75 66 66 65		    .text _s
>c6c7		72
.c6c8						+
="scr"						    _s := "" ? "" : str(.scr)
>c6c8		03 08				    .byte len(_s), NN
>c6ca		d3 c6 3a b0 3f b0		    .word false ? 0 : +, xt_scr, z_scr
>c6d0		73 63 72			    .text _s
.c6d3						+
="blk"						    _s := "" ? "" : str(.blk)
>c6d3		03 08				    .byte len(_s), NN
>c6d5		de c6 73 ad 78 ad		    .word false ? 0 : +, xt_blk, z_blk
>c6db		62 6c 6b			    .text _s
.c6de						+
="block-write"					    _s := "block-write" ? "block-write" : str(.block_write)
>c6de		0b 08				    .byte len(_s), NN
>c6e0		f1 c6 6f af 7d af		    .word false ? 0 : +, xt_block_write, z_block_write
>c6e6		62 6c 6f 63 6b 2d 77 72		    .text _s
>c6ee		69 74 65
.c6f1						+
="block-write-vector"				    _s := "block-write-vector" ? "block-write-vector" : str(.block_write_vector)
>c6f1		12 08				    .byte len(_s), NN
>c6f3		0b c7 7d af 82 af		    .word false ? 0 : +, xt_block_write_vector, z_block_write_vector
>c6f9		62 6c 6f 63 6b 2d 77 72		    .text _s
>c701		69 74 65 2d 76 65 63 74 6f 72
.c70b						+
="block-read"					    _s := "block-read" ? "block-read" : str(.block_read)
>c70b		0a 28				    .byte len(_s), HC+NN
>c70d		1d c7 57 af 65 af		    .word false ? 0 : +, xt_block_read, z_block_read
>c713		62 6c 6f 63 6b 2d 72 65		    .text _s
>c71b		61 64
.c71d						+
="block-read-vector"				    _s := "block-read-vector" ? "block-read-vector" : str(.block_read_vector)
>c71d		11 28				    .byte len(_s), HC+NN
>c71f		36 c7 65 af 6a af		    .word false ? 0 : +, xt_block_read_vector, z_block_read_vector
>c725		62 6c 6f 63 6b 2d 72 65		    .text _s
>c72d		61 64 2d 76 65 63 74 6f 72
.c736						+
="save-buffers"					    _s := "save-buffers" ? "save-buffers" : str(.save_buffers)
>c736		0c 00				    .byte len(_s), 0
>c738		4a c7 1f b0 39 b0		    .word false ? 0 : +, xt_save_buffers, z_save_buffers
>c73e		73 61 76 65 2d 62 75 66		    .text _s
>c746		66 65 72 73
.c74a						+
="block"					    _s := "" ? "" : str(.block)
>c74a		05 00				    .byte len(_s), 0
>c74c		57 c7 86 ad d8 ad		    .word false ? 0 : +, xt_block, z_block
>c752		62 6c 6f 63 6b			    .text _s
.c757						+
="update"					    _s := "" ? "" : str(.update)
>c757		06 00				    .byte len(_s), 0
>c759		65 c7 84 b0 8c b0		    .word false ? 0 : +, xt_update, z_update
>c75f		75 70 64 61 74 65		    .text _s
.c765						+
="buffer"					    _s := "" ? "" : str(.buffer)
>c765		06 00				    .byte len(_s), 0
>c767		73 c7 87 af b7 af		    .word false ? 0 : +, xt_buffer, z_buffer
>c76d		62 75 66 66 65 72		    .text _s
.c773						+
="empty-buffers"				    _s := "empty-buffers" ? "empty-buffers" : str(.empty_buffers)
>c773		0d 00				    .byte len(_s), 0
>c775		88 c7 bd af c3 af		    .word false ? 0 : +, xt_empty_buffers, z_empty_buffers
>c77b		65 6d 70 74 79 2d 62 75		    .text _s
>c783		66 66 65 72 73
.c788						+
="flush"					    _s := "" ? "" : str(.flush)
>c788		05 00				    .byte len(_s), 0
>c78a		95 c7 c4 af cd af		    .word false ? 0 : +, xt_flush, z_flush
>c790		66 6c 75 73 68			    .text _s
.c795						+
="load"						    _s := "" ? "" : str(.load)
>c795		04 10				    .byte len(_s), UF
>c797		a1 c7 db af 1e b0		    .word false ? 0 : +, xt_load, z_load
>c79d		6c 6f 61 64			    .text _s
.c7a1						+
="thru"						    _s := "" ? "" : str(.thru)
>c7a1		04 10				    .byte len(_s), UF
>c7a3		ad c7 3f b0 83 b0		    .word false ? 0 : +, xt_thru, z_thru
>c7a9		74 68 72 75			    .text _s
.c7ad						+
="list"						    _s := "" ? "" : str(.list)
>c7ad		04 10				    .byte len(_s), UF
>c7af		b9 c7 ce af da af		    .word false ? 0 : +, xt_list, z_list
>c7b5		6c 69 73 74			    .text _s
.c7b9						+
="block-c65-init"				    _s := "block-c65-init" ? "block-c65-init" : str(.block_c65_init)
>c7b9		0e 00				    .byte len(_s), 0
>c7bb		cf c7 d9 ad 0e ae		    .word false ? 0 : +, xt_block_c65_init, z_block_c65_init
>c7c1		62 6c 6f 63 6b 2d 63 36		    .text _s
>c7c9		35 2d 69 6e 69 74
.c7cf						+
="block-ramdrive-init"				    _s := "block-ramdrive-init" ? "block-ramdrive-init" : str(.block_ramdrive_init)
>c7cf		13 10				    .byte len(_s), UF
>c7d1		ea c7 31 ae 3e ae		    .word false ? 0 : +, xt_block_ramdrive_init, z_block_ramdrive_init
>c7d7		62 6c 6f 63 6b 2d 72 61		    .text _s
>c7df		6d 64 72 69 76 65 2d 69 6e 69 74
.c7ea						+
="definitions"					    _s := "" ? "" : str(.definitions)
>c7ea		0b 00				    .byte len(_s), 0
>c7ec		fd c7 c2 b1 ca b1		    .word false ? 0 : +, xt_definitions, z_definitions
>c7f2		64 65 66 69 6e 69 74 69		    .text _s
>c7fa		6f 6e 73
.c7fd						+
="wordlist"					    _s := "" ? "" : str(.wordlist)
>c7fd		08 00				    .byte len(_s), 0
>c7ff		0d c8 2d b3 43 b3		    .word false ? 0 : +, xt_wordlist, z_wordlist
>c805		77 6f 72 64 6c 69 73 74		    .text _s
.c80d						+
="search-wordlist"				    _s := "search-wordlist" ? "search-wordlist" : str(.search_wordlist)
>c80d		0f 10				    .byte len(_s), UF
>c80f		24 c8 66 b2 d9 b2		    .word false ? 0 : +, xt_search_wordlist, z_search_wordlist
>c815		73 65 61 72 63 68 2d 77		    .text _s
>c81d		6f 72 64 6c 69 73 74
.c824						+
="set-current"					    _s := "set-current" ? "set-current" : str(.set_current)
>c824		0b 10				    .byte len(_s), UF
>c826		37 c8 da b2 e5 b2		    .word false ? 0 : +, xt_set_current, z_set_current
>c82c		73 65 74 2d 63 75 72 72		    .text _s
>c834		65 6e 74
.c837						+
="get-current"					    _s := "get-current" ? "get-current" : str(.get_current)
>c837		0b 00				    .byte len(_s), 0
>c839		4a c8 d2 b1 dc b1		    .word false ? 0 : +, xt_get_current, z_get_current
>c83f		67 65 74 2d 63 75 72 72		    .text _s
>c847		65 6e 74
.c84a						+
="set-order"					    _s := "set-order" ? "set-order" : str(.set_order)
>c84a		09 00				    .byte len(_s), 0
>c84c		5b c8 e6 b2 19 b3		    .word false ? 0 : +, xt_set_order, z_set_order
>c852		73 65 74 2d 6f 72 64 65		    .text _s
>c85a		72
.c85b						+
="get-order"					    _s := "get-order" ? "get-order" : str(.get_order)
>c85b		09 00				    .byte len(_s), 0
>c85d		6c c8 dd b1 05 b2		    .word false ? 0 : +, xt_get_order, z_get_order
>c863		67 65 74 2d 6f 72 64 65		    .text _s
>c86b		72
.c86c						+
="root-wordlist"				    _s := "root-wordlist" ? "root-wordlist" : str(.root_wordlist)
>c86c		0d 00				    .byte len(_s), 0
>c86e		81 c8 5d b2 65 b2		    .word false ? 0 : +, xt_root_wordlist, z_root_wordlist
>c874		72 6f 6f 74 2d 77 6f 72		    .text _s
>c87c		64 6c 69 73 74
.c881						+
="assembler-wordlist"				    _s := "assembler-wordlist" ? "assembler-wordlist" : str(.assembler_wordlist)
>c881		12 00				    .byte len(_s), 0
>c883		9b c8 a7 9d af 9d		    .word false ? 0 : +, xt_assembler_wordlist, z_assembler_wordlist
>c889		61 73 73 65 6d 62 6c 65		    .text _s
>c891		72 2d 77 6f 72 64 6c 69 73 74
.c89b						+
="editor-wordlist"				    _s := "editor-wordlist" ? "editor-wordlist" : str(.editor_wordlist)
>c89b		0f 00				    .byte len(_s), 0
>c89d		b2 c8 76 9d 7e 9d		    .word false ? 0 : +, xt_editor_wordlist, z_editor_wordlist
>c8a3		65 64 69 74 6f 72 2d 77		    .text _s
>c8ab		6f 72 64 6c 69 73 74
.c8b2						+
="forth-wordlist"				    _s := "forth-wordlist" ? "forth-wordlist" : str(.forth_wordlist)
>c8b2		0e 00				    .byte len(_s), 0
>c8b4		c8 c8 dc 9d e2 9d		    .word false ? 0 : +, xt_forth_wordlist, z_forth_wordlist
>c8ba		66 6f 72 74 68 2d 77 6f		    .text _s
>c8c2		72 64 6c 69 73 74
.c8c8						+
="only"						    _s := "" ? "" : str(.only)
>c8c8		04 00				    .byte len(_s), 0
>c8ca		d4 c8 06 b2 0c b2		    .word false ? 0 : +, xt_only, z_only
>c8d0		6f 6e 6c 79			    .text _s
.c8d4						+
="also"						    _s := "" ? "" : str(.also)
>c8d4		04 00				    .byte len(_s), 0
>c8d6		e0 c8 b2 b1 c1 b1		    .word false ? 0 : +, xt_also, z_also
>c8dc		61 6c 73 6f			    .text _s
.c8e0						+
="previous"					    _s := "" ? "" : str(.previous)
>c8e0		08 00				    .byte len(_s), 0
>c8e2		f0 c8 50 b2 5c b2		    .word false ? 0 : +, xt_previous, z_previous
>c8e8		70 72 65 76 69 6f 75 73		    .text _s
.c8f0						+
=">order"					    _s := ">order" ? ">order" : str(.to_order)
>c8f0		06 00				    .byte len(_s), 0
>c8f2		fe c8 1a b3 2c b3		    .word false ? 0 : +, xt_to_order, z_to_order
>c8f8		3e 6f 72 64 65 72		    .text _s
.c8fe						+
="order"					    _s := "" ? "" : str(.order)
>c8fe		05 00				    .byte len(_s), 0
>c900		0b c9 0d b2 37 b2		    .word false ? 0 : +, xt_order, z_order
>c906		6f 72 64 65 72			    .text _s
.c90b						+
="forth"					    _s := "" ? "" : str(.forth)
>c90b		05 00				    .byte len(_s), 0
>c90d		18 c9 cb b1 d1 b1		    .word false ? 0 : +, xt_forth, z_forth
>c913		66 6f 72 74 68			    .text _s
.c918						+
="see"						    _s := "" ? "" : str(.see)
>c918		03 08				    .byte len(_s), NN
>c91a		23 c9 0e 99 9b 99		    .word false ? 0 : +, xt_see, z_see
>c920		73 65 65			    .text _s
.c923						+
="ed:"						    _s := "ed:" ? "ed:" : str(.ed)
>c923		03 08				    .byte len(_s), NN
>c925		2e c9 80 a7 83 a7		    .word false ? 0 : +, xt_ed, z_ed
>c92b		65 64 3a			    .text _s
.c92e						+
="cold"						    _s := "" ? "" : str(.cold)
>c92e		04 00				    .byte len(_s), 0
>c930		3a c9 00 80 af 80		    .word false ? 0 : +, xt_cold, z_cold
>c936		63 6f 6c 64			    .text _s
.c93a						+
="bye"						    _s := "" ? "" : str(.bye)
>c93a		03 00				    .byte len(_s), 0
>c93c		00 00 45 98 48 98		    .word true ? 0 : +, xt_bye, z_bye
>c942		62 79 65			    .text _s
.c945						root_dictionary_start:
="set-order"					    _s := "set-order" ? "set-order" : str(.set_order)
>c945		09 00				    .byte len(_s), 0
>c947		56 c9 e6 b2 19 b3		    .word false ? 0 : +, xt_set_order, z_set_order
>c94d		73 65 74 2d 6f 72 64 65		    .text _s
>c955		72
.c956						+
="forth"					    _s := "" ? "" : str(.forth)
>c956		05 00				    .byte len(_s), 0
>c958		63 c9 cb b1 d1 b1		    .word false ? 0 : +, xt_forth, z_forth
>c95e		66 6f 72 74 68			    .text _s
.c963						+
="forth-wordlist"				    _s := "forth-wordlist" ? "forth-wordlist" : str(.forth_wordlist)
>c963		0e 00				    .byte len(_s), 0
>c965		79 c9 dc 9d e2 9d		    .word false ? 0 : +, xt_forth_wordlist, z_forth_wordlist
>c96b		66 6f 72 74 68 2d 77 6f		    .text _s
>c973		72 64 6c 69 73 74
.c979						+
="words"					    _s := "" ? "" : str(.words)
>c979		05 00				    .byte len(_s), 0
>c97b		00 00 9c 99 f8 99		    .word true ? 0 : +, xt_words, z_words
>c981		77 6f 72 64 73			    .text _s
.c986						editor_dictionary_start:
="o"						    _s := "o" ? "o" : str(.editor_o)
>c986		01 00				    .byte len(_s), 0
>c988		8f c9 6c b1 b1 b1		    .word false ? 0 : +, xt_editor_o, z_editor_o
>c98e		6f				    .text _s
.c98f						+
="line"						    _s := "line" ? "line" : str(.editor_line)
>c98f		04 10				    .byte len(_s), UF
>c991		9b c9 53 b1 6b b1		    .word false ? 0 : +, xt_editor_line, z_editor_line
>c997		6c 69 6e 65			    .text _s
.c99b						+
="l"						    _s := "l" ? "l" : str(.editor_l)
>c99b		01 00				    .byte len(_s), 0
>c99d		a4 c9 d9 b0 52 b1		    .word false ? 0 : +, xt_editor_l, z_editor_l
>c9a3		6c				    .text _s
.c9a4						+
="el"						    _s := "el" ? "el" : str(.editor_el)
>c9a4		02 00				    .byte len(_s), 0
>c9a6		ae c9 c7 b0 d8 b0		    .word false ? 0 : +, xt_editor_el, z_editor_el
>c9ac		65 6c				    .text _s
.c9ae						+
="erase-screen"					    _s := "erase-screen" ? "erase-screen" : str(.editor_erase_screen)
>c9ae		0c 00				    .byte len(_s), 0
>c9b0		c2 c9 b5 b0 c6 b0		    .word false ? 0 : +, xt_editor_erase_screen, z_editor_erase_screen
>c9b6		65 72 61 73 65 2d 73 63		    .text _s
>c9be		72 65 65 6e
.c9c2						+
="enter-screen"					    _s := "enter-screen" ? "enter-screen" : str(.editor_enter_screen)
>c9c2		0c 00				    .byte len(_s), 0
>c9c4		00 00 99 b0 b4 b0		    .word true ? 0 : +, xt_editor_enter_screen, z_editor_enter_screen
>c9ca		65 6e 74 65 72 2d 73 63		    .text _s
>c9d2		72 65 65 6e
.c9d6						assembler_dictionary_start:
="adc.#"					    _s := "adc.#" ? "adc.#" : str(.asm_adc_h)
>c9d6		05 0c				    .byte len(_s), IM+NN
>c9d8		e3 c9 ca a3 cf a3		    .word false ? 0 : +, xt_asm_adc_h, z_asm_adc_h
>c9de		61 64 63 2e 23			    .text _s
.c9e3						+
="adc.x"					    _s := "adc.x" ? "adc.x" : str(.asm_adc_x)
>c9e3		05 0c				    .byte len(_s), IM+NN
>c9e5		f0 c9 cf a3 d4 a3		    .word false ? 0 : +, xt_asm_adc_x, z_asm_adc_x
>c9eb		61 64 63 2e 78			    .text _s
.c9f0						+
="adc.y"					    _s := "adc.y" ? "adc.y" : str(.asm_adc_y)
>c9f0		05 0c				    .byte len(_s), IM+NN
>c9f2		fd c9 d4 a3 d9 a3		    .word false ? 0 : +, xt_asm_adc_y, z_asm_adc_y
>c9f8		61 64 63 2e 79			    .text _s
.c9fd						+
="adc.z"					    _s := "adc.z" ? "adc.z" : str(.asm_adc_z)
>c9fd		05 0c				    .byte len(_s), IM+NN
>c9ff		0a ca d9 a3 de a3		    .word false ? 0 : +, xt_asm_adc_z, z_asm_adc_z
>ca05		61 64 63 2e 7a			    .text _s
.ca0a						+
="adc.zi"					    _s := "adc.zi" ? "adc.zi" : str(.asm_adc_zi)
>ca0a		06 0c				    .byte len(_s), IM+NN
>ca0c		18 ca de a3 e3 a3		    .word false ? 0 : +, xt_asm_adc_zi, z_asm_adc_zi
>ca12		61 64 63 2e 7a 69		    .text _s
.ca18						+
="adc.ziy"					    _s := "adc.ziy" ? "adc.ziy" : str(.asm_adc_ziy)
>ca18		07 0c				    .byte len(_s), IM+NN
>ca1a		27 ca e3 a3 e8 a3		    .word false ? 0 : +, xt_asm_adc_ziy, z_asm_adc_ziy
>ca20		61 64 63 2e 7a 69 79		    .text _s
.ca27						+
="adc.zx"					    _s := "adc.zx" ? "adc.zx" : str(.asm_adc_zx)
>ca27		06 0c				    .byte len(_s), IM+NN
>ca29		35 ca e8 a3 ed a3		    .word false ? 0 : +, xt_asm_adc_zx, z_asm_adc_zx
>ca2f		61 64 63 2e 7a 78		    .text _s
.ca35						+
="adc.zxi"					    _s := "adc.zxi" ? "adc.zxi" : str(.asm_adc_zxi)
>ca35		07 0c				    .byte len(_s), IM+NN
>ca37		44 ca ed a3 f2 a3		    .word false ? 0 : +, xt_asm_adc_zxi, z_asm_adc_zxi
>ca3d		61 64 63 2e 7a 78 69		    .text _s
.ca44						+
="and."						    _s := "and." ? "and." : str(.asm_and)
>ca44		04 0c				    .byte len(_s), IM+NN
>ca46		50 ca f2 a3 f7 a3		    .word false ? 0 : +, xt_asm_and, z_asm_and
>ca4c		61 6e 64 2e			    .text _s
.ca50						+
="and.#"					    _s := "and.#" ? "and.#" : str(.asm_and_h)
>ca50		05 0c				    .byte len(_s), IM+NN
>ca52		5d ca f7 a3 fc a3		    .word false ? 0 : +, xt_asm_and_h, z_asm_and_h
>ca58		61 6e 64 2e 23			    .text _s
.ca5d						+
="and.x"					    _s := "and.x" ? "and.x" : str(.asm_and_x)
>ca5d		05 0c				    .byte len(_s), IM+NN
>ca5f		6a ca fc a3 01 a4		    .word false ? 0 : +, xt_asm_and_x, z_asm_and_x
>ca65		61 6e 64 2e 78			    .text _s
.ca6a						+
="and.y"					    _s := "and.y" ? "and.y" : str(.asm_and_y)
>ca6a		05 0c				    .byte len(_s), IM+NN
>ca6c		77 ca 01 a4 06 a4		    .word false ? 0 : +, xt_asm_and_y, z_asm_and_y
>ca72		61 6e 64 2e 79			    .text _s
.ca77						+
="and.z"					    _s := "and.z" ? "and.z" : str(.asm_and_z)
>ca77		05 0c				    .byte len(_s), IM+NN
>ca79		84 ca 06 a4 0b a4		    .word false ? 0 : +, xt_asm_and_z, z_asm_and_z
>ca7f		61 6e 64 2e 7a			    .text _s
.ca84						+
="and.zi"					    _s := "and.zi" ? "and.zi" : str(.asm_and_zi)
>ca84		06 0c				    .byte len(_s), IM+NN
>ca86		92 ca 0b a4 10 a4		    .word false ? 0 : +, xt_asm_and_zi, z_asm_and_zi
>ca8c		61 6e 64 2e 7a 69		    .text _s
.ca92						+
="and.ziy"					    _s := "and.ziy" ? "and.ziy" : str(.asm_and_ziy)
>ca92		07 0c				    .byte len(_s), IM+NN
>ca94		a1 ca 10 a4 15 a4		    .word false ? 0 : +, xt_asm_and_ziy, z_asm_and_ziy
>ca9a		61 6e 64 2e 7a 69 79		    .text _s
.caa1						+
="and.zx"					    _s := "and.zx" ? "and.zx" : str(.asm_and_zx)
>caa1		06 0c				    .byte len(_s), IM+NN
>caa3		af ca 15 a4 1a a4		    .word false ? 0 : +, xt_asm_and_zx, z_asm_and_zx
>caa9		61 6e 64 2e 7a 78		    .text _s
.caaf						+
="and.zxi"					    _s := "and.zxi" ? "and.zxi" : str(.asm_and_zxi)
>caaf		07 0c				    .byte len(_s), IM+NN
>cab1		be ca 1a a4 1f a4		    .word false ? 0 : +, xt_asm_and_zxi, z_asm_and_zxi
>cab7		61 6e 64 2e 7a 78 69		    .text _s
.cabe						+
="asl"						    _s := "asl" ? "asl" : str(.asm_asl)
>cabe		03 0c				    .byte len(_s), IM+NN
>cac0		c9 ca 1f a4 24 a4		    .word false ? 0 : +, xt_asm_asl, z_asm_asl
>cac6		61 73 6c			    .text _s
.cac9						+
="asl.a"					    _s := "asl.a" ? "asl.a" : str(.asm_asl_a)
>cac9		05 0c				    .byte len(_s), IM+NN
>cacb		d6 ca 24 a4 29 a4		    .word false ? 0 : +, xt_asm_asl_a, z_asm_asl_a
>cad1		61 73 6c 2e 61			    .text _s
.cad6						+
="asl.x"					    _s := "asl.x" ? "asl.x" : str(.asm_asl_x)
>cad6		05 0c				    .byte len(_s), IM+NN
>cad8		e3 ca 29 a4 2e a4		    .word false ? 0 : +, xt_asm_asl_x, z_asm_asl_x
>cade		61 73 6c 2e 78			    .text _s
.cae3						+
="asl.z"					    _s := "asl.z" ? "asl.z" : str(.asm_asl_z)
>cae3		05 0c				    .byte len(_s), IM+NN
>cae5		f0 ca 2e a4 33 a4		    .word false ? 0 : +, xt_asm_asl_z, z_asm_asl_z
>caeb		61 73 6c 2e 7a			    .text _s
.caf0						+
="asl.zx"					    _s := "asl.zx" ? "asl.zx" : str(.asm_asl_zx)
>caf0		06 0c				    .byte len(_s), IM+NN
>caf2		fe ca 33 a4 38 a4		    .word false ? 0 : +, xt_asm_asl_zx, z_asm_asl_zx
>caf8		61 73 6c 2e 7a 78		    .text _s
.cafe						+
="bcc"						    _s := "bcc" ? "bcc" : str(.asm_bcc)
>cafe		03 0c				    .byte len(_s), IM+NN
>cb00		09 cb 38 a4 3d a4		    .word false ? 0 : +, xt_asm_bcc, z_asm_bcc
>cb06		62 63 63			    .text _s
.cb09						+
="bcs"						    _s := "bcs" ? "bcs" : str(.asm_bcs)
>cb09		03 0c				    .byte len(_s), IM+NN
>cb0b		14 cb 3d a4 44 a4		    .word false ? 0 : +, xt_asm_bcs, z_asm_bcs
>cb11		62 63 73			    .text _s
.cb14						+
="beq"						    _s := "beq" ? "beq" : str(.asm_beq)
>cb14		03 0c				    .byte len(_s), IM+NN
>cb16		1f cb 44 a4 49 a4		    .word false ? 0 : +, xt_asm_beq, z_asm_beq
>cb1c		62 65 71			    .text _s
.cb1f						+
="bit"						    _s := "bit" ? "bit" : str(.asm_bit)
>cb1f		03 0c				    .byte len(_s), IM+NN
>cb21		2a cb 49 a4 4e a4		    .word false ? 0 : +, xt_asm_bit, z_asm_bit
>cb27		62 69 74			    .text _s
.cb2a						+
="bit.#"					    _s := "bit.#" ? "bit.#" : str(.asm_bit_h)
>cb2a		05 0c				    .byte len(_s), IM+NN
>cb2c		37 cb 4e a4 53 a4		    .word false ? 0 : +, xt_asm_bit_h, z_asm_bit_h
>cb32		62 69 74 2e 23			    .text _s
.cb37						+
="bit.x"					    _s := "bit.x" ? "bit.x" : str(.asm_bit_x)
>cb37		05 0c				    .byte len(_s), IM+NN
>cb39		44 cb 53 a4 58 a4		    .word false ? 0 : +, xt_asm_bit_x, z_asm_bit_x
>cb3f		62 69 74 2e 78			    .text _s
.cb44						+
="bit.z"					    _s := "bit.z" ? "bit.z" : str(.asm_bit_z)
>cb44		05 0c				    .byte len(_s), IM+NN
>cb46		51 cb 58 a4 5d a4		    .word false ? 0 : +, xt_asm_bit_z, z_asm_bit_z
>cb4c		62 69 74 2e 7a			    .text _s
.cb51						+
="bit.zx"					    _s := "bit.zx" ? "bit.zx" : str(.asm_bit_zx)
>cb51		06 0c				    .byte len(_s), IM+NN
>cb53		5f cb 5d a4 62 a4		    .word false ? 0 : +, xt_asm_bit_zx, z_asm_bit_zx
>cb59		62 69 74 2e 7a 78		    .text _s
.cb5f						+
="bmi"						    _s := "bmi" ? "bmi" : str(.asm_bmi)
>cb5f		03 0c				    .byte len(_s), IM+NN
>cb61		6a cb 62 a4 67 a4		    .word false ? 0 : +, xt_asm_bmi, z_asm_bmi
>cb67		62 6d 69			    .text _s
.cb6a						+
="bne"						    _s := "bne" ? "bne" : str(.asm_bne)
>cb6a		03 0c				    .byte len(_s), IM+NN
>cb6c		75 cb 67 a4 6c a4		    .word false ? 0 : +, xt_asm_bne, z_asm_bne
>cb72		62 6e 65			    .text _s
.cb75						+
="bpl"						    _s := "bpl" ? "bpl" : str(.asm_bpl)
>cb75		03 0c				    .byte len(_s), IM+NN
>cb77		80 cb 6c a4 71 a4		    .word false ? 0 : +, xt_asm_bpl, z_asm_bpl
>cb7d		62 70 6c			    .text _s
.cb80						+
="bra"						    _s := "bra" ? "bra" : str(.asm_bra)
>cb80		03 0c				    .byte len(_s), IM+NN
>cb82		8b cb 71 a4 76 a4		    .word false ? 0 : +, xt_asm_bra, z_asm_bra
>cb88		62 72 61			    .text _s
.cb8b						+
="brk"						    _s := "brk" ? "brk" : str(.asm_brk)
>cb8b		03 0c				    .byte len(_s), IM+NN
>cb8d		96 cb 76 a4 7b a4		    .word false ? 0 : +, xt_asm_brk, z_asm_brk
>cb93		62 72 6b			    .text _s
.cb96						+
="bvc"						    _s := "bvc" ? "bvc" : str(.asm_bvc)
>cb96		03 0c				    .byte len(_s), IM+NN
>cb98		a1 cb 7b a4 80 a4		    .word false ? 0 : +, xt_asm_bvc, z_asm_bvc
>cb9e		62 76 63			    .text _s
.cba1						+
="bvs"						    _s := "bvs" ? "bvs" : str(.asm_bvs)
>cba1		03 0c				    .byte len(_s), IM+NN
>cba3		ac cb 80 a4 85 a4		    .word false ? 0 : +, xt_asm_bvs, z_asm_bvs
>cba9		62 76 73			    .text _s
.cbac						+
="clc"						    _s := "clc" ? "clc" : str(.asm_clc)
>cbac		03 0c				    .byte len(_s), IM+NN
>cbae		b7 cb 85 a4 8a a4		    .word false ? 0 : +, xt_asm_clc, z_asm_clc
>cbb4		63 6c 63			    .text _s
.cbb7						+
="cld"						    _s := "cld" ? "cld" : str(.asm_cld)
>cbb7		03 0c				    .byte len(_s), IM+NN
>cbb9		c2 cb 8a a4 8f a4		    .word false ? 0 : +, xt_asm_cld, z_asm_cld
>cbbf		63 6c 64			    .text _s
.cbc2						+
="cli"						    _s := "cli" ? "cli" : str(.asm_cli)
>cbc2		03 0c				    .byte len(_s), IM+NN
>cbc4		cd cb 8f a4 94 a4		    .word false ? 0 : +, xt_asm_cli, z_asm_cli
>cbca		63 6c 69			    .text _s
.cbcd						+
="clv"						    _s := "clv" ? "clv" : str(.asm_clv)
>cbcd		03 0c				    .byte len(_s), IM+NN
>cbcf		d8 cb 94 a4 99 a4		    .word false ? 0 : +, xt_asm_clv, z_asm_clv
>cbd5		63 6c 76			    .text _s
.cbd8						+
="cmp"						    _s := "cmp" ? "cmp" : str(.asm_cmp)
>cbd8		03 0c				    .byte len(_s), IM+NN
>cbda		e3 cb 99 a4 9e a4		    .word false ? 0 : +, xt_asm_cmp, z_asm_cmp
>cbe0		63 6d 70			    .text _s
.cbe3						+
="cmp.#"					    _s := "cmp.#" ? "cmp.#" : str(.asm_cmp_h)
>cbe3		05 0c				    .byte len(_s), IM+NN
>cbe5		f0 cb 9e a4 a3 a4		    .word false ? 0 : +, xt_asm_cmp_h, z_asm_cmp_h
>cbeb		63 6d 70 2e 23			    .text _s
.cbf0						+
="cmp.x"					    _s := "cmp.x" ? "cmp.x" : str(.asm_cmp_x)
>cbf0		05 0c				    .byte len(_s), IM+NN
>cbf2		fd cb a3 a4 a8 a4		    .word false ? 0 : +, xt_asm_cmp_x, z_asm_cmp_x
>cbf8		63 6d 70 2e 78			    .text _s
.cbfd						+
="cmp.y"					    _s := "cmp.y" ? "cmp.y" : str(.asm_cmp_y)
>cbfd		05 0c				    .byte len(_s), IM+NN
>cbff		0a cc a8 a4 ad a4		    .word false ? 0 : +, xt_asm_cmp_y, z_asm_cmp_y
>cc05		63 6d 70 2e 79			    .text _s
.cc0a						+
="cmp.z"					    _s := "cmp.z" ? "cmp.z" : str(.asm_cmp_z)
>cc0a		05 0c				    .byte len(_s), IM+NN
>cc0c		17 cc ad a4 b2 a4		    .word false ? 0 : +, xt_asm_cmp_z, z_asm_cmp_z
>cc12		63 6d 70 2e 7a			    .text _s
.cc17						+
="cmp.zi"					    _s := "cmp.zi" ? "cmp.zi" : str(.asm_cmp_zi)
>cc17		06 0c				    .byte len(_s), IM+NN
>cc19		25 cc b2 a4 b7 a4		    .word false ? 0 : +, xt_asm_cmp_zi, z_asm_cmp_zi
>cc1f		63 6d 70 2e 7a 69		    .text _s
.cc25						+
="cmp.ziy"					    _s := "cmp.ziy" ? "cmp.ziy" : str(.asm_cmp_ziy)
>cc25		07 0c				    .byte len(_s), IM+NN
>cc27		34 cc b7 a4 bc a4		    .word false ? 0 : +, xt_asm_cmp_ziy, z_asm_cmp_ziy
>cc2d		63 6d 70 2e 7a 69 79		    .text _s
.cc34						+
="cmp.zx"					    _s := "cmp.zx" ? "cmp.zx" : str(.asm_cmp_zx)
>cc34		06 0c				    .byte len(_s), IM+NN
>cc36		42 cc bc a4 c1 a4		    .word false ? 0 : +, xt_asm_cmp_zx, z_asm_cmp_zx
>cc3c		63 6d 70 2e 7a 78		    .text _s
.cc42						+
="cmp.zxi"					    _s := "cmp.zxi" ? "cmp.zxi" : str(.asm_cmp_zxi)
>cc42		07 0c				    .byte len(_s), IM+NN
>cc44		51 cc c1 a4 c6 a4		    .word false ? 0 : +, xt_asm_cmp_zxi, z_asm_cmp_zxi
>cc4a		63 6d 70 2e 7a 78 69		    .text _s
.cc51						+
="cpx"						    _s := "cpx" ? "cpx" : str(.asm_cpx)
>cc51		03 0c				    .byte len(_s), IM+NN
>cc53		5c cc c6 a4 cb a4		    .word false ? 0 : +, xt_asm_cpx, z_asm_cpx
>cc59		63 70 78			    .text _s
.cc5c						+
="cpx.#"					    _s := "cpx.#" ? "cpx.#" : str(.asm_cpx_h)
>cc5c		05 0c				    .byte len(_s), IM+NN
>cc5e		69 cc cb a4 d0 a4		    .word false ? 0 : +, xt_asm_cpx_h, z_asm_cpx_h
>cc64		63 70 78 2e 23			    .text _s
.cc69						+
="cpx.z"					    _s := "cpx.z" ? "cpx.z" : str(.asm_cpx_z)
>cc69		05 0c				    .byte len(_s), IM+NN
>cc6b		76 cc d0 a4 d5 a4		    .word false ? 0 : +, xt_asm_cpx_z, z_asm_cpx_z
>cc71		63 70 78 2e 7a			    .text _s
.cc76						+
="cpy"						    _s := "cpy" ? "cpy" : str(.asm_cpy)
>cc76		03 0c				    .byte len(_s), IM+NN
>cc78		81 cc d5 a4 dc a4		    .word false ? 0 : +, xt_asm_cpy, z_asm_cpy
>cc7e		63 70 79			    .text _s
.cc81						+
="cpy.#"					    _s := "cpy.#" ? "cpy.#" : str(.asm_cpy_h)
>cc81		05 0c				    .byte len(_s), IM+NN
>cc83		8e cc dc a4 e1 a4		    .word false ? 0 : +, xt_asm_cpy_h, z_asm_cpy_h
>cc89		63 70 79 2e 23			    .text _s
.cc8e						+
="cpy.z"					    _s := "cpy.z" ? "cpy.z" : str(.asm_cpy_z)
>cc8e		05 0c				    .byte len(_s), IM+NN
>cc90		9b cc e1 a4 e6 a4		    .word false ? 0 : +, xt_asm_cpy_z, z_asm_cpy_z
>cc96		63 70 79 2e 7a			    .text _s
.cc9b						+
="dec"						    _s := "dec" ? "dec" : str(.asm_dec)
>cc9b		03 0c				    .byte len(_s), IM+NN
>cc9d		a6 cc e6 a4 eb a4		    .word false ? 0 : +, xt_asm_dec, z_asm_dec
>cca3		64 65 63			    .text _s
.cca6						+
="dec.a"					    _s := "dec.a" ? "dec.a" : str(.asm_dec_a)
>cca6		05 0c				    .byte len(_s), IM+NN
>cca8		b3 cc eb a4 f0 a4		    .word false ? 0 : +, xt_asm_dec_a, z_asm_dec_a
>ccae		64 65 63 2e 61			    .text _s
.ccb3						+
="dec.x"					    _s := "dec.x" ? "dec.x" : str(.asm_dec_x)
>ccb3		05 0c				    .byte len(_s), IM+NN
>ccb5		c0 cc f0 a4 f5 a4		    .word false ? 0 : +, xt_asm_dec_x, z_asm_dec_x
>ccbb		64 65 63 2e 78			    .text _s
.ccc0						+
="dec.z"					    _s := "dec.z" ? "dec.z" : str(.asm_dec_z)
>ccc0		05 0c				    .byte len(_s), IM+NN
>ccc2		cd cc f5 a4 fa a4		    .word false ? 0 : +, xt_asm_dec_z, z_asm_dec_z
>ccc8		64 65 63 2e 7a			    .text _s
.cccd						+
="dec.zx"					    _s := "dec.zx" ? "dec.zx" : str(.asm_dec_zx)
>cccd		06 0c				    .byte len(_s), IM+NN
>cccf		db cc fa a4 ff a4		    .word false ? 0 : +, xt_asm_dec_zx, z_asm_dec_zx
>ccd5		64 65 63 2e 7a 78		    .text _s
.ccdb						+
="dex"						    _s := "dex" ? "dex" : str(.asm_dex)
>ccdb		03 0c				    .byte len(_s), IM+NN
>ccdd		e6 cc ff a4 04 a5		    .word false ? 0 : +, xt_asm_dex, z_asm_dex
>cce3		64 65 78			    .text _s
.cce6						+
="dey"						    _s := "dey" ? "dey" : str(.asm_dey)
>cce6		03 0c				    .byte len(_s), IM+NN
>cce8		f1 cc 04 a5 09 a5		    .word false ? 0 : +, xt_asm_dey, z_asm_dey
>ccee		64 65 79			    .text _s
.ccf1						+
="eor"						    _s := "eor" ? "eor" : str(.asm_eor)
>ccf1		03 0c				    .byte len(_s), IM+NN
>ccf3		fc cc 09 a5 0e a5		    .word false ? 0 : +, xt_asm_eor, z_asm_eor
>ccf9		65 6f 72			    .text _s
.ccfc						+
="eor.#"					    _s := "eor.#" ? "eor.#" : str(.asm_eor_h)
>ccfc		05 0c				    .byte len(_s), IM+NN
>ccfe		09 cd 0e a5 13 a5		    .word false ? 0 : +, xt_asm_eor_h, z_asm_eor_h
>cd04		65 6f 72 2e 23			    .text _s
.cd09						+
="eor.x"					    _s := "eor.x" ? "eor.x" : str(.asm_eor_x)
>cd09		05 0c				    .byte len(_s), IM+NN
>cd0b		16 cd 13 a5 18 a5		    .word false ? 0 : +, xt_asm_eor_x, z_asm_eor_x
>cd11		65 6f 72 2e 78			    .text _s
.cd16						+
="eor.y"					    _s := "eor.y" ? "eor.y" : str(.asm_eor_y)
>cd16		05 0c				    .byte len(_s), IM+NN
>cd18		23 cd 18 a5 1d a5		    .word false ? 0 : +, xt_asm_eor_y, z_asm_eor_y
>cd1e		65 6f 72 2e 79			    .text _s
.cd23						+
="eor.z"					    _s := "eor.z" ? "eor.z" : str(.asm_eor_z)
>cd23		05 0c				    .byte len(_s), IM+NN
>cd25		30 cd 1d a5 22 a5		    .word false ? 0 : +, xt_asm_eor_z, z_asm_eor_z
>cd2b		65 6f 72 2e 7a			    .text _s
.cd30						+
="eor.zi"					    _s := "eor.zi" ? "eor.zi" : str(.asm_eor_zi)
>cd30		06 0c				    .byte len(_s), IM+NN
>cd32		3e cd 22 a5 27 a5		    .word false ? 0 : +, xt_asm_eor_zi, z_asm_eor_zi
>cd38		65 6f 72 2e 7a 69		    .text _s
.cd3e						+
="eor.ziy"					    _s := "eor.ziy" ? "eor.ziy" : str(.asm_eor_ziy)
>cd3e		07 0c				    .byte len(_s), IM+NN
>cd40		4d cd 27 a5 2c a5		    .word false ? 0 : +, xt_asm_eor_ziy, z_asm_eor_ziy
>cd46		65 6f 72 2e 7a 69 79		    .text _s
.cd4d						+
="eor.zx"					    _s := "eor.zx" ? "eor.zx" : str(.asm_eor_zx)
>cd4d		06 0c				    .byte len(_s), IM+NN
>cd4f		5b cd 2c a5 31 a5		    .word false ? 0 : +, xt_asm_eor_zx, z_asm_eor_zx
>cd55		65 6f 72 2e 7a 78		    .text _s
.cd5b						+
="eor.zxi"					    _s := "eor.zxi" ? "eor.zxi" : str(.asm_eor_zxi)
>cd5b		07 0c				    .byte len(_s), IM+NN
>cd5d		6a cd 31 a5 36 a5		    .word false ? 0 : +, xt_asm_eor_zxi, z_asm_eor_zxi
>cd63		65 6f 72 2e 7a 78 69		    .text _s
.cd6a						+
="inc"						    _s := "inc" ? "inc" : str(.asm_inc)
>cd6a		03 0c				    .byte len(_s), IM+NN
>cd6c		75 cd 36 a5 3b a5		    .word false ? 0 : +, xt_asm_inc, z_asm_inc
>cd72		69 6e 63			    .text _s
.cd75						+
="inc.a"					    _s := "inc.a" ? "inc.a" : str(.asm_inc_a)
>cd75		05 0c				    .byte len(_s), IM+NN
>cd77		82 cd 3b a5 40 a5		    .word false ? 0 : +, xt_asm_inc_a, z_asm_inc_a
>cd7d		69 6e 63 2e 61			    .text _s
.cd82						+
="inc.x"					    _s := "inc.x" ? "inc.x" : str(.asm_inc_x)
>cd82		05 0c				    .byte len(_s), IM+NN
>cd84		8f cd 40 a5 45 a5		    .word false ? 0 : +, xt_asm_inc_x, z_asm_inc_x
>cd8a		69 6e 63 2e 78			    .text _s
.cd8f						+
="inc.z"					    _s := "inc.z" ? "inc.z" : str(.asm_inc_z)
>cd8f		05 0c				    .byte len(_s), IM+NN
>cd91		9c cd 45 a5 4a a5		    .word false ? 0 : +, xt_asm_inc_z, z_asm_inc_z
>cd97		69 6e 63 2e 7a			    .text _s
.cd9c						+
="inc.zx"					    _s := "inc.zx" ? "inc.zx" : str(.asm_inc_zx)
>cd9c		06 0c				    .byte len(_s), IM+NN
>cd9e		aa cd 4a a5 4f a5		    .word false ? 0 : +, xt_asm_inc_zx, z_asm_inc_zx
>cda4		69 6e 63 2e 7a 78		    .text _s
.cdaa						+
="inx"						    _s := "inx" ? "inx" : str(.asm_inx)
>cdaa		03 0c				    .byte len(_s), IM+NN
>cdac		b5 cd 4f a5 54 a5		    .word false ? 0 : +, xt_asm_inx, z_asm_inx
>cdb2		69 6e 78			    .text _s
.cdb5						+
="iny"						    _s := "iny" ? "iny" : str(.asm_iny)
>cdb5		03 0c				    .byte len(_s), IM+NN
>cdb7		c0 cd 54 a5 59 a5		    .word false ? 0 : +, xt_asm_iny, z_asm_iny
>cdbd		69 6e 79			    .text _s
.cdc0						+
="jmp"						    _s := "jmp" ? "jmp" : str(.asm_jmp)
>cdc0		03 0c				    .byte len(_s), IM+NN
>cdc2		cb cd 59 a5 5e a5		    .word false ? 0 : +, xt_asm_jmp, z_asm_jmp
>cdc8		6a 6d 70			    .text _s
.cdcb						+
="jmp.i"					    _s := "jmp.i" ? "jmp.i" : str(.asm_jmp_i)
>cdcb		05 0c				    .byte len(_s), IM+NN
>cdcd		d8 cd 5e a5 63 a5		    .word false ? 0 : +, xt_asm_jmp_i, z_asm_jmp_i
>cdd3		6a 6d 70 2e 69			    .text _s
.cdd8						+
="jmp.xi"					    _s := "jmp.xi" ? "jmp.xi" : str(.asm_jmp_xi)
>cdd8		06 0c				    .byte len(_s), IM+NN
>cdda		e6 cd 63 a5 68 a5		    .word false ? 0 : +, xt_asm_jmp_xi, z_asm_jmp_xi
>cde0		6a 6d 70 2e 78 69		    .text _s
.cde6						+
="jsr"						    _s := "jsr" ? "jsr" : str(.asm_jsr)
>cde6		03 0c				    .byte len(_s), IM+NN
>cde8		f1 cd 68 a5 6d a5		    .word false ? 0 : +, xt_asm_jsr, z_asm_jsr
>cdee		6a 73 72			    .text _s
.cdf1						+
="lda"						    _s := "lda" ? "lda" : str(.asm_lda)
>cdf1		03 0c				    .byte len(_s), IM+NN
>cdf3		fc cd 6d a5 72 a5		    .word false ? 0 : +, xt_asm_lda, z_asm_lda
>cdf9		6c 64 61			    .text _s
.cdfc						+
="lda.#"					    _s := "lda.#" ? "lda.#" : str(.asm_lda_h)
>cdfc		05 0c				    .byte len(_s), IM+NN
>cdfe		09 ce 72 a5 77 a5		    .word false ? 0 : +, xt_asm_lda_h, z_asm_lda_h
>ce04		6c 64 61 2e 23			    .text _s
.ce09						+
="lda.x"					    _s := "lda.x" ? "lda.x" : str(.asm_lda_x)
>ce09		05 0c				    .byte len(_s), IM+NN
>ce0b		16 ce 77 a5 7c a5		    .word false ? 0 : +, xt_asm_lda_x, z_asm_lda_x
>ce11		6c 64 61 2e 78			    .text _s
.ce16						+
="lda.y"					    _s := "lda.y" ? "lda.y" : str(.asm_lda_y)
>ce16		05 0c				    .byte len(_s), IM+NN
>ce18		23 ce 7c a5 81 a5		    .word false ? 0 : +, xt_asm_lda_y, z_asm_lda_y
>ce1e		6c 64 61 2e 79			    .text _s
.ce23						+
="lda.z"					    _s := "lda.z" ? "lda.z" : str(.asm_lda_z)
>ce23		05 0c				    .byte len(_s), IM+NN
>ce25		30 ce 81 a5 86 a5		    .word false ? 0 : +, xt_asm_lda_z, z_asm_lda_z
>ce2b		6c 64 61 2e 7a			    .text _s
.ce30						+
="lda.zi"					    _s := "lda.zi" ? "lda.zi" : str(.asm_lda_zi)
>ce30		06 0c				    .byte len(_s), IM+NN
>ce32		3e ce 86 a5 8b a5		    .word false ? 0 : +, xt_asm_lda_zi, z_asm_lda_zi
>ce38		6c 64 61 2e 7a 69		    .text _s
.ce3e						+
="lda.ziy"					    _s := "lda.ziy" ? "lda.ziy" : str(.asm_lda_ziy)
>ce3e		07 0c				    .byte len(_s), IM+NN
>ce40		4d ce 8b a5 90 a5		    .word false ? 0 : +, xt_asm_lda_ziy, z_asm_lda_ziy
>ce46		6c 64 61 2e 7a 69 79		    .text _s
.ce4d						+
="lda.zx"					    _s := "lda.zx" ? "lda.zx" : str(.asm_lda_zx)
>ce4d		06 0c				    .byte len(_s), IM+NN
>ce4f		5b ce 90 a5 95 a5		    .word false ? 0 : +, xt_asm_lda_zx, z_asm_lda_zx
>ce55		6c 64 61 2e 7a 78		    .text _s
.ce5b						+
="lda.zxi"					    _s := "lda.zxi" ? "lda.zxi" : str(.asm_lda_zxi)
>ce5b		07 0c				    .byte len(_s), IM+NN
>ce5d		6a ce 95 a5 9a a5		    .word false ? 0 : +, xt_asm_lda_zxi, z_asm_lda_zxi
>ce63		6c 64 61 2e 7a 78 69		    .text _s
.ce6a						+
="ldx"						    _s := "ldx" ? "ldx" : str(.asm_ldx)
>ce6a		03 0c				    .byte len(_s), IM+NN
>ce6c		75 ce 9a a5 9f a5		    .word false ? 0 : +, xt_asm_ldx, z_asm_ldx
>ce72		6c 64 78			    .text _s
.ce75						+
="ldx.#"					    _s := "ldx.#" ? "ldx.#" : str(.asm_ldx_h)
>ce75		05 0c				    .byte len(_s), IM+NN
>ce77		82 ce 9f a5 a4 a5		    .word false ? 0 : +, xt_asm_ldx_h, z_asm_ldx_h
>ce7d		6c 64 78 2e 23			    .text _s
.ce82						+
="ldx.y"					    _s := "ldx.y" ? "ldx.y" : str(.asm_ldx_y)
>ce82		05 0c				    .byte len(_s), IM+NN
>ce84		8f ce a4 a5 a9 a5		    .word false ? 0 : +, xt_asm_ldx_y, z_asm_ldx_y
>ce8a		6c 64 78 2e 79			    .text _s
.ce8f						+
="ldx.z"					    _s := "ldx.z" ? "ldx.z" : str(.asm_ldx_z)
>ce8f		05 0c				    .byte len(_s), IM+NN
>ce91		9c ce a9 a5 ae a5		    .word false ? 0 : +, xt_asm_ldx_z, z_asm_ldx_z
>ce97		6c 64 78 2e 7a			    .text _s
.ce9c						+
="ldx.zy"					    _s := "ldx.zy" ? "ldx.zy" : str(.asm_ldx_zy)
>ce9c		06 0c				    .byte len(_s), IM+NN
>ce9e		aa ce ae a5 b3 a5		    .word false ? 0 : +, xt_asm_ldx_zy, z_asm_ldx_zy
>cea4		6c 64 78 2e 7a 79		    .text _s
.ceaa						+
="ldy"						    _s := "ldy" ? "ldy" : str(.asm_ldy)
>ceaa		03 0c				    .byte len(_s), IM+NN
>ceac		b5 ce b3 a5 b8 a5		    .word false ? 0 : +, xt_asm_ldy, z_asm_ldy
>ceb2		6c 64 79			    .text _s
.ceb5						+
="ldy.#"					    _s := "ldy.#" ? "ldy.#" : str(.asm_ldy_h)
>ceb5		05 0c				    .byte len(_s), IM+NN
>ceb7		c2 ce b8 a5 bd a5		    .word false ? 0 : +, xt_asm_ldy_h, z_asm_ldy_h
>cebd		6c 64 79 2e 23			    .text _s
.cec2						+
="ldy.x"					    _s := "ldy.x" ? "ldy.x" : str(.asm_ldy_x)
>cec2		05 0c				    .byte len(_s), IM+NN
>cec4		cf ce bd a5 c2 a5		    .word false ? 0 : +, xt_asm_ldy_x, z_asm_ldy_x
>ceca		6c 64 79 2e 78			    .text _s
.cecf						+
="ldy.z"					    _s := "ldy.z" ? "ldy.z" : str(.asm_ldy_z)
>cecf		05 0c				    .byte len(_s), IM+NN
>ced1		dc ce c2 a5 c7 a5		    .word false ? 0 : +, xt_asm_ldy_z, z_asm_ldy_z
>ced7		6c 64 79 2e 7a			    .text _s
.cedc						+
="ldy.zx"					    _s := "ldy.zx" ? "ldy.zx" : str(.asm_ldy_zx)
>cedc		06 0c				    .byte len(_s), IM+NN
>cede		ea ce c7 a5 cc a5		    .word false ? 0 : +, xt_asm_ldy_zx, z_asm_ldy_zx
>cee4		6c 64 79 2e 7a 78		    .text _s
.ceea						+
="lsr"						    _s := "lsr" ? "lsr" : str(.asm_lsr)
>ceea		03 0c				    .byte len(_s), IM+NN
>ceec		f5 ce cc a5 d1 a5		    .word false ? 0 : +, xt_asm_lsr, z_asm_lsr
>cef2		6c 73 72			    .text _s
.cef5						+
="lsr.a"					    _s := "lsr.a" ? "lsr.a" : str(.asm_lsr_a)
>cef5		05 0c				    .byte len(_s), IM+NN
>cef7		02 cf d1 a5 d6 a5		    .word false ? 0 : +, xt_asm_lsr_a, z_asm_lsr_a
>cefd		6c 73 72 2e 61			    .text _s
.cf02						+
="lsr.x"					    _s := "lsr.x" ? "lsr.x" : str(.asm_lsr_x)
>cf02		05 0c				    .byte len(_s), IM+NN
>cf04		0f cf d6 a5 db a5		    .word false ? 0 : +, xt_asm_lsr_x, z_asm_lsr_x
>cf0a		6c 73 72 2e 78			    .text _s
.cf0f						+
="lsr.z"					    _s := "lsr.z" ? "lsr.z" : str(.asm_lsr_z)
>cf0f		05 0c				    .byte len(_s), IM+NN
>cf11		1c cf db a5 e0 a5		    .word false ? 0 : +, xt_asm_lsr_z, z_asm_lsr_z
>cf17		6c 73 72 2e 7a			    .text _s
.cf1c						+
="lsr.zx"					    _s := "lsr.zx" ? "lsr.zx" : str(.asm_lsr_zx)
>cf1c		06 0c				    .byte len(_s), IM+NN
>cf1e		2a cf e0 a5 e5 a5		    .word false ? 0 : +, xt_asm_lsr_zx, z_asm_lsr_zx
>cf24		6c 73 72 2e 7a 78		    .text _s
.cf2a						+
="nop"						    _s := "nop" ? "nop" : str(.asm_nop)
>cf2a		03 0c				    .byte len(_s), IM+NN
>cf2c		35 cf e5 a5 ea a5		    .word false ? 0 : +, xt_asm_nop, z_asm_nop
>cf32		6e 6f 70			    .text _s
.cf35						+
="ora"						    _s := "ora" ? "ora" : str(.asm_ora)
>cf35		03 0c				    .byte len(_s), IM+NN
>cf37		40 cf ea a5 ef a5		    .word false ? 0 : +, xt_asm_ora, z_asm_ora
>cf3d		6f 72 61			    .text _s
.cf40						+
="ora.#"					    _s := "ora.#" ? "ora.#" : str(.asm_ora_h)
>cf40		05 0c				    .byte len(_s), IM+NN
>cf42		4d cf ef a5 f4 a5		    .word false ? 0 : +, xt_asm_ora_h, z_asm_ora_h
>cf48		6f 72 61 2e 23			    .text _s
.cf4d						+
="ora.x"					    _s := "ora.x" ? "ora.x" : str(.asm_ora_x)
>cf4d		05 0c				    .byte len(_s), IM+NN
>cf4f		5a cf f4 a5 f9 a5		    .word false ? 0 : +, xt_asm_ora_x, z_asm_ora_x
>cf55		6f 72 61 2e 78			    .text _s
.cf5a						+
="ora.y"					    _s := "ora.y" ? "ora.y" : str(.asm_ora_y)
>cf5a		05 0c				    .byte len(_s), IM+NN
>cf5c		67 cf f9 a5 fe a5		    .word false ? 0 : +, xt_asm_ora_y, z_asm_ora_y
>cf62		6f 72 61 2e 79			    .text _s
.cf67						+
="ora.z"					    _s := "ora.z" ? "ora.z" : str(.asm_ora_z)
>cf67		05 0c				    .byte len(_s), IM+NN
>cf69		74 cf fe a5 03 a6		    .word false ? 0 : +, xt_asm_ora_z, z_asm_ora_z
>cf6f		6f 72 61 2e 7a			    .text _s
.cf74						+
="ora.zi"					    _s := "ora.zi" ? "ora.zi" : str(.asm_ora_zi)
>cf74		06 0c				    .byte len(_s), IM+NN
>cf76		82 cf 03 a6 0a a6		    .word false ? 0 : +, xt_asm_ora_zi, z_asm_ora_zi
>cf7c		6f 72 61 2e 7a 69		    .text _s
.cf82						+
="ora.ziy"					    _s := "ora.ziy" ? "ora.ziy" : str(.asm_ora_ziy)
>cf82		07 0c				    .byte len(_s), IM+NN
>cf84		91 cf 0a a6 0f a6		    .word false ? 0 : +, xt_asm_ora_ziy, z_asm_ora_ziy
>cf8a		6f 72 61 2e 7a 69 79		    .text _s
.cf91						+
="ora.zx"					    _s := "ora.zx" ? "ora.zx" : str(.asm_ora_zx)
>cf91		06 0c				    .byte len(_s), IM+NN
>cf93		9f cf 0f a6 14 a6		    .word false ? 0 : +, xt_asm_ora_zx, z_asm_ora_zx
>cf99		6f 72 61 2e 7a 78		    .text _s
.cf9f						+
="ora.zxi"					    _s := "ora.zxi" ? "ora.zxi" : str(.asm_ora_zxi)
>cf9f		07 0c				    .byte len(_s), IM+NN
>cfa1		ae cf 14 a6 19 a6		    .word false ? 0 : +, xt_asm_ora_zxi, z_asm_ora_zxi
>cfa7		6f 72 61 2e 7a 78 69		    .text _s
.cfae						+
="pha"						    _s := "pha" ? "pha" : str(.asm_pha)
>cfae		03 0c				    .byte len(_s), IM+NN
>cfb0		b9 cf 19 a6 1e a6		    .word false ? 0 : +, xt_asm_pha, z_asm_pha
>cfb6		70 68 61			    .text _s
.cfb9						+
="php"						    _s := "php" ? "php" : str(.asm_php)
>cfb9		03 0c				    .byte len(_s), IM+NN
>cfbb		c4 cf 1e a6 23 a6		    .word false ? 0 : +, xt_asm_php, z_asm_php
>cfc1		70 68 70			    .text _s
.cfc4						+
="phx"						    _s := "phx" ? "phx" : str(.asm_phx)
>cfc4		03 0c				    .byte len(_s), IM+NN
>cfc6		cf cf 23 a6 28 a6		    .word false ? 0 : +, xt_asm_phx, z_asm_phx
>cfcc		70 68 78			    .text _s
.cfcf						+
="phy"						    _s := "phy" ? "phy" : str(.asm_phy)
>cfcf		03 0c				    .byte len(_s), IM+NN
>cfd1		da cf 28 a6 2d a6		    .word false ? 0 : +, xt_asm_phy, z_asm_phy
>cfd7		70 68 79			    .text _s
.cfda						+
="pla"						    _s := "pla" ? "pla" : str(.asm_pla)
>cfda		03 0c				    .byte len(_s), IM+NN
>cfdc		e5 cf 2d a6 32 a6		    .word false ? 0 : +, xt_asm_pla, z_asm_pla
>cfe2		70 6c 61			    .text _s
.cfe5						+
="plp"						    _s := "plp" ? "plp" : str(.asm_plp)
>cfe5		03 0c				    .byte len(_s), IM+NN
>cfe7		f0 cf 32 a6 37 a6		    .word false ? 0 : +, xt_asm_plp, z_asm_plp
>cfed		70 6c 70			    .text _s
.cff0						+
="plx"						    _s := "plx" ? "plx" : str(.asm_plx)
>cff0		03 0c				    .byte len(_s), IM+NN
>cff2		fb cf 37 a6 3c a6		    .word false ? 0 : +, xt_asm_plx, z_asm_plx
>cff8		70 6c 78			    .text _s
.cffb						+
="ply"						    _s := "ply" ? "ply" : str(.asm_ply)
>cffb		03 0c				    .byte len(_s), IM+NN
>cffd		06 d0 3c a6 41 a6		    .word false ? 0 : +, xt_asm_ply, z_asm_ply
>d003		70 6c 79			    .text _s
.d006						+
="rol"						    _s := "rol" ? "rol" : str(.asm_rol)
>d006		03 0c				    .byte len(_s), IM+NN
>d008		11 d0 41 a6 46 a6		    .word false ? 0 : +, xt_asm_rol, z_asm_rol
>d00e		72 6f 6c			    .text _s
.d011						+
="rol.a"					    _s := "rol.a" ? "rol.a" : str(.asm_rol_a)
>d011		05 0c				    .byte len(_s), IM+NN
>d013		1e d0 46 a6 4b a6		    .word false ? 0 : +, xt_asm_rol_a, z_asm_rol_a
>d019		72 6f 6c 2e 61			    .text _s
.d01e						+
="rol.x"					    _s := "rol.x" ? "rol.x" : str(.asm_rol_x)
>d01e		05 0c				    .byte len(_s), IM+NN
>d020		2b d0 4b a6 50 a6		    .word false ? 0 : +, xt_asm_rol_x, z_asm_rol_x
>d026		72 6f 6c 2e 78			    .text _s
.d02b						+
="rol.z"					    _s := "rol.z" ? "rol.z" : str(.asm_rol_z)
>d02b		05 0c				    .byte len(_s), IM+NN
>d02d		38 d0 50 a6 55 a6		    .word false ? 0 : +, xt_asm_rol_z, z_asm_rol_z
>d033		72 6f 6c 2e 7a			    .text _s
.d038						+
="rol.zx"					    _s := "rol.zx" ? "rol.zx" : str(.asm_rol_zx)
>d038		06 0c				    .byte len(_s), IM+NN
>d03a		46 d0 55 a6 5a a6		    .word false ? 0 : +, xt_asm_rol_zx, z_asm_rol_zx
>d040		72 6f 6c 2e 7a 78		    .text _s
.d046						+
="ror"						    _s := "ror" ? "ror" : str(.asm_ror)
>d046		03 0c				    .byte len(_s), IM+NN
>d048		51 d0 5a a6 5f a6		    .word false ? 0 : +, xt_asm_ror, z_asm_ror
>d04e		72 6f 72			    .text _s
.d051						+
="ror.a"					    _s := "ror.a" ? "ror.a" : str(.asm_ror_a)
>d051		05 0c				    .byte len(_s), IM+NN
>d053		5e d0 5f a6 64 a6		    .word false ? 0 : +, xt_asm_ror_a, z_asm_ror_a
>d059		72 6f 72 2e 61			    .text _s
.d05e						+
="ror.x"					    _s := "ror.x" ? "ror.x" : str(.asm_ror_x)
>d05e		05 0c				    .byte len(_s), IM+NN
>d060		6b d0 64 a6 69 a6		    .word false ? 0 : +, xt_asm_ror_x, z_asm_ror_x
>d066		72 6f 72 2e 78			    .text _s
.d06b						+
="ror.z"					    _s := "ror.z" ? "ror.z" : str(.asm_ror_z)
>d06b		05 0c				    .byte len(_s), IM+NN
>d06d		78 d0 69 a6 6e a6		    .word false ? 0 : +, xt_asm_ror_z, z_asm_ror_z
>d073		72 6f 72 2e 7a			    .text _s
.d078						+
="ror.zx"					    _s := "ror.zx" ? "ror.zx" : str(.asm_ror_zx)
>d078		06 0c				    .byte len(_s), IM+NN
>d07a		86 d0 6e a6 73 a6		    .word false ? 0 : +, xt_asm_ror_zx, z_asm_ror_zx
>d080		72 6f 72 2e 7a 78		    .text _s
.d086						+
="rti"						    _s := "rti" ? "rti" : str(.asm_rti)
>d086		03 0c				    .byte len(_s), IM+NN
>d088		91 d0 73 a6 78 a6		    .word false ? 0 : +, xt_asm_rti, z_asm_rti
>d08e		72 74 69			    .text _s
.d091						+
="rts"						    _s := "rts" ? "rts" : str(.asm_rts)
>d091		03 0c				    .byte len(_s), IM+NN
>d093		9c d0 78 a6 7d a6		    .word false ? 0 : +, xt_asm_rts, z_asm_rts
>d099		72 74 73			    .text _s
.d09c						+
="sbc"						    _s := "sbc" ? "sbc" : str(.asm_sbc)
>d09c		03 0c				    .byte len(_s), IM+NN
>d09e		a7 d0 7d a6 82 a6		    .word false ? 0 : +, xt_asm_sbc, z_asm_sbc
>d0a4		73 62 63			    .text _s
.d0a7						+
="sbc.#"					    _s := "sbc.#" ? "sbc.#" : str(.asm_sbc_h)
>d0a7		05 0c				    .byte len(_s), IM+NN
>d0a9		b4 d0 82 a6 87 a6		    .word false ? 0 : +, xt_asm_sbc_h, z_asm_sbc_h
>d0af		73 62 63 2e 23			    .text _s
.d0b4						+
="sbc.x"					    _s := "sbc.x" ? "sbc.x" : str(.asm_sbc_x)
>d0b4		05 0c				    .byte len(_s), IM+NN
>d0b6		c1 d0 87 a6 8c a6		    .word false ? 0 : +, xt_asm_sbc_x, z_asm_sbc_x
>d0bc		73 62 63 2e 78			    .text _s
.d0c1						+
="sbc.y"					    _s := "sbc.y" ? "sbc.y" : str(.asm_sbc_y)
>d0c1		05 0c				    .byte len(_s), IM+NN
>d0c3		ce d0 8c a6 91 a6		    .word false ? 0 : +, xt_asm_sbc_y, z_asm_sbc_y
>d0c9		73 62 63 2e 79			    .text _s
.d0ce						+
="sbc.z"					    _s := "sbc.z" ? "sbc.z" : str(.asm_sbc_z)
>d0ce		05 0c				    .byte len(_s), IM+NN
>d0d0		db d0 91 a6 96 a6		    .word false ? 0 : +, xt_asm_sbc_z, z_asm_sbc_z
>d0d6		73 62 63 2e 7a			    .text _s
.d0db						+
="sbc.zi"					    _s := "sbc.zi" ? "sbc.zi" : str(.asm_sbc_zi)
>d0db		06 0c				    .byte len(_s), IM+NN
>d0dd		e9 d0 96 a6 9b a6		    .word false ? 0 : +, xt_asm_sbc_zi, z_asm_sbc_zi
>d0e3		73 62 63 2e 7a 69		    .text _s
.d0e9						+
="sbc.ziy"					    _s := "sbc.ziy" ? "sbc.ziy" : str(.asm_sbc_ziy)
>d0e9		07 0c				    .byte len(_s), IM+NN
>d0eb		f8 d0 9b a6 a0 a6		    .word false ? 0 : +, xt_asm_sbc_ziy, z_asm_sbc_ziy
>d0f1		73 62 63 2e 7a 69 79		    .text _s
.d0f8						+
="sbc.zx"					    _s := "sbc.zx" ? "sbc.zx" : str(.asm_sbc_zx)
>d0f8		06 0c				    .byte len(_s), IM+NN
>d0fa		06 d1 a0 a6 a5 a6		    .word false ? 0 : +, xt_asm_sbc_zx, z_asm_sbc_zx
>d100		73 62 63 2e 7a 78		    .text _s
.d106						+
="sbc.zxi"					    _s := "sbc.zxi" ? "sbc.zxi" : str(.asm_sbc_zxi)
>d106		07 0c				    .byte len(_s), IM+NN
>d108		15 d1 a5 a6 a9 a6		    .word false ? 0 : +, xt_asm_sbc_zxi, z_asm_sbc_zxi
>d10e		73 62 63 2e 7a 78 69		    .text _s
.d115						+
="sec"						    _s := "sec" ? "sec" : str(.asm_sec)
>d115		03 0c				    .byte len(_s), IM+NN
>d117		20 d1 a9 a6 ad a6		    .word false ? 0 : +, xt_asm_sec, z_asm_sec
>d11d		73 65 63			    .text _s
.d120						+
="sed"						    _s := "sed" ? "sed" : str(.asm_sed)
>d120		03 0c				    .byte len(_s), IM+NN
>d122		2b d1 ad a6 b1 a6		    .word false ? 0 : +, xt_asm_sed, z_asm_sed
>d128		73 65 64			    .text _s
.d12b						+
="sei"						    _s := "sei" ? "sei" : str(.asm_sei)
>d12b		03 0c				    .byte len(_s), IM+NN
>d12d		36 d1 b1 a6 b5 a6		    .word false ? 0 : +, xt_asm_sei, z_asm_sei
>d133		73 65 69			    .text _s
.d136						+
="sta"						    _s := "sta" ? "sta" : str(.asm_sta)
>d136		03 0c				    .byte len(_s), IM+NN
>d138		41 d1 b5 a6 b9 a6		    .word false ? 0 : +, xt_asm_sta, z_asm_sta
>d13e		73 74 61			    .text _s
.d141						+
="sta.x"					    _s := "sta.x" ? "sta.x" : str(.asm_sta_x)
>d141		05 0c				    .byte len(_s), IM+NN
>d143		4e d1 b9 a6 bd a6		    .word false ? 0 : +, xt_asm_sta_x, z_asm_sta_x
>d149		73 74 61 2e 78			    .text _s
.d14e						+
="sta.y"					    _s := "sta.y" ? "sta.y" : str(.asm_sta_y)
>d14e		05 0c				    .byte len(_s), IM+NN
>d150		5b d1 bd a6 c1 a6		    .word false ? 0 : +, xt_asm_sta_y, z_asm_sta_y
>d156		73 74 61 2e 79			    .text _s
.d15b						+
="sta.z"					    _s := "sta.z" ? "sta.z" : str(.asm_sta_z)
>d15b		05 0c				    .byte len(_s), IM+NN
>d15d		68 d1 c1 a6 c5 a6		    .word false ? 0 : +, xt_asm_sta_z, z_asm_sta_z
>d163		73 74 61 2e 7a			    .text _s
.d168						+
="sta.zi"					    _s := "sta.zi" ? "sta.zi" : str(.asm_sta_zi)
>d168		06 0c				    .byte len(_s), IM+NN
>d16a		76 d1 c5 a6 c9 a6		    .word false ? 0 : +, xt_asm_sta_zi, z_asm_sta_zi
>d170		73 74 61 2e 7a 69		    .text _s
.d176						+
="sta.ziy"					    _s := "sta.ziy" ? "sta.ziy" : str(.asm_sta_ziy)
>d176		07 0c				    .byte len(_s), IM+NN
>d178		85 d1 c9 a6 cd a6		    .word false ? 0 : +, xt_asm_sta_ziy, z_asm_sta_ziy
>d17e		73 74 61 2e 7a 69 79		    .text _s
.d185						+
="sta.zx"					    _s := "sta.zx" ? "sta.zx" : str(.asm_sta_zx)
>d185		06 0c				    .byte len(_s), IM+NN
>d187		93 d1 cd a6 d1 a6		    .word false ? 0 : +, xt_asm_sta_zx, z_asm_sta_zx
>d18d		73 74 61 2e 7a 78		    .text _s
.d193						+
="sta.zxi"					    _s := "sta.zxi" ? "sta.zxi" : str(.asm_sta_zxi)
>d193		07 0c				    .byte len(_s), IM+NN
>d195		a2 d1 d1 a6 d5 a6		    .word false ? 0 : +, xt_asm_sta_zxi, z_asm_sta_zxi
>d19b		73 74 61 2e 7a 78 69		    .text _s
.d1a2						+
="stx"						    _s := "stx" ? "stx" : str(.asm_stx)
>d1a2		03 0c				    .byte len(_s), IM+NN
>d1a4		ad d1 d5 a6 d9 a6		    .word false ? 0 : +, xt_asm_stx, z_asm_stx
>d1aa		73 74 78			    .text _s
.d1ad						+
="stx.z"					    _s := "stx.z" ? "stx.z" : str(.asm_stx_z)
>d1ad		05 0c				    .byte len(_s), IM+NN
>d1af		ba d1 d9 a6 dd a6		    .word false ? 0 : +, xt_asm_stx_z, z_asm_stx_z
>d1b5		73 74 78 2e 7a			    .text _s
.d1ba						+
="stx.zy"					    _s := "stx.zy" ? "stx.zy" : str(.asm_stx_zy)
>d1ba		06 0c				    .byte len(_s), IM+NN
>d1bc		c8 d1 dd a6 e1 a6		    .word false ? 0 : +, xt_asm_stx_zy, z_asm_stx_zy
>d1c2		73 74 78 2e 7a 79		    .text _s
.d1c8						+
="sty"						    _s := "sty" ? "sty" : str(.asm_sty)
>d1c8		03 0c				    .byte len(_s), IM+NN
>d1ca		d3 d1 e1 a6 e5 a6		    .word false ? 0 : +, xt_asm_sty, z_asm_sty
>d1d0		73 74 79			    .text _s
.d1d3						+
="sty.z"					    _s := "sty.z" ? "sty.z" : str(.asm_sty_z)
>d1d3		05 0c				    .byte len(_s), IM+NN
>d1d5		e0 d1 e5 a6 e9 a6		    .word false ? 0 : +, xt_asm_sty_z, z_asm_sty_z
>d1db		73 74 79 2e 7a			    .text _s
.d1e0						+
="sty.zx"					    _s := "sty.zx" ? "sty.zx" : str(.asm_sty_zx)
>d1e0		06 0c				    .byte len(_s), IM+NN
>d1e2		ee d1 e9 a6 ed a6		    .word false ? 0 : +, xt_asm_sty_zx, z_asm_sty_zx
>d1e8		73 74 79 2e 7a 78		    .text _s
.d1ee						+
="stz"						    _s := "stz" ? "stz" : str(.asm_stz)
>d1ee		03 0c				    .byte len(_s), IM+NN
>d1f0		f9 d1 ed a6 f1 a6		    .word false ? 0 : +, xt_asm_stz, z_asm_stz
>d1f6		73 74 7a			    .text _s
.d1f9						+
="stz.x"					    _s := "stz.x" ? "stz.x" : str(.asm_stz_x)
>d1f9		05 0c				    .byte len(_s), IM+NN
>d1fb		06 d2 f1 a6 f5 a6		    .word false ? 0 : +, xt_asm_stz_x, z_asm_stz_x
>d201		73 74 7a 2e 78			    .text _s
.d206						+
="stz.z"					    _s := "stz.z" ? "stz.z" : str(.asm_stz_z)
>d206		05 0c				    .byte len(_s), IM+NN
>d208		13 d2 f5 a6 f9 a6		    .word false ? 0 : +, xt_asm_stz_z, z_asm_stz_z
>d20e		73 74 7a 2e 7a			    .text _s
.d213						+
="stz.zx"					    _s := "stz.zx" ? "stz.zx" : str(.asm_stz_zx)
>d213		06 0c				    .byte len(_s), IM+NN
>d215		21 d2 f9 a6 fd a6		    .word false ? 0 : +, xt_asm_stz_zx, z_asm_stz_zx
>d21b		73 74 7a 2e 7a 78		    .text _s
.d221						+
="tax"						    _s := "tax" ? "tax" : str(.asm_tax)
>d221		03 0c				    .byte len(_s), IM+NN
>d223		2c d2 fd a6 01 a7		    .word false ? 0 : +, xt_asm_tax, z_asm_tax
>d229		74 61 78			    .text _s
.d22c						+
="tay"						    _s := "tay" ? "tay" : str(.asm_tay)
>d22c		03 0c				    .byte len(_s), IM+NN
>d22e		37 d2 01 a7 05 a7		    .word false ? 0 : +, xt_asm_tay, z_asm_tay
>d234		74 61 79			    .text _s
.d237						+
="trb"						    _s := "trb" ? "trb" : str(.asm_trb)
>d237		03 0c				    .byte len(_s), IM+NN
>d239		42 d2 05 a7 09 a7		    .word false ? 0 : +, xt_asm_trb, z_asm_trb
>d23f		74 72 62			    .text _s
.d242						+
="trb.z"					    _s := "trb.z" ? "trb.z" : str(.asm_trb_z)
>d242		05 0c				    .byte len(_s), IM+NN
>d244		4f d2 09 a7 0d a7		    .word false ? 0 : +, xt_asm_trb_z, z_asm_trb_z
>d24a		74 72 62 2e 7a			    .text _s
.d24f						+
="tsb"						    _s := "tsb" ? "tsb" : str(.asm_tsb)
>d24f		03 0c				    .byte len(_s), IM+NN
>d251		5a d2 0d a7 11 a7		    .word false ? 0 : +, xt_asm_tsb, z_asm_tsb
>d257		74 73 62			    .text _s
.d25a						+
="tsb.z"					    _s := "tsb.z" ? "tsb.z" : str(.asm_tsb_z)
>d25a		05 0c				    .byte len(_s), IM+NN
>d25c		67 d2 11 a7 15 a7		    .word false ? 0 : +, xt_asm_tsb_z, z_asm_tsb_z
>d262		74 73 62 2e 7a			    .text _s
.d267						+
="tsx"						    _s := "tsx" ? "tsx" : str(.asm_tsx)
>d267		03 0c				    .byte len(_s), IM+NN
>d269		72 d2 15 a7 19 a7		    .word false ? 0 : +, xt_asm_tsx, z_asm_tsx
>d26f		74 73 78			    .text _s
.d272						+
="txa"						    _s := "txa" ? "txa" : str(.asm_txa)
>d272		03 0c				    .byte len(_s), IM+NN
>d274		7d d2 19 a7 1d a7		    .word false ? 0 : +, xt_asm_txa, z_asm_txa
>d27a		74 78 61			    .text _s
.d27d						+
="txs"						    _s := "txs" ? "txs" : str(.asm_txs)
>d27d		03 0c				    .byte len(_s), IM+NN
>d27f		88 d2 1d a7 21 a7		    .word false ? 0 : +, xt_asm_txs, z_asm_txs
>d285		74 78 73			    .text _s
.d288						+
="tya"						    _s := "tya" ? "tya" : str(.asm_tya)
>d288		03 0c				    .byte len(_s), IM+NN
>d28a		93 d2 21 a7 25 a7		    .word false ? 0 : +, xt_asm_tya, z_asm_tya
>d290		74 79 61			    .text _s
.d293						+
="-->"						    _s := "-->" ? "-->" : str(.asm_arrow)
>d293		03 04				    .byte len(_s), IM
>d295		9e d2 1b 89 25 89		    .word false ? 0 : +, xt_asm_arrow, z_asm_arrow
>d29b		2d 2d 3e			    .text _s
.d29e						+
="<j"						    _s := "<j" ? "<j" : str(.asm_back_jump)
>d29e		02 04				    .byte len(_s), IM
>d2a0		a8 d2 76 a7 76 a7		    .word false ? 0 : +, xt_asm_back_jump, z_asm_back_jump
>d2a6		3c 6a				    .text _s
.d2a8						+
="<b"						    _s := "<b" ? "<b" : str(.asm_back_branch)
>d2a8		02 04				    .byte len(_s), IM
>d2aa		b2 d2 77 a7 7f a7		    .word false ? 0 : +, xt_asm_back_branch, z_asm_back_branch
>d2b0		3c 62				    .text _s
.d2b2						+
="push-a"					    _s := "push-a" ? "push-a" : str(.asm_push_a)
>d2b2		06 0c				    .byte len(_s), IM+NN
>d2b4		00 00 5f a7 6e a7		    .word true ? 0 : +, xt_asm_push_a, z_asm_push_a
>d2ba		70 75 73 68 2d 61		    .text _s

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix         ; unused?
=1						ix += 1
=1						str_compile        = ix         ; unused?
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix         ; unused?
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_sdc     = ix
=13						ix += 1
=13						str_disasm_lit     = ix
=14						ix += 1
=14						str_disasm_0bra    = ix
=15						ix += 1
=15						str_disasm_loop    = ix
=16						ix += 1
=16						str_disasm_do      = ix
=17						ix += 1
.d2c0						string_table:
>d2c0		e2 d2 e6 d2 f0 d2 fb d2		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d2c8		32 d3 2a d3 1f d3 39 d3		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d2d0		3f d3 5b d3 60 d3 65 d3		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d2d8		76 d3 89 d3 92 d3 9b d3		        .word s_disasm_sdc, s_disasm_lit, s_disasm_0bra, s_disasm_loop, s_disasm_do ; 12-16
>d2e0		a1 d3
>d2e2		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d2e6		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d2ee		64 00
>d2f0		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d2f8		64 20 00
>d2fb		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d303		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d313		4f 50 51 52 53 54 55 56 57 58 59 5a
>d31f		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d327		72 20 00
>d32a		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d332		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d339		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d33f		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d347		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d357		29 3a 20 00
>d35b		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d360		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d365		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d36d		63 69 6d 61 6c 29 3a 20 00
>d376		20 53 54 41 43 4b 20 44		s_disasm_sdc: .text " STACK DEPTH CHECK", 0
>d37e		45 50 54 48 20 43 48 45 43 4b 00
>d389		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d391		00
>d392		30 42 52 41 4e 43 48 20		s_disasm_0bra: .text "0BRANCH ",0
>d39a		00
>d39b		4c 4f 4f 50 20 00		s_disasm_loop: .text "LOOP ",0
>d3a1		44 4f 20 00			s_disasm_do: .text "DO ",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d3a5						error_table:
>d3a5		c1 d3 e2 d3 02 d4 23 d4		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d3ad		40 d4 51 d4 61 d4 8f d4		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d3b5		a7 d4 c8 d4 dd d4 f9 d4		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d3bd		10 d5 4f d5			        .word es_blockwords, es_returnstack                     ; 12-13
>d3c1		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d3c9		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d3d9		65 20 6d 65 6d 6f 72 79 00
>d3e2		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d3ea		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d3fa		20 52 45 46 49 4c 4c 00
>d402		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d40a		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d41a		6e 6c 79 20 77 6f 72 64 00
>d423		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d42b		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d43b		20 79 65 74 00
>d440		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d448		20 62 79 20 7a 65 72 6f 00
>d451		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d459		66 61 69 6c 75 72 65 00
>d461		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d469		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d479		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d489		64 20 2d 31 29 00
>d48f		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d497		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d4a7		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d4af		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d4bf		64 20 6e 75 6d 62 65 72 00
>d4c8		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d4d0		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d4dd		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d4e5		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d4f5		4c 4f 54 00
>d4f9		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d501		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d510		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d518		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d528		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d538		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d548		56 45 43 54 4f 52 00
>d54f		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d557		74 61 63 6b 3a 00
>d55d		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d565		44 2d 53 54 52 49 4e 47
>d56d		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d573		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d578		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d580		2d 55 4e 49 54 2d 42 49 54 53
>d58a		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d592		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d59a		52
>d59b		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d5a1		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d5a7		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d5af		53 54 41 43 4b 2d 43 45 4c 4c 53
>d5ba		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d5c2		45 4c 4c 53
>d5c6		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d5ce		54 53
>d5d0		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d5d6		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d5dd						doconst:
.d5dd		ca		dex		                dex             ; make room for constant
.d5de		ca		dex		                dex
.d5df		68		pla		                pla             ; LSB of return address
.d5e0		85 25		sta $25		                sta tmp1
.d5e2		68		pla		                pla             ; MSB of return address
.d5e3		85 26		sta $26		                sta tmp1+1
.d5e5		a0 01		ldy #$01	                ldy #1
.d5e7		b1 25		lda ($25),y	                lda (tmp1),y
.d5e9		95 00		sta $00,x	                sta 0,x
.d5eb		c8		iny		                iny
.d5ec		b1 25		lda ($25),y	                lda (tmp1),y
.d5ee		95 01		sta $01,x	                sta 1,x
.d5f0		60		rts		                rts
.d5f1						dodefer:
.d5f1		68		pla		                pla             ; LSB
.d5f2		85 25		sta $25		                sta tmp1
.d5f4		68		pla		                pla             ; MSB
.d5f5		85 26		sta $26		                sta tmp1+1
.d5f7		a0 01		ldy #$01	                ldy #1
.d5f9		b1 25		lda ($25),y	                lda (tmp1),y
.d5fb		85 27		sta $27		                sta tmp2
.d5fd		c8		iny		                iny
.d5fe		b1 25		lda ($25),y	                lda (tmp1),y
.d600		85 28		sta $28		                sta tmp2+1
.d602		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d605						defer_error:
.d605		a9 03		lda #$03	                lda #err_defer
.d607		4c 8b d7	jmp $d78b	                jmp error
.d60a						dodoes:
.d60a		7a		ply		                ply             ; LSB
.d60b		68		pla		                pla             ; MSB
.d60c		c8		iny		                iny
.d60d		d0 01		bne $d610	                bne +
.d60f		1a		inc a		                ina
.d610						+
.d610		84 27		sty $27		                sty tmp2
.d612		85 28		sta $28		                sta tmp2+1
.d614		ca		dex		                dex
.d615		ca		dex		                dex
.d616		7a		ply		                ply
.d617		68		pla		                pla
.d618		c8		iny		                iny
.d619		d0 01		bne $d61c	                bne +
.d61b		1a		inc a		                ina
.d61c						+
.d61c		94 00		sty $00,x	                sty 0,x         ; LSB
.d61e		95 01		sta $01,x	                sta 1,x         ; MSB
.d620		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d623						dovar:
.d623		7a		ply		                ply             ; LSB
.d624		68		pla		                pla             ; MSB
.d625		c8		iny		                iny
.d626		d0 01		bne $d629	                bne +
.d628		1a		inc a		                ina
.d629						+
.d629		ca		dex		                dex
.d62a		ca		dex		                dex
.d62b		95 01		sta $01,x	                sta 1,x
.d62d		98		tya		                tya
.d62e		95 00		sta $00,x	                sta 0,x
.d630		60		rts		                rts
.d631						push_upvar_tos:
.d631		ca		dex		                dex
.d632		ca		dex		                dex
.d633		18		clc		                clc
.d634		65 08		adc $08		                adc up
.d636		95 00		sta $00,x	                sta 0,x
.d638		a5 09		lda $09		                lda up+1
.d63a		90 01		bcc $d63d	                bcc +
.d63c		1a		inc a		                ina
.d63d						+
.d63d		95 01		sta $01,x	                sta 1,x
.d63f		60		rts		                rts
.d640						byte_to_ascii:
.d640		48		pha		                pha
.d641		4a		lsr a		                lsr             ; convert high nibble first
.d642		4a		lsr a		                lsr
.d643		4a		lsr a		                lsr
.d644		4a		lsr a		                lsr
.d645		20 49 d6	jsr $d649	                jsr _nibble_to_ascii
.d648		68		pla		                pla
.d649						_nibble_to_ascii:
.d649		29 0f		and #$0f	                and #$F
.d64b		09 30		ora #$30	                ora #'0'
.d64d		c9 3a		cmp #$3a	                cmp #'9'+1
.d64f		90 02		bcc $d653	                bcc +
.d651		69 06		adc #$06	                adc #6
.d653		4c c5 86	jmp $86c5	+               jmp emit_a
.d656		60		rts		                rts
.d657						find_header_name:
.d657		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d659		85 27		sta $27		                sta tmp2
.d65b		b5 03		lda $03,x	                lda 3,x
.d65d		85 28		sta $28		                sta tmp2+1
.d65f						_loop:
.d65f		b2 25		lda ($25)	                lda (tmp1)
.d661		d5 00		cmp $00,x	                cmp 0,x
.d663		d0 3a		bne $d69f	                bne _next_entry
.d665		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d667		a0 08		ldy #$08	                ldy #8
.d669		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d66b		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d66d		d0 30		bne $d69f	                bne _next_entry ; definitely not equal if any bits differ
.d66f		a5 25		lda $25		                lda tmp1
.d671		48		pha		                pha             ; Save original address on the stack
.d672		18		clc		                clc
.d673		69 08		adc #$08	                adc #8
.d675		85 25		sta $25		                sta tmp1
.d677		a5 26		lda $26		                lda tmp1+1
.d679		48		pha		                pha
.d67a		90 03		bcc $d67f	                bcc +
.d67c		1a		inc a		                ina
.d67d		85 26		sta $26		                sta tmp1+1
.d67f						+
.d67f		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d681		88		dey		                dey
.d682						_next_char:
.d682		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d684		c9 5b		cmp #$5b	                cmp #'Z'+1
.d686		b0 06		bcs $d68e	                bcs _check_char
.d688		c9 41		cmp #$41	                cmp #'A'
.d68a		90 02		bcc $d68e	                bcc _check_char
.d68c		09 20		ora #$20	                ora #$20
.d68e						_check_char:
.d68e		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d690		d0 03		bne $d695	                bne _reset_tmp1
.d692		88		dey		                dey
.d693		10 ed		bpl $d682	                bpl _next_char
.d695						_reset_tmp1:
.d695		68		pla		                pla
.d696		85 26		sta $26		                sta tmp1+1
.d698		68		pla		                pla
.d699		85 25		sta $25		                sta tmp1
.d69b		98		tya		                tya             ; leave A = $FF on success
.d69c		c8		iny		                iny             ; if Y was $FF, we succeeded
.d69d		f0 11		beq $d6b0	                beq _done
.d69f						_next_entry:
.d69f		a0 02		ldy #$02	                ldy #2
.d6a1		b1 25		lda ($25),y	                lda (tmp1),y
.d6a3		48		pha		                pha
.d6a4		c8		iny		                iny
.d6a5		b1 25		lda ($25),y	                lda (tmp1),y
.d6a7		85 26		sta $26		                sta tmp1+1
.d6a9		68		pla		                pla
.d6aa		85 25		sta $25		                sta tmp1
.d6ac		05 26		ora $26		                ora tmp1+1
.d6ae		d0 af		bne $d65f	                bne _loop
.d6b0		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d6b2		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d6b3						compare_16bit:
.d6b3		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d6b5		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d6b7		f0 08		beq $d6c1	                beq _equal
.d6b9		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6bb		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6bd		70 08		bvs $d6c7	                bvs _overflow
.d6bf		80 08		bra $d6c9	                bra _not_equal
.d6c1						_equal:
.d6c1		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6c3		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6c5		50 04		bvc $d6cb	                bvc _done
.d6c7						_overflow:
.d6c7		49 80		eor #$80	                eor #$80                ; complement negative flag
.d6c9						_not_equal:
.d6c9		09 01		ora #$01	                ora #1                  ; set Z=0 since we're not equal
.d6cb						_done:
.d6cb		60		rts		                rts
.d6cc						current_to_dp:
.d6cc		a0 08		ldy #$08	                ldy #current_offset
.d6ce		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d6d0		0a		asl a		                asl             ; turn it into an offset (in cells)
.d6d1		18		clc		                clc
.d6d2		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d6d4		a8		tay		                tay
.d6d5		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d6d7		85 02		sta $02		                sta dp
.d6d9		c8		iny		                iny
.d6da		b1 08		lda ($08),y	                lda (up),y
.d6dc		85 03		sta $03		                sta dp+1
.d6de		60		rts		                rts
.d6df						dp_to_current:
.d6df		a0 08		ldy #$08	                ldy #current_offset
.d6e1		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d6e3		0a		asl a		                asl             ; turn it into an offset (in cells)
.d6e4		18		clc		                clc
.d6e5		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d6e7		a8		tay		                tay
.d6e8		a5 02		lda $02		                lda dp
.d6ea		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d6ec		c8		iny		                iny
.d6ed		a5 03		lda $03		                lda dp+1
.d6ef		91 08		sta ($08),y	                sta (up),y
.d6f1		60		rts		                rts
.d6f2						interpret:
.d6f2						_loop:
.d6f2		20 51 8d	jsr $8d51	                jsr xt_parse_name       ; ( "string" -- addr u )
.d6f5		b5 00		lda $00,x	                lda 0,x
.d6f7		15 01		ora $01,x	                ora 1,x
.d6f9		f0 5b		beq $d756	                beq _line_done
.d6fb		20 af 93	jsr $93af	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d6fe		20 db 9a	jsr $9adb	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d701		b5 00		lda $00,x	                lda 0,x
.d703		15 01		ora $01,x	                ora 1,x
.d705		d0 19		bne $d720	                bne _got_name_token
.d707		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d708		e8		inx		                inx
.d709		20 7c 9c	jsr $9c7c	                jsr xt_number           ; ( addr u -- u|d )
.d70c		a5 1a		lda $1a		                lda state
.d70e		f0 e2		beq $d6f2	                beq _loop
.d710		a9 20		lda #$20	                lda #%00100000
.d712		24 1c		bit $1c		                bit status
.d714		d0 05		bne $d71b	                bne _double_number
.d716		20 f2 89	jsr $89f2	                jsr xt_literal
.d719		80 d7		bra $d6f2	                bra _loop
.d71b						_double_number:
.d71b		20 d4 9e	jsr $9ed4	                jsr xt_two_literal
.d71e		80 d2		bra $d6f2	                bra _loop
.d720						_got_name_token:
.d720		b5 00		lda $00,x	                lda 0,x
.d722		95 04		sta $04,x	                sta 4,x
.d724		b5 01		lda $01,x	                lda 1,x
.d726		95 05		sta $05,x	                sta 5,x
.d728		e8		inx		                inx
.d729		e8		inx		                inx
.d72a		e8		inx		                inx
.d72b		e8		inx		                inx                     ; ( nt )
.d72c		20 e9 8c	jsr $8ce9	                jsr xt_one_plus
.d72f		a1 00		lda ($00,x)	                lda (0,x)
.d731		48		pha		                pha
.d732		20 dd 8c	jsr $8cdd	                jsr xt_one_minus
.d735		20 19 9c	jsr $9c19	                jsr xt_name_to_int      ; ( nt - xt )
.d738		a5 1a		lda $1a		                lda state
.d73a		d0 10		bne $d74c	                bne _compile
.d73c		68		pla		                pla
.d73d		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d73f		f0 05		beq $d746	                beq _interpret
.d741		a9 02		lda #$02	                lda #err_compileonly
.d743		4c 8b d7	jmp $d78b	                jmp error
.d746						_interpret:
.d746		20 05 88	jsr $8805	                jsr xt_execute
.d749		4c f2 d6	jmp $d6f2	                jmp _loop
.d74c						_compile:
.d74c		68		pla		                pla
.d74d		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d74f		d0 f5		bne $d746	                bne _interpret          ; IMMEDIATE word, execute right now
.d751		20 c7 96	jsr $96c7	                jsr xt_compile_comma
.d754		80 9c		bra $d6f2	                bra _loop
.d756						_line_done:
.d756		e8		inx		                inx
.d757		e8		inx		                inx
.d758		e8		inx		                inx
.d759		e8		inx		                inx
.d75a		60		rts		                rts
.d75b						is_printable:
.d75b		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d75d		90 08		bcc $d767	                bcc _done
.d75f		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d761		b0 03		bcs $d766	                bcs _failed
.d763		38		sec		                sec
.d764		80 01		bra $d767	                bra _done
.d766						_failed:
.d766		18		clc		                clc
.d767						_done:
.d767		60		rts		                rts
.d768						is_whitespace:
.d768		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d76a		90 08		bcc $d774	                bcc _done
.d76c		c9 21		cmp #$21	                cmp #AscSP+1
.d76e		b0 03		bcs $d773	                bcs _failed
.d770		38		sec		                sec
.d771		80 01		bra $d774	                bra _done
.d773						_failed:
.d773		18		clc		                clc
.d774						_done:
.d774		60		rts		                rts
.d775						underflow_1:
.d775		e0 77		cpx #$77	                cpx #dsp0-1
.d777		10 10		bpl $d789	                bpl underflow_error
.d779		60		rts		                rts
.d77a						underflow_2:
.d77a		e0 75		cpx #$75	                cpx #dsp0-3
.d77c		10 0b		bpl $d789	                bpl underflow_error
.d77e		60		rts		                rts
.d77f						underflow_3:
.d77f		e0 73		cpx #$73	                cpx #dsp0-5
.d781		10 06		bpl $d789	                bpl underflow_error
.d783		60		rts		                rts
.d784						underflow_4:
.d784		e0 71		cpx #$71	                cpx #dsp0-7
.d786		10 01		bpl $d789	                bpl underflow_error
.d788		60		rts		                rts
.d789						underflow_error:
.d789		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d78b						error:
.d78b		48		pha		                pha                     ; save error
.d78c		20 cb d7	jsr $d7cb	                jsr print_error
.d78f		20 3a 84	jsr $843a	                jsr xt_cr
.d792		68		pla		                pla
.d793		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d795		d0 17		bne $d7ae	                bne _no_underflow
.d797		a9 0d		lda #$0d	                lda #err_returnstack
.d799		20 cb d7	jsr $d7cb	                jsr print_error
.d79c		ba		tsx		                tsx
.d79d						-
.d79d		e8		inx		                inx
.d79e		f0 0b		beq $d7ab	                beq +
.d7a0		20 cb 91	jsr $91cb	                jsr xt_space
.d7a3		bd 00 01	lda $0100,x	                lda $100,x
.d7a6		20 40 d6	jsr $d640	                jsr byte_to_ascii
.d7a9		80 f2		bra $d79d	                bra -
.d7ab						+
.d7ab		20 3a 84	jsr $843a	                jsr xt_cr
.d7ae						_no_underflow:
.d7ae		4c 5e 80	jmp $805e	                jmp xt_abort            ; no jsr, as we clobber return stack
.d7b1						print_string_no_lf:
.d7b1		0a		asl a		                asl
.d7b2		a8		tay		                tay
.d7b3		b9 c0 d2	lda $d2c0,y	                lda string_table,y
.d7b6		85 29		sta $29		                sta tmp3                ; LSB
.d7b8		c8		iny		                iny
.d7b9		b9 c0 d2	lda $d2c0,y	                lda string_table,y
.d7bc		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d7be						print_common:
.d7be		a0 00		ldy #$00	                ldy #0
.d7c0						_loop:
.d7c0		b1 29		lda ($29),y	                lda (tmp3),y
.d7c2		f0 06		beq $d7ca	                beq _done               ; strings are zero-terminated
.d7c4		20 c5 86	jsr $86c5	                jsr emit_a              ; allows vectoring via output
.d7c7		c8		iny		                iny
.d7c8		80 f6		bra $d7c0	                bra _loop
.d7ca						_done:
.d7ca		60		rts		                rts
.d7cb						print_error:
.d7cb		0a		asl a		                asl
.d7cc		a8		tay		                tay
.d7cd		b9 a5 d3	lda $d3a5,y	                lda error_table,y
.d7d0		85 29		sta $29		                sta tmp3                ; LSB
.d7d2		c8		iny		                iny
.d7d3		b9 a5 d3	lda $d3a5,y	                lda error_table,y
.d7d6		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d7d8		20 be d7	jsr $d7be	                jsr print_common
.d7db		60		rts		                rts
.d7dc						print_string:
.d7dc		20 b1 d7	jsr $d7b1	                jsr print_string_no_lf
.d7df		4c 3a 84	jmp $843a	                jmp xt_cr               ; JSR/RTS because never compiled
.d7e2						print_u:
.d7e2		20 dc 9d	jsr $9ddc	                jsr xt_zero                     ; 0
.d7e5		20 cf 89	jsr $89cf	                jsr xt_less_number_sign         ; <#
.d7e8		20 b3 8c	jsr $8cb3	                jsr xt_number_sign_s            ; #S
.d7eb		20 91 8c	jsr $8c91	                jsr xt_number_sign_greater      ; #>
.d7ee		4c c4 94	jmp $94c4	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm


;******  Processing file: platform/simulator.asm

=$f000						io_start = $f000
>f000						                .byte ?
>f001						io_putc:        .byte ?     ; $f001     write byte to stdout
>f002						                .word ?
>f004						io_getc:        .byte ?     ; $f004     read byte from stdin
>f005						io_peekc:       .byte ?     ; $f005     non-blocking input
>f006						io_clk_start:   .byte ?     ; $f006     *read* to start cycle counter
>f007						io_clk_stop:    .byte ?     ; $f007     *read* to stop the cycle counter
>f008						io_clk_cycles:  .word ?,?   ; $f008-b   32-bit cycle count in NUXI order
>f00c						                .word ?,?
>f010						io_blk_action:  .byte ?     ; $f010     Write to act (status=0 read=1 write=2)
>f011						io_blk_status:  .byte ?     ; $f011     Read action result (OK=0)
>f012						io_blk_number:  .word ?     ; $f012     Little endian block number 0-ffff
>f014						io_blk_buffer:  .word ?     ; $f014     Little endian memory address
.f016						io_end:
.f016						kernel_init:
.f016		78		sei		                sei             ; Disable interrupts
.f017		a2 00		ldx #$00	                ldx #0
.f019		bd 32 f0	lda $f032,x	-               lda s_kernel_id,x
.f01c		f0 06		beq $f024	                beq _done
.f01e		20 2d f0	jsr $f02d	                jsr kernel_putc
.f021		e8		inx		                inx
.f022		80 f5		bra $f019	                bra -
.f024						_done:
.f024		4c 00 80	jmp $8000	                jmp forth
.f027						kernel_getc:
.f027						_loop:
.f027		ad 04 f0	lda $f004	                lda io_getc
.f02a		f0 fb		beq $f027	                beq _loop
.f02c		60		rts		                rts
.f02d						kernel_putc:
.f02d		8d 01 f0	sta $f001	                sta io_putc
.f030		60		rts		                rts
.f031						kernel_bye:
.f031		00		brk #		                brk

;******  Return to file: platform/platform-py65mon.asm

.f032						s_kernel_id:
>f032		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f03a		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f04a		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f05a		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		16 f0				v_nmi   .word kernel_init
>fffc		16 f0				v_reset .word kernel_init
>fffe		16 f0				v_irq   .word kernel_init

;******  End of listing
