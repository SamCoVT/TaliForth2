
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Thu Aug 15 14:58:41 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

="py65mon"					TALI_ARCH := "py65mon"
=$7fff						ram_end = $7fff
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/simulator.asm


;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../words/all.asm

.8000						xt_cold:
.8000						w_cold:
.8000		d8		cld		                cld
.8001		a9 22		lda #$22	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd bf b3	lda $b3bf,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad bf b3	lda $b3bf	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f						_load_user_vars_loop:
.801f		b9 dd b3	lda $b3dd,y	                lda cold_user_table,y
.8022		91 08		sta ($08),y	                sta (up),y
.8024		88		dey		                dey
.8025		d0 f8		bne $801f	                bne _load_user_vars_loop
.8027		ad dd b3	lda $b3dd	                lda cold_user_table
.802a		92 08		sta ($08)	                sta (up)
.802c		20 17 84	jsr $8417	                jsr w_cr
.802f		ca		dex		                dex
.8030		ca		dex		                dex
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		a9 c0		lda #$c0	                lda #<forth_words_start
.8035		95 02		sta $02,x	                sta 2,x
.8037		a9 ba		lda #$ba	                lda #>forth_words_start
.8039		95 03		sta $03,x	                sta 3,x
.803b		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803d		95 00		sta $00,x	                sta 0,x
.803f		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8041		95 01		sta $01,x	                sta 1,x
.8043		20 a9 88	jsr $88a9	                jsr w_evaluate
.8046		9c 00 7c	stz $7c00	                stz hist_buff
.8049		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804c		9c 00 7d	stz $7d00	                stz hist_buff+$100
.804f		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8052		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8055		9c 80 7e	stz $7e80	                stz hist_buff+$280
.8058		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805b		9c 80 7f	stz $7f80	                stz hist_buff+$380
.805e						xt_abort:
.805e						w_abort:
.805e		a2 78		ldx #$78	                ldx #dsp0
.8060						xt_quit:
.8060						w_quit:
.8060		8a		txa		                txa             ; Save the DSP that we just defined
.8061		a2 ff		ldx #$ff	                ldx #rsp0
.8063		9a		txs		                txs
.8064		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8065		64 04		stz $04		                stz ip
.8067		64 05		stz $05		                stz ip+1
.8069		64 0a		stz $0a		                stz insrc
.806b		64 0b		stz $0b		                stz insrc+1
.806d		a9 00		lda #$00	                lda #0
.806f		a0 04		ldy #$04	                ldy #blk_offset
.8071		91 08		sta ($08),y	                sta (up),y
.8073		c8		iny		                iny
.8074		91 08		sta ($08),y	                sta (up),y
.8076		a9 fc		lda #$fc	                lda #(256-4)
.8078		85 1f		sta $1f		                sta loopctrl
.807a		64 1a		stz $1a		                stz state
.807c		64 1b		stz $1b		                stz state+1
.807e						_get_line:
.807e		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8080		85 0c		sta $0c		                sta cib
.8082		a9 02		lda #$02	                lda #>buffer0
.8084		85 0d		sta $0d		                sta cib+1
.8086		64 0e		stz $0e		                stz ciblen
.8088		64 0f		stz $0f		                stz ciblen+1
.808a		20 2f 8f	jsr $8f2f	                jsr w_refill           ; ( -- f )
.808d		b5 00		lda $00,x	                lda 0,x
.808f		d0 05		bne $8096	                bne _success
.8091		a9 06		lda #$06	                lda #err_refill
.8093		4c 08 d8	jmp $d808	                jmp error
.8096						_success:
.8096		e8		inx		                inx                     ; drop
.8097		e8		inx		                inx
.8098		20 71 d7	jsr $d771	                jsr interpret
.809b		e0 78		cpx #$78	                cpx #dsp0
.809d		f0 05		beq $80a4	                beq _stack_ok
.809f		90 03		bcc $80a4	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a1		4c 06 d8	jmp $d806	                jmp underflow_error
.80a4						_stack_ok:
.80a4		a5 1a		lda $1a		                lda state
.80a6		f0 02		beq $80aa	                beq _print
.80a8		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80aa						_print:
.80aa		20 2e d8	jsr $d82e	                jsr print_string_no_lf
.80ad		20 17 84	jsr $8417	                jsr w_cr
.80b0		80 cc		bra $807e	                bra _get_line
.80b2						z_cold:
.80b2						z_abort:
.80b2						z_quit:

;******  Processing file: platform/../words/core.asm

.80b2						xt_abort_quote:
.80b2						w_abort_quote:
.80b2		20 ca 8f	jsr $8fca	                jsr w_s_quote          ; S"
.80b5		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b7		a9 bd		lda #$bd	                lda #<abort_quote_runtime
.80b9		20 d9 97	jsr $97d9	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80bc		60		rts		z_abort_quote:  rts
.80bd						abort_quote_runtime:
.80bd		b5 04		lda $04,x	                lda 4,x
.80bf		15 05		ora $05,x	                ora 5,x
.80c1		f0 09		beq $80cc	                beq _done       ; if FALSE, we're done
.80c3		20 dc 94	jsr $94dc	                jsr w_type
.80c6		20 17 84	jsr $8417	                jsr w_cr
.80c9		4c 5e 80	jmp $805e	                jmp w_abort    ; not JSR, so never come back
.80cc						_done:
.80cc		8a		txa		                txa
.80cd		18		clc		                clc
.80ce		69 06		adc #$06	                adc #6
.80d0		aa		tax		                tax
.80d1		60		rts		                rts
.80d2						xt_abs:
.80d2		20 f2 d7	jsr $d7f2	                jsr underflow_1
.80d5						w_abs:
.80d5		b5 01		lda $01,x	                lda 1,x
.80d7		10 0d		bpl $80e6	                bpl _done       ; positive number, easy money!
.80d9		38		sec		                sec
.80da		a9 00		lda #$00	                lda #0
.80dc		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80de		95 00		sta $00,x	                sta 0,x
.80e0		a9 00		lda #$00	                lda #0          ; MSB
.80e2		f5 01		sbc $01,x	                sbc 1,x
.80e4		95 01		sta $01,x	                sta 1,x
.80e6						_done:
.80e6		60		rts		z_abs:          rts
.80e7						xt_accept:
.80e7		20 f7 d7	jsr $d7f7	                jsr underflow_2
.80ea						w_accept:
.80ea		b5 00		lda $00,x	                lda 0,x
.80ec		15 01		ora $01,x	                ora 1,x
.80ee		d0 09		bne $80f9	                bne _not_zero
.80f0		e8		inx		                inx
.80f1		e8		inx		                inx
.80f2		74 00		stz $00,x	                stz 0,x
.80f4		74 01		stz $01,x	                stz 1,x
.80f6		4c d9 81	jmp $81d9	                jmp accept_done
.80f9						_not_zero:
.80f9		a9 1b		lda #$1b	                lda #27         ; ESC (beginning of ANSI sequence)
.80fb		20 bb 86	jsr $86bb	                jsr emit_a
.80fe		a9 5b		lda #$5b	                lda #'['
.8100		20 bb 86	jsr $86bb	                jsr emit_a
.8103		a9 31		lda #$31	                lda #'1'        ; BOLD
.8105		20 bb 86	jsr $86bb	                jsr emit_a
.8108		a9 6d		lda #$6d	                lda #'m'
.810a		20 bb 86	jsr $86bb	                jsr emit_a      ; end of ANSI sequence
.810d		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.810f		85 27		sta $27		                sta tmp2
.8111		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.8113		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8115		85 25		sta $25		                sta tmp1
.8117		b5 03		lda $03,x	                lda 3,x
.8119		85 26		sta $26		                sta tmp1+1
.811b		e8		inx		                inx
.811c		e8		inx		                inx
.811d		a0 00		ldy #$00	                ldy #0
.811f		a5 1c		lda $1c		                lda status
.8121		29 f7		and #$f7	                and #$F7
.8123		1a		inc a		                ina
.8124		09 08		ora #$08	                ora #%00001000
.8126		85 1c		sta $1c		                sta status
.8128						accept_loop:
.8128		20 a5 89	jsr $89a5	                jsr key_a
.812b		c9 0a		cmp #$0a	                cmp #AscLF
.812d		f0 20		beq $814f	                beq _eol
.812f		c9 0d		cmp #$0d	                cmp #AscCR
.8131		f0 1c		beq $814f	                beq _eol
.8133		c9 08		cmp #$08	                cmp #AscBS
.8135		f0 22		beq $8159	                beq _backspace
.8137		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8139		f0 1e		beq $8159	                beq _backspace
.813b		c9 10		cmp #$10	                cmp #AscCP
.813d		f0 36		beq $8175	                beq _ctrl_p
.813f		c9 0e		cmp #$0e	                cmp #AscCN
.8141		f0 44		beq $8187	                beq _ctrl_n
.8143		91 25		sta ($25),y	                sta (tmp1),y
.8145		c8		iny		                iny
.8146		20 bb 86	jsr $86bb	                jsr emit_a
.8149		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.814b		d0 db		bne $8128	                bne accept_loop       ; fall through if buffer limit reached
.814d		80 03		bra $8152	                bra _buffer_full
.814f						_eol:
.814f		20 dd 91	jsr $91dd	                jsr w_space    ; print final space
.8152						_buffer_full:
.8152		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.8154		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.8156		4c d9 81	jmp $81d9	                jmp accept_done
.8159						_backspace:
.8159		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.815b		d0 06		bne $8163	                bne +
.815d		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.815f		20 bb 86	jsr $86bb	                jsr emit_a
.8162		c8		iny		                iny
.8163						+
.8163		88		dey		                dey
.8164		a9 08		lda #$08	                lda #AscBS      ; move back one
.8166		20 bb 86	jsr $86bb	                jsr emit_a
.8169		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.816b		20 bb 86	jsr $86bb	                jsr emit_a
.816e		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8170		20 bb 86	jsr $86bb	                jsr emit_a
.8173		80 b3		bra $8128	                bra accept_loop
.8175						_ctrl_p:
.8175		a5 1c		lda $1c		                lda status
.8177		29 07		and #$07	                and #7
.8179		d0 08		bne $8183	                bne _ctrl_p_dec
.817b		a5 1c		lda $1c		                lda status
.817d		09 07		ora #$07	                ora #7
.817f		85 1c		sta $1c		                sta status
.8181		80 11		bra $8194	                bra _recall_history
.8183						_ctrl_p_dec:
.8183		c6 1c		dec $1c		                dec status
.8185		80 0d		bra $8194	                bra _recall_history
.8187						_ctrl_n:
.8187		a9 08		lda #$08	                lda #$8
.8189		24 1c		bit $1c		                bit status
.818b		d0 07		bne $8194	                bne _recall_history
.818d		a5 1c		lda $1c		                lda status
.818f		29 f7		and #$f7	                and #$F7
.8191		1a		inc a		               ina
.8192		85 1c		sta $1c		                sta status
.8194						_recall_history:
.8194		a9 08		lda #$08	                lda #%00001000
.8196		14 1c		trb $1c		                trb status
.8198		20 08 82	jsr $8208	                jsr accept_total_recall
.819b		a9 0d		lda #$0d	                lda #AscCR
.819d		20 bb 86	jsr $86bb	                jsr emit_a
.81a0						input_clear:
.81a0		c0 00		cpy #$00	                cpy #0
.81a2		f0 08		beq $81ac	                beq input_cleared
.81a4		a9 20		lda #$20	                lda #AscSP
.81a6		20 bb 86	jsr $86bb	                jsr emit_a
.81a9		88		dey		                dey
.81aa		80 f4		bra $81a0	                bra input_clear
.81ac						input_cleared:
.81ac		a9 0d		lda #$0d	                lda #AscCR
.81ae		20 bb 86	jsr $86bb	                jsr emit_a
.81b1		b1 29		lda ($29),y	                lda (tmp3),y
.81b3		85 1d		sta $1d		                sta status+1
.81b5		e6 29		inc $29		                inc tmp3
.81b7		d0 02		bne $81bb	                bne +           ; Increment the upper byte on carry.
.81b9		e6 2a		inc $2a		                inc tmp3+1
.81bb						+
.81bb		a9 0d		lda #$0d	                lda #AscCR
.81bd		20 bb 86	jsr $86bb	                jsr emit_a
.81c0						_history_loop:
.81c0		c4 1d		cpy $1d		                cpy status+1
.81c2		d0 03		bne $81c7	                bne +
.81c4		4c 28 81	jmp $8128	                jmp accept_loop       ; Needs a long jump
.81c7						+
.81c7		c4 27		cpy $27		                cpy tmp2
.81c9		f0 0a		beq $81d5	                beq _hist_filled_buffer
.81cb		b1 29		lda ($29),y	                lda (tmp3),y
.81cd		91 25		sta ($25),y	                sta (tmp1),y
.81cf		20 bb 86	jsr $86bb	                jsr emit_a
.81d2		c8		iny		                iny
.81d3		80 eb		bra $81c0	                bra _history_loop
.81d5						_hist_filled_buffer:
.81d5		88		dey		                dey
.81d6		4c 28 81	jmp $8128	                jmp accept_loop
.81d9						accept_done:
.81d9		20 08 82	jsr $8208	                jsr accept_total_recall
.81dc		85 1d		sta $1d		                sta status+1
.81de		a0 00		ldy #$00	                ldy #0
.81e0		91 29		sta ($29),y	                sta (tmp3),y
.81e2		e6 29		inc $29		                inc tmp3
.81e4		d0 02		bne $81e8	                bne +           ; Increment the upper byte on carry.
.81e6		e6 2a		inc $2a		                inc tmp3+1
.81e8						+
.81e8						_save_history_loop:
.81e8		c4 1d		cpy $1d		                cpy status+1
.81ea		f0 07		beq $81f3	                beq _save_history_done
.81ec		b1 25		lda ($25),y	                lda (tmp1),y
.81ee		91 29		sta ($29),y	                sta (tmp3),y
.81f0		c8		iny		                iny
.81f1		80 f5		bra $81e8	                bra _save_history_loop
.81f3						_save_history_done:
.81f3		a9 1b		lda #$1b	                lda #27         ; ESC (beginning of ANSI sequence)
.81f5		20 bb 86	jsr $86bb	                jsr emit_a
.81f8		a9 5b		lda #$5b	                lda #'['
.81fa		20 bb 86	jsr $86bb	                jsr emit_a
.81fd		a9 30		lda #$30	                lda #'0'        ; NORMAL
.81ff		20 bb 86	jsr $86bb	                jsr emit_a
.8202		a9 6d		lda #$6d	                lda #'m'
.8204		20 bb 86	jsr $86bb	                jsr emit_a      ; end of ANSI sequence
.8207						z_accept:
.8207		60		rts		                rts
.8208						accept_total_recall:
.8208		a9 00		lda #$00	                lda #<hist_buff
.820a		85 29		sta $29		                sta tmp3
.820c		a9 7c		lda #$7c	                lda #>hist_buff
.820e		85 2a		sta $2a		                sta tmp3+1
.8210		a5 1c		lda $1c		                lda status
.8212		6a		ror a		                ror
.8213		29 03		and #$03	                and #3
.8215		18		clc		                clc
.8216		65 2a		adc $2a		                adc tmp3+1
.8218		85 2a		sta $2a		                sta tmp3+1
.821a		a5 1c		lda $1c		                lda status
.821c		6a		ror a		                ror             ; Rotate through carry into msb.
.821d		6a		ror a		                ror
.821e		29 80		and #$80	                and #$80
.8220		18		clc		                clc
.8221		65 29		adc $29		                adc tmp3
.8223		85 29		sta $29		                sta tmp3
.8225		90 02		bcc $8229	                bcc +           ; Increment the upper byte on carry.
.8227		e6 2a		inc $2a		                inc tmp3+1
.8229						+
.8229		98		tya		                tya
.822a		c9 80		cmp #$80	                cmp #$80
.822c		90 02		bcc $8230	                bcc +
.822e		a9 7f		lda #$7f	                lda #$7F
.8230						+
.8230		60		rts		                rts
.8231						xt_action_of:
.8231						w_action_of:
.8231		a5 1a		lda $1a		                lda state
.8233		05 1b		ora $1b		                ora state+1
.8235		f0 0c		beq $8243	                beq _interpreting
.8237		20 3f 83	jsr $833f	                jsr w_bracket_tick
.823a		a0 85		ldy #$85	                ldy #>w_defer_fetch
.823c		a9 2f		lda #$2f	                lda #<w_defer_fetch
.823e		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.8241		80 06		bra $8249	                bra _done
.8243						_interpreting:
.8243		20 57 92	jsr $9257	                jsr w_tick
.8246		20 2f 85	jsr $852f	                jsr w_defer_fetch
.8249						_done:
.8249		60		rts		z_action_of:           rts
.824a						xt_again:
.824a		20 f2 d7	jsr $d7f2	                jsr underflow_1
.824d						w_again:
.824d		20 ca 97	jsr $97ca	                jsr cmpl_jump_tos
.8250		60		rts		z_again:        rts
.8251						xt_align:
.8251						xt_aligned:
.8251						w_align:
.8251						w_aligned:
.8251						z_align:
.8251						z_aligned:
.8251		60		rts		                rts             ; stripped out during native compile
.8252						xt_allot:
.8252		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8255						w_allot:
.8255		b5 01		lda $01,x	                lda 1,x
.8257		30 22		bmi $827b	                bmi _release
.8259		18		clc		                clc
.825a		a5 00		lda $00		                lda cp
.825c		75 00		adc $00,x	                adc 0,x
.825e		85 00		sta $00		                sta cp
.8260		a5 01		lda $01		                lda cp+1
.8262		75 01		adc $01,x	                adc 1,x
.8264		85 01		sta $01		                sta cp+1
.8266		a0 00		ldy #$00	                ldy #<cp_end
.8268		c4 00		cpy $00		                cpy cp
.826a		a9 7c		lda #$7c	                lda #>cp_end
.826c		e5 01		sbc $01		                sbc cp+1
.826e		b0 48		bcs $82b8	                bcs _done               ; we're fine.
.8270		84 00		sty $00		                sty cp                  ; still #<cp_end
.8272		a9 7c		lda #$7c	                lda #>cp_end
.8274		85 01		sta $01		                sta cp+1
.8276		a9 00		lda #$00	                lda #err_allot
.8278		4c 08 d8	jmp $d808	                jmp error
.827b						_release:
.827b		ca		dex		                dex
.827c		ca		dex		                dex
.827d		a5 00		lda $00		                lda cp
.827f		95 00		sta $00,x	                sta 0,x
.8281		a5 01		lda $01		                lda cp+1
.8283		95 01		sta $01,x	                sta 1,x
.8285		20 51 8e	jsr $8e51	                jsr w_plus                     ; new CP is now TOS
.8288		ca		dex		                dex
.8289		ca		dex		                dex                             ; new CP now NOS
.828a		a9 00		lda #$00	                lda #<cp0
.828c		95 00		sta $00,x	                sta 0,x
.828e		a9 03		lda #$03	                lda #>cp0
.8290		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8292		20 32 d7	jsr $d732	                jsr compare_16bit               ; still ( CP CP0 )
.8295		f0 17		beq $82ae	                beq _nega_done
.8297		30 15		bmi $82ae	                bmi _nega_done
.8299		a9 00		lda #$00	                lda #<cp0
.829b		85 00		sta $00		                sta cp
.829d		a9 03		lda #$03	                lda #>cp0
.829f		85 01		sta $01		                sta cp+1
.82a1		a9 a2		lda #$a2	                lda #<dictionary_start
.82a3		85 02		sta $02		                sta dp
.82a5		a9 bb		lda #$bb	                lda #>dictionary_start
.82a7		85 03		sta $03		                sta dp+1
.82a9		a9 0a		lda #$0a	                lda #err_negallot
.82ab		4c 08 d8	jmp $d808	                jmp error
.82ae						_nega_done:
.82ae		b5 02		lda $02,x	                lda 2,x
.82b0		85 00		sta $00		                sta cp
.82b2		b5 03		lda $03,x	                lda 3,x
.82b4		85 01		sta $01		                sta cp+1
.82b6		e8		inx		                inx
.82b7		e8		inx		                inx                     ; drop through to _done
.82b8						_done:
.82b8		e8		inx		                inx
.82b9		e8		inx		                inx
.82ba						z_allot:
.82ba		60		rts		                rts
.82bb						xt_and:
.82bb		20 f7 d7	jsr $d7f7	                jsr underflow_2
.82be						w_and:
.82be		b5 00		lda $00,x	                lda 0,x
.82c0		35 02		and $02,x	                and 2,x
.82c2		95 02		sta $02,x	                sta 2,x
.82c4		b5 01		lda $01,x	                lda 1,x
.82c6		35 03		and $03,x	                and 3,x
.82c8		95 03		sta $03,x	                sta 3,x
.82ca		e8		inx		                inx
.82cb		e8		inx		                inx
.82cc		60		rts		z_and:          rts
.82cd						xt_at_xy:
.82cd		20 f7 d7	jsr $d7f7	                jsr underflow_2
.82d0						w_at_xy:
.82d0		a5 18		lda $18		                lda base
.82d2		48		pha		                pha
.82d3		a9 0a		lda #$0a	                lda #10
.82d5		85 18		sta $18		                sta base
.82d7		a9 1b		lda #$1b	                lda #AscESC
.82d9		20 bb 86	jsr $86bb	                jsr emit_a
.82dc		a9 5b		lda #$5b	                lda #'['
.82de		20 bb 86	jsr $86bb	                jsr emit_a
.82e1		20 e7 8c	jsr $8ce7	                jsr w_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82e4		20 5a d8	jsr $d85a	                jsr print_u
.82e7		a9 3b		lda #$3b	                lda #';'
.82e9		20 bb 86	jsr $86bb	                jsr emit_a
.82ec		20 e7 8c	jsr $8ce7	                jsr w_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82ef		20 5a d8	jsr $d85a	                jsr print_u
.82f2		a9 48		lda #$48	                lda #'H'
.82f4		20 bb 86	jsr $86bb	                jsr emit_a
.82f7		68		pla		                pla
.82f8		85 18		sta $18		                sta base
.82fa		60		rts		z_at_xy:        rts
.82fb						xt_backslash:
.82fb						w_backslash:
.82fb		a0 04		ldy #$04	                ldy #blk_offset
.82fd		b1 08		lda ($08),y	                lda (up),y
.82ff		c8		iny		                iny
.8300		11 08		ora ($08),y	                ora (up),y
.8302		f0 19		beq $831d	                beq backslash_not_block
.8304		a5 10		lda $10		                lda toin
.8306		29 3f		and #$3f	                and #$3F
.8308		f0 1b		beq $8325	                beq z_backslash
.830a		c9 01		cmp #$01	                cmp #$1
.830c		f0 17		beq $8325	                beq z_backslash
.830e		a5 10		lda $10		                lda toin
.8310		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.8312		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.8313		69 40		adc #$40	                adc #$40
.8315		85 10		sta $10		                sta toin
.8317		90 0c		bcc $8325	                bcc z_backslash
.8319		e6 11		inc $11		                inc toin+1
.831b		80 08		bra $8325	                bra z_backslash
.831d						backslash_not_block:
.831d		a5 0e		lda $0e		                lda ciblen
.831f		85 10		sta $10		                sta toin
.8321		a5 0f		lda $0f		                lda ciblen+1
.8323		85 11		sta $11		                sta toin+1
.8325		60		rts		z_backslash:    rts
.8326						xt_base:
.8326						w_base:
.8326		ca		dex		                dex
.8327		ca		dex		                dex
.8328		a9 18		lda #$18	                lda #<base
.832a		95 00		sta $00,x	                sta 0,x         ; LSB
.832c		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.832e		60		rts		z_base:         rts
.832f						xt_bl:
.832f						w_bl:
.832f		ca		dex		                dex
.8330		ca		dex		                dex
.8331		a9 20		lda #$20	                lda #AscSP
.8333		95 00		sta $00,x	                sta 0,x
.8335		74 01		stz $01,x	                stz 1,x
.8337		60		rts		z_bl:           rts
.8338						xt_bracket_char:
.8338						w_bracket_char:
.8338		20 7e 83	jsr $837e	                jsr w_char
.833b		20 fb 89	jsr $89fb	                jsr w_literal
.833e		60		rts		z_bracket_char: rts
.833f						xt_bracket_tick:
.833f						w_bracket_tick:
.833f		20 57 92	jsr $9257	                jsr w_tick
.8342		20 fb 89	jsr $89fb	                jsr w_literal
.8345		60		rts		z_bracket_tick: rts
.8346						xt_buffer_colon:
.8346						w_buffer_colon:
.8346		20 1d 84	jsr $841d	                jsr w_create            ; will report default PFA size of 2 in SEE
.8349		20 55 82	jsr $8255	                jsr w_allot
.834c		60		rts		z_buffer_colon: rts
.834d						xt_c_comma:
.834d		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8350						w_c_comma:
.8350		b5 00		lda $00,x	                lda 0,x
.8352		20 e4 97	jsr $97e4	                jsr cmpl_a
.8355		e8		inx		                inx
.8356		e8		inx		                inx
.8357		60		rts		z_c_comma:      rts
.8358						xt_c_fetch:
.8358		20 f2 d7	jsr $d7f2	                jsr underflow_1
.835b						w_c_fetch:
.835b		a1 00		lda ($00,x)	                lda (0,x)
.835d		95 00		sta $00,x	                sta 0,x
.835f		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8361		60		rts		z_c_fetch:      rts
.8362						xt_c_store:
.8362		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8365						w_c_store:
.8365		b5 02		lda $02,x	                lda 2,x
.8367		81 00		sta ($00,x)	                sta (0,x)
.8369		e8		inx		                inx
.836a		e8		inx		                inx
.836b		e8		inx		                inx
.836c		e8		inx		                inx
.836d		60		rts		z_c_store:      rts
.836e						xt_cell_plus:
.836e		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8371						w_cell_plus:
.8371		f6 00		inc $00,x	                inc 0,x
.8373		d0 02		bne $8377	                bne +
.8375		f6 01		inc $01,x	                inc 1,x
.8377						+
.8377		f6 00		inc $00,x	                inc 0,x
.8379		d0 02		bne $837d	                bne _done
.837b		f6 01		inc $01,x	                inc 1,x
.837d						_done:
.837d		60		rts		z_cell_plus:    rts
.837e						xt_char:
.837e						w_char:
.837e		20 4c 8d	jsr $8d4c	                jsr w_parse_name
.8381		b5 00		lda $00,x	                lda 0,x
.8383		15 01		ora $01,x	                ora 1,x
.8385		d0 05		bne $838c	                bne _not_empty
.8387		a9 05		lda #$05	                lda #err_noname
.8389		4c 08 d8	jmp $d808	                jmp error
.838c						_not_empty:
.838c		e8		inx		                inx             ; drop number of characters, leave addr
.838d		e8		inx		                inx
.838e		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8390		95 00		sta $00,x	                sta 0,x
.8392		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8394		60		rts		z_char:         rts
.8395						xt_chars:
.8395		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8398						w_chars:
.8398		60		rts		z_chars:        rts
.8399						xt_colon:
.8399						w_colon:
.8399		a5 1a		lda $1a		                lda state
.839b		05 1b		ora $1b		                ora state+1
.839d		f0 05		beq $83a4	                beq +
.839f		a9 07		lda #$07	                lda #err_state
.83a1		4c 08 d8	jmp $d808	                jmp error
.83a4						+
.83a4		c6 1a		dec $1a		                dec state
.83a6		c6 1b		dec $1b		                dec state+1
.83a8		a9 d0		lda #$d0	                lda #%11010000
.83aa		04 1c		tsb $1c		                tsb status
.83ac		a5 00		lda $00		                lda cp
.83ae		85 06		sta $06		                sta workword
.83b0		a5 01		lda $01		                lda cp+1
.83b2		85 07		sta $07		                sta workword+1
.83b4		a0 00		ldy #$00	                ldy #0                  ; Tell CREATE we want neither CFA nor dictionary update
.83b6		20 25 84	jsr $8425	                jsr create_common
.83b9		60		rts		z_colon:        rts
.83ba						xt_colon_noname:
.83ba						w_colon_noname:
.83ba		a5 1a		lda $1a		                lda state
.83bc		05 1b		ora $1b		                ora state+1
.83be		f0 05		beq $83c5	                beq +
.83c0		a9 07		lda #$07	                lda #err_state
.83c2		4c 08 d8	jmp $d808	                jmp error
.83c5						+
.83c5		c6 1a		dec $1a		                dec state
.83c7		c6 1b		dec $1b		                dec state+1
.83c9		a9 40		lda #$40	                lda #%01000000
.83cb		14 1c		trb $1c		                trb status
.83cd		a5 00		lda $00		                lda cp
.83cf		85 06		sta $06		                sta workword
.83d1		a5 01		lda $01		                lda cp+1
.83d3		85 07		sta $07		                sta workword+1
.83d5		60		rts		z_colon_noname:        rts
.83d6						xt_comma:
.83d6		20 f2 d7	jsr $d7f2	                jsr underflow_1
.83d9						w_comma:
.83d9		a0 02		ldy #$02	                ldy #2
.83db		b5 00		lda $00,x	_twice:         lda 0,x
.83dd		20 e4 97	jsr $97e4	                jsr cmpl_a
.83e0		e8		inx		                inx
.83e1		88		dey		                dey
.83e2		d0 f7		bne $83db	                bne _twice
.83e4		60		rts		z_comma:        rts
.83e5						xt_compile_only:
.83e5						w_compile_only:
.83e5		20 4b d7	jsr $d74b	                jsr current_to_dp
.83e8		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.83ea		b1 02		lda ($02),y	                lda (dp),y
.83ec		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.83ee		91 02		sta ($02),y	                sta (dp),y
.83f0		60		rts		z_compile_only: rts
.83f1						xt_value:
.83f1						xt_constant:
.83f1		20 f2 d7	jsr $d7f2	                jsr underflow_1
.83f4						w_value:
.83f4						w_constant:
.83f4		a9 02		lda #$02	                lda #2
.83f6		85 1e		sta $1e		                sta tmpdsp              ; 2 byte PFA
.83f8		a9 61		lda #$61	                lda #<doconst           ; LSB of DOCONST
.83fa		a0 d6		ldy #$d6	                ldy #>doconst           ; MSB of DOCONST
.83fc		20 25 84	jsr $8425	                jsr create_common
.83ff		20 d9 83	jsr $83d9	                jsr w_comma
.8402						z_value:
.8402		60		rts		z_constant:     rts
.8403						xt_count:
.8403		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8406						w_count:
.8406		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.8408		a8		tay		                tay
.8409		f6 00		inc $00,x	                inc 0,x         ; LSB
.840b		d0 02		bne $840f	                bne +
.840d		f6 01		inc $01,x	                inc 1,x         ; MSB
.840f		98		tya		+               tya
.8410		ca		dex		                dex
.8411		ca		dex		                dex
.8412		95 00		sta $00,x	                sta 0,x         ; LSB
.8414		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8416		60		rts		z_count:        rts
.8417						xt_cr:
.8417						w_cr:
.8417		a9 0a		lda #$0a	                lda #AscLF
.8419		20 bb 86	jsr $86bb	                jsr emit_a
.841c		60		rts		z_cr:           rts
.841d						xt_create:
.841d						w_create:
.841d		a9 02		lda #$02	                lda #2                  ; 2 byte PFA for variable
.841f		85 1e		sta $1e		                sta tmpdsp
.8421						create_dovar:
.8421		a0 d6		ldy #$d6	                ldy #>dovar
.8423		a9 a2		lda #$a2	                lda #<dovar
.8425						create_common:
.8425		ca		dex		                dex
.8426		ca		dex		                dex
.8427		95 00		sta $00,x	                sta 0,x
.8429		94 01		sty $01,x	                sty 1,x
.842b		20 4c 8d	jsr $8d4c	                jsr w_parse_name        ; ( cfa addr u )
.842e		b5 01		lda $01,x	                lda 1,x
.8430		d0 0d		bne $843f	                bne _too_long
.8432		b5 00		lda $00,x	                lda 0,x
.8434		d0 05		bne $843b	                bne +
.8436		a9 05		lda #$05	                lda #err_noname
.8438		4c 08 d8	jmp $d808	                jmp error
.843b						+
.843b		c9 20		cmp #$20	                cmp #32
.843d		90 06		bcc $8445	                bcc +
.843f						_too_long:
.843f		a9 1f		lda #$1f	                lda #31
.8441		95 00		sta $00,x	                sta 0,x
.8443		74 01		stz $01,x	                stz 1,x
.8445						+
.8445		20 c7 93	jsr $93c7	                jsr w_two_dup           ; ( cfa addr u addr u )
.8448		20 85 9b	jsr $9b85	                jsr w_find_name         ; ( cfa addr u flag ) (non-zero nt as flag)
.844b		e8		inx		                inx                     ; pre-drop flag (nt) from find-name.
.844c		e8		inx		                inx
.844d		b5 fe		lda $fe,x	                lda $fe,x
.844f		15 ff		ora $ff,x	                ora $ff,x
.8451		f0 1a		beq $846d	                beq _new_name           ; We haven't seen this one before.
.8453		24 1c		bit $1c		                bit status
.8455		10 06		bpl $845d	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8457		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8459		04 1c		tsb $1c		                tsb status
.845b		80 14		bra $8471	                bra _process_name
.845d						_redefined_name:
.845d		a9 02		lda #$02	                lda #str_redefined
.845f		20 2e d8	jsr $d82e	                jsr print_string_no_lf
.8462		20 c7 93	jsr $93c7	                jsr w_two_dup           ; ( cfa addr u addr u )
.8465		20 dc 94	jsr $94dc	                jsr w_type
.8468		20 dd 91	jsr $91dd	                jsr w_space
.846b		80 04		bra $8471	                bra _process_name
.846d						_new_name:
.846d		a9 80		lda #$80	                lda #$80                ; Clear status bit 7 to indicate new word.
.846f		14 1c		trb $1c		                trb status
.8471						_process_name:
.8471		a5 00		lda $00		                lda cp
.8473		85 25		sta $25		                sta tmp1
.8475		a5 01		lda $01		                lda cp+1
.8477		85 26		sta $26		                sta tmp1+1
.8479		b5 00		lda $00,x	                lda 0,x
.847b		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.847d		18		clc		                clc
.847e		69 08		adc #$08	                adc #8
.8480		85 28		sta $28		                sta tmp2+1               ; total header length
.8482		95 00		sta $00,x	                sta 0,x
.8484		74 01		stz $01,x	                stz 1,x                 ; max header size is 255 chars
.8486		20 55 82	jsr $8255	                jsr w_allot
.8489		20 4b d7	jsr $d74b	                jsr current_to_dp
.848c		a0 00		ldy #$00	                ldy #0
.848e		a5 27		lda $27		                lda tmp2
.8490		91 25		sta ($25),y	                sta (tmp1),y
.8492		c8		iny		                iny
.8493		b5 03		lda $03,x	                lda 3,x                 ; check MSB of CFA
.8495		f0 02		beq $8499	                beq +                   ; 0 means no CFA, leave A=0
.8497		a9 10		lda #$10	                lda #HC                 ; otherwise set the HC bit
.8499						+
.8499		09 08		ora #$08	                ora #NN
.849b		91 25		sta ($25),y	                sta (tmp1),y
.849d		c8		iny		                iny
.849e		a5 02		lda $02		                lda dp
.84a0		91 25		sta ($25),y	                sta (tmp1),y
.84a2		c8		iny		                iny
.84a3		a5 03		lda $03		                lda dp+1
.84a5		91 25		sta ($25),y	                sta (tmp1),y
.84a7		c8		iny		                iny
.84a8		b5 03		lda $03,x	                lda 3,x
.84aa		f0 08		beq $84b4	                beq +
.84ac		a5 26		lda $26		                lda tmp1+1
.84ae		85 03		sta $03		                sta dp+1
.84b0		a5 25		lda $25		                lda tmp1
.84b2		85 02		sta $02		                sta dp
.84b4						+
.84b4		18		clc		                clc
.84b5		a5 25		lda $25		                lda tmp1                ; redundant unless we skipped interlude
.84b7		65 28		adc $28		                adc tmp2+1              ; add total header length
.84b9		91 25		sta ($25),y	                sta (tmp1),y
.84bb		85 23		sta $23		                sta tmptos              ; save result for next step
.84bd		c8		iny		                iny
.84be		a5 26		lda $26		                lda tmp1+1
.84c0		69 00		adc #$00	                adc #0                  ; only need the carry
.84c2		91 25		sta ($25),y	                sta (tmp1),y
.84c4		85 24		sta $24		                sta tmptos+1
.84c6		c8		iny		                iny
.84c7		18		clc		                clc
.84c8		b5 03		lda $03,x	                lda 3,x
.84ca		f0 04		beq $84d0	                beq +                   ; leave A=0
.84cc		a9 03		lda #$03	                lda #3
.84ce		65 1e		adc $1e		                adc tmpdsp              ; add PFA size, assume no carry
.84d0						+
.84d0		65 23		adc $23		                adc tmptos              ; add LSB of xt_
.84d2		91 25		sta ($25),y	                sta (tmp1),y
.84d4		c8		iny		                iny
.84d5		a5 24		lda $24		                lda tmptos+1            ; recall MSB of xt_
.84d7		69 00		adc #$00	                adc #0                  ; only need the carry
.84d9		91 25		sta ($25),y	                sta (tmp1),y
.84db		c8		iny		                iny
.84dc		b5 00		lda $00,x	                lda 0,x
.84de		38		sec		                sec
.84df		e9 08		sbc #$08	                sbc #8
.84e1		85 23		sta $23		                sta tmptos
.84e3		b5 01		lda $01,x	                lda 1,x
.84e5		e9 00		sbc #$00	                sbc #0          ; only need carry
.84e7		85 24		sta $24		                sta tmptos+1
.84e9						_name_loop:
.84e9		b1 23		lda ($23),y	                lda (tmptos),y
.84eb		c9 5b		cmp #$5b	                cmp #'Z'+1
.84ed		b0 06		bcs $84f5	                bcs _store_name
.84ef		c9 41		cmp #$41	                cmp #'A'
.84f1		90 02		bcc $84f5	                bcc _store_name
.84f3		09 20		ora #$20	                ora #$20
.84f5						_store_name:
.84f5		91 25		sta ($25),y	                sta (tmp1),y
.84f7		c8		iny		                iny
.84f8		c6 27		dec $27		                dec tmp2
.84fa		d0 ed		bne $84e9	                bne _name_loop
.84fc		b4 03		ldy $03,x	                ldy 3,x
.84fe		f0 08		beq $8508	                beq +
.8500		b5 02		lda $02,x	                lda 2,x
.8502		20 d9 97	jsr $97d9	                jsr cmpl_subroutine             ; Add the CFA jsr
.8505		20 5e d7	jsr $d75e	                jsr dp_to_current
.8508						+
.8508		e8		inx		                inx
.8509		e8		inx		                inx
.850a		e8		inx		                inx
.850b		e8		inx		                inx
.850c		60		rts		z_create:       rts
.850d						xt_decimal:
.850d						w_decimal:
.850d		a9 0a		lda #$0a	                lda #10
.850f		85 18		sta $18		                sta base
.8511		64 19		stz $19		                stz base+1              ; paranoid
.8513		60		rts		z_decimal:      rts
.8514						xt_defer:
.8514						w_defer:
.8514		a9 02		lda #$02	                lda #2
.8516		85 1e		sta $1e		                sta tmpdsp      ; 2 byte PFA
.8518		a9 75		lda #$75	                lda #<dodefer   ; LSB
.851a		a0 d6		ldy #$d6	                ldy #>dodefer   ; MSB
.851c		20 25 84	jsr $8425	                jsr create_common
.851f		a9 27		lda #$27	                lda #<defer_error
.8521		a0 85		ldy #$85	                ldy #>defer_error
.8523		20 e0 97	jsr $97e0	                jsr cmpl_word
.8526		60		rts		z_defer:        rts
.8527						defer_error:
.8527		a9 03		lda #$03	                lda #err_defer
.8529		4c 08 d8	jmp $d808	                jmp error
.852c						xt_defer_fetch:
.852c		20 f2 d7	jsr $d7f2	                jsr underflow_1
.852f						w_defer_fetch:
.852f		20 b6 92	jsr $92b6	                jsr w_to_body
.8532		20 11 88	jsr $8811	                jsr w_fetch
.8535		60		rts		z_defer_fetch:  rts
.8536						xt_defer_store:
.8536		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8539						w_defer_store:
.8539		20 b6 92	jsr $92b6	                jsr w_to_body
.853c		20 30 92	jsr $9230	                jsr w_store
.853f		60		rts		z_defer_store:  rts
.8540						xt_depth:
.8540						w_depth:
.8540		a9 78		lda #$78	                lda #dsp0
.8542		86 1e		stx $1e		                stx tmpdsp
.8544		38		sec		                sec
.8545		e5 1e		sbc $1e		                sbc tmpdsp
.8547		4a		lsr a		                lsr
.8548		ca		dex		                dex
.8549		ca		dex		                dex
.854a		95 00		sta $00,x	                sta 0,x
.854c		74 01		stz $01,x	                stz 1,x
.854e		60		rts		z_depth:        rts
.854f						xt_question_do:
.854f						w_question_do:
.854f		ca		dex		                dex
.8550		ca		dex		                dex
.8551		a9 92		lda #$92	                lda #<question_do_runtime
.8553		95 00		sta $00,x	                sta 0,x
.8555		a9 85		lda #$85	                lda #>question_do_runtime
.8557		95 01		sta $01,x	                sta 1,x
.8559		20 91 86	jsr $8691	                jsr w_dup              ; xt and xt' are the same
.855c		ca		dex		                dex
.855d		ca		dex		                dex
.855e		a9 10		lda #$10	                lda #question_do_runtime_size
.8560		95 00		sta $00,x	                sta 0,x
.8562		74 01		stz $01,x	                stz 1,x
.8564		20 57 97	jsr $9757	                jsr cmpl_by_limit
.8567		90 0b		bcc $8574	                bcc _native
.8569		20 0f 89	jsr $890f	                jsr w_here
.856c		20 99 9e	jsr $9e99	                jsr w_zero
.856f		20 d9 83	jsr $83d9	                jsr w_comma
.8572		80 08		bra $857c	                bra do_common
.8574						_native:
.8574		20 b9 97	jsr $97b9	                jsr cmpl_jump_later
.8577		80 03		bra $857c	                bra do_common
.8579						xt_do:
.8579						w_do:
.8579		20 99 9e	jsr $9e99	                jsr w_zero             ; push 0 TOS
.857c						do_common:
.857c		ca		dex		                dex
.857d		ca		dex		                dex
.857e		a5 21		lda $21		                lda loopleave
.8580		95 00		sta $00,x	                sta 0,x
.8582		a5 22		lda $22		                lda loopleave+1
.8584		95 01		sta $01,x	                sta 1,x
.8586		64 22		stz $22		                stz loopleave+1
.8588		a0 85		ldy #$85	                ldy #>do_runtime
.858a		a9 aa		lda #$aa	                lda #<do_runtime
.858c		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.858f		4c 0f 89	jmp $890f	                jmp w_here
.8592						z_question_do:
.8592						z_do:
.8592						question_do_runtime:
.8592		b5 00		lda $00,x	                lda 0,x
.8594		d5 02		cmp $02,x	                cmp 2,x
.8596		d0 0d		bne $85a5	                bne _begin
.8598		b5 01		lda $01,x	                lda 1,x
.859a		d5 03		cmp $03,x	                cmp 3,x
.859c		d0 07		bne $85a5	                bne _begin
.859e		e8		inx		                inx                     ; drop loop limits and skip
.859f		e8		inx		                inx
.85a0		e8		inx		                inx
.85a1		e8		inx		                inx
=16						question_do_runtime_size = * - question_do_runtime
.85a2		a9 00		lda #$00	                lda #0
>85a4		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.85a5		a9 01		lda #$01	_begin:         lda #1
.85a7		4c 7c 98	jmp $987c	                jmp zbranch_runtime
.85aa						do_runtime:
.85aa		a4 1f		ldy $1f		                ldy loopctrl
.85ac		30 05		bmi $85b3	                bmi +                   ; is this the first LCB?
.85ae		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.85b0		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.85b3						+
.85b3		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.85b4		c8		iny		                iny
.85b5		c8		iny		                iny
.85b6		c8		iny		                iny
.85b7		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.85b9		38		sec		                sec
.85ba		a9 00		lda #$00	                lda #0
.85bc		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.85be		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.85c1		a9 80		lda #$80	                lda #$80
.85c3		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.85c5		99 03 01	sta $0103,y	                sta loopfufa+1,y
.85c8		18		clc		                clc
.85c9		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.85cb		79 02 01	adc $0102,y	                adc loopfufa,y
.85ce		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.85d0		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.85d2		79 03 01	adc $0103,y	                adc loopfufa+1,y
.85d5		99 01 01	sta $0101,y	                sta loopindex+1,y
.85d8		e8		inx		                inx                 ; clean up the stack
.85d9		e8		inx		                inx
.85da		e8		inx		                inx
.85db		e8		inx		                inx
.85dc		60		rts		                rts
.85dd						xt_does:
.85dd						w_does:
.85dd		a0 85		ldy #$85	                ldy #>does_runtime
.85df		a9 ec		lda #$ec	                lda #<does_runtime
.85e1		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.85e4		a0 d6		ldy #$d6	                ldy #>dodoes
.85e6		a9 89		lda #$89	                lda #<dodoes
.85e8		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.85eb		60		rts		z_does:         rts
.85ec						does_runtime:
.85ec		7a		ply		                ply             ; LSB
.85ed		68		pla		                pla             ; MSB
.85ee		c8		iny		                iny
.85ef		d0 01		bne $85f2	                bne +
.85f1		1a		inc a		                ina
.85f2						+
.85f2		84 25		sty $25		                sty tmp1
.85f4		85 26		sta $26		                sta tmp1+1
.85f6		20 4b d7	jsr $d74b	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.85f9		a5 02		lda $02		                lda dp
.85fb		18		clc		                clc
.85fc		69 04		adc #$04	                adc #4
.85fe		85 27		sta $27		                sta tmp2
.8600		a5 03		lda $03		                lda dp+1
.8602		69 00		adc #$00	                adc #0          ; we only care about the carry
.8604		85 28		sta $28		                sta tmp2+1
.8606		b2 27		lda ($27)	                lda (tmp2)
.8608		18		clc		                clc
.8609		69 01		adc #$01	                adc #1
.860b		85 29		sta $29		                sta tmp3
.860d		a0 01		ldy #$01	                ldy #1
.860f		b1 27		lda ($27),y	                lda (tmp2),y
.8611		69 00		adc #$00	                adc #0          ; we only care about the carry
.8613		85 2a		sta $2a		                sta tmp3+1
.8615		a5 25		lda $25		                lda tmp1        ; LSB
.8617		92 29		sta ($29)	                sta (tmp3)
.8619		a5 26		lda $26		                lda tmp1+1
.861b		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.861d		60		rts		                rts
.861e						xt_dot:
.861e		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8621						w_dot:
.8621		20 91 86	jsr $8691	                jsr w_dup                      ; ( n n )
.8624		20 d5 80	jsr $80d5	                jsr w_abs                      ; ( n u )
.8627		20 99 9e	jsr $9e99	                jsr w_zero                     ; ( n u 0 )
.862a		20 d5 89	jsr $89d5	                jsr w_less_number_sign         ; ( n u 0 )
.862d		20 b1 8c	jsr $8cb1	                jsr w_number_sign_s            ; ( n ud )
.8630		20 84 8f	jsr $8f84	                jsr w_rot                      ; ( ud n )
.8633		20 60 91	jsr $9160	                jsr w_sign                     ; ( ud )
.8636		20 8f 8c	jsr $8c8f	                jsr w_number_sign_greater      ; ( addr u )
.8639		20 dc 94	jsr $94dc	                jsr w_type
.863c		20 dd 91	jsr $91dd	                jsr w_space
.863f		60		rts		z_dot:          rts
.8640						xt_dot_paren:
.8640						w_dot_paren:
.8640		ca		dex		                dex
.8641		ca		dex		                dex
.8642		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8644		95 00		sta $00,x	                sta 0,x
.8646		74 01		stz $01,x	                stz 1,x
.8648		20 aa 8d	jsr $8daa	                jsr w_parse
.864b		20 dc 94	jsr $94dc	                jsr w_type
.864e		60		rts		z_dot_paren:    rts
.864f						xt_dot_quote:
.864f						w_dot_quote:
.864f		20 ca 8f	jsr $8fca	                jsr w_s_quote
.8652		a0 94		ldy #$94	                ldy #>w_type
.8654		a9 dc		lda #$dc	                lda #<w_type
.8656		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.8659		60		rts		z_dot_quote:    rts
.865a						xt_dot_r:
.865a		20 f7 d7	jsr $d7f7	                jsr underflow_2
.865d						w_dot_r:
.865d		20 81 93	jsr $9381	                jsr w_to_r
.8660		20 91 86	jsr $8691	                jsr w_dup
.8663		20 d5 80	jsr $80d5	                jsr w_abs
.8666		20 99 9e	jsr $9e99	                jsr w_zero
.8669		20 d5 89	jsr $89d5	                jsr w_less_number_sign
.866c		20 b1 8c	jsr $8cb1	                jsr w_number_sign_s
.866f		20 84 8f	jsr $8f84	                jsr w_rot
.8672		20 60 91	jsr $9160	                jsr w_sign
.8675		20 8f 8c	jsr $8c8f	                jsr w_number_sign_greater
.8678		20 dd 8e	jsr $8edd	                jsr w_r_from
.867b		20 03 8d	jsr $8d03	                jsr w_over
.867e		20 e3 8b	jsr $8be3	                jsr w_minus
.8681		20 e6 91	jsr $91e6	                jsr w_spaces
.8684		20 dc 94	jsr $94dc	                jsr w_type
.8687		60		rts		z_dot_r:        rts
.8688						xt_drop:
.8688		20 f2 d7	jsr $d7f2	                jsr underflow_1
.868b						w_drop:
.868b		e8		inx		                inx
.868c		e8		inx		                inx
.868d		60		rts		z_drop:         rts
.868e						xt_dup:
.868e		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8691						w_dup:
.8691		ca		dex		                dex
.8692		ca		dex		                dex
.8693		b5 02		lda $02,x	                lda 2,x         ; LSB
.8695		95 00		sta $00,x	                sta 0,x
.8697		b5 03		lda $03,x	                lda 3,x         ; MSB
.8699		95 01		sta $01,x	                sta 1,x
.869b		60		rts		z_dup:          rts
.869c						xt_else:
.869c						xt_endof:
.869c		20 f2 d7	jsr $d7f2	                jsr underflow_1
.869f						w_else:
.869f						w_endof:
.869f		20 b9 97	jsr $97b9	                jsr cmpl_jump_later
.86a2		20 46 92	jsr $9246	                jsr w_swap              ; ( target orig )
.86a5		80 03		bra $86aa	                bra w_then              ; fall through to then
.86a7						xt_then:
.86a7		20 f2 d7	jsr $d7f2	                jsr underflow_1
.86aa						w_then:
.86aa		20 0f 89	jsr $890f	                jsr w_here
.86ad		20 46 92	jsr $9246	                jsr w_swap
.86b0		20 30 92	jsr $9230	                jsr w_store
.86b3						z_else:
.86b3						z_endof:
.86b3		60		rts		z_then:         rts
.86b4						xt_emit:
.86b4		20 f2 d7	jsr $d7f2	                jsr underflow_1
.86b7						w_emit:
.86b7		b5 00		lda $00,x	                lda 0,x
.86b9		e8		inx		                inx
.86ba		e8		inx		                inx
.86bb						emit_a:
.86bb		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.86be						z_emit:
.86be						xt_endcase:
.86be		20 f2 d7	jsr $d7f2	                jsr underflow_1
.86c1						w_endcase:
.86c1		a0 86		ldy #$86	                ldy #>w_drop
.86c3		a9 8b		lda #$8b	                lda #<w_drop
.86c5		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.86c8						_endcase_loop:
.86c8		b5 00		lda $00,x	                lda 0,x
.86ca		15 01		ora $01,x	                ora 1,x
.86cc		f0 05		beq $86d3	                beq _done
.86ce		20 aa 86	jsr $86aa	                jsr w_then
.86d1		80 f5		bra $86c8	                bra _endcase_loop
.86d3						_done:
.86d3		e8		inx		                inx
.86d4		e8		inx		                inx
.86d5		60		rts		z_endcase:      rts
.86d6						xt_environment_q:
.86d6		20 f2 d7	jsr $d7f2	                jsr underflow_1
.86d9						w_environment_q:
.86d9		a0 00		ldy #$00	                ldy #0                  ; index for table
.86db						_table_loop:
.86db		c0 1a		cpy #$1a	                cpy #env_table_end - env_table_single
.86dd		f0 60		beq $873f	                beq _table_done
.86df		20 c7 93	jsr $93c7	                jsr w_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.86e2		ca		dex		                dex
.86e3		ca		dex		                dex                     ; ( addr u addr u ? )
.86e4		b9 48 87	lda $8748,y	                lda env_table_single,y
.86e7		95 00		sta $00,x	                sta 0,x
.86e9		c8		iny		                iny
.86ea		b9 48 87	lda $8748,y	                lda env_table_single,y
.86ed		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-s )
.86ef		c8		iny		                iny
.86f0		ca		dex		                dex
.86f1		ca		dex		                dex
.86f2		b9 48 87	lda $8748,y	                lda env_table_single,y
.86f5		95 00		sta $00,x	                sta 0,x
.86f7		b9 49 87	lda $8749,y	                lda env_table_single+1,y
.86fa		95 01		sta $01,x	                sta 1,x
.86fc		20 00 8d	jsr $8d00	                jsr xt_over
.86ff		20 e0 8b	jsr $8be0	                jsr xt_minus            ; ( addr u addr u addr-s u-s )
.8702		20 e8 a0	jsr $a0e8	                jsr w_compare           ; ( addr u f )
.8705		e8		inx		                inx                     ; DROP, now ( addr u )
.8706		e8		inx		                inx
.8707		b5 fe		lda $fe,x	                lda $fe,x
.8709		15 ff		ora $ff,x	                ora $ff,x
.870b		d0 ce		bne $86db	                bne _table_loop         ; Not a match, so try next string
.870d		88		dey		                dey                     ; go back to index we had
.870e		88		dey		                dey
.870f		c0 16		cpy #$16	                cpy #env_table_double - env_table_single
.8711		b0 0c		bcs $871f	                bcs _double_result
.8713		b9 64 87	lda $8764,y	                lda env_results_single,y
.8716		95 02		sta $02,x	                sta 2,x
.8718		b9 65 87	lda $8765,y	                lda env_results_single+1,y
.871b		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.871d		80 1c		bra $873b	                bra _set_flag
.871f						_double_result:
.871f		ca		dex		                dex                     ; ( addr u ? )
.8720		ca		dex		                dex
.8721		98		tya		                tya
.8722		38		sec		                sec
.8723		e9 16		sbc #$16	                sbc #(env_table_double - env_table_single)
.8725		0a		asl a		                asl
.8726		a8		tay		                tay
.8727		b9 7a 87	lda $877a,y	                lda env_results_double,y
.872a		95 02		sta $02,x	                sta 2,x
.872c		b9 7b 87	lda $877b,y	                lda env_results_double+1,y
.872f		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8731		b9 7c 87	lda $877c,y	                lda env_results_double+2,y
.8734		95 04		sta $04,x	                sta 4,x
.8736		b9 7d 87	lda $877d,y	                lda env_results_double+3,y
.8739		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.873b						_set_flag:
.873b		a9 ff		lda #$ff	                lda #$ff
.873d		80 04		bra $8743	                bra _done
.873f						_table_done:
.873f		e8		inx		                inx
.8740		e8		inx		                inx
.8741		a9 00		lda #$00	                lda #0                  ; flag failure and fall through
.8743						_done:
.8743		95 00		sta $00,x	                sta 0,x
.8745		95 01		sta $01,x	                sta 1,x
.8747						z_environment_q:
.8747		60		rts		                rts
.8748						env_table_single:
>8748		ee d5 fd d5 02 d6 06 d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8750		17 d6
>8752		1e d6 26 d6 2b d6 30 d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>875a		42 d6 4d d6			        .word envs_sc, envs_wl
.875e						env_table_double:
>875e		56 d6 5b d6			        .word envs_max_d, envs_max_ud
.8762						env_table_end:
>8762		61 d6				        .word envs_eot                  ; pointer beyond last string
.8764						env_results_single:
>8764		ff 00				        .word $00FF     ; /COUNTED-STRING
>8766		ff 00				        .word $00FF     ; /HOLD
>8768		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>876a		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>876c		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>876e		ff 00				        .word $00FF     ; MAX-CHAR
>8770		ff 7f				        .word $7FFF     ; MAX-N
>8772		ff ff				        .word $FFFF     ; MAX-U
>8774		80 00				        .word $0080     ; RETURN-STACK-CELLS
>8776		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8778		09 00				        .word $0009     ; WORDLISTS
.877a						env_results_double:
>877a		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>877e		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8782						xt_equal:
.8782		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8785						w_equal:
.8785		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8787		d5 02		cmp $02,x	                cmp 2,x
.8789		d0 0a		bne $8795	                bne _false
.878b		b5 01		lda $01,x	                lda 1,x                 ; MSB
.878d		d5 03		cmp $03,x	                cmp 3,x
.878f		d0 04		bne $8795	                bne _false
.8791		a9 ff		lda #$ff	                lda #$FF
.8793		80 02		bra $8797	                bra _done
.8795		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8797		95 02		sta $02,x	_done:          sta 2,x
.8799		95 03		sta $03,x	                sta 3,x
.879b		e8		inx		                inx
.879c		e8		inx		                inx
.879d		60		rts		z_equal:        rts
.879e						xt_blank:
.879e		20 f7 d7	jsr $d7f7	                jsr underflow_2
.87a1						w_blank:
.87a1		ca		dex		                dex
.87a2		ca		dex		                dex
.87a3		a9 20		lda #$20	                lda #AscSP
.87a5		95 00		sta $00,x	                sta 0,x
.87a7		74 01		stz $01,x	                stz 1,x
.87a9		80 0e		bra $87b9	                bra w_fill     ; skip over code for ERASE
.87ab						xt_erase:
.87ab		20 f7 d7	jsr $d7f7	                jsr underflow_2
.87ae						w_erase:
.87ae		ca		dex		                dex
.87af		ca		dex		                dex
.87b0		74 00		stz $00,x	                stz 0,x
.87b2		74 01		stz $01,x	                stz 1,x
.87b4		80 03		bra $87b9	                bra w_fill
.87b6						xt_fill:
.87b6		20 fc d7	jsr $d7fc	                jsr underflow_3
.87b9						w_fill:
.87b9		b5 04		lda $04,x	                lda 4,x         ; LSB
.87bb		85 25		sta $25		                sta tmp1
.87bd		b5 05		lda $05,x	                lda 5,x
.87bf		85 26		sta $26		                sta tmp1+1
.87c1		b5 02		lda $02,x	                lda 2,x
.87c3		85 27		sta $27		                sta tmp2
.87c5		b5 03		lda $03,x	                lda 3,x
.87c7		85 28		sta $28		                sta tmp2+1
.87c9		b5 00		lda $00,x	                lda 0,x
.87cb		a8		tay		                tay
.87cc						_loop:
.87cc		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.87ce		c5 26		cmp $26		                cmp tmp1+1
.87d0		90 21		bcc $87f3	                bcc _done               ; RAM_END < TMP1, so leave
.87d2		d0 06		bne $87da	                bne _check_counter      ; RAM_END is not smaller and not equal
.87d4		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.87d6		c5 25		cmp $25		                cmp tmp1
.87d8		90 19		bcc $87f3	                bcc _done               ; RAM_END < TMP1, so leave
.87da						_check_counter:
.87da		a5 27		lda $27		                lda tmp2
.87dc		05 28		ora $28		                ora tmp2+1
.87de		f0 13		beq $87f3	                beq _done
.87e0		98		tya		                tya
.87e1		92 25		sta ($25)	                sta (tmp1)
.87e3		a5 27		lda $27		                lda tmp2
.87e5		d0 02		bne $87e9	                bne +
.87e7		c6 28		dec $28		                dec tmp2+1
.87e9		c6 27		dec $27		+               dec tmp2
.87eb		e6 25		inc $25		                inc tmp1
.87ed		d0 dd		bne $87cc	                bne _loop
.87ef		e6 26		inc $26		                inc tmp1+1
.87f1		80 d9		bra $87cc	                bra _loop
.87f3						_done:
.87f3		8a		txa		                txa
.87f4		18		clc		                clc
.87f5		69 06		adc #$06	                adc #6
.87f7		aa		tax		                tax
.87f8						z_blank:
.87f8						z_erase:
.87f8		60		rts		z_fill:         rts
.87f9						xt_execute:
.87f9		20 f2 d7	jsr $d7f2	                jsr underflow_1
.87fc						w_execute:
.87fc		20 00 88	jsr $8800	                jsr doexecute   ; do not combine to JMP (native coding)
.87ff		60		rts		z_execute:      rts
.8800						doexecute:
.8800		b5 00		lda $00,x	                lda 0,x
.8802		85 04		sta $04		                sta ip
.8804		b5 01		lda $01,x	                lda 1,x
.8806		85 05		sta $05		                sta ip+1
.8808		e8		inx		                inx
.8809		e8		inx		                inx
.880a		6c 04 00	jmp ($0004)	                jmp (ip)
.880d						xt_exit:
.880d						w_exit:
.880d		60		rts		                rts             ; keep before z_exit
.880e						z_exit:
.880e						xt_fetch:
.880e		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8811						w_fetch:
.8811		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8813		a8		tay		                tay
.8814		f6 00		inc $00,x	                inc 0,x
.8816		d0 02		bne $881a	                bne +
.8818		f6 01		inc $01,x	                inc 1,x
.881a						+
.881a		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.881c		95 01		sta $01,x	                sta 1,x
.881e		94 00		sty $00,x	                sty 0,x
.8820		60		rts		z_fetch:        rts
.8821						xt_find:
.8821		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8824						w_find:
.8824		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8826		48		pha		                pha
.8827		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8829		48		pha		                pha
.882a		20 06 84	jsr $8406	                jsr w_count            ; ( caddr -- addr u )
.882d		20 85 9b	jsr $9b85	                jsr w_find_name        ; ( addr u -- nt | 0 )
.8830		b5 00		lda $00,x	                lda 0,x
.8832		15 01		ora $01,x	                ora 1,x
.8834		d0 0b		bne $8841	                bne _found_word
.8836		20 99 9e	jsr $9e99	                jsr w_false            ; ( 0 0 )
.8839		68		pla		                pla                     ; LSB of address
.883a		95 02		sta $02,x	                sta 2,x
.883c		68		pla		                pla
.883d		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.883f		80 27		bra $8868	                bra _done               ; ( addr 0 )
.8841						_found_word:
.8841		68		pla		                pla
.8842		68		pla		                pla
.8843		20 91 86	jsr $8691	                jsr w_dup              ; ( nt nt )
.8846		20 d9 9c	jsr $9cd9	                jsr w_name_to_int      ; ( nt xt )
.8849		20 46 92	jsr $9246	                jsr w_swap             ; ( xt nt )
.884c		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.884e		f6 00		inc $00,x	                inc 0,x
.8850		d0 02		bne $8854	                bne +
.8852		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8854						+
.8854		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8856		29 02		and #$02	                and #IM
.8858		d0 08		bne $8862	                bne _immediate          ; bit set, we're immediate
.885a		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.885c		95 00		sta $00,x	                sta 0,x
.885e		95 01		sta $01,x	                sta 1,x
.8860		80 06		bra $8868	                bra _done
.8862						_immediate:
.8862		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8864		95 00		sta $00,x	                sta 0,x
.8866		74 01		stz $01,x	                stz 1,x
.8868						_done:
.8868		60		rts		z_find:         rts
.8869						xt_fm_slash_mod:
.8869		20 fc d7	jsr $d7fc	                jsr underflow_3
.886c						w_fm_slash_mod:
.886c		64 27		stz $27		                stz tmp2        ; default: n is positive
.886e		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8870		10 0e		bpl $8880	                bpl _check_d
.8872		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.8874		20 21 8c	jsr $8c21	                jsr w_negate   ; NEGATE
.8877		20 81 93	jsr $9381	                jsr w_to_r     ; >R
.887a		20 0a 9f	jsr $9f0a	                jsr w_dnegate  ; DNEGATE
.887d		20 dd 8e	jsr $8edd	                jsr w_r_from   ; R>
.8880						_check_d:
.8880		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.8882		10 0d		bpl $8891	                bpl _multiply
.8884		18		clc		                clc
.8885		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.8887		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.8889		95 02		sta $02,x	                sta 2,x
.888b		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.888d		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.888f		95 03		sta $03,x	                sta 3,x
.8891						_multiply:
.8891		20 61 95	jsr $9561	                jsr w_um_slash_mod     ; ( d n1 -- rem n2 )
.8894		a5 27		lda $27		                lda tmp2
.8896		f0 07		beq $889f	                beq _done
.8898		e8		inx		                inx             ; pretend that we SWAP
.8899		e8		inx		                inx
.889a		20 21 8c	jsr $8c21	                jsr w_negate
.889d		ca		dex		                dex
.889e		ca		dex		                dex
.889f						_done:
.889f		60		rts		z_fm_slash_mod: rts
.88a0						load_evaluate:
.88a0		a9 ff		lda #$ff	                lda #$FF
.88a2		85 25		sta $25		                sta tmp1
.88a4		80 11		bra $88b7	                bra load_evaluate_start
.88a6						xt_evaluate:
.88a6		20 f7 d7	jsr $d7f7	                jsr underflow_2
.88a9						w_evaluate:
.88a9		64 25		stz $25		                stz tmp1
.88ab		b5 00		lda $00,x	                lda 0,x
.88ad		15 01		ora $01,x	                ora 1,x
.88af		d0 06		bne $88b7	                bne evaluate_got_work
.88b1		e8		inx		                inx
.88b2		e8		inx		                inx
.88b3		e8		inx		                inx
.88b4		e8		inx		                inx
.88b5		80 42		bra $88f9	                bra evaluate_done
.88b7						load_evaluate_start:
.88b7						evaluate_got_work:
.88b7		a0 05		ldy #$05	                ldy #blk_offset+1
.88b9		b1 08		lda ($08),y	                lda (up),y
.88bb		48		pha		                pha
.88bc		88		dey		                dey
.88bd		b1 08		lda ($08),y	                lda (up),y
.88bf		48		pha		                pha
.88c0		a5 25		lda $25		                lda tmp1
.88c2		d0 05		bne $88c9	                bne _nozero
.88c4		91 08		sta ($08),y	                sta (up),y
.88c6		c8		iny		                iny
.88c7		91 08		sta ($08),y	                sta (up),y
.88c9						_nozero:
.88c9		20 3a 9c	jsr $9c3a	                jsr w_input_to_r
.88cc		a9 ff		lda #$ff	                lda #$FF
.88ce		85 0a		sta $0a		                sta insrc
.88d0		85 0b		sta $0b		                sta insrc+1
.88d2		64 10		stz $10		                stz toin
.88d4		64 11		stz $11		                stz toin+1
.88d6		b5 00		lda $00,x	                lda 0,x
.88d8		85 0e		sta $0e		                sta ciblen
.88da		b5 01		lda $01,x	                lda 1,x
.88dc		85 0f		sta $0f		                sta ciblen+1
.88de		b5 02		lda $02,x	                lda 2,x
.88e0		85 0c		sta $0c		                sta cib
.88e2		b5 03		lda $03,x	                lda 3,x
.88e4		85 0d		sta $0d		                sta cib+1
.88e6		e8		inx		                inx             ; A clean stack is a clean mind
.88e7		e8		inx		                inx
.88e8		e8		inx		                inx
.88e9		e8		inx		                inx
.88ea		20 71 d7	jsr $d771	                jsr interpret   ; ( -- )
.88ed		20 47 9e	jsr $9e47	                jsr w_r_to_input
.88f0		a0 04		ldy #$04	                ldy #blk_offset
.88f2		68		pla		                pla
.88f3		91 08		sta ($08),y	                sta (up),y
.88f5		c8		iny		                iny
.88f6		68		pla		                pla
.88f7		91 08		sta ($08),y	                sta (up),y
.88f9						evaluate_done:
.88f9		60		rts		z_evaluate:     rts
.88fa						xt_greater_than:
.88fa		20 f7 d7	jsr $d7f7	                jsr underflow_2
.88fd						w_greater_than:
.88fd		a0 00		ldy #$00	                ldy #0          ; default false
.88ff		20 32 d7	jsr $d732	                jsr compare_16bit
.8902		f0 03		beq $8907	                beq _false
.8904		10 01		bpl $8907	                bpl _false
.8906		88		dey		                dey
.8907						_false:
.8907		98		tya		                tya
.8908		e8		inx		                inx
.8909		e8		inx		                inx
.890a		95 00		sta $00,x	                sta 0,x
.890c		95 01		sta $01,x	                sta 1,x
.890e		60		rts		z_greater_than: rts
.890f						xt_here:
.890f						xt_begin:
.890f						xt_asm_arrow:
.890f						w_here:
.890f						w_begin:
.890f						w_asm_arrow:
.890f		ca		dex		                dex
.8910		ca		dex		                dex
.8911		a5 00		lda $00		                lda cp
.8913		95 00		sta $00,x	                sta 0,x
.8915		a5 01		lda $01		                lda cp+1
.8917		95 01		sta $01,x	                sta 1,x
.8919						z_here:
.8919						z_begin:
.8919						z_asm_arrow:
.8919		60		rts		                rts
.891a						xt_hex:
.891a						w_hex:
.891a		a9 10		lda #$10	                lda #16
.891c		85 18		sta $18		                sta base
.891e		64 19		stz $19		                stz base+1              ; paranoid
.8920		60		rts		z_hex:          rts
.8921						xt_hold:
.8921		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8924						w_hold:
.8924		a5 2b		lda $2b		                lda tohold
.8926		d0 02		bne $892a	                bne +
.8928		c6 2c		dec $2c		                dec tohold+1
.892a						+
.892a		c6 2b		dec $2b		                dec tohold
.892c		b5 00		lda $00,x	                lda 0,x
.892e		92 2b		sta ($2b)	                sta (tohold)
.8930		e8		inx		                inx
.8931		e8		inx		                inx
.8932		60		rts		z_hold:         rts
.8933						xt_i:
.8933						w_i:
.8933		ca		dex		                dex
.8934		ca		dex		                dex
.8935		a4 1f		ldy $1f		                ldy loopctrl
.8937		38		sec		                sec
.8938		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.893a		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.893d		95 00		sta $00,x	                sta 0,x
.893f		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8942		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8945		95 01		sta $01,x	                sta 1,x
.8947		60		rts		z_i:            rts
.8948						xt_if:
.8948						w_if:
.8948		20 ff 97	jsr $97ff	                jsr cmpl_0branch_later
.894b		60		rts		z_if:           rts
.894c						xt_immediate:
.894c						w_immediate:
.894c		20 4b d7	jsr $d74b	                jsr current_to_dp
.894f		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8951		b1 02		lda ($02),y	                lda (dp),y
.8953		09 02		ora #$02	                ora #IM        ; make sure bit 7 is set
.8955		91 02		sta ($02),y	                sta (dp),y
.8957		60		rts		z_immediate:    rts
.8958						xt_invert:
.8958		20 f2 d7	jsr $d7f2	                jsr underflow_1
.895b						w_invert:
.895b		a9 ff		lda #$ff	                lda #$FF
.895d		55 00		eor $00,x	                eor 0,x         ; LSB
.895f		95 00		sta $00,x	                sta 0,x
.8961		a9 ff		lda #$ff	                lda #$FF
.8963		55 01		eor $01,x	                eor 1,x         ; MSB
.8965		95 01		sta $01,x	                sta 1,x
.8967		60		rts		z_invert:       rts
.8968						xt_is:
.8968						w_is:
.8968		a5 1a		lda $1a		                lda state
.896a		05 1b		ora $1b		                ora state+1
.896c		f0 0c		beq $897a	                beq _interpreting
.896e		20 3f 83	jsr $833f	                jsr w_bracket_tick
.8971		a0 85		ldy #$85	                ldy #>w_defer_store
.8973		a9 39		lda #$39	                lda #<w_defer_store
.8975		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.8978		80 06		bra $8980	                bra _done
.897a						_interpreting:
.897a		20 57 92	jsr $9257	                jsr w_tick
.897d		20 39 85	jsr $8539	                jsr w_defer_store
.8980						_done:
.8980		60		rts		z_is:           rts
.8981						xt_j:
.8981						w_j:
.8981		ca		dex		                dex                 ; make space on the stack
.8982		ca		dex		                dex
.8983		a5 1f		lda $1f		                lda loopctrl
.8985		38		sec		                sec
.8986		e9 04		sbc #$04	                sbc #4
.8988		a8		tay		                tay
.8989		38		sec		                sec
.898a		b9 00 01	lda $0100,y	                lda loopindex,y
.898d		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8990		95 00		sta $00,x	                sta 0,x
.8992		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8995		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8998		95 01		sta $01,x	                sta 1,x
.899a		60		rts		z_j:            rts
.899b						xt_key:
.899b						w_key:
.899b		20 a5 89	jsr $89a5	                jsr key_a               ; returns char in A
.899e		ca		dex		                dex
.899f		ca		dex		                dex
.89a0		95 00		sta $00,x	                sta 0,x
.89a2		74 01		stz $01,x	                stz 1,x
.89a4		60		rts		z_key:          rts
.89a5						key_a:
.89a5		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.89a8						xt_keyq:
.89a8						w_keyq:
.89a8		a0 00		ldy #$00	                ldy #0
.89aa		20 b7 89	jsr $89b7	                jsr keyq_a
.89ad		f0 01		beq $89b0	                beq +           ; A=0 => Y=0
.89af		88		dey		                dey             ; A<>0 => Y=#$ff
.89b0						+
.89b0		ca		dex		                dex
.89b1		ca		dex		                dex
.89b2		94 00		sty $00,x	                sty 0,x         ; store either $0000 or $ffff
.89b4		94 01		sty $01,x	                sty 1,x
.89b6		60		rts		z_keyq:         rts
.89b7		6c 16 00	jmp ($0016)	keyq_a:         jmp (havekey)
.89ba						xt_leave:
.89ba						w_leave:
.89ba		a5 21		lda $21		                lda loopleave
.89bc		a4 22		ldy $22		                ldy loopleave+1
.89be		20 d0 97	jsr $97d0	                jsr cmpl_jump   ; emit the JMP chaining prior leave address
.89c1		38		sec		                sec
.89c2		a5 00		lda $00		                lda cp
.89c4		e9 02		sbc #$02	                sbc #2
.89c6		85 21		sta $21		                sta loopleave
.89c8		a5 01		lda $01		                lda cp+1
.89ca		b0 01		bcs $89cd	                bcs +
.89cc		3a		dec a		                dea
.89cd		85 22		sta $22		+               sta loopleave+1
.89cf						z_leave:
.89cf		60		rts		                rts
.89d0						xt_left_bracket:
.89d0						w_left_bracket:
.89d0		64 1a		stz $1a		                stz state
.89d2		64 1b		stz $1b		                stz state+1
.89d4		60		rts		z_left_bracket: rts
.89d5						xt_less_number_sign:
.89d5						w_less_number_sign:
.89d5		20 0e 8d	jsr $8d0e	                jsr w_pad      ; ( addr )
.89d8		b5 00		lda $00,x	                lda 0,x
.89da		85 2b		sta $2b		                sta tohold
.89dc		b5 01		lda $01,x	                lda 1,x
.89de		85 2c		sta $2c		                sta tohold+1
.89e0		e8		inx		                inx
.89e1		e8		inx		                inx
.89e2						z_less_number_sign:
.89e2		60		rts		                rts
.89e3						xt_less_than:
.89e3		20 f7 d7	jsr $d7f7	                jsr underflow_2
.89e6						w_less_than:
.89e6		a0 00		ldy #$00	                ldy #0          ; default false
.89e8		20 32 d7	jsr $d732	                jsr compare_16bit
.89eb		f0 03		beq $89f0	                beq _false
.89ed		30 01		bmi $89f0	                bmi _false
.89ef		88		dey		                dey
.89f0						_false:
.89f0		98		tya		                tya
.89f1		e8		inx		                inx
.89f2		e8		inx		                inx
.89f3		95 00		sta $00,x	                sta 0,x
.89f5		95 01		sta $01,x	                sta 1,x
.89f7		60		rts		z_less_than:    rts
.89f8						xt_literal:
.89f8		20 f2 d7	jsr $d7f2	                jsr underflow_1
.89fb						w_literal:
.89fb		a9 0a		lda #$0a	                lda #template_push_tos_size
.89fd		20 ed 97	jsr $97ed	                jsr check_nc_limit
.8a00		90 0c		bcc $8a0e	                bcc _inline
.8a02		a0 8a		ldy #$8a	                ldy #>literal_runtime
.8a04		a9 40		lda #$40	                lda #<literal_runtime
.8a06		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.8a09		20 d9 83	jsr $83d9	                jsr w_comma
.8a0c		80 27		bra $8a35	                bra z_literal
.8a0e						_inline:
.8a0e		a0 94		ldy #$94	                ldy #$94        ; STY opcode
.8a10		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a12		d0 02		bne $8a16	                bne +
.8a14		a0 74		ldy #$74	                ldy #$74        ; STZ opcode
.8a16		5a		phy		+               phy
.8a17		b5 00		lda $00,x	                lda 0,x         ; LSB
.8a19		48		pha		                pha
.8a1a		a0 02		ldy #$02	                ldy #2
.8a1c		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a1e		f0 03		beq $8a23	                beq _copy
.8a20		a0 00		ldy #$00	                ldy #0
.8a22		48		pha		                pha
.8a23		b9 36 8a	lda $8a36,y	_copy:          lda template_push_tos,y
.8a26		c9 ff		cmp #$ff	                cmp #$ff        ; is it a placeholder?
.8a28		d0 01		bne $8a2b	                bne +
.8a2a		68		pla		                pla
.8a2b		20 e4 97	jsr $97e4	+               jsr cmpl_a
.8a2e		c8		iny		                iny
.8a2f		c0 0a		cpy #$0a	                cpy #template_push_tos_size
.8a31		d0 f0		bne $8a23	                bne _copy
.8a33		e8		inx		                inx             ; drop the literal
.8a34		e8		inx		                inx
.8a35		60		rts		z_literal:      rts
.8a36						template_push_tos:
.8a36		a0 ff		ldy #$ff	                ldy #$ff        ; we'll omit this if MSB is zero
.8a38		a9 ff		lda #$ff	                lda #$ff
.8a3a		ca		dex		                dex
.8a3b		ca		dex		                dex
.8a3c		95 00		sta $00,x	                sta 0,x
>8a3e		ff 01				                .byte $ff, 1    ; this will become either sty 1,x or stz 1,x
=10						template_push_tos_size = * - template_push_tos
.8a40						literal_runtime:
.8a40		ca		dex		                dex
.8a41		ca		dex		                dex
.8a42		68		pla		                pla             ; LSB
.8a43		85 25		sta $25		                sta tmp1
.8a45		68		pla		                pla             ; MSB
.8a46		85 26		sta $26		                sta tmp1+1
.8a48		a0 01		ldy #$01	                ldy #1
.8a4a		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.8a4c		95 00		sta $00,x	                sta 0,x
.8a4e		c8		iny		                iny
.8a4f		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.8a51		95 01		sta $01,x	                sta 1,x
.8a53		98		tya		                tya
.8a54		18		clc		                clc
.8a55		65 25		adc $25		                adc tmp1
.8a57		a8		tay		                tay
.8a58		a5 26		lda $26		                lda tmp1+1
.8a5a		69 00		adc #$00	                adc #0
.8a5c		48		pha		                pha
.8a5d		5a		phy		                phy
.8a5e		60		rts		                rts
.8a5f						xt_loop:
.8a5f						w_loop:
.8a5f		ca		dex		                dex
.8a60		ca		dex		                dex
.8a61		ca		dex		                dex
.8a62		ca		dex		                dex
.8a63		a9 d8		lda #$d8	                lda #<loop_runtime
.8a65		95 02		sta $02,x	                sta 2,x
.8a67		a9 8a		lda #$8a	                lda #>loop_runtime
.8a69		95 03		sta $03,x	                sta 3,x
.8a6b		a9 11		lda #$11	                lda #loop_runtime_size
.8a6d		95 00		sta $00,x	                sta 0,x
.8a6f		74 01		stz $01,x	                stz 1,x
.8a71		80 12		bra $8a85	                bra loop_common
.8a73						xt_plus_loop:
.8a73						w_plus_loop:
.8a73		ca		dex		                dex
.8a74		ca		dex		                dex
.8a75		ca		dex		                dex
.8a76		ca		dex		                dex
.8a77		a9 f1		lda #$f1	                lda #<plus_loop_runtime
.8a79		95 02		sta $02,x	                sta 2,x
.8a7b		a9 8a		lda #$8a	                lda #>plus_loop_runtime
.8a7d		95 03		sta $03,x	                sta 3,x
.8a7f		a9 1a		lda #$1a	                lda #plus_loop_runtime_size
.8a81		95 00		sta $00,x	                sta 0,x
.8a83		74 01		stz $01,x	                stz 1,x
.8a85						loop_common:
.8a85		20 03 8d	jsr $8d03	                jsr w_over
.8a88		20 46 92	jsr $9246	                jsr w_swap             ; xt and xt' are the same
.8a8b		20 57 97	jsr $9757	                jsr cmpl_by_limit
.8a8e		90 05		bcc $8a95	                bcc _native
.8a90		20 d9 83	jsr $83d9	                jsr w_comma
.8a93		80 03		bra $8a98	                bra +
.8a95						_native:
.8a95		20 ca 97	jsr $97ca	                jsr cmpl_jump_tos
.8a98						+
.8a98		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.8a9a		f0 19		beq $8ab5	                beq _noleave
.8a9c						_next:
.8a9c		a0 01		ldy #$01	                ldy #1
.8a9e		b1 21		lda ($21),y	                lda (loopleave),y
.8aa0		48		pha		                pha
.8aa1		a5 01		lda $01		                lda cp+1
.8aa3		91 21		sta ($21),y	                sta (loopleave),y
.8aa5		88		dey		                dey
.8aa6		b1 21		lda ($21),y	                lda (loopleave),y
.8aa8		48		pha		                pha
.8aa9		a5 00		lda $00		                lda cp
.8aab		91 21		sta ($21),y	                sta (loopleave),y
.8aad		68		pla		                pla
.8aae		85 21		sta $21		                sta loopleave
.8ab0		68		pla		                pla
.8ab1		85 22		sta $22		                sta loopleave+1
.8ab3		d0 e7		bne $8a9c	                bne _next
.8ab5						_noleave:
.8ab5		b5 00		lda $00,x	                lda 0,x
.8ab7		85 21		sta $21		                sta loopleave
.8ab9		b5 01		lda $01,x	                lda 1,x
.8abb		85 22		sta $22		                sta loopleave+1
.8abd		a9 45		lda #$45	                lda #<nt_unloop
.8abf		95 00		sta $00,x	                sta 0,x
.8ac1		a9 c3		lda #$c3	                lda #>nt_unloop
.8ac3		95 01		sta $01,x	                sta 1,x
.8ac5		20 d5 96	jsr $96d5	                jsr compile_nt_comma    ; use the faster entry with the NT
.8ac8		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.8aca		f0 09		beq $8ad5	                beq +
.8acc		20 0f 89	jsr $890f	                jsr w_here
.8acf		20 46 92	jsr $9246	                jsr w_swap
.8ad2		4c 30 92	jmp $9230	                jmp w_store             ; write here as ?DO jmp target and return
.8ad5		e8		inx		+               inx                     ; drop the ignored word for DO
.8ad6		e8		inx		                inx
.8ad7						z_loop:
.8ad7		60		rts		z_plus_loop:    rts
.8ad8						loop_runtime:
.8ad8		e6 20		inc $20		                inc loopidx0            ; increment the LSB of loopindex
.8ada		d0 0d		bne $8ae9	                bne _repeat             ; avoid expensive test most of the time
.8adc		a4 1f		ldy $1f		                ldy loopctrl
.8ade		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8ae1		1a		inc a		                ina
.8ae2		c9 80		cmp #$80	                cmp #$80
.8ae4		f0 06		beq $8aec	                beq _done
.8ae6		99 01 01	sta $0101,y	                sta loopindex+1,y
=17						loop_runtime_size = * - loop_runtime
.8ae9						_repeat:
.8ae9		a9 00		lda #$00	                lda #0
>8aeb		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8aec		a9 01		lda #$01	_done:          lda #1
.8aee		4c 7c 98	jmp $987c	                jmp zbranch_runtime
.8af1						plus_loop_runtime:
.8af1		18		clc		                clc
.8af2		b5 00		lda $00,x	                lda 0,x                 ; LSB of step
.8af4		65 20		adc $20		                adc loopidx0
.8af6		85 20		sta $20		                sta loopidx0
.8af8		e8		inx		                inx                     ; dump step from TOS before MSB test
.8af9		e8		inx		                inx                     ; since we might skip it
.8afa		b5 ff		lda $ff,x	                lda $FF,x               ; MSB of step since 1,x == -1,x+2
.8afc		d0 02		bne $8b00	                bne _chkv               ; if it's non-zero we have to check
.8afe		90 0b		bcc $8b0b	                bcc _repeat             ; but if 0 and no carry, we're good
.8b00		b8		clv		_chkv:          clv
.8b01		a4 1f		ldy $1f		                ldy loopctrl            ; get LCB offset
.8b03		79 01 01	adc $0101,y	                adc loopindex+1,y       ; MSB of index
.8b06		99 01 01	sta $0101,y	                sta loopindex+1,y       ; put MSB of index back on stack
.8b09		70 03		bvs $8b0e	                bvs _done               ; skip over JMP instruction
=26						plus_loop_runtime_size = * - plus_loop_runtime
.8b0b						_repeat:
.8b0b		a9 00		lda #$00	                lda #0
>8b0d		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8b0e		a9 01		lda #$01	_done:          lda #1
.8b10		4c 7c 98	jmp $987c	                jmp zbranch_runtime
.8b13						xt_lshift:
.8b13		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8b16						w_lshift:
.8b16		b5 00		lda $00,x	                lda 0,x
.8b18		29 0f		and #$0f	                and #%00001111
.8b1a		f0 08		beq $8b24	                beq _done
.8b1c		a8		tay		                tay
.8b1d						_loop:
.8b1d		16 02		asl $02,x	                asl 2,x
.8b1f		36 03		rol $03,x	                rol 3,x
.8b21		88		dey		                dey
.8b22		d0 f9		bne $8b1d	                bne _loop
.8b24						_done:
.8b24		e8		inx		                inx
.8b25		e8		inx		                inx
.8b26		60		rts		z_lshift:       rts
.8b27						xt_m_star:
.8b27		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8b2a						w_m_star:
.8b2a		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8b2c		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.8b2e		48		pha		                pha
.8b2f		20 d5 80	jsr $80d5	                jsr w_abs
.8b32		20 46 92	jsr $9246	                jsr w_swap
.8b35		20 d5 80	jsr $80d5	                jsr w_abs
.8b38		20 a3 95	jsr $95a3	                jsr w_um_star          ; ( d )
.8b3b		68		pla		                pla
.8b3c		10 03		bpl $8b41	                bpl _done
.8b3e		20 0a 9f	jsr $9f0a	                jsr w_dnegate
.8b41						_done:
.8b41		60		rts		z_m_star:       rts
.8b42						xt_marker:
.8b42						w_marker:
.8b42		20 4b d7	jsr $d74b	                jsr current_to_dp
.8b45		a5 02		lda $02		                lda dp
.8b47		48		pha		                pha
.8b48		a5 03		lda $03		                lda dp+1
.8b4a		48		pha		                pha
.8b4b		a5 00		lda $00		                lda cp
.8b4d		48		pha		                pha
.8b4e		a5 01		lda $01		                lda cp+1
.8b50		48		pha		                pha
.8b51		a9 28		lda #$28	                lda #4 + marker_end_offset - marker_start_offset
.8b53		85 1e		sta $1e		                sta tmpdsp              ; PFA size in bytes
.8b55		a9 73		lda #$73	                lda #<marker_runtime
.8b57		a0 8b		ldy #$8b	                ldy #>marker_runtime
.8b59		20 25 84	jsr $8425	                jsr create_common
.8b5c		7a		ply		                ply                     ; MSB
.8b5d		68		pla		                pla                     ; LSB
.8b5e		20 e0 97	jsr $97e0	                jsr cmpl_word
.8b61		7a		ply		                ply                     ; MSB
.8b62		68		pla		                pla                     ; LSB
.8b63		20 e0 97	jsr $97e0	                jsr cmpl_word
.8b66		a0 08		ldy #$08	                ldy #marker_start_offset
.8b68						-
.8b68		b1 08		lda ($08),y	                lda (up),y
.8b6a		20 e4 97	jsr $97e4	                jsr cmpl_a
.8b6d		c8		iny		                iny
.8b6e		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8b70		d0 f6		bne $8b68	                bne -
.8b72		60		rts		z_marker:       rts
.8b73						marker_runtime:
.8b73		68		pla		                pla
.8b74		85 25		sta $25		                sta tmp1        ; LSB of address
.8b76		68		pla		                pla
.8b77		85 26		sta $26		                sta tmp1+1      ; MSB of address
.8b79		a0 01		ldy #$01	                ldy #1          ; start at 1 due to RTS mechanics
.8b7b		b1 25		lda ($25),y	                lda (tmp1),y
.8b7d		85 00		sta $00		                sta cp
.8b7f		c8		iny		                iny
.8b80		b1 25		lda ($25),y	                lda (tmp1),y
.8b82		85 01		sta $01		                sta cp+1
.8b84		c8		iny		                iny
.8b85		b1 25		lda ($25),y	                lda (tmp1),y
.8b87		85 02		sta $02		                sta dp
.8b89		c8		iny		                iny
.8b8a		b1 25		lda ($25),y	                lda (tmp1),y
.8b8c		85 03		sta $03		                sta dp+1
.8b8e		38		sec		                sec
.8b8f		a5 25		lda $25		                lda tmp1
.8b91		e9 03		sbc #$03	                sbc #marker_start_offset - 5
.8b93		85 25		sta $25		                sta tmp1
.8b95		b0 02		bcs $8b99	                bcs +
.8b97		c6 26		dec $26		                dec tmp1+1
.8b99						+
.8b99		a0 08		ldy #$08	                ldy #marker_start_offset
.8b9b						-
.8b9b		b1 25		lda ($25),y	                lda (tmp1),y
.8b9d		91 08		sta ($08),y	                sta (up),y
.8b9f		c8		iny		                iny
.8ba0		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8ba2		d0 f7		bne $8b9b	                bne -
.8ba4		20 5e d7	jsr $d75e	                jsr dp_to_current       ; Move the CURRENT DP back.
.8ba7		60		rts		                rts
.8ba8						xt_max:
.8ba8		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8bab						w_max:
.8bab		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bad		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.8baf		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bb1		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bb3		50 02		bvc $8bb7	                bvc _no_overflow
.8bb5		49 80		eor #$80	                eor #$80        ; complement negative flag
.8bb7						_no_overflow:
.8bb7		30 08		bmi $8bc1	                bmi _keep_nos
.8bb9		b5 00		lda $00,x	                lda 0,x
.8bbb		95 02		sta $02,x	                sta 2,x
.8bbd		b5 01		lda $01,x	                lda 1,x
.8bbf		95 03		sta $03,x	                sta 3,x
.8bc1						_keep_nos:
.8bc1		e8		inx		                inx
.8bc2		e8		inx		                inx
.8bc3		60		rts		z_max:          rts
.8bc4						xt_min:
.8bc4		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8bc7						w_min:
.8bc7		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bc9		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.8bcb		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bcd		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bcf		50 02		bvc $8bd3	                bvc _no_overflow
.8bd1		49 80		eor #$80	                eor #$80
.8bd3						_no_overflow:
.8bd3		10 08		bpl $8bdd	                bpl _keep_nos
.8bd5		b5 00		lda $00,x	                lda 0,x
.8bd7		95 02		sta $02,x	                sta 2,x
.8bd9		b5 01		lda $01,x	                lda 1,x
.8bdb		95 03		sta $03,x	                sta 3,x
.8bdd						_keep_nos:
.8bdd		e8		inx		                inx
.8bde		e8		inx		                inx
.8bdf		60		rts		z_min:          rts
.8be0						xt_minus:
.8be0		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8be3						w_minus:
.8be3		38		sec		                sec
.8be4		b5 02		lda $02,x	                lda 2,x         ; LSB
.8be6		f5 00		sbc $00,x	                sbc 0,x
.8be8		95 02		sta $02,x	                sta 2,x
.8bea		b5 03		lda $03,x	                lda 3,x         ; MSB
.8bec		f5 01		sbc $01,x	                sbc 1,x
.8bee		95 03		sta $03,x	                sta 3,x
.8bf0		e8		inx		                inx
.8bf1		e8		inx		                inx
.8bf2		60		rts		z_minus:        rts
.8bf3						xt_mod:
.8bf3		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8bf6						w_mod:
.8bf6		20 7c 91	jsr $917c	                jsr w_slash_mod
.8bf9		e8		inx		                inx             ; DROP
.8bfa		e8		inx		                inx
.8bfb						z_mod:
.8bfb		60		rts		                rts
.8bfc						xt_move:
.8bfc		20 fc d7	jsr $d7fc	                jsr underflow_3
.8bff						w_move:
.8bff		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.8c01		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.8c03		f0 05		beq $8c0a	                beq _lsb                ; wasn't helpful, move to LSB
.8c05		b0 0e		bcs $8c15	                bcs _to_move_up         ; we want CMOVE>
.8c07		4c 72 a0	jmp $a072	                jmp w_cmove            ; JSR/RTS
.8c0a						_lsb:
.8c0a		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.8c0c		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.8c0e		f0 08		beq $8c18	                beq _equal              ; LSB is equal as well
.8c10		b0 03		bcs $8c15	                bcs _to_move_up         ; we want CMOVE>
.8c12		4c 72 a0	jmp $a072	                jmp w_cmove            ; JSR/RTS
.8c15						_to_move_up:
.8c15		4c ad a0	jmp $a0ad	                jmp w_cmove_up         ; JSR/RTS
.8c18						_equal:
.8c18		8a		txa		                txa
.8c19		18		clc		                clc
.8c1a		69 06		adc #$06	                adc #6
.8c1c		aa		tax		                tax
.8c1d		60		rts		z_move:         rts
.8c1e						xt_negate:
.8c1e		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8c21						w_negate:
.8c21		a9 00		lda #$00	        	lda #0
.8c23		38		sec		                sec
.8c24		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8c26		95 00		sta $00,x	                sta 0,x
.8c28		a9 00		lda #$00	                lda #0
.8c2a		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.8c2c		95 01		sta $01,x	                sta 1,x
.8c2e		60		rts		z_negate:       rts
.8c2f						xt_nip:
.8c2f		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8c32						w_nip:
.8c32		b5 00		lda $00,x	                lda 0,x         ; LSB
.8c34		95 02		sta $02,x	                sta 2,x
.8c36		b5 01		lda $01,x	                lda 1,x         ; MSB
.8c38		95 03		sta $03,x	                sta 3,x
.8c3a		e8		inx		                inx
.8c3b		e8		inx		                inx
.8c3c		60		rts		z_nip:          rts
.8c3d						xt_not_equals:
.8c3d		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8c40						w_not_equals:
.8c40		a0 00		ldy #$00	                ldy #0                  ; default is true
.8c42		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8c44		d5 02		cmp $02,x	                cmp 2,x
.8c46		d0 0a		bne $8c52	                bne _not_equal
.8c48		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8c4a		d5 03		cmp $03,x	                cmp 3,x
.8c4c		d0 04		bne $8c52	                bne _not_equal
.8c4e		a9 ff		lda #$ff	                lda #$FF
.8c50		80 01		bra $8c53	                bra _done
.8c52						_not_equal:
.8c52		88		dey		                dey                     ; drop thru to done
.8c53						_done:
.8c53		98		tya		                tya
.8c54		e8		inx		                inx
.8c55		e8		inx		                inx
.8c56		95 00		sta $00,x	                sta 0,x
.8c58		95 01		sta $01,x	                sta 1,x
.8c5a		60		rts		z_not_equals:   rts
.8c5b						xt_number_sign:
.8c5b		20 f7 d7	jsr $d7f7	                jsr underflow_2         ; double number
.8c5e						w_number_sign:
.8c5e		ca		dex		                dex                     ; inline w_zero
.8c5f		ca		dex		                dex
.8c60		74 00		stz $00,x	                stz 0,x
.8c62		74 01		stz $01,x	                stz 1,x
.8c64		e6 19		inc $19		                inc base+1
.8c66		b5 02		lda $02,x	                lda 2,x                 ; if msw is 0 we can skip the first pass
.8c68		15 03		ora $03,x	                ora 3,x
.8c6a		f0 0b		beq $8c77	                beq _skip               ; enter with ( v 0 0 -rot -- 0 v 0 )
.8c6c						_loop:
.8c6c		ca		dex		                dex                     ; inline `base @`
.8c6d		ca		dex		                dex
.8c6e		a5 18		lda $18		                lda base                ; base <= 36
.8c70		95 00		sta $00,x	                sta 0,x
.8c72		74 01		stz $01,x	                stz 1,x
.8c74		20 61 95	jsr $9561	                jsr w_um_slash_mod      ; ( v u 0 base -- v ru qu )
.8c77		20 20 9d	jsr $9d20	_skip:          jsr w_not_rot           ; ( qu v ru )
.8c7a		46 19		lsr $19		                lsr base+1              ; 1 => 0 + C=1 => 0 + C=0
.8c7c		b0 ee		bcs $8c6c	                bcs _loop               ; run two passes
.8c7e		b5 00		lda $00,x	                lda 0,x
.8c80		a8		tay		                tay
.8c81		b9 4b d3	lda $d34b,y	                lda alpha36,y           ; upper case 0-9A-Z
.8c84		95 00		sta $00,x	                sta 0,x
.8c86		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.8c88		20 24 89	jsr $8924	                jsr w_hold
.8c8b						z_number_sign:
.8c8b		60		rts		                rts
.8c8c						xt_number_sign_greater:
.8c8c		20 f7 d7	jsr $d7f7	                jsr underflow_2         ; double number
.8c8f						w_number_sign_greater:
.8c8f		a5 2b		lda $2b		                lda tohold
.8c91		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.8c93		95 02		sta $02,x	                sta 2,x
.8c95		a5 2c		lda $2c		                lda tohold+1
.8c97		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.8c99		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.8c9b		20 0e 8d	jsr $8d0e	                jsr w_pad      ; ( addr addr pad )
.8c9e		38		sec		                sec
.8c9f		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.8ca1		f5 02		sbc $02,x	                sbc 2,x
.8ca3		95 02		sta $02,x	                sta 2,x
.8ca5		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.8ca7		f5 03		sbc $03,x	                sbc 3,x
.8ca9		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.8cab		e8		inx		                inx
.8cac		e8		inx		                inx
.8cad						z_number_sign_greater:
.8cad		60		rts		                rts
.8cae						xt_number_sign_s:
.8cae		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8cb1						w_number_sign_s:
.8cb1						_loop:
.8cb1		20 5e 8c	jsr $8c5e	                jsr w_number_sign
.8cb4		b5 00		lda $00,x	                lda 0,x
.8cb6		15 01		ora $01,x	                ora 1,x
.8cb8		15 02		ora $02,x	                ora 2,x
.8cba		15 03		ora $03,x	                ora 3,x
.8cbc		d0 f3		bne $8cb1	                bne _loop
.8cbe						z_number_sign_s:
.8cbe		60		rts		                rts
.8cbf						xt_of:
.8cbf						w_of:
.8cbf		a0 8d		ldy #$8d	                ldy #>w_over
.8cc1		a9 03		lda #$03	                lda #<w_over
.8cc3		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.8cc6		a0 87		ldy #$87	                ldy #>w_equal
.8cc8		a9 85		lda #$85	                lda #<w_equal
.8cca		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.8ccd		20 48 89	jsr $8948	                jsr w_if
.8cd0		a0 86		ldy #$86	                ldy #>w_drop
.8cd2		a9 8b		lda #$8b	                lda #<w_drop
.8cd4		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.8cd7		60		rts		z_of:           rts
.8cd8						xt_one_minus:
.8cd8		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8cdb						w_one_minus:
.8cdb		b5 00		lda $00,x	                lda 0,x
.8cdd		d0 02		bne $8ce1	                bne +
.8cdf		d6 01		dec $01,x	                dec 1,x
.8ce1						+
.8ce1		d6 00		dec $00,x	                dec 0,x
.8ce3		60		rts		z_one_minus:    rts
.8ce4						xt_char_plus:
.8ce4						xt_one_plus:
.8ce4		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8ce7						w_char_plus:
.8ce7						w_one_plus:
.8ce7		f6 00		inc $00,x	                inc 0,x
.8ce9		d0 02		bne $8ced	                bne _done
.8ceb		f6 01		inc $01,x	                inc 1,x
.8ced						_done:
.8ced						z_char_plus:
.8ced		60		rts		z_one_plus:     rts
.8cee						xt_or:
.8cee		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8cf1						w_or:
.8cf1		b5 00		lda $00,x	                lda 0,x
.8cf3		15 02		ora $02,x	                ora 2,x
.8cf5		95 02		sta $02,x	                sta 2,x
.8cf7		b5 01		lda $01,x	                lda 1,x
.8cf9		15 03		ora $03,x	                ora 3,x
.8cfb		95 03		sta $03,x	                sta 3,x
.8cfd		e8		inx		                inx
.8cfe		e8		inx		                inx
.8cff		60		rts		z_or:           rts
.8d00						xt_over:
.8d00		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8d03						w_over:
.8d03		ca		dex		                dex
.8d04		ca		dex		                dex
.8d05		b5 04		lda $04,x	                lda 4,x         ; LSB
.8d07		95 00		sta $00,x	                sta 0,x
.8d09		b5 05		lda $05,x	                lda 5,x         ; MSB
.8d0b		95 01		sta $01,x	                sta 1,x
.8d0d		60		rts		z_over:         rts
.8d0e						xt_pad:
.8d0e						w_pad:
.8d0e		ca		dex		                dex
.8d0f		ca		dex		                dex
.8d10		a5 00		lda $00		                lda cp
.8d12		18		clc		                clc
.8d13		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.8d15		95 00		sta $00,x	                sta 0,x
.8d17		a5 01		lda $01		                lda cp+1
.8d19		69 00		adc #$00	                adc #0          ; only need carry
.8d1b		95 01		sta $01,x	                sta 1,x
.8d1d		60		rts		z_pad:          rts
.8d1e						xt_page:
.8d1e						w_page:
.8d1e		a9 1b		lda #$1b	                lda #AscESC
.8d20		20 bb 86	jsr $86bb	                jsr emit_a
.8d23		a9 5b		lda #$5b	                lda #'['
.8d25		20 bb 86	jsr $86bb	                jsr emit_a
.8d28		a9 32		lda #$32	                lda #'2'
.8d2a		20 bb 86	jsr $86bb	                jsr emit_a
.8d2d		a9 4a		lda #$4a	                lda #'J'
.8d2f		20 bb 86	jsr $86bb	                jsr emit_a
.8d32		20 99 9e	jsr $9e99	                jsr w_zero
.8d35		20 99 9e	jsr $9e99	                jsr w_zero
.8d38		20 d0 82	jsr $82d0	                jsr w_at_xy
.8d3b		60		rts		z_page:         rts
.8d3c						xt_paren:
.8d3c						w_paren:
.8d3c		ca		dex		                dex
.8d3d		ca		dex		                dex
.8d3e		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8d40		95 00		sta $00,x	                sta 0,x
.8d42		74 01		stz $01,x	                stz 1,x
.8d44		20 aa 8d	jsr $8daa	                jsr w_parse
.8d47		e8		inx		                inx
.8d48		e8		inx		                inx
.8d49		e8		inx		                inx
.8d4a		e8		inx		                inx
.8d4b		60		rts		z_paren:        rts
.8d4c						xt_parse_name:
.8d4c						w_parse_name:
.8d4c		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.8d4e		38		sec		                sec
.8d4f		e5 10		sbc $10		                sbc toin
.8d51		85 25		sta $25		                sta tmp1
.8d53		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.8d55		e5 11		sbc $11		                sbc toin+1
.8d57		85 26		sta $26		                sta tmp1+1
.8d59		a5 25		lda $25		                lda tmp1
.8d5b		05 26		ora $26		                ora tmp1+1
.8d5d		f0 28		beq $8d87	                beq _empty_line
.8d5f		a5 0c		lda $0c		                lda cib
.8d61		18		clc		                clc
.8d62		65 10		adc $10		                adc toin
.8d64		85 27		sta $27		                sta tmp2                ; LSB of first character
.8d66		a5 0d		lda $0d		                lda cib+1
.8d68		65 11		adc $11		                adc toin+1
.8d6a		85 28		sta $28		                sta tmp2+1              ; MSB
.8d6c						_skip_loop:
.8d6c		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.8d6e		20 e5 d7	jsr $d7e5	                jsr is_whitespace
.8d71		90 1f		bcc $8d92	                bcc _char_found
.8d73		e6 27		inc $27		                inc tmp2
.8d75		d0 02		bne $8d79	                bne +
.8d77		e6 28		inc $28		                inc tmp2+1
.8d79						+
.8d79		a5 25		lda $25		                lda tmp1
.8d7b		d0 02		bne $8d7f	                bne +
.8d7d		c6 26		dec $26		                dec tmp1+1
.8d7f		c6 25		dec $25		+               dec tmp1
.8d81		a5 25		lda $25		                lda tmp1
.8d83		05 26		ora $26		                ora tmp1+1
.8d85		d0 e5		bne $8d6c	                bne _skip_loop          ; fall through if empty line
.8d87						_empty_line:
.8d87		ca		dex		                dex
.8d88		ca		dex		                dex
.8d89		ca		dex		                dex
.8d8a		ca		dex		                dex
.8d8b		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.8d8d		74 01		stz $01,x	                stz 1,x
.8d8f		4c 3c 8e	jmp $8e3c	                jmp z_parse_name        ; skip over PARSE
.8d92						_char_found:
.8d92		a5 27		lda $27		                lda tmp2
.8d94		38		sec		                sec
.8d95		e5 0c		sbc $0c		                sbc cib
.8d97		85 10		sta $10		                sta toin
.8d99		a5 28		lda $28		                lda tmp2+1
.8d9b		e5 0d		sbc $0d		                sbc cib+1
.8d9d		85 11		sta $11		                sta toin+1
.8d9f		ca		dex		                dex
.8da0		ca		dex		                dex
.8da1		a9 20		lda #$20	                lda #AscSP
.8da3		95 00		sta $00,x	                sta 0,x
.8da5		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.8da7						xt_parse:
.8da7		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8daa						w_parse:
.8daa		a5 0e		lda $0e		                lda ciblen
.8dac		05 0f		ora $0f		                ora ciblen+1
.8dae		f0 0c		beq $8dbc	                beq _abort_parse
.8db0		a5 11		lda $11		                lda toin+1              ; MSB
.8db2		c5 0f		cmp $0f		                cmp ciblen+1
.8db4		90 0e		bcc $8dc4	                bcc _go_parse           ; unsigned comparison
.8db6		a5 10		lda $10		                lda toin                ; LSB
.8db8		c5 0e		cmp $0e		                cmp ciblen
.8dba		90 08		bcc $8dc4	                bcc _go_parse
.8dbc						_abort_parse:
.8dbc		ca		dex		                dex
.8dbd		ca		dex		                dex
.8dbe		74 00		stz $00,x	                stz 0,x
.8dc0		74 01		stz $01,x	                stz 1,x
.8dc2		80 78		bra $8e3c	                bra _done
.8dc4						_go_parse:
.8dc4		b5 00		lda $00,x	                lda 0,x
.8dc6		85 23		sta $23		                sta tmptos
.8dc8		ca		dex		                dex
.8dc9		ca		dex		                dex
.8dca		a5 0c		lda $0c		                lda cib
.8dcc		18		clc		                clc
.8dcd		65 10		adc $10		                adc toin        ; LSB
.8dcf		85 25		sta $25		                sta tmp1
.8dd1		85 27		sta $27		                sta tmp2
.8dd3		95 02		sta $02,x	                sta 2,x
.8dd5		a5 0d		lda $0d		                lda cib+1
.8dd7		65 11		adc $11		                adc toin+1      ; MSB
.8dd9		85 26		sta $26		                sta tmp1+1
.8ddb		85 28		sta $28		                sta tmp2+1
.8ddd		95 03		sta $03,x	                sta 3,x
.8ddf		a5 0c		lda $0c		                lda cib
.8de1		18		clc		                clc
.8de2		65 0e		adc $0e		                adc ciblen
.8de4		85 29		sta $29		                sta tmp3
.8de6		a5 0d		lda $0d		                lda cib+1
.8de8		65 0f		adc $0f		                adc ciblen+1
.8dea		85 2a		sta $2a		                sta tmp3+1
.8dec		64 24		stz $24		                stz tmptos+1
.8dee						_loop:
.8dee		a5 27		lda $27		                lda tmp2
.8df0		c5 29		cmp $29		                cmp tmp3
.8df2		d0 06		bne $8dfa	                bne _not_empty
.8df4		a5 28		lda $28		                lda tmp2+1
.8df6		c5 2a		cmp $2a		                cmp tmp3+1
.8df8		f0 1d		beq $8e17	                beq _eol
.8dfa						_not_empty:
.8dfa		b2 27		lda ($27)	                lda (tmp2)
.8dfc		a4 23		ldy $23		                ldy tmptos
.8dfe		c0 20		cpy #$20	                cpy #AscSP
.8e00		d0 07		bne $8e09	                bne _not_whitespace
.8e02		20 e5 d7	jsr $d7e5	                jsr is_whitespace
.8e05		90 02		bcc $8e09	                bcc _not_whitespace
.8e07		80 0c		bra $8e15	                bra _found_delimiter
.8e09						_not_whitespace:
.8e09		c5 23		cmp $23		                cmp tmptos
.8e0b		f0 08		beq $8e15	                beq _found_delimiter
.8e0d		e6 27		inc $27		                inc tmp2
.8e0f		d0 dd		bne $8dee	                bne _loop
.8e11		e6 28		inc $28		                inc tmp2+1
.8e13		80 d9		bra $8dee	                bra _loop
.8e15						_found_delimiter:
.8e15		e6 24		inc $24		                inc tmptos+1
.8e17						_eol:
.8e17		a5 27		lda $27		                lda tmp2
.8e19		38		sec		                sec
.8e1a		e5 25		sbc $25		                sbc tmp1
.8e1c		95 00		sta $00,x	                sta 0,x
.8e1e		a5 28		lda $28		                lda tmp2+1
.8e20		e5 26		sbc $26		                sbc tmp1+1
.8e22		95 01		sta $01,x	                sta 1,x
.8e24		a5 27		lda $27		                lda tmp2
.8e26		38		sec		                sec
.8e27		e5 0c		sbc $0c		                sbc cib
.8e29		85 10		sta $10		                sta toin
.8e2b		a5 28		lda $28		                lda tmp2+1
.8e2d		e5 0d		sbc $0d		                sbc cib+1
.8e2f		85 11		sta $11		                sta toin+1
.8e31		a5 10		lda $10		                lda toin
.8e33		18		clc		                clc
.8e34		65 24		adc $24		                adc tmptos+1
.8e36		85 10		sta $10		                sta toin
.8e38		90 02		bcc $8e3c	                bcc +
.8e3a		e6 11		inc $11		                inc toin+1
.8e3c						+
.8e3c						_done:
.8e3c						z_parse_name:
.8e3c		60		rts		z_parse:        rts
.8e3d						xt_pick:
.8e3d						w_pick:
.8e3d		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.8e3f		8a		txa		                txa
.8e40		75 00		adc $00,x	                adc 0,x
.8e42		a8		tay		                tay
.8e43		b9 02 00	lda $0002,y	                lda 0002,y
.8e46		95 00		sta $00,x	                sta 0,x
.8e48		b9 03 00	lda $0003,y	                lda 0003,y
.8e4b		95 01		sta $01,x	                sta 1,x
.8e4d		60		rts		z_pick:         rts
.8e4e						xt_plus:
.8e4e		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8e51						w_plus:
.8e51		18		clc		                clc
.8e52		b5 00		lda $00,x	                lda 0,x         ; LSB
.8e54		75 02		adc $02,x	                adc 2,x
.8e56		95 02		sta $02,x	                sta 2,x
.8e58		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.8e5a		75 03		adc $03,x	                adc 3,x
.8e5c		95 03		sta $03,x	                sta 3,x
.8e5e		e8		inx		                inx
.8e5f		e8		inx		                inx
.8e60		60		rts		z_plus:         rts
.8e61						xt_plus_store:
.8e61		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8e64						w_plus_store:
.8e64		18		clc		                clc
.8e65		a1 00		lda ($00,x)	                lda (0,x)       ; fetch LSB at addr
.8e67		75 02		adc $02,x	                adc 2,x
.8e69		81 00		sta ($00,x)	                sta (0,x)
.8e6b		f6 00		inc $00,x	                inc 0,x         ; addr++
.8e6d		d0 02		bne $8e71	                bne +
.8e6f		f6 01		inc $01,x	                inc 1,x
.8e71						+
.8e71		a1 00		lda ($00,x)	                lda (0,x)       ; fetch MSB
.8e73		75 03		adc $03,x	                adc 3,x
.8e75		81 00		sta ($00,x)	                sta (0,x)
.8e77		e8		inx		                inx
.8e78		e8		inx		                inx
.8e79		e8		inx		                inx
.8e7a		e8		inx		                inx
.8e7b		60		rts		z_plus_store:   rts
.8e7c						xt_postpone:
.8e7c						w_postpone:
.8e7c		20 4c 8d	jsr $8d4c	                jsr w_parse_name               ; ( -- addr n )
.8e7f		b5 00		lda $00,x	                lda 0,x
.8e81		15 01		ora $01,x	                ora 1,x
.8e83		d0 05		bne $8e8a	                bne +
.8e85		a9 05		lda #$05	                lda #err_noname
.8e87		4c 08 d8	jmp $d808	                jmp error
.8e8a						+
.8e8a		20 85 9b	jsr $9b85	                jsr w_find_name                ; ( -- nt | 0 )
.8e8d		d0 05		bne $8e94	                bne +
.8e8f		a9 05		lda #$05	                lda #err_noname
.8e91		4c 08 d8	jmp $d808	                jmp error
.8e94						+
.8e94		20 91 86	jsr $8691	                jsr w_dup
.8e97		20 e7 8c	jsr $8ce7	                jsr w_one_plus
.8e9a		a1 00		lda ($00,x)	                lda (0,x)
.8e9c		e8		inx		                inx
.8e9d		e8		inx		                inx
.8e9e		29 02		and #$02	                and #IM         ; mask all but Intermediate flag
.8ea0		f0 05		beq $8ea7	                beq _not_immediate
.8ea2		20 d5 96	jsr $96d5	                jsr compile_nt_comma
.8ea5		80 0a		bra $8eb1	                bra _done
.8ea7						_not_immediate:
.8ea7		20 fb 89	jsr $89fb	                jsr w_literal                   ; ( nt -- )
.8eaa		a0 96		ldy #$96	                ldy #>compile_nt_comma
.8eac		a9 d5		lda #$d5	                lda #<compile_nt_comma
.8eae		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.8eb1						_done:
.8eb1		60		rts		z_postpone:     rts
.8eb2						xt_question_dup:
.8eb2		20 f2 d7	jsr $d7f2	                jsr underflow_1
.8eb5						w_question_dup:
.8eb5		b5 00		lda $00,x	                lda 0,x
.8eb7		15 01		ora $01,x	                ora 1,x
.8eb9		f0 0a		beq $8ec5	                beq _done
.8ebb		ca		dex		                dex
.8ebc		ca		dex		                dex
.8ebd		b5 02		lda $02,x	                lda 2,x
.8ebf		95 00		sta $00,x	                sta 0,x
.8ec1		b5 03		lda $03,x	                lda 3,x
.8ec3		95 01		sta $01,x	                sta 1,x
.8ec5						_done:
.8ec5		60		rts		z_question_dup: rts
.8ec6						xt_r_fetch:
.8ec6						w_r_fetch:
.8ec6		68		pla		                pla                     ; LSB
.8ec7		7a		ply		                ply                     ; MSB
.8ec8		1a		inc a		                inc a
.8ec9		85 25		sta $25		                sta tmp1                ; LSB
.8ecb		d0 01		bne $8ece	                bne +
.8ecd		c8		iny		                iny
.8ece						+
.8ece		84 26		sty $26		                sty tmp1+1              ; MSB
.8ed0		ca		dex		                dex
.8ed1		ca		dex		                dex
.8ed2		7a		ply		                ply             ; LSB
.8ed3		94 00		sty $00,x	                sty 0,x
.8ed5		68		pla		                pla             ; MSB
.8ed6		95 01		sta $01,x	                sta 1,x
.8ed8		48		pha		                pha
.8ed9		5a		phy		                phy
.8eda		6c 25 00	jmp ($0025)	z_r_fetch:      jmp (tmp1)
.8edd						xt_r_from:
.8edd						w_r_from:
.8edd		68		pla		                pla                     ; LSB
.8ede		7a		ply		                ply                     ; MSB
.8edf		1a		inc a		                inc a
.8ee0		85 25		sta $25		                sta tmp1                ; LSB
.8ee2		d0 01		bne $8ee5	                bne +
.8ee4		c8		iny		                iny
.8ee5						+
.8ee5		84 26		sty $26		                sty tmp1+1              ; MSB
.8ee7		ca		dex		                dex
.8ee8		ca		dex		                dex
.8ee9		68		pla		                pla             ; LSB
.8eea		95 00		sta $00,x	                sta 0,x
.8eec		68		pla		                pla             ; MSB
.8eed		95 01		sta $01,x	                sta 1,x
.8eef		6c 25 00	jmp ($0025)	z_r_from:       jmp (tmp1)
.8ef2						xt_recurse:
.8ef2						w_recurse:
.8ef2		a0 00		ldy #$00	                ldy #0
.8ef4		a9 20		lda #$20	                lda #OpJSR
.8ef6		91 00		sta ($00),y	                sta (cp),y
.8ef8		c8		iny		                iny
.8ef9		24 1c		bit $1c		                bit status
.8efb		70 0c		bvs $8f09	                bvs _nt_in_workword
.8efd		a5 06		lda $06		                lda workword
.8eff		91 00		sta ($00),y	                sta (cp),y
.8f01		c8		iny		                iny
.8f02		a5 07		lda $07		                lda workword+1
.8f04		91 00		sta ($00),y	                sta (cp),y
.8f06		c8		iny		                iny
.8f07		80 1b		bra $8f24	                bra _update_cp
.8f09						_nt_in_workword:
.8f09		a5 06		lda $06		                lda workword            ; LSB
.8f0b		18		clc		                clc
.8f0c		69 04		adc #$04	                adc #4
.8f0e		85 25		sta $25		                sta tmp1
.8f10		a5 07		lda $07		                lda workword+1          ; MSB
.8f12		69 00		adc #$00	                adc #0
.8f14		85 26		sta $26		                sta tmp1+1
.8f16		b2 25		lda ($25)	                lda (tmp1)
.8f18		91 00		sta ($00),y	                sta (cp),y
.8f1a		5a		phy		                phy
.8f1b		a0 01		ldy #$01	                ldy #1
.8f1d		b1 25		lda ($25),y	                lda (tmp1),y
.8f1f		7a		ply		                ply
.8f20		c8		iny		                iny
.8f21		91 00		sta ($00),y	                sta (cp),y
.8f23		c8		iny		                iny
.8f24						_update_cp:
.8f24		98		tya		                tya
.8f25		18		clc		                clc
.8f26		65 00		adc $00		                adc cp
.8f28		85 00		sta $00		                sta cp
.8f2a		90 02		bcc $8f2e	                bcc _done
.8f2c		e6 01		inc $01		                inc cp+1
.8f2e						_done:
.8f2e		60		rts		z_recurse:      rts
.8f2f						xt_refill:
.8f2f						w_refill:
.8f2f		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.8f31		d0 2d		bne $8f60	                bne _src_not_kbd
.8f33		ca		dex		                dex
.8f34		ca		dex		                dex
.8f35		ca		dex		                dex
.8f36		ca		dex		                dex
.8f37		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.8f39		95 02		sta $02,x	                sta 2,x
.8f3b		a5 0d		lda $0d		                lda cib+1
.8f3d		95 03		sta $03,x	                sta 3,x
.8f3f		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.8f41		64 0f		stz $0f		                stz ciblen+1
.8f43		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.8f45		95 00		sta $00,x	                sta 0,x
.8f47		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.8f49		20 ea 80	jsr $80ea	                jsr w_accept           ; ( addr n1 -- n2)
.8f4c		b5 00		lda $00,x	                lda 0,x
.8f4e		85 0e		sta $0e		                sta ciblen
.8f50		b5 01		lda $01,x	                lda 1,x
.8f52		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.8f54		64 10		stz $10		                stz toin
.8f56		64 11		stz $11		                stz toin+1
.8f58		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.8f5a		95 00		sta $00,x	                sta 0,x
.8f5c		95 01		sta $01,x	                sta 1,x
.8f5e		80 10		bra $8f70	                bra _done
.8f60						_src_not_kbd:
.8f60		1a		inc a		                ina
.8f61		d0 08		bne $8f6b	                bne _src_not_string
.8f63		ca		dex		                dex
.8f64		ca		dex		                dex
.8f65		74 00		stz $00,x	                stz 0,x
.8f67		74 01		stz $01,x	                stz 1,x
.8f69		80 05		bra $8f70	                bra z_refill
.8f6b						_src_not_string:
.8f6b		a9 01		lda #$01	                lda #err_badsource
.8f6d		4c 08 d8	jmp $d808	                jmp error
.8f70						_done:
.8f70		60		rts		z_refill:       rts
.8f71						xt_repeat:
.8f71		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8f74						w_repeat:
.8f74		20 4d 82	jsr $824d	                jsr w_again
.8f77		4c aa 86	jmp $86aa	                jmp w_then
.8f7a						z_repeat:
.8f7a						xt_right_bracket:
.8f7a						w_right_bracket:
.8f7a		a9 ff		lda #$ff	                lda #$FF
.8f7c		85 1a		sta $1a		                sta state
.8f7e		85 1b		sta $1b		                sta state+1
.8f80						z_right_bracket:
.8f80		60		rts		                rts
.8f81						xt_rot:
.8f81		20 fc d7	jsr $d7fc	                jsr underflow_3
.8f84						w_rot:
.8f84		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.8f86		b5 03		lda $03,x	                lda 3,x
.8f88		95 05		sta $05,x	                sta 5,x
.8f8a		b5 01		lda $01,x	                lda 1,x
.8f8c		95 03		sta $03,x	                sta 3,x
.8f8e		94 01		sty $01,x	                sty 1,x
.8f90		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.8f92		b5 02		lda $02,x	                lda 2,x
.8f94		95 04		sta $04,x	                sta 4,x
.8f96		b5 00		lda $00,x	                lda 0,x
.8f98		95 02		sta $02,x	                sta 2,x
.8f9a		94 00		sty $00,x	                sty 0,x
.8f9c		60		rts		z_rot:          rts
.8f9d						xt_rshift:
.8f9d		20 f7 d7	jsr $d7f7	                jsr underflow_2
.8fa0						w_rshift:
.8fa0		b5 00		lda $00,x	                lda 0,x
.8fa2		29 0f		and #$0f	                and #%00001111
.8fa4		f0 08		beq $8fae	                beq _done               ; if 0 shifts, quit
.8fa6		a8		tay		                tay
.8fa7						_loop:
.8fa7		56 03		lsr $03,x	                lsr 3,x
.8fa9		76 02		ror $02,x	                ror 2,x
.8fab		88		dey		                dey
.8fac		d0 f9		bne $8fa7	                bne _loop
.8fae						_done:
.8fae		e8		inx		                inx
.8faf		e8		inx		                inx
.8fb0		60		rts		z_rshift:       rts
.8fb1						xt_s_backslash_quote:
.8fb1						w_s_backslash_quote:
.8fb1		a9 ff		lda #$ff	                lda #$FF
.8fb3		85 27		sta $27		                sta tmp2
.8fb5		64 28		stz $28		                stz tmp2+1
.8fb7		20 ce 8f	jsr $8fce	                jsr s_quote_start
.8fba						z_s_backslash_quote:
.8fba		60		rts		                rts
.8fbb						convert_hex_value:
.8fbb		c9 41		cmp #$41	        cmp #'A'
.8fbd		90 07		bcc $8fc6	        bcc _digit
.8fbf		29 df		and #$df	        and #$DF                ; Make it uppercase.
.8fc1		38		sec		        sec
.8fc2		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.8fc4		80 03		bra $8fc9	        bra _done
.8fc6						_digit:
.8fc6		38		sec		        sec
.8fc7		e9 30		sbc #$30	        sbc #'0'
.8fc9						_done:
.8fc9		60		rts		        rts
.8fca						xt_s_quote:
.8fca						w_s_quote:
.8fca		64 27		stz $27		                stz tmp2
.8fcc		64 28		stz $28		                stz tmp2+1
.8fce						s_quote_start:
.8fce		a5 1a		lda $1a		                lda state               ; check whether we're interpeting (0) or compiling (-1)
.8fd0		05 1b		ora $1b		                ora state+1             ; paranoid
.8fd2		48		pha		                pha                     ; save zero / nonzero for post-processing
.8fd3		f0 0b		beq $8fe0	                beq _interpeting        ; just write string directly
.8fd5		18		clc		                clc
.8fd6		a5 00		lda $00		                lda cp
.8fd8		69 05		adc #$05	                adc #5                  ; reserve five bytes for the prologue (see below)
.8fda		85 00		sta $00		                sta cp
.8fdc		90 02		bcc $8fe0	                bcc +
.8fde		e6 01		inc $01		                inc cp+1
.8fe0						+
.8fe0						_interpeting:
.8fe0		20 0f 89	jsr $890f	                jsr w_here              ; ( addr )
.8fe3						_savechars_loop:
.8fe3		a5 11		lda $11		                lda toin+1              ; MSB
.8fe5		c5 0f		cmp $0f		                cmp ciblen+1
.8fe7		90 2a		bcc $9013	                bcc _input_fine         ; unsigned comparison
.8fe9		a5 10		lda $10		                lda toin                ; LSB
.8feb		c5 0e		cmp $0e		                cmp ciblen
.8fed		90 24		bcc $9013	                bcc _input_fine
.8fef		a5 27		lda $27		                lda tmp2
.8ff1		48		pha		                pha
.8ff2		a5 28		lda $28		                lda tmp2+1
.8ff4		48		pha		                pha
.8ff5		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.8ff7		48		pha		                pha
.8ff8		20 2f 8f	jsr $8f2f	                jsr w_refill           ; ( -- f )
.8ffb		68		pla		                pla
.8ffc		85 29		sta $29		                sta tmp3
.8ffe		68		pla		                pla
.8fff		85 28		sta $28		                sta tmp2+1
.9001		68		pla		                pla
.9002		85 27		sta $27		                sta tmp2
.9004		b5 00		lda $00,x	                lda 0,x
.9006		15 01		ora $01,x	                ora 1,x
.9008		d0 05		bne $900f	                bne _refill_ok
.900a		a9 06		lda #$06	                lda #err_refill
.900c		4c 08 d8	jmp $d808	                jmp error
.900f						_refill_ok:
.900f		e8		inx		                inx
.9010		e8		inx		                inx
.9011		80 d0		bra $8fe3	                bra _savechars_loop
.9013						_input_fine:
.9013		a5 0c		lda $0c		                lda cib
.9015		18		clc		                clc
.9016		65 10		adc $10		                adc toin        ; LSB
.9018		85 25		sta $25		                sta tmp1
.901a		a5 0d		lda $0d		                lda cib+1
.901c		65 11		adc $11		                adc toin+1      ; MSB
.901e		85 26		sta $26		                sta tmp1+1
.9020		b2 25		lda ($25)	                lda (tmp1)
.9022		24 27		bit $27		                bit tmp2
.9024		30 03		bmi $9029	                bmi _handle_escapes    ; Only checking bit 7
.9026		4c 91 90	jmp $9091	                jmp _regular_char
.9029						_handle_escapes:
.9029		24 28		bit $28		                bit tmp2+1
.902b		30 03		bmi $9030	                bmi _escaped
.902d		4c 87 90	jmp $9087	                jmp _not_escaped
.9030						_escaped:
.9030		70 21		bvs $9053	                bvs _check_esc_chars
.9032		a9 01		lda #$01	                lda #1
.9034		24 28		bit $28		                bit tmp2+1
.9036		d0 10		bne $9048	                bne _esc_x_second_digit
.9038		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.903a		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.903c		20 bb 8f	jsr $8fbb	                jsr convert_hex_value
.903f		0a		asl a		                asl
.9040		0a		asl a		                asl
.9041		0a		asl a		                asl
.9042		0a		asl a		                asl
.9043		85 29		sta $29		                sta tmp3    ; Save it for later.
.9045		4c 98 90	jmp $9098	                jmp _next_character
.9048						_esc_x_second_digit:
.9048		64 28		stz $28		                stz tmp2+1
.904a		b2 25		lda ($25)	                lda (tmp1)
.904c		20 bb 8f	jsr $8fbb	                jsr convert_hex_value
.904f		05 29		ora $29		                ora tmp3
.9051		80 42		bra $9095	                bra _save_character
.9053						_check_esc_chars:
.9053		64 28		stz $28		                stz tmp2+1
.9055		c9 61		cmp #$61	                cmp #'a'
.9057		30 1a		bmi $9073	                bmi _check_esc_quote
.9059		c9 7b		cmp #$7b	                cmp #'z'+1
.905b		10 16		bpl $9073	                bpl _check_esc_quote
.905d		a8		tay		                tay
.905e		b9 63 90	lda $9063,y	                lda escape_tr_table - 'a',y   ; fake base address to index with a-z directly
.9061		d0 03		bne $9066	                bne _esc_replace
.9063		98		tya		                tya                     ; revert if no translation
.9064		80 0d		bra $9073	                bra _check_esc_quote
.9066		10 2d		bpl $9095	_esc_replace:   bpl _save_character     ; simple replacement
.9068		29 7f		and #$7f	                and #$7F                ; clear hi bit
.906a		f0 29		beq $9095	                beq _save_character     ; NUL we can just output
.906c		20 e4 97	jsr $97e4	                jsr cmpl_a              ; else output first char (CR)
.906f		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9071		80 22		bra $9095	                bra _save_character
.9073						_check_esc_quote:
.9073		c9 22		cmp #$22	                cmp #'"'
.9075		f0 1e		beq $9095	                beq _save_character
.9077		c9 78		cmp #$78	                cmp #'x'
.9079		d0 06		bne $9081	                bne _check_esc_backslash
.907b		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.907d		85 28		sta $28		                sta tmp2+1
.907f		80 17		bra $9098	                bra _next_character
.9081						_check_esc_backslash:
.9081		c9 5c		cmp #$5c	                cmp #'\'
.9083		d0 0c		bne $9091	                bne _regular_char
.9085		80 0e		bra $9095	                bra _save_character
.9087						_not_escaped:
.9087		c9 5c		cmp #$5c	                cmp #'\'
.9089		d0 06		bne $9091	                bne _regular_char
.908b		a9 ff		lda #$ff	                lda #$FF
.908d		85 28		sta $28		                sta tmp2+1
.908f		80 07		bra $9098	                bra _next_character
.9091						_regular_char:
.9091		c9 22		cmp #$22	                cmp #'"'
.9093		f0 0c		beq $90a1	                beq _found_string_end
.9095						_save_character:
.9095		20 e4 97	jsr $97e4	                jsr cmpl_a
.9098						_next_character:
.9098		e6 10		inc $10		                inc toin
.909a		d0 02		bne $909e	                bne _savechars_loop_longjump
.909c		e6 11		inc $11		                inc toin+1
.909e						_savechars_loop_longjump:
.909e		4c e3 8f	jmp $8fe3	                jmp _savechars_loop
.90a1						_found_string_end:
.90a1		e6 10		inc $10		                inc toin
.90a3		d0 02		bne $90a7	                bne +
.90a5		e6 11		inc $11		                inc toin+1
.90a7						+
.90a7		20 0f 89	jsr $890f	                jsr w_here
.90aa		20 03 8d	jsr $8d03	                jsr w_over
.90ad		20 e3 8b	jsr $8be3	                jsr w_minus    ; HERE - addr gives string length
.90b0		68		pla		                pla                     ; fetch the state flag (0 = interpret)
.90b1		f0 10		beq $90c3	                beq _done
.90b3		38		sec		                sec                     ; rewind the CP to addr-5
.90b4		b5 02		lda $02,x	                lda 2,x
.90b6		e9 05		sbc #$05	                sbc #5
.90b8		85 00		sta $00		                sta cp
.90ba		b5 03		lda $03,x	                lda 3,x
.90bc		e9 00		sbc #$00	                sbc #0
.90be		85 01		sta $01		                sta cp+1
.90c0		20 62 a2	jsr $a262	                jsr w_sliteral         ; ( addr u -- )
.90c3						_done:
.90c3		60		rts		z_s_quote:      rts
.90c4						escape_tr_table:
>90c4		07				    .byte   7               ; a -> BEL (ASCII value 7)
>90c5		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>90c6		00 00				    .byte   0,0             ; c, d no escape
>90c8		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>90c9		0c				    .byte   12              ; f -> FF (ASCII value 12)
>90ca		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>90cf		0a				    .byte   10              ; l -> LF (ASCII value 10)
>90d0		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>90d1		0a				    .byte   10              ; n behaves like l --> lf
>90d2		00 00				    .byte   0,0             ; o,p
>90d4		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>90d5		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>90d6		00				    .byte   0               ; s
>90d7		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>90d8		00				    .byte   0               ; u
>90d9		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>90da		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>90dd		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.90de						xt_s_to_d:
.90de		20 f2 d7	jsr $d7f2	                jsr underflow_1
.90e1						w_s_to_d:
.90e1		ca		dex		                dex
.90e2		ca		dex		                dex
.90e3		74 00		stz $00,x	                stz 0,x
.90e5		74 01		stz $01,x	                stz 1,x
.90e7		b5 03		lda $03,x	                lda 3,x
.90e9		10 04		bpl $90ef	                bpl _done
.90eb		d6 00		dec $00,x	                dec 0,x
.90ed		d6 01		dec $01,x	                dec 1,x
.90ef						_done:
.90ef		60		rts		z_s_to_d:       rts
.90f0						xt_semicolon:
.90f0						w_semicolon:
.90f0		24 1c		bit $1c		                bit status              ; check bit 6 (overflow flag)
.90f2		70 11		bvs $9105	                bvs _colonword
.90f4		a9 60		lda #$60	                lda #OpRTS
.90f6		20 e4 97	jsr $97e4	                jsr cmpl_a
.90f9		ca		dex		                dex
.90fa		ca		dex		                dex
.90fb		a5 06		lda $06		                lda workword
.90fd		95 00		sta $00,x	                sta 0,x
.90ff		a5 07		lda $07		                lda workword+1
.9101		95 01		sta $01,x	                sta 1,x
.9103		80 53		bra $9158	                bra _semicolon_done
.9105						_colonword:
.9105		a9 10		lda #$10	                lda #%00010000
.9107		25 1c		and $1c		                and status
.9109		f0 08		beq $9113	                beq +
.910b		a0 01		ldy #$01	                ldy #1
.910d		b1 06		lda ($06),y	                lda (workword),y
.910f		29 f7		and #$f7	                and #255-NN
.9111		91 06		sta ($06),y	                sta (workword),y
.9113						+
.9113		a0 06		ldy #$06	                ldy #6
.9115		a5 00		lda $00		                lda cp
.9117		91 06		sta ($06),y	                sta (workword),y
.9119		c8		iny		                iny
.911a		a5 01		lda $01		                lda cp+1
.911c		91 06		sta ($06),y	                sta (workword),y
.911e		a9 60		lda #$60	                lda #OpRTS
.9120		20 e4 97	jsr $97e4	                jsr cmpl_a
.9123		24 1c		bit $1c		                bit status
.9125		10 26		bpl $914d	                bpl _new_word   ; Bit 7 is clear = new word
.9127		ca		dex		                dex
.9128		ca		dex		                dex
.9129		ca		dex		                dex
.912a		ca		dex		                dex
.912b		b2 06		lda ($06)	                lda (workword)
.912d		95 00		sta $00,x	                sta 0,x
.912f		74 01		stz $01,x	                stz 1,x
.9131		a5 06		lda $06		                lda workword
.9133		18		clc		                clc
.9134		69 08		adc #$08	                adc #8
.9136		95 02		sta $02,x	                sta 2,x
.9138		a5 07		lda $07		                lda workword+1
.913a		69 00		adc #$00	                adc #0                  ; only want carry
.913c		95 03		sta $03,x	                sta 3,x
.913e		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9140		20 2e d8	jsr $d82e	                jsr print_string_no_lf
.9143		20 dc 94	jsr $94dc	                jsr w_type
.9146		20 dd 91	jsr $91dd	                jsr w_space
.9149		a9 80		lda #$80	                lda #%10000000
.914b		14 1c		trb $1c		                trb status
.914d						_new_word:
.914d		a5 06		lda $06		                lda workword
.914f		85 02		sta $02		                sta dp
.9151		a5 07		lda $07		                lda workword+1
.9153		85 03		sta $03		                sta dp+1
.9155		20 5e d7	jsr $d75e	                jsr dp_to_current       ; Save the updated DP to the
.9158						_semicolon_done:
.9158		64 1a		stz $1a		                stz state
.915a		64 1b		stz $1b		                stz state+1
.915c		60		rts		z_semicolon:    rts
.915d						xt_sign:
.915d		20 f2 d7	jsr $d7f2	                jsr underflow_1
.9160						w_sign:
.9160		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9162		30 04		bmi $9168	                bmi _minus
.9164		e8		inx		                inx
.9165		e8		inx		                inx
.9166		80 09		bra $9171	                bra _done
.9168						_minus:
.9168		a9 2d		lda #$2d	                lda #'-'
.916a		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.916c		74 01		stz $01,x	                stz 1,x         ; paranoid
.916e		20 24 89	jsr $8924	                jsr w_hold
.9171						_done:
.9171		60		rts		z_sign:         rts
.9172						xt_slash:
.9172		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9175						w_slash:
.9175		a9 00		lda #$00	                lda #0
.9177		80 05		bra $917e	                bra slashmod_common
.9179						xt_slash_mod:
.9179		20 f7 d7	jsr $d7f7	                jsr underflow_2
.917c						w_slash_mod:
.917c		a9 ff		lda #$ff	                lda #$FF                ; falls through to _common
.917e						slashmod_common:
.917e		48		pha		                pha
.917f		20 81 93	jsr $9381	                jsr w_to_r             ; >R
.9182		20 e1 90	jsr $90e1	                jsr w_s_to_d           ; S>D
.9185		20 dd 8e	jsr $8edd	                jsr w_r_from           ; R>
.9188		20 97 91	jsr $9197	                jsr w_sm_slash_rem     ; SM/REM
.918b		68		pla		                pla
.918c		d0 05		bne $9193	                bne _done
.918e		20 46 92	jsr $9246	                jsr w_swap
.9191		e8		inx		                inx             ; DROP
.9192		e8		inx		                inx
.9193						_done:
.9193						z_slash_mod:
.9193		60		rts		z_slash:        rts
.9194						xt_sm_slash_rem:
.9194		20 fc d7	jsr $d7fc	                jsr underflow_3 ; contains double number
.9197						w_sm_slash_rem:
.9197		b5 03		lda $03,x	                lda 3,x
.9199		48		pha		                pha
.919a		b5 01		lda $01,x	                lda 1,x
.919c		55 03		eor $03,x	                eor 3,x
.919e		48		pha		                pha
.919f		20 d5 80	jsr $80d5	                jsr w_abs
.91a2		e8		inx		                inx             ; pretend we pushed n1 to R
.91a3		e8		inx		                inx
.91a4		20 eb 9e	jsr $9eeb	                jsr w_dabs
.91a7		ca		dex		                dex
.91a8		ca		dex		                dex
.91a9		20 61 95	jsr $9561	                jsr w_um_slash_mod     ; UM/MOD
.91ac		68		pla		                pla
.91ad		10 03		bpl $91b2	                bpl +
.91af		20 21 8c	jsr $8c21	                jsr w_negate
.91b2						+
.91b2		68		pla		                pla
.91b3		10 07		bpl $91bc	                bpl _done
.91b5		e8		inx		                inx             ; pretend we pushed quotient to R
.91b6		e8		inx		                inx
.91b7		20 21 8c	jsr $8c21	                jsr w_negate
.91ba		ca		dex		                dex
.91bb		ca		dex		                dex
.91bc						_done:
.91bc		60		rts		z_sm_slash_rem: rts
.91bd						xt_source:
.91bd						w_source:
.91bd		ca		dex		                dex
.91be		ca		dex		                dex
.91bf		a5 0c		lda $0c		                lda cib
.91c1		95 00		sta $00,x	                sta 0,x
.91c3		a5 0d		lda $0d		                lda cib+1
.91c5		95 01		sta $01,x	                sta 1,x
.91c7		ca		dex		                dex
.91c8		ca		dex		                dex
.91c9		a5 0e		lda $0e		                lda ciblen
.91cb		95 00		sta $00,x	                sta 0,x
.91cd		a5 0f		lda $0f		                lda ciblen+1
.91cf		95 01		sta $01,x	                sta 1,x
.91d1		60		rts		z_source:       rts
.91d2						xt_source_id:
.91d2						w_source_id:
.91d2		ca		dex		                dex
.91d3		ca		dex		                dex
.91d4		a5 0a		lda $0a		                lda insrc
.91d6		95 00		sta $00,x	                sta 0,x
.91d8		a5 0b		lda $0b		                lda insrc+1
.91da		95 01		sta $01,x	                sta 1,x
.91dc		60		rts		z_source_id:    rts
.91dd						xt_space:
.91dd						w_space:
.91dd		a9 20		lda #$20	                lda #AscSP
.91df		20 bb 86	jsr $86bb	                jsr emit_a
.91e2		60		rts		z_space:        rts
.91e3						xt_spaces:
.91e3		20 f2 d7	jsr $d7f2	                jsr underflow_1
.91e6						w_spaces:
.91e6		b5 01		lda $01,x	                lda 1,x         ; ANS says this word takes a signed value
.91e8		30 10		bmi $91fa	                bmi _done       ; but prints no spaces for negative values.
.91ea		b4 00		ldy $00,x	                ldy 0,x
.91ec		f0 08		beq $91f6	                beq _msb
.91ee						_loop:
.91ee		a9 20		lda #$20	                lda #AscSP
.91f0		20 bb 86	jsr $86bb	                jsr emit_a      ; user routine preserves X and Y
.91f3		88		dey		                dey
.91f4		d0 f8		bne $91ee	                bne _loop       ; Y is zero on exit so looping again emits 256 more spaces
.91f6						_msb:
.91f6		d6 01		dec $01,x	                dec 1,x         ; when decrementing MSB goes negative, it was zero so we're done
.91f8		10 f4		bpl $91ee	                bpl _loop       ; otherwise emit another 256 spaces
.91fa		e8		inx		_done:          inx
.91fb		e8		inx		                inx
.91fc		60		rts		z_spaces:       rts
.91fd						xt_star:
.91fd		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9200						w_star:
.9200		20 a3 95	jsr $95a3	                jsr w_um_star
.9203		e8		inx		                inx
.9204		e8		inx		                inx
.9205		60		rts		z_star:         rts
.9206						xt_star_slash:
.9206		20 fc d7	jsr $d7fc	                jsr underflow_3
.9209						w_star_slash:
.9209		20 15 92	jsr $9215	                jsr w_star_slash_mod
.920c		20 46 92	jsr $9246	                jsr w_swap
.920f		e8		inx		                inx
.9210		e8		inx		                inx
.9211						z_star_slash:
.9211		60		rts		                rts
.9212						xt_star_slash_mod:
.9212		20 fc d7	jsr $d7fc	                jsr underflow_3
.9215						w_star_slash_mod:
.9215		20 81 93	jsr $9381	                jsr w_to_r
.9218		20 2a 8b	jsr $8b2a	                jsr w_m_star
.921b		20 dd 8e	jsr $8edd	                jsr w_r_from
.921e		20 97 91	jsr $9197	                jsr w_sm_slash_rem
.9221						z_star_slash_mod:
.9221		60		rts		                rts
.9222						xt_state:
.9222						w_state:
.9222		ca		dex		                dex
.9223		ca		dex		                dex
.9224		a9 1a		lda #$1a	                lda #<state
.9226		95 00		sta $00,x	                sta 0,x
.9228		a9 00		lda #$00	                lda #>state
.922a		95 01		sta $01,x	                sta 1,x
.922c		60		rts		z_state:        rts
.922d						xt_store:
.922d		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9230						w_store:
.9230		b5 02		lda $02,x	                lda 2,x         ; LSB
.9232		81 00		sta ($00,x)	                sta (0,x)
.9234		f6 00		inc $00,x	                inc 0,x
.9236		d0 02		bne $923a	                bne +
.9238		f6 01		inc $01,x	                inc 1,x
.923a						+
.923a		b5 03		lda $03,x	                lda 3,x         ; MSB
.923c		81 00		sta ($00,x)	                sta (0,x)
.923e		e8		inx		                inx             ; 2DROP
.923f		e8		inx		                inx
.9240		e8		inx		                inx
.9241		e8		inx		                inx
.9242		60		rts		z_store:        rts
.9243						xt_swap:
.9243		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9246						w_swap:
.9246		b5 00		lda $00,x	                lda 0,x         ; LSB
.9248		b4 02		ldy $02,x	                ldy 2,x
.924a		95 02		sta $02,x	                sta 2,x
.924c		94 00		sty $00,x	                sty 0,x
.924e		b5 01		lda $01,x	                lda 1,x         ; MSB
.9250		b4 03		ldy $03,x	                ldy 3,x
.9252		95 03		sta $03,x	                sta 3,x
.9254		94 01		sty $01,x	                sty 1,x
.9256		60		rts		z_swap:         rts
.9257						xt_tick:
.9257						w_tick:
.9257		20 4c 8d	jsr $8d4c	                jsr w_parse_name       ; ( -- addr u )
.925a		b5 00		lda $00,x	                lda 0,x
.925c		15 01		ora $01,x	                ora 1,x
.925e		d0 05		bne $9265	                bne +
.9260		a9 05		lda #$05	                lda #err_noname
.9262		4c 08 d8	jmp $d808	                jmp error
.9265						+
.9265		20 85 9b	jsr $9b85	                jsr w_find_name        ; ( addr u -- nt )
.9268		b5 00		lda $00,x	                lda 0,x
.926a		15 01		ora $01,x	                ora 1,x
.926c		d0 05		bne $9273	                bne +
.926e		a9 08		lda #$08	                lda #err_syntax
.9270		4c 08 d8	jmp $d808	                jmp error
.9273						+
.9273		20 d9 9c	jsr $9cd9	                jsr w_name_to_int      ; ( nt -- xt )
.9276		60		rts		z_tick:         rts
.9277						xt_to:
.9277						w_to:
.9277		20 57 92	jsr $9257	                jsr w_tick             ; ( [n] xt )
.927a		b5 00		lda $00,x	                lda 0,x                 ; LSB
.927c		18		clc		                clc
.927d		69 03		adc #$03	                adc #3
.927f		85 25		sta $25		                sta tmp1
.9281		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9283		69 00		adc #$00	                adc #0                  ; we just want the carry
.9285		85 26		sta $26		                sta tmp1+1
.9287		a5 1a		lda $1a		                lda state
.9289		05 1b		ora $1b		                ora state+1
.928b		f0 14		beq $92a1	                beq _interpret
.928d		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.928f		95 00		sta $00,x	                sta 0,x
.9291		a5 26		lda $26		                lda tmp1+1
.9293		95 01		sta $01,x	                sta 1,x
.9295		20 fb 89	jsr $89fb	                jsr w_literal      ; generate the runtime for LITERAL tmp1
.9298		a0 92		ldy #$92	                ldy #>w_store      ; write the runtime for !
.929a		a9 30		lda #$30	                lda #<w_store
.929c		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.929f		80 11		bra $92b2	                bra _done
.92a1						_interpret:
.92a1		20 f7 d7	jsr $d7f7	                jsr underflow_2
.92a4		e8		inx		                inx
.92a5		e8		inx		                inx                     ; leaving just ( n )
.92a6		b5 00		lda $00,x	                lda 0,x
.92a8		92 25		sta ($25)	                sta (tmp1)              ; LSB
.92aa		a0 01		ldy #$01	                ldy #1
.92ac		b5 01		lda $01,x	                lda 1,x                 ; MSB
.92ae		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.92b0		e8		inx		                inx                     ; DROP
.92b1		e8		inx		                inx
.92b2						_done:
.92b2		60		rts		z_to:           rts
.92b3						xt_to_body:
.92b3		20 f2 d7	jsr $d7f2	                jsr underflow_1
.92b6						w_to_body:
.92b6		20 91 86	jsr $8691	                jsr w_dup              ; ( xt xt )
.92b9		20 53 9c	jsr $9c53	                jsr w_int_to_name      ; ( xt nt )
.92bc		f6 00		inc $00,x	                inc 0,x
.92be		d0 02		bne $92c2	                bne +
.92c0		f6 01		inc $01,x	                inc 1,x
.92c2						+
.92c2		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.92c4		29 10		and #$10	                and #HC
.92c6		f0 0b		beq $92d3	                beq _no_cfa
.92c8		18		clc		                clc
.92c9		b5 02		lda $02,x	                lda 2,x         ; LSB
.92cb		69 03		adc #$03	                adc #3
.92cd		95 02		sta $02,x	                sta 2,x
.92cf		90 02		bcc $92d3	                bcc _no_cfa
.92d1		f6 03		inc $03,x	                inc 3,x         ; MSB
.92d3						_no_cfa:
.92d3		e8		inx		                inx             ; get rid of the nt
.92d4		e8		inx		                inx
.92d5		60		rts		z_to_body:      rts
.92d6						xt_to_in:
.92d6						w_to_in:
.92d6		ca		dex		                dex
.92d7		ca		dex		                dex
.92d8		a9 10		lda #$10	                lda #<toin
.92da		95 00		sta $00,x	                sta 0,x
.92dc		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.92de		95 01		sta $01,x	                sta 1,x
.92e0		60		rts		z_to_in:        rts
.92e1						xt_to_number:
.92e1		20 01 d8	jsr $d801	                jsr underflow_4
.92e4						w_to_number:
.92e4		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.92e6		85 2d		sta $2d		                sta scratch
.92e8		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.92ea		85 2e		sta $2e		                sta scratch+1
.92ec		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.92ee		85 2f		sta $2f		                sta scratch+2
.92f0		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.92f2		85 30		sta $30		                sta scratch+3
.92f4		ca		dex		                dex
.92f5		ca		dex		                dex
.92f6						_loop:
.92f6		a1 04		lda ($04,x)	                lda (4,x)
.92f8		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.92fa		74 01		stz $01,x	                stz 1,x                 ; paranoid
.92fc		20 29 9b	jsr $9b29	                jsr w_digit_question   ; ( char -- n -1 | char 0 )
.92ff		b5 00		lda $00,x	                lda 0,x
.9301		d0 04		bne $9307	                bne _digit_ok
.9303		e8		inx		                inx
.9304		e8		inx		                inx
.9305		80 67		bra $936e	                bra _done       ; ( ud-lo ud-hi addr u char )
.9307						_digit_ok:
.9307		b5 02		lda $02,x	                lda 2,x
.9309		85 31		sta $31		                sta scratch+4
.930b		b5 03		lda $03,x	                lda 3,x
.930d		85 32		sta $32		                sta scratch+5
.930f		a5 2f		lda $2f		                lda scratch+2
.9311		95 02		sta $02,x	                sta 2,x         ; NOS
.9313		a5 30		lda $30		                lda scratch+3
.9315		95 03		sta $03,x	                sta 3,x
.9317		a5 18		lda $18		                lda base
.9319		95 00		sta $00,x	                sta 0,x         ; TOS
.931b		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.931d		20 a3 95	jsr $95a3	                jsr w_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.9320		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.9322		85 33		sta $33		                sta scratch+6
.9324		b5 03		lda $03,x	                lda 3,x
.9326		85 34		sta $34		                sta scratch+7
.9328		a5 2d		lda $2d		                lda scratch
.932a		95 02		sta $02,x	                sta 2,x
.932c		a5 2e		lda $2e		                lda scratch+1
.932e		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.9330		a5 18		lda $18		                lda base
.9332		95 00		sta $00,x	                sta 0,x
.9334		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.9336		20 a3 95	jsr $95a3	                jsr w_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.9339		b5 00		lda $00,x	                lda 0,x
.933b		85 2f		sta $2f		                sta scratch+2
.933d		b5 01		lda $01,x	                lda 1,x
.933f		85 30		sta $30		                sta scratch+3
.9341		b5 02		lda $02,x	                lda 2,x
.9343		85 2d		sta $2d		                sta scratch
.9345		b5 03		lda $03,x	                lda 3,x
.9347		85 2e		sta $2e		                sta scratch+1
.9349		18		clc		                clc
.934a		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.934c		65 31		adc $31		                adc scratch+4   ; n LSB
.934e		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.9350		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.9352		65 32		adc $32		                adc scratch+5   ; n MSB
.9354		85 2e		sta $2e		                sta scratch+1
.9356		a5 2f		lda $2f		                lda scratch+2   ; LSB
.9358		65 33		adc $33		                adc scratch+6
.935a		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.935c		a5 30		lda $30		                lda scratch+3   ; MSB
.935e		65 34		adc $34		                adc scratch+7
.9360		85 30		sta $30		                sta scratch+3
.9362		e8		inx		                inx
.9363		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.9364		f6 04		inc $04,x	                inc 4,x
.9366		d0 02		bne $936a	                bne +
.9368		f6 05		inc $05,x	                inc 5,x
.936a						+
.936a		d6 02		dec $02,x	                dec 2,x
.936c		d0 88		bne $92f6	                bne _loop
.936e						_done:
.936e		e8		inx		                inx
.936f		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.9370		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.9372		95 06		sta $06,x	                sta 6,x
.9374		a5 2e		lda $2e		                lda scratch+1
.9376		95 07		sta $07,x	                sta 7,x
.9378		a5 2f		lda $2f		                lda scratch+2
.937a		95 04		sta $04,x	                sta 4,x
.937c		a5 30		lda $30		                lda scratch+3
.937e		95 05		sta $05,x	                sta 5,x
.9380		60		rts		z_to_number:    rts
.9381						xt_to_r:
.9381						w_to_r:
.9381		68		pla		                pla                     ; LSB
.9382		7a		ply		                ply                     ; MSB
.9383		1a		inc a		                inc a
.9384		85 25		sta $25		                sta tmp1                ; LSB
.9386		d0 01		bne $9389	                bne +
.9388		c8		iny		                iny
.9389						+
.9389		84 26		sty $26		                sty tmp1+1              ; MSB
.938b		20 f2 d7	jsr $d7f2	                jsr underflow_1
.938e		b5 01		lda $01,x	                lda 1,x         ; MSB
.9390		48		pha		                pha
.9391		b5 00		lda $00,x	                lda 0,x         ; LSB
.9393		48		pha		                pha
.9394		e8		inx		                inx
.9395		e8		inx		                inx
.9396		6c 25 00	jmp ($0025)	z_to_r:         jmp (tmp1)
.9399						xt_true:
.9399						w_true:
.9399		ca		dex		                dex
.939a		ca		dex		                dex
.939b		a9 ff		lda #$ff	                lda #$FF
.939d		95 00		sta $00,x	                sta 0,x
.939f		95 01		sta $01,x	                sta 1,x
.93a1		60		rts		z_true:         rts
.93a2						xt_tuck:
.93a2		20 f7 d7	jsr $d7f7	                jsr underflow_2
.93a5						w_tuck:
.93a5		ca		dex		                dex
.93a6		ca		dex		                dex
.93a7		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.93a9		b5 02		lda $02,x	                lda 2,x
.93ab		95 04		sta $04,x	                sta 4,x
.93ad		94 02		sty $02,x	                sty 2,x
.93af		95 00		sta $00,x	                sta 0,x
.93b1		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.93b3		b5 03		lda $03,x	                lda 3,x
.93b5		95 05		sta $05,x	                sta 5,x
.93b7		94 03		sty $03,x	                sty 3,x         ; bba
.93b9		95 01		sta $01,x	                sta 1,x         ; baa
.93bb		60		rts		z_tuck:         rts
.93bc						xt_two_drop:
.93bc		20 f7 d7	jsr $d7f7	                jsr underflow_2
.93bf						w_two_drop:
.93bf		e8		inx		                inx
.93c0		e8		inx		                inx
.93c1		e8		inx		                inx
.93c2		e8		inx		                inx
.93c3		60		rts		z_two_drop:     rts
.93c4						xt_two_dup:
.93c4		20 f7 d7	jsr $d7f7	                jsr underflow_2
.93c7						w_two_dup:
.93c7		ca		dex		                dex
.93c8		ca		dex		                dex
.93c9		ca		dex		                dex
.93ca		ca		dex		                dex
.93cb		b5 04		lda $04,x	                lda 4,x         ; TOS
.93cd		95 00		sta $00,x	                sta 0,x
.93cf		b5 05		lda $05,x	                lda 5,x
.93d1		95 01		sta $01,x	                sta 1,x
.93d3		b5 06		lda $06,x	                lda 6,x         ; NOS
.93d5		95 02		sta $02,x	                sta 2,x
.93d7		b5 07		lda $07,x	                lda 7,x
.93d9		95 03		sta $03,x	                sta 3,x
.93db		60		rts		z_two_dup:      rts
.93dc						xt_two_fetch:
.93dc		20 f2 d7	jsr $d7f2	                jsr underflow_1
.93df						w_two_fetch:
.93df		b5 00		lda $00,x	                lda 0,x
.93e1		85 25		sta $25		                sta tmp1
.93e3		b4 01		ldy $01,x	                ldy 1,x
.93e5		84 26		sty $26		                sty tmp1+1
.93e7		ca		dex		                dex             ; reuse one stack element
.93e8		ca		dex		                dex
.93e9		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.93eb		95 00		sta $00,x	                sta 0,x
.93ed		a0 01		ldy #$01	                ldy #1          ; copy next
.93ef		b1 25		lda ($25),y	                lda (tmp1),y
.93f1		95 01		sta $01,x	                sta 1,x
.93f3		c8		iny		                iny             ; copy next
.93f4		b1 25		lda ($25),y	                lda (tmp1),y
.93f6		95 02		sta $02,x	                sta 2,x
.93f8		c8		iny		                iny             ; copy next
.93f9		b1 25		lda ($25),y	                lda (tmp1),y
.93fb		95 03		sta $03,x	                sta 3,x
.93fd		60		rts		z_two_fetch:    rts
.93fe						xt_two_over:
.93fe		20 01 d8	jsr $d801	                jsr underflow_4
.9401						w_two_over:
.9401		ca		dex		                dex
.9402		ca		dex		                dex
.9403		ca		dex		                dex
.9404		ca		dex		                dex
.9405		b5 08		lda $08,x	                lda 8,x
.9407		95 00		sta $00,x	                sta 0,x
.9409		b5 09		lda $09,x	                lda 9,x
.940b		95 01		sta $01,x	                sta 1,x
.940d		b5 0a		lda $0a,x	                lda 10,x
.940f		95 02		sta $02,x	                sta 2,x
.9411		b5 0b		lda $0b,x	                lda 11,x
.9413		95 03		sta $03,x	                sta 3,x
.9415		60		rts		z_two_over:     rts
.9416						xt_two_r_fetch:
.9416						w_two_r_fetch:
.9416		68		pla		                pla                     ; LSB
.9417		7a		ply		                ply                     ; MSB
.9418		1a		inc a		                inc a
.9419		85 25		sta $25		                sta tmp1                ; LSB
.941b		d0 01		bne $941e	                bne +
.941d		c8		iny		                iny
.941e						+
.941e		84 26		sty $26		                sty tmp1+1              ; MSB
.9420		8a		txa		                txa             ; arrange for Y = SP; X -= 4
.9421		ba		tsx		                tsx
.9422		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.9423		7a		ply		                ply
.9424		38		sec		                sec
.9425		e9 04		sbc #$04	                sbc #4
.9427		aa		tax		                tax
.9428		b9 01 01	lda $0101,y	                lda $101,y
.942b		95 00		sta $00,x	                sta 0,x
.942d		b9 02 01	lda $0102,y	                lda $102,y
.9430		95 01		sta $01,x	                sta 1,x
.9432		b9 03 01	lda $0103,y	                lda $103,y
.9435		95 02		sta $02,x	                sta 2,x
.9437		b9 04 01	lda $0104,y	                lda $104,y
.943a		95 03		sta $03,x	                sta 3,x
.943c		6c 25 00	jmp ($0025)	z_two_r_fetch:  jmp (tmp1)
.943f						xt_two_r_from:
.943f						w_two_r_from:
.943f		68		pla		                pla
.9440		7a		ply		                ply                     ; MSB
.9441		1a		inc a		                inc a
.9442		85 25		sta $25		                sta tmp1                ; LSB
.9444		d0 01		bne $9447	                bne +
.9446		c8		iny		                iny
.9447						+
.9447		84 26		sty $26		                sty tmp1+1              ; MSB
.9449		ca		dex		                dex
.944a		ca		dex		                dex
.944b		ca		dex		                dex
.944c		ca		dex		                dex
.944d		68		pla		                pla                     ; LSB
.944e		95 00		sta $00,x	                sta 0,x
.9450		68		pla		                pla                     ; MSB
.9451		95 01		sta $01,x	                sta 1,x
.9453		68		pla		                pla                     ; LSB
.9454		95 02		sta $02,x	                sta 2,x
.9456		68		pla		                pla                     ; MSB
.9457		95 03		sta $03,x	                sta 3,x
.9459		6c 25 00	jmp ($0025)	z_two_r_from:   jmp (tmp1)
.945c						xt_two_slash:
.945c		20 f2 d7	jsr $d7f2	                jsr underflow_1
.945f						w_two_slash:
.945f		b5 01		lda $01,x	                lda 1,x
.9461		0a		asl a		                asl                     ; save the sign
.9462		76 01		ror $01,x	                ror 1,x
.9464		76 00		ror $00,x	                ror 0,x
.9466		60		rts		z_two_slash:    rts
.9467						xt_two_star:
.9467						xt_cells:
.9467		20 f2 d7	jsr $d7f2	                jsr underflow_1
.946a						w_two_star:
.946a						w_cells:
.946a		16 00		asl $00,x	                asl 0,x
.946c		36 01		rol $01,x	                rol 1,x
.946e						z_cells:
.946e		60		rts		z_two_star:     rts
.946f						xt_two_store:
.946f		20 fc d7	jsr $d7fc	                jsr underflow_3
.9472						w_two_store:
.9472		b5 00		lda $00,x	                lda 0,x
.9474		85 25		sta $25		                sta tmp1
.9476		b4 01		ldy $01,x	                ldy 1,x
.9478		84 26		sty $26		                sty tmp1+1
.947a		e8		inx		                inx
.947b		e8		inx		                inx
.947c		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.947e		92 25		sta ($25)	                sta (tmp1)
.9480		b5 01		lda $01,x	                lda 1,x         ; copy next
.9482		a0 01		ldy #$01	                ldy #1
.9484		91 25		sta ($25),y	                sta (tmp1),y
.9486		b5 02		lda $02,x	                lda 2,x         ; copy next
.9488		c8		iny		                iny
.9489		91 25		sta ($25),y	                sta (tmp1),y
.948b		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.948d		c8		iny		                iny
.948e		91 25		sta ($25),y	                sta (tmp1),y
.9490		e8		inx		                inx             ; 2DROP
.9491		e8		inx		                inx
.9492		e8		inx		                inx
.9493		e8		inx		                inx
.9494		60		rts		z_two_store:    rts
.9495						xt_two_swap:
.9495		20 01 d8	jsr $d801	                jsr underflow_4
.9498						w_two_swap:
.9498		b5 00		lda $00,x	                lda 0,x
.949a		b4 04		ldy $04,x	                ldy 4,x
.949c		95 04		sta $04,x	                sta 4,x
.949e		94 00		sty $00,x	                sty 0,x
.94a0		b5 01		lda $01,x	                lda 1,x
.94a2		b4 05		ldy $05,x	                ldy 5,x
.94a4		95 05		sta $05,x	                sta 5,x
.94a6		94 01		sty $01,x	                sty 1,x
.94a8		b5 02		lda $02,x	                lda 2,x
.94aa		b4 06		ldy $06,x	                ldy 6,x
.94ac		95 06		sta $06,x	                sta 6,x
.94ae		94 02		sty $02,x	                sty 2,x
.94b0		b5 03		lda $03,x	                lda 3,x
.94b2		b4 07		ldy $07,x	                ldy 7,x
.94b4		95 07		sta $07,x	                sta 7,x
.94b6		94 03		sty $03,x	                sty 3,x
.94b8		60		rts		z_two_swap:     rts
.94b9						xt_two_to_r:
.94b9						w_two_to_r:
.94b9		68		pla		                pla                     ; LSB
.94ba		7a		ply		                ply                     ; MSB
.94bb		1a		inc a		                inc a
.94bc		85 25		sta $25		                sta tmp1                ; LSB
.94be		d0 01		bne $94c1	                bne +
.94c0		c8		iny		                iny
.94c1						+
.94c1		84 26		sty $26		                sty tmp1+1              ; MSB
.94c3		20 f7 d7	jsr $d7f7	                jsr underflow_2
.94c6		b5 03		lda $03,x	                lda 3,x         ; MSB
.94c8		48		pha		                pha
.94c9		b5 02		lda $02,x	                lda 2,x         ; LSB
.94cb		48		pha		                pha
.94cc		b5 01		lda $01,x	                lda 1,x         ; MSB
.94ce		48		pha		                pha
.94cf		b5 00		lda $00,x	                lda 0,x         ; LSB
.94d1		48		pha		                pha
.94d2		e8		inx		                inx
.94d3		e8		inx		                inx
.94d4		e8		inx		                inx
.94d5		e8		inx		                inx
.94d6		6c 25 00	jmp ($0025)	z_two_to_r:     jmp (tmp1)
.94d9						xt_type:
.94d9		20 f7 d7	jsr $d7f7	                jsr underflow_2
.94dc						w_type:
.94dc		b5 02		lda $02,x	                lda 2,x
.94de		85 25		sta $25		                sta tmp1
.94e0		b5 03		lda $03,x	                lda 3,x
.94e2		85 26		sta $26		                sta tmp1+1
.94e4						_loop:
.94e4		b5 00		lda $00,x	                lda 0,x
.94e6		15 01		ora $01,x	                ora 1,x
.94e8		f0 15		beq $94ff	                beq _done
.94ea		b2 25		lda ($25)	                lda (tmp1)
.94ec		20 bb 86	jsr $86bb	                jsr emit_a      ; avoids stack foolery
.94ef		e6 25		inc $25		                inc tmp1
.94f1		d0 02		bne $94f5	                bne +
.94f3		e6 26		inc $26		                inc tmp1+1
.94f5						+
.94f5		b5 00		lda $00,x	                lda 0,x
.94f7		d0 02		bne $94fb	                bne +
.94f9		d6 01		dec $01,x	                dec 1,x
.94fb						+
.94fb		d6 00		dec $00,x	                dec 0,x
.94fd		80 e5		bra $94e4	                bra _loop
.94ff						_done:
.94ff		e8		inx		                inx
.9500		e8		inx		                inx
.9501		e8		inx		                inx
.9502		e8		inx		                inx
.9503		60		rts		z_type:         rts
.9504						xt_u_dot:
.9504		20 f2 d7	jsr $d7f2	                jsr underflow_1
.9507						w_u_dot:
.9507		20 5a d8	jsr $d85a	                jsr print_u
.950a		a9 20		lda #$20	                lda #AscSP
.950c		20 bb 86	jsr $86bb	                jsr emit_a
.950f		60		rts		z_u_dot:        rts
.9510						xt_u_dot_r:
.9510		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9513						w_u_dot_r:
.9513		20 81 93	jsr $9381	                jsr w_to_r
.9516		20 99 9e	jsr $9e99	                jsr w_zero
.9519		20 d5 89	jsr $89d5	                jsr w_less_number_sign
.951c		20 b1 8c	jsr $8cb1	                jsr w_number_sign_s
.951f		20 8f 8c	jsr $8c8f	                jsr w_number_sign_greater
.9522		20 dd 8e	jsr $8edd	                jsr w_r_from
.9525		20 03 8d	jsr $8d03	                jsr w_over
.9528		20 e3 8b	jsr $8be3	                jsr w_minus
.952b		20 e6 91	jsr $91e6	                jsr w_spaces
.952e		20 dc 94	jsr $94dc	                jsr w_type
.9531		60		rts		z_u_dot_r:      rts
.9532						xt_u_greater_than:
.9532		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9535						w_u_greater_than:
.9535		b5 00		lda $00,x	                lda 0,x
.9537		d5 02		cmp $02,x	                cmp 2,x
.9539		b5 01		lda $01,x	                lda 1,x
.953b		f5 03		sbc $03,x	                sbc 3,x
.953d		e8		inx		                inx
.953e		e8		inx		                inx
.953f		a9 00		lda #$00	                lda #0
.9541		69 ff		adc #$ff	                adc #$FF
.9543		95 00		sta $00,x	                sta 0,x         ; store flag
.9545		95 01		sta $01,x	                sta 1,x
.9547		60		rts		z_u_greater_than:    rts
.9548						xt_u_less_than:
.9548		20 f7 d7	jsr $d7f7	                jsr underflow_2
.954b						w_u_less_than:
.954b		b5 02		lda $02,x	                lda 2,x
.954d		d5 00		cmp $00,x	                cmp 0,x
.954f		b5 03		lda $03,x	                lda 3,x
.9551		f5 01		sbc $01,x	                sbc 1,x
.9553		e8		inx		                inx
.9554		e8		inx		                inx
.9555		a9 00		lda #$00	                lda #0
.9557		69 ff		adc #$ff	                adc #$FF
.9559		95 00		sta $00,x	                sta 0,x         ; store flag
.955b		95 01		sta $01,x	                sta 1,x
.955d		60		rts		z_u_less_than:    rts
.955e						xt_um_slash_mod:
.955e		20 fc d7	jsr $d7fc	                jsr underflow_3
.9561						w_um_slash_mod:
.9561		b5 00		lda $00,x	                lda 0,x
.9563		15 01		ora $01,x	                ora 1,x
.9565		d0 05		bne $956c	                bne _not_zero
.9567		a9 04		lda #$04	                lda #err_divzero
.9569		4c 08 d8	jmp $d808	                jmp error
.956c						_not_zero:
.956c		a9 11		lda #$11	                lda #17
.956e		85 23		sta $23		                sta tmptos
.9570						_loop:
.9570		36 04		rol $04,x	                rol 4,x
.9572		36 05		rol $05,x	                rol 5,x
.9574		c6 23		dec $23		                dec tmptos
.9576		f0 22		beq $959a	                beq _done
.9578		36 02		rol $02,x	                rol 2,x
.957a		36 03		rol $03,x	                rol 3,x
.957c		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.957e		26 25		rol $25		                rol tmp1
.9580		38		sec		                sec
.9581		b5 02		lda $02,x	                lda 2,x
.9583		f5 00		sbc $00,x	                sbc 0,x
.9585		85 26		sta $26		                sta tmp1+1
.9587		b5 03		lda $03,x	                lda 3,x
.9589		f5 01		sbc $01,x	                sbc 1,x
.958b		a8		tay		                tay
.958c		a5 25		lda $25		                lda tmp1
.958e		e9 00		sbc #$00	                sbc #0
.9590		90 de		bcc $9570	                bcc _loop
.9592		a5 26		lda $26		                lda tmp1+1
.9594		95 02		sta $02,x	                sta 2,x
.9596		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.9598		80 d6		bra $9570	                bra _loop
.959a						_done:
.959a		e8		inx		                inx
.959b		e8		inx		                inx
.959c		20 46 92	jsr $9246	                jsr w_swap
.959f		60		rts		z_um_slash_mod: rts
.95a0						xt_um_star:
.95a0		20 f7 d7	jsr $d7f7	                jsr underflow_2
.95a3						w_um_star:
.95a3		18		clc		                clc
.95a4		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.95a6		e9 00		sbc #$00	                sbc #0
.95a8		85 27		sta $27		                sta tmp2
.95aa		b5 01		lda $01,x	                lda 1,x
.95ac		e9 00		sbc #$00	                sbc #0
.95ae		90 31		bcc $95e1	                bcc _zero       ; is TOS zero?
.95b0		85 28		sta $28		                sta tmp2+1
.95b2		a9 00		lda #$00	                lda #0
.95b4		85 25		sta $25		                sta tmp1
.95b6		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.95b8		ca		dex		                dex
.95b9		ca		dex		                dex
.95ba						_outer_loop:
.95ba		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.95bc		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.95be						_inner_loop:
.95be		90 0c		bcc $95cc	                bcc _no_add
.95c0		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.95c2		a5 25		lda $25		                lda tmp1
.95c4		65 27		adc $27		                adc tmp2
.95c6		85 25		sta $25		                sta tmp1
.95c8		a5 26		lda $26		                lda tmp1+1
.95ca		65 28		adc $28		                adc tmp2+1
.95cc						_no_add:
.95cc		6a		ror a		                ror
.95cd		66 25		ror $25		                ror tmp1
.95cf		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.95d1		88		dey		                dey
.95d2		d0 ea		bne $95be	                bne _inner_loop ; go back for one more shift?
.95d4		e8		inx		                inx
.95d5		e4 29		cpx $29		                cpx tmp3
.95d7		d0 e1		bne $95ba	                bne _outer_loop ; go back for eight more shifts?
.95d9		95 01		sta $01,x	                sta 1,x
.95db		a5 25		lda $25		                lda tmp1
.95dd		95 00		sta $00,x	                sta 0,x
.95df		80 04		bra $95e5	                bra _done
.95e1						_zero:
.95e1		74 02		stz $02,x	                stz 2,x
.95e3		74 03		stz $03,x	                stz 3,x
.95e5						_done:
.95e5		60		rts		z_um_star:      rts
.95e6						xt_unloop:
.95e6						w_unloop:
.95e6		a4 1f		ldy $1f		                ldy loopctrl
.95e8		88		dey		                dey
.95e9		88		dey		                dey
.95ea		88		dey		                dey
.95eb		88		dey		                dey
.95ec		84 1f		sty $1f		                sty loopctrl
.95ee		30 05		bmi $95f5	                bmi z_unloop            ; no active loops?
.95f0		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.95f3		85 20		sta $20		                sta loopidx0
.95f5		60		rts		z_unloop:       rts
.95f6						xt_until:
.95f6		20 f2 d7	jsr $d7f2	                jsr underflow_1
.95f9						w_until:
.95f9		20 14 98	jsr $9814	                jsr cmpl_0branch_tos
.95fc		60		rts		z_until:        rts
.95fd						xt_unused:
.95fd						w_unused:
.95fd		ca		dex		                dex
.95fe		ca		dex		                dex
.95ff		a9 00		lda #$00	                lda #<cp_end
.9601		38		sec		                sec
.9602		e5 00		sbc $00		                sbc cp
.9604		95 00		sta $00,x	                sta 0,x
.9606		a9 7c		lda #$7c	                lda #>cp_end
.9608		e5 01		sbc $01		                sbc cp+1
.960a		95 01		sta $01,x	                sta 1,x
.960c		60		rts		z_unused:       rts
.960d						xt_variable:
.960d						w_variable:
.960d		20 1d 84	jsr $841d	                jsr w_create
.9610		a9 00		lda #$00	                lda #0
.9612		20 e4 97	jsr $97e4	                jsr cmpl_a
.9615		20 e4 97	jsr $97e4	                jsr cmpl_a
.9618		60		rts		z_variable:     rts
.9619						xt_while:
.9619		20 f2 d7	jsr $d7f2	                jsr underflow_1
.961c						w_while:
.961c		20 ff 97	jsr $97ff	                jsr cmpl_0branch_later          ; branch to location we'll determine later
.961f		20 46 92	jsr $9246	                jsr w_swap
.9622		60		rts		z_while:        rts
.9623						xt_within:
.9623		20 fc d7	jsr $d7fc	                jsr underflow_3
.9626						w_within:
.9626		20 03 8d	jsr $8d03	                jsr w_over
.9629		20 e3 8b	jsr $8be3	                jsr w_minus
.962c		20 81 93	jsr $9381	                jsr w_to_r
.962f		20 e3 8b	jsr $8be3	                jsr w_minus
.9632		20 dd 8e	jsr $8edd	                jsr w_r_from
.9635		20 4b 95	jsr $954b	                jsr w_u_less_than
.9638		60		rts		z_within:       rts
.9639						xt_word:
.9639		20 f2 d7	jsr $d7f2	                jsr underflow_1
.963c						w_word:
.963c		a4 10		ldy $10		                ldy toin                ; >IN
.963e						_loop:
.963e		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.9640		f0 09		beq $964b	                beq _found_char
.9642		b1 0c		lda ($0c),y	                lda (cib),y
.9644		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.9646		d0 03		bne $964b	                bne _found_char
.9648		c8		iny		                iny
.9649		80 f3		bra $963e	                bra _loop
.964b						_found_char:
.964b		84 10		sty $10		                sty toin
.964d		20 aa 8d	jsr $8daa	                jsr w_parse            ; Returns ( addr u )
.9650		b5 00		lda $00,x	                lda 0,x
.9652		92 00		sta ($00)	                sta (cp)                ; Save length of string
.9654		48		pha		                pha                     ; Keep copy of length for later
.9655		20 91 86	jsr $8691	                jsr w_dup              ; ( addr u u )
.9658		a5 00		lda $00		                lda cp
.965a		18		clc		                clc
.965b		69 01		adc #$01	                adc #1
.965d		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.965f		a5 01		lda $01		                lda cp+1
.9661		69 00		adc #$00	                adc #0
.9663		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.9665		20 ff 8b	jsr $8bff	                jsr w_move
.9668		ca		dex		                dex
.9669		ca		dex		                dex
.966a		a5 00		lda $00		                lda cp
.966c		95 00		sta $00,x	                sta 0,x
.966e		a5 01		lda $01		                lda cp+1
.9670		95 01		sta $01,x	                sta 1,x
.9672		68		pla		                pla                     ; length of string
.9673		18		clc		                clc
.9674		65 00		adc $00		                adc cp
.9676		85 00		sta $00		                sta cp
.9678		90 02		bcc $967c	                bcc z_word
.967a		e6 01		inc $01		                inc cp+1
.967c		60		rts		z_word:         rts
.967d						xt_xor:
.967d		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9680						w_xor:
.9680		b5 00		lda $00,x	                lda 0,x
.9682		55 02		eor $02,x	                eor 2,x
.9684		95 02		sta $02,x	                sta 2,x
.9686		b5 01		lda $01,x	                lda 1,x
.9688		55 03		eor $03,x	                eor 3,x
.968a		95 03		sta $03,x	                sta 3,x
.968c		e8		inx		                inx
.968d		e8		inx		                inx
.968e		60		rts		z_xor:          rts
.968f						xt_zero_equal:
.968f		20 f2 d7	jsr $d7f2	                jsr underflow_1
.9692						w_zero_equal:
.9692		b5 00		lda $00,x	                lda 0,x
.9694		15 01		ora $01,x	                ora 1,x
.9696		f0 02		beq $969a	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.9698		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.969a						_zero:
.969a		49 ff		eor #$ff	                eor #$FF        ; now just invert:
.969c		95 00		sta $00,x	                sta 0,x
.969e		95 01		sta $01,x	                sta 1,x
.96a0		60		rts		z_zero_equal:   rts
.96a1						xt_zero_greater:
.96a1		20 f2 d7	jsr $d7f2	                jsr underflow_1
.96a4						w_zero_greater:
.96a4		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.96a6		b5 01		lda $01,x	                lda 1,x         ; MSB
.96a8		30 05		bmi $96af	                bmi _done       ; TOS is negative, keep FLASE
.96aa		15 00		ora $00,x	                ora 0,x
.96ac		f0 01		beq $96af	                beq _done       ; TOS is zero, keep FALSE
.96ae		88		dey		                dey             ; TOS is postive, make true
.96af						_done:
.96af		98		tya		                tya
.96b0		95 00		sta $00,x	                sta 0,x
.96b2		95 01		sta $01,x	                sta 1,x
.96b4		60		rts		z_zero_greater: rts
.96b5						xt_zero_less:
.96b5		20 f2 d7	jsr $d7f2	                jsr underflow_1
.96b8						w_zero_less:
.96b8		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.96ba		b5 01		lda $01,x	                lda 1,x         ; MSB
.96bc		10 01		bpl $96bf	                bpl _done       ; TOS is positive, so keep FALSE
.96be		88		dey		                dey             ; TOS is negative, make TRUE
.96bf						_done:
.96bf		98		tya		                tya
.96c0		95 00		sta $00,x	                sta 0,x
.96c2		95 01		sta $01,x	                sta 1,x
.96c4		60		rts		z_zero_less:    rts
.96c5						xt_zero_unequal:
.96c5		20 f2 d7	jsr $d7f2	                jsr underflow_1
.96c8						w_zero_unequal:
.96c8		b5 00		lda $00,x	                lda 0,x
.96ca		15 01		ora $01,x	                ora 1,x
.96cc		f0 02		beq $96d0	                beq _zero
.96ce		a9 ff		lda #$ff	                lda #$FF
.96d0						_zero:
.96d0		95 00		sta $00,x	                sta 0,x
.96d2		95 01		sta $01,x	                sta 1,x
.96d4		60		rts		z_zero_unequal: rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/compile.asm

.96d5						compile_nt_comma:
.96d5		20 91 86	jsr $8691	        jsr w_dup                       ; ( nt nt )
.96d8		20 d9 9c	jsr $9cd9	        jsr w_name_to_int               ; ( nt xt )
.96db		20 91 86	jsr $8691	        jsr w_dup                       ; ( nt xt xt )
.96de		20 84 8f	jsr $8f84	        jsr w_rot                       ; ( xt xt nt )
.96e1		80 12		bra $96f5	        bra compile_comma_common
.96e3						xt_compile_comma:
.96e3		20 f2 d7	jsr $d7f2	                jsr underflow_1
.96e6						w_compile_comma:
.96e6		20 91 86	jsr $8691	                jsr w_dup               ; keep an unadjusted copy of xt
.96e9		20 91 86	jsr $8691	                jsr w_dup               ; plus one to convert to nt
.96ec		20 53 9c	jsr $9c53	                jsr w_int_to_name
.96ef		b5 00		lda $00,x	                lda 0,x
.96f1		15 01		ora $01,x	                ora 1,x
.96f3		f0 73		beq $9768	                beq cmpl_as_call        ; No nt so unknown size; must compile as a JSR
.96f5						compile_comma_common:
.96f5		20 91 86	jsr $8691	                jsr w_dup
.96f8		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; status is at nt+1
.96fb		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.96fd		e8		inx		                inx                     ; drop pointer
.96fe		e8		inx		                inx
.96ff		85 29		sta $29		                sta tmp3                ; keep copy of status byte
.9701		29 0c		and #$0c	                and #AN+NN              ; check if never native (NN)
.9703		c9 08		cmp #$08	                cmp #NN                 ; NN=1, AN=0?  i.e. not ST=AN+AN
.9705		f0 61		beq $9768	                beq cmpl_as_call
.9707		20 7b 9e	jsr $9e7b	                jsr w_wordsize
.970a		a5 29		lda $29		                lda tmp3
.970c		29 0c		and #$0c	                and #ST                 ; Check the Stack Thrash flag (ST=NN+AN)
.970e		c9 0c		cmp #$0c	                cmp #ST
.9710		d0 16		bne $9728	                bne _check_uf
=10						_strip_sz = 10  ; skip the standard 10 byte header which saves return address + 1 to tmp1
.9712		18		clc		                clc
.9713		b5 02		lda $02,x	                lda 2,x
.9715		69 0a		adc #$0a	                adc #_strip_sz
.9717		95 02		sta $02,x	                sta 2,x
.9719		90 02		bcc $971d	                bcc +
.971b		f6 03		inc $03,x	                inc 3,x                 ; we just care about the carry
.971d						+
.971d		38		sec		                sec
.971e		b5 00		lda $00,x	                lda 0,x
.9720		e9 0a		sbc #$0a	                sbc #_strip_sz
.9722		95 00		sta $00,x	                sta 0,x
.9724		b0 02		bcs $9728	                bcs +
.9726		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.9728						+
.9728						_check_uf:
.9728		a0 02		ldy #$02	                ldy #uf_strip_offset
.972a		b1 08		lda ($08),y	                lda (up),y
.972c		c8		iny		                iny
.972d		11 08		ora ($08),y	                ora (up),y
.972f		f0 1e		beq $974f	                beq _check_limit
.9731		20 03 8d	jsr $8d03	                jsr w_over
.9734		20 97 97	jsr $9797	                jsr has_uf_check
.9737		90 16		bcc $974f	                bcc _check_limit        ; not an underflow check
.9739		18		clc		                clc
.973a		b5 02		lda $02,x	                lda 2,x
.973c		69 03		adc #$03	                adc #3
.973e		95 02		sta $02,x	                sta 2,x
.9740		90 02		bcc $9744	                bcc +
.9742		f6 03		inc $03,x	                inc 3,x                  ; we just care about the carry
.9744						+
.9744		38		sec		                sec
.9745		b5 00		lda $00,x	                lda 0,x
.9747		e9 03		sbc #$03	                sbc #3
.9749		95 00		sta $00,x	                sta 0,x
.974b		b0 02		bcs $974f	                bcs +
.974d		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.974f						+
.974f						_check_limit:
.974f		a5 29		lda $29		                lda tmp3
.9751		29 0c		and #$0c	                and #AN+NN              ; check Always Native (AN) bit
.9753		c9 04		cmp #$04	                cmp #AN                 ; AN=1, NN=0?  (i.e. not ST=AN+NN)
.9755		f0 2c		beq $9783	                beq cmpl_inline         ; always natively compile
.9757						cmpl_by_limit:
.9757		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.9759		b5 01		lda $01,x	                lda 1,x                 ; MSB of word size
.975b		d1 08		cmp ($08),y	                cmp (up),y              ; user-defined limit MSB
.975d		90 24		bcc $9783	                bcc cmpl_inline         ; borrow (C=0) means size < limit
.975f		d0 07		bne $9768	                bne cmpl_as_call        ; else non-zero means size > limit
.9761		88		dey		                dey
.9762		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.9764		d5 00		cmp $00,x	                cmp 0,x
.9766		b0 1b		bcs $9783	                bcs cmpl_inline         ; not bigger, so good to go
.9768						cmpl_as_call:
.9768		a5 29		lda $29		                lda tmp3
.976a		29 0c		and #$0c	                and #ST
.976c		d0 08		bne $9776	                bne +
.976e		20 8b 86	jsr $868b	                jsr w_drop              ; no stack juggling, use middle (xt or xt')
.9771		20 32 8c	jsr $8c32	                jsr w_nip
.9774		80 03		bra $9779	                bra _cmpl
.9776						+
.9776		20 bf 93	jsr $93bf	                jsr w_two_drop          ; stack juggling, must use first (xt)
.9779						_cmpl:
.9779		a9 20		lda #$20	                lda #OpJSR
.977b		20 e4 97	jsr $97e4	                jsr cmpl_a
.977e		20 d9 83	jsr $83d9	                jsr w_comma
.9781		38		sec		                sec
.9782		60		rts		                rts
.9783						cmpl_inline:
.9783		20 0f 89	jsr $890f	                jsr w_here
.9786		20 46 92	jsr $9246	                jsr w_swap
.9789		20 91 86	jsr $8691	                jsr w_dup
.978c		20 55 82	jsr $8255	                jsr w_allot            ; allocate space for the word
.978f		20 ff 8b	jsr $8bff	                jsr w_move
.9792		20 8b 86	jsr $868b	                jsr w_drop             ; drop original xt
.9795		18		clc		                clc
.9796						z_compile_comma:
.9796		60		rts		                rts
.9797						has_uf_check:
.9797		a1 00		lda ($00,x)	                lda (0,x)               ; fetch byte @ addr
.9799		c9 20		cmp #$20	                cmp #OpJSR
.979b		d0 18		bne $97b5	                bne _not_uf             ; not a JSR
.979d		20 e7 8c	jsr $8ce7	                jsr w_one_plus
.97a0		20 11 88	jsr $8811	                jsr w_fetch             ; get JSR address to TOS
.97a3		b5 00		lda $00,x	                lda 0,x                 ; LSB of jsr address
.97a5		38		sec		                sec
.97a6		e9 f2		sbc #$f2	                sbc #<underflow_1
.97a8		a8		tay		                tay                     ; stash LSB of result and finish subtraction
.97a9		b5 01		lda $01,x	                lda 1,x                 ; MSB of jsr address
.97ab		e9 d7		sbc #$d7	                sbc #>underflow_1
.97ad		d0 06		bne $97b5	                bne _not_uf             ; MSB of result must be zero
.97af		c0 10		cpy #$10	                cpy #(underflow_4-underflow_1+1)
.97b1		b0 02		bcs $97b5	                bcs _not_uf             ; LSB is too big
.97b3		38		sec		                sec                     ; C=1 means it is an UF check
>97b4		24				                .byte OpBITzp           ; mask the clc, with no effect on carry
.97b5		18		clc		_not_uf:        clc                     ; C=0 means it isn't a UF check
.97b6		e8		inx		                inx                     ; clean up stack
.97b7		e8		inx		                inx
.97b8		60		rts		                rts
.97b9						cmpl_jump_later:
.97b9		ca		dex		                dex
.97ba		ca		dex		                dex
.97bb		a5 01		lda $01		                lda cp+1
.97bd		95 01		sta $01,x	                sta 1,x
.97bf		a5 00		lda $00		                lda cp
.97c1		1a		inc a		                inc a
.97c2		95 00		sta $00,x	                sta 0,x
.97c4		d0 0a		bne $97d0	                bne cmpl_jump
.97c6		f6 01		inc $01,x	                inc 1,x
.97c8		80 06		bra $97d0	                bra cmpl_jump
.97ca						cmpl_jump_tos:
.97ca		b5 00		lda $00,x	                lda 0,x         ; set up for cmpl_jump Y/A
.97cc		b4 01		ldy $01,x	                ldy 1,x
.97ce		e8		inx		                inx
.97cf		e8		inx		                inx
.97d0						cmpl_jump:
.97d0		48		pha		                pha             ; save LSB of address
.97d1		a9 10		lda #$10	                lda #%00010000  ; unset bit 4 to flag as never-native
.97d3		14 1c		trb $1c		                trb status
.97d5		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP
.97d7		80 03		bra $97dc	                bra +
.97d9						cmpl_subroutine:
.97d9		48		pha		                pha             ; save LSB of address
.97da		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR and fall through
.97dc						+
.97dc		20 e4 97	jsr $97e4	                jsr cmpl_a      ; compile opcode
.97df		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.97e0						cmpl_word:
.97e0		20 e4 97	jsr $97e4	                jsr cmpl_a      ; compile LSB of address
.97e3		98		tya		                tya             ; fall thru for MSB
.97e4						cmpl_a:
.97e4		92 00		sta ($00)	                sta (cp)
.97e6		e6 00		inc $00		                inc cp
.97e8		d0 02		bne $97ec	                bne _done
.97ea		e6 01		inc $01		                inc cp+1
.97ec						_done:
.97ec		60		rts		                rts
.97ed						check_nc_limit:
.97ed		48		pha		                pha
.97ee		38		sec		                sec
.97ef		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.97f1		b1 08		lda ($08),y	                lda (up),y              ; if MSB non zero we're good, leave with C=0
.97f3		f0 01		beq $97f6	                beq +
.97f5		18		clc		                clc
.97f6						+
.97f6		68		pla		                pla
.97f7		90 05		bcc $97fe	                bcc _done
.97f9		3a		dec a		                dea                     ; simplify test to A-1 < nc-limit
.97fa		88		dey		                dey
.97fb		d1 08		cmp ($08),y	                cmp (up),y              ; A-1 < LSB leaves C=0, else C=1
.97fd		1a		inc a		                ina                     ; restore A, preserves carry
.97fe						_done:
.97fe		60		rts		                rts
.97ff						cmpl_0branch_later:
.97ff		20 99 9e	jsr $9e99	                jsr w_zero             ; dummy placeholder, which forces long jmp in native version
.9802		20 14 98	jsr $9814	                jsr cmpl_0branch_tos    ; generate native or subroutine branch code
.9805		20 0f 89	jsr $890f	                jsr w_here             ; either way the target address is two bytes before here
.9808		38		sec		                sec
.9809		b5 00		lda $00,x	                lda 0,x
.980b		e9 02		sbc #$02	                sbc #2
.980d		95 00		sta $00,x	                sta 0,x
.980f		b0 02		bcs $9813	                bcs +
.9811		d6 01		dec $01,x	                dec 1,x
.9813						+
.9813		60		rts		                rts
.9814						cmpl_0branch_tos:
.9814		a9 0b		lda #$0b	                lda #ztest_runtime_size+5       ; typical size of inline form
.9816		20 ed 97	jsr $97ed	                jsr check_nc_limit              ; returns C=0 if we should native compile
.9819		90 0a		bcc $9825	                bcc _inline
.981b		a0 98		ldy #$98	                ldy #>zero_branch_runtime
.981d		a9 76		lda #$76	                lda #<zero_branch_runtime
.981f		20 d9 97	jsr $97d9	                jsr cmpl_subroutine             ; call the 0branch runtime
.9822		4c d9 83	jmp $83d9	                jmp w_comma                    ; add the payload and return
.9825						_inline:
.9825		a0 00		ldy #$00	                ldy #0
.9827						-
.9827		b9 76 98	lda $9876,y	                lda ztest_runtime,y
.982a		20 e4 97	jsr $97e4	                jsr cmpl_a
.982d		c8		iny		                iny
.982e		c0 06		cpy #$06	                cpy #ztest_runtime_size
.9830		d0 f5		bne $9827	                bne -
.9832		b5 00		lda $00,x	                lda 0,x
.9834		15 01		ora $01,x	                ora 1,x
.9836		f0 31		beq $9869	                beq _long               ; always use the long form if target is 0
.9838		20 91 86	jsr $8691	                jsr w_dup
.983b		20 0f 89	jsr $890f	                jsr w_here
.983e		18		clc		                clc
.983f		a9 02		lda #$02	                lda #2
.9841		75 00		adc $00,x	                adc 0,x
.9843		95 00		sta $00,x	                sta 0,x
.9845		90 02		bcc $9849	                bcc +
.9847		f6 01		inc $01,x	                inc 1,x
.9849						+
.9849		20 e3 8b	jsr $8be3	                jsr w_minus
.984c		e8		inx		                inx             ; pre-drop offset and use wraparound indexing to preserve flags
.984d		e8		inx		                inx
.984e		b5 ff		lda $ff,x	                lda $ff,x
.9850		a8		tay		                tay             ; Y=MSB of offset
.9851		b5 fe		lda $fe,x	                lda $fe,x       ; A=LSB, setting N flag to bit 7
.9853		30 04		bmi $9859	                bmi _minus
.9855		c0 00		cpy #$00	                cpy #0          ; if LSB is positive we need MSB = 0
.9857		80 02		bra $985b	                bra +
.9859		c0 ff		cpy #$ff	_minus:         cpy #$ff        ; if LSB is negative we need MSB = ff
.985b		d0 0c		bne $9869	+               bne _long
.985d		a9 f0		lda #$f0	                lda #OpBEQ
.985f		20 e4 97	jsr $97e4	                jsr cmpl_a
.9862		b5 fe		lda $fe,x	                lda $fe,x
.9864		e8		inx		                inx             ; drop the original address we used to calc offset
.9865		e8		inx		                inx
.9866		4c e4 97	jmp $97e4	                jmp cmpl_a
.9869						_long:
.9869		a9 d0		lda #$d0	                lda #OpBNE
.986b		20 e4 97	jsr $97e4	                jsr cmpl_a
.986e		a9 03		lda #$03	                lda #3
.9870		20 e4 97	jsr $97e4	                jsr cmpl_a
.9873		4c ca 97	jmp $97ca	                jmp cmpl_jump_tos
.9876						zero_branch_runtime:
.9876						ztest_runtime:
.9876		e8		inx		                inx
.9877		e8		inx		                inx
.9878		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.987a		15 ff		ora $ff,x	                ora $FF,x
=6						ztest_runtime_size = * - ztest_runtime
.987c						zbranch_runtime:
.987c		7a		ply		                ply
.987d		84 25		sty $25		                sty tmp1
.987f		7a		ply		                ply
.9880		84 26		sty $26		                sty tmp1+1
.9882		a8		tay		                tay             ; test if A = 0 which tells us whether to branch
.9883		f0 0d		beq $9892	                beq _branch
.9885		18		clc		                clc
.9886		a5 25		lda $25		                lda tmp1        ; LSB
.9888		69 03		adc #$03	                adc #3          ; skip two bytes plus the extra for jsr/rts behavior
.988a		85 25		sta $25		                sta tmp1
.988c		90 11		bcc $989f	                bcc _jmp
.988e		e6 26		inc $26		                inc tmp1+1
.9890		80 0d		bra $989f	                bra _jmp
.9892						_branch:
.9892		a0 01		ldy #$01	                ldy #1
.9894		b1 25		lda ($25),y	                lda (tmp1),y
.9896		48		pha		                pha                     ; stash the LSB until we've read the MSB too
.9897		c8		iny		                iny
.9898		b1 25		lda ($25),y	                lda (tmp1),y
.989a		85 26		sta $26		                sta tmp1+1              ; update tmp1 with our branch target
.989c		68		pla		                pla
.989d		85 25		sta $25		                sta tmp1
.989f						_jmp:
.989f		6c 25 00	jmp ($0025)	                jmp (tmp1)

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tools.asm

.98a2						xt_bye:
.98a2						w_bye:
.98a2		4c 21 f0	jmp $f021	                jmp kernel_bye
.98a5						z_bye:
.98a5						xt_dot_s:
.98a5						w_dot_s:
.98a5		20 40 85	jsr $8540	                jsr w_depth    ; ( -- u )
.98a8		a9 3c		lda #$3c	                lda #'<'
.98aa		20 bb 86	jsr $86bb	                jsr emit_a
.98ad		b5 00		lda $00,x	                lda 0,x
.98af		48		pha		                pha
.98b0		ca		dex		                dex             ; DUP
.98b1		ca		dex		                dex
.98b2		95 00		sta $00,x	                sta 0,x
.98b4		74 01		stz $01,x	                stz 1,x
.98b6		20 5a d8	jsr $d85a	                jsr print_u
.98b9		a9 3e		lda #$3e	                lda #'>'
.98bb		20 bb 86	jsr $86bb	                jsr emit_a
.98be		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.98c0		20 bb 86	jsr $86bb	                jsr emit_a
.98c3		e8		inx		                inx
.98c4		e8		inx		                inx
.98c5		e0 78		cpx #$78	                cpx #dsp0
.98c7		f0 1e		beq $98e7	                beq _done
.98c9		7a		ply		                ply
.98ca		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.98cc		85 29		sta $29		                sta tmp3
.98ce		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.98d0						_loop:
.98d0		ca		dex		                dex
.98d1		ca		dex		                dex
.98d2		b2 29		lda ($29)	                lda (tmp3)
.98d4		95 01		sta $01,x	                sta 1,x
.98d6		c6 29		dec $29		                dec tmp3
.98d8		b2 29		lda ($29)	                lda (tmp3)
.98da		95 00		sta $00,x	                sta 0,x
.98dc		c6 29		dec $29		                dec tmp3
.98de		5a		phy		                phy
.98df		20 21 86	jsr $8621	                jsr w_dot
.98e2		7a		ply		                ply
.98e3		88		dey		                dey
.98e4		d0 ea		bne $98d0	                bne _loop
.98e6		48		pha		                pha             ; dummy to balance stack
.98e7						_done:
.98e7		68		pla		                pla
.98e8		60		rts		z_dot_s:        rts
.98e9						xt_dump:
.98e9		20 f7 d7	jsr $d7f7	                jsr underflow_2
.98ec						w_dump:
.98ec						_row:
.98ec		b5 03		lda $03,x	                lda 3,x
.98ee		85 28		sta $28		                sta tmp2+1
.98f0		b5 02		lda $02,x	                lda 2,x
.98f2		85 27		sta $27		                sta tmp2
.98f4		20 17 84	jsr $8417	                jsr w_cr
.98f7		a0 10		ldy #$10	                ldy #16                 ; max 16
.98f9		b5 01		lda $01,x	                lda 1,x                 ; if u > 256 keep 16
.98fb		d0 09		bne $9906	                bne +
.98fd		b5 00		lda $00,x	                lda 0,x                 ; if u = 0 we're done
.98ff		f0 61		beq $9962	                beq _done
.9901		c9 10		cmp #$10	                cmp #16                 ; if u < 16 do what's left
.9903		b0 01		bcs $9906	                bcs +
.9905		a8		tay		                tay
.9906						+
.9906		84 25		sty $25		                sty tmp1                ; temporary storage for loop counter
.9908		a9 40		lda #$40	                lda #$40                ; bit 6 set on first pass and bit 7 on second
.990a		85 26		sta $26		                sta tmp1+1              ; so we can use bit tmp1+1 to check N flag
.990c		a0 01		ldy #$01	                ldy #1
.990e						-
.990e		b9 27 00	lda $0027,y	                lda tmp2,y
.9911		20 bf d6	jsr $d6bf	                jsr byte_to_ascii
.9914		88		dey		                dey
.9915		10 f7		bpl $990e	                bpl -
.9917		20 dd 91	jsr $91dd	                jsr w_space
.991a						_pass:
.991a		a0 00		ldy #$00	                ldy #0
.991c						_bytes:
.991c		98		tya		                tya
.991d		29 07		and #$07	                and #7
.991f		d0 03		bne $9924	                bne +
.9921		20 dd 91	jsr $91dd	                jsr w_space             ; extra space before bytes 0 and 8
.9924						+
.9924		b1 27		lda ($27),y	                lda (tmp2),y
.9926		24 26		bit $26		                bit tmp1+1              ; which pass are we on?
.9928		30 08		bmi $9932	                bmi _ascii              ; bit 7 set on second pass
.992a		20 bf d6	jsr $d6bf	                jsr byte_to_ascii       ; show byte value
.992d		20 dd 91	jsr $91dd	                jsr w_space
.9930		80 0a		bra $993c	                bra _nextbyte
.9932						_ascii:
.9932		20 d9 d7	jsr $d7d9	                jsr is_printable        ; show ascii char
.9935		b0 02		bcs $9939	                bcs +
.9937		a9 2e		lda #$2e	                lda #'.'                ; use dot if not printable
.9939						+
.9939		20 bb 86	jsr $86bb	                jsr emit_a
.993c						_nextbyte:
.993c		c8		iny		                iny
.993d		c4 25		cpy $25		                cpy tmp1
.993f		d0 db		bne $991c	                bne _bytes
.9941		06 26		asl $26		                asl tmp1+1              ; $40 -> $80 -> 0
.9943		f0 13		beq $9958	                beq +                   ; done both passes?
.9945		88		dey		                dey                     ; Y-1 is 0...15
.9946		98		tya		                tya
.9947		49 0f		eor #$0f	                eor #$f                 ; 15-(Y-1) is 16-Y
.9949		85 1e		sta $1e		                sta tmpdsp
.994b		0a		asl a		                asl a                   ; A is 2*(16-Y)
.994c		c9 10		cmp #$10	                cmp #16
.994e		65 1e		adc $1e		                adc tmpdsp              ; 3*(16-Y) + 1 if Y<9
.9950		20 a7 a4	jsr $a4a7	                jsr push_a_tos
.9953		20 e6 91	jsr $91e6	                jsr w_spaces
.9956		80 c2		bra $991a	                bra _pass
.9958						+
.9958		a5 25		lda $25		                lda tmp1
.995a		20 a7 a4	jsr $a4a7	                jsr push_a_tos
.995d		20 42 a2	jsr $a242	                jsr w_slash_string      ; ( addr n k -- addr+k n-k )
.9960		80 8a		bra $98ec	                bra _row                ; new row
.9962						_done:
.9962		e8		inx		                inx
.9963		e8		inx		                inx
.9964		e8		inx		                inx
.9965		e8		inx		                inx
.9966		60		rts		z_dump:         rts
.9967						xt_question:
.9967						w_question:
.9967		20 11 88	jsr $8811	                jsr w_fetch
.996a		20 21 86	jsr $8621	                jsr w_dot
.996d		60		rts		z_question:     rts
.996e						xt_see:
.996e						w_see:
.996e		20 4c 8d	jsr $8d4c	                jsr w_parse_name       ; ( addr u )
.9971		20 85 9b	jsr $9b85	                jsr w_find_name        ; ( nt | 0 )
.9974		b5 00		lda $00,x	                lda 0,x
.9976		15 01		ora $01,x	                ora 1,x
.9978		d0 05		bne $997f	                bne +
.997a		a9 05		lda #$05	                lda #err_noname
.997c		4c 08 d8	jmp $d808	                jmp error
.997f						+
.997f		20 17 84	jsr $8417	                jsr w_cr
.9982		a5 18		lda $18		                lda base
.9984		48		pha		                pha
.9985		20 1a 89	jsr $891a	                jsr w_hex
.9988		a9 07		lda #$07	                lda #str_see_nt
.998a		20 2e d8	jsr $d82e	                jsr print_string_no_lf
.998d		20 91 86	jsr $8691	                jsr w_dup              ; ( nt nt )
.9990		20 07 95	jsr $9507	                jsr w_u_dot
.9993		20 dd 91	jsr $91dd	                jsr w_space            ; ( nt )
.9996		20 91 86	jsr $8691	                jsr w_dup              ; ( nt nt )
.9999		20 d9 9c	jsr $9cd9	                jsr w_name_to_int      ; ( nt xt )
.999c		a9 08		lda #$08	                lda #str_see_xt
.999e		20 2e d8	jsr $d82e	                jsr print_string_no_lf
.99a1		20 91 86	jsr $8691	                jsr w_dup              ; ( nt xt xt )
.99a4		20 07 95	jsr $9507	                jsr w_u_dot
.99a7		20 17 84	jsr $8417	                jsr w_cr               ; ( nt xt )
.99aa		20 03 8d	jsr $8d03	                jsr w_over              ; ( nt xt nt )
.99ad		20 e7 8c	jsr $8ce7	                jsr w_one_plus          ; ( nt xt nt+1 )
.99b0		a1 00		lda ($00,x)	                lda (0,x)
.99b2		95 00		sta $00,x	                sta 0,x                 ; stash status flag byte
.99b4		74 01		stz $01,x	                stz 1,x                 ; placeholder for synthetic flags
.99b6		48		pha		                pha                     ; save a copy of flags for later
.99b7		29 0c		and #$0c	                and #ST                 ; calculate ST flag
.99b9		c9 0c		cmp #$0c	                cmp #ST
.99bb		f0 01		beq $99be	                beq +                   ; C=1 when ST set
.99bd		18		clc		                clc
.99be						+
.99be		36 01		rol $01,x	                rol 1,x                 ; add to flag byte
.99c0		20 03 8d	jsr $8d03	                jsr w_over
.99c3		20 97 97	jsr $9797	                jsr has_uf_check        ; C=1 when UF set
.99c6		36 01		rol $01,x	                rol 1,x                 ; add to flag byte
.99c8		a9 05		lda #$05	                lda #N_FLAGS            ; count off status byte flags
.99ca		85 23		sta $23		                sta tmptos
.99cc		a9 e4		lda #$e4	                lda #<see_flags_template
.99ce		85 29		sta $29		                sta tmp3                ; LSB
.99d0		a9 d3		lda #$d3	                lda #>see_flags_template
.99d2		85 2a		sta $2a		                sta tmp3+1              ; MSB
.99d4		a0 00		ldy #$00	                ldy #0                  ; index the string
.99d6						_loop:
.99d6		b1 29		lda ($29),y	                lda (tmp3),y            ; next char in template
.99d8		10 04		bpl $99de	                bpl +                   ; end of string?
.99da		a0 ff		ldy #$ff	                ldy #$ff                ; flag end of loop
.99dc		29 7f		and #$7f	                and #$7f                ; clear high bit of A to get last character
.99de						+
.99de		d0 16		bne $99f6	                bne _emit               ; flag placeholder?
.99e0		20 dd 91	jsr $91dd	                jsr w_space             ; no stack effect
.99e3		c6 23		dec $23		                dec tmptos
.99e5		30 04		bmi $99eb	                bmi _synthetic          ; more core status flags?
.99e7		56 00		lsr $00,x	                lsr 0,x                 ; shift next flag bit into carry
.99e9		80 02		bra $99ed	                bra +
.99eb						_synthetic:
.99eb		56 01		lsr $01,x	                lsr 1,x                 ; show synthetic flags after core ones
.99ed						+
.99ed		a9 30		lda #$30	                lda #'0'                ; convert C=0/1 into '0' or '1'
.99ef		69 00		adc #$00	                adc #0
.99f1		20 bb 86	jsr $86bb	                jsr emit_a              ; write the flag digit
.99f4		a9 20		lda #$20	                lda #' '                ; fall through and add trailing space
.99f6						_emit:
.99f6		20 bb 86	jsr $86bb	                jsr emit_a
.99f9		c8		iny		                iny
.99fa		d0 da		bne $99d6	                bne _loop
.99fc		20 17 84	jsr $8417	                jsr w_cr
.99ff		e8		inx		                inx
.9a00		e8		inx		                inx                     ; ( nt xt )
.9a01		a9 09		lda #$09	                lda #str_see_size
.9a03		20 2e d8	jsr $d82e	                jsr print_string_no_lf
.9a06		20 46 92	jsr $9246	                jsr w_swap              ; ( xt nt )
.9a09		20 7b 9e	jsr $9e7b	                jsr w_wordsize          ; ( xt u )
.9a0c		20 91 86	jsr $8691	                jsr w_dup               ; ( xt u u )
.9a0f		20 0d 85	jsr $850d	                jsr w_decimal
.9a12		68		pla		                pla                     ; fetch flag byte we saved earlier
.9a13		29 10		and #$10	                and #HC                 ; does it have CFA?
.9a15		48		pha		                pha                     ; we'll need to check once more
.9a16		f0 0c		beq $9a24	                beq +
.9a18		a9 0a		lda #$0a	                lda #str_see_cfapfa
.9a1a		20 2e d8	jsr $d82e	                jsr print_string_no_lf  ; print "CFA: 3  PFA: "
.9a1d		38		sec		                sec
.9a1e		b5 00		lda $00,x	                lda 0,x                 ; reduce to u-3
.9a20		e9 03		sbc #$03	                sbc #3
.9a22		95 00		sta $00,x	                sta 0,x                 ; assume u < 256
.9a24						+
.9a24		20 07 95	jsr $9507	                jsr w_u_dot             ; print u (or u-3 for PFA)
.9a27		20 17 84	jsr $8417	                jsr w_cr
.9a2a		20 c7 93	jsr $93c7	                jsr w_two_dup           ; ( xt u xt u )
.9a2d		20 1a 89	jsr $891a	                jsr w_hex
.9a30		20 ec 98	jsr $98ec	                jsr w_dump
.9a33		68		pla		                pla                     ; recover HC flag
.9a34		f0 06		beq $9a3c	                beq +
.9a36		a9 03		lda #$03	                lda #3
.9a38		95 00		sta $00,x	                sta 0,x                 ; for CFA words, just show three bytes
.9a3a		74 01		stz $01,x	                stz 1,x
.9a3c						+
.9a3c		20 b0 a2	jsr $a2b0	                jsr w_disasm
.9a3f		68		pla		                pla
.9a40		85 18		sta $18		                sta base
.9a42		60		rts		z_see:          rts
.9a43						xt_words:
.9a43						w_words:
.9a43		20 17 84	jsr $8417	                jsr w_cr
.9a46		a9 00		lda #$00	                lda #0
.9a48		48		pha		                pha
.9a49		ca		dex		                dex                     ; Make room on the stack for
.9a4a		ca		dex		                dex                     ; a dictionary pointer.
.9a4b		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.9a4d						_wordlist_loop:
.9a4d		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.9a4f		a5 29		lda $29		                lda tmp3
.9a51		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.9a53		d0 02		bne $9a57	                bne _have_wordlist
.9a55		80 45		bra $9a9c	                bra _words_done
.9a57						_have_wordlist:
.9a57		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.9a58		69 23		adc #$23	                adc #search_order_offset
.9a5a		a8		tay		                tay
.9a5b		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.9a5d		0a		asl a		                asl                     ; Turn offset into cells offset.
.9a5e		18		clc		                clc
.9a5f		69 0a		adc #$0a	                adc #wordlists_offset
.9a61		a8		tay		                tay
.9a62		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9a64		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.9a66		c8		iny		                iny
.9a67		b1 08		lda ($08),y	                lda (up),y
.9a69		95 01		sta $01,x	                sta 1,x
.9a6b						_loop:
.9a6b		20 91 86	jsr $8691	                jsr w_dup              ; ( nt nt )
.9a6e		20 f6 9c	jsr $9cf6	                jsr w_name_to_string   ; ( nt addr u )
.9a71		68		pla		                pla
.9a72		18		clc		                clc
.9a73		75 00		adc $00,x	                adc 0,x
.9a75		1a		inc a		                ina                     ; don't forget the space between words
.9a76		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.9a78		90 06		bcc $9a80	                bcc +
.9a7a		20 17 84	jsr $8417	                jsr w_cr
.9a7d		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.9a7f		1a		inc a		                ina                     ; with length of this word.
.9a80						+
.9a80		48		pha		                pha
.9a81		20 dc 94	jsr $94dc	                jsr w_type             ; ( nt )
.9a84		a9 20		lda #$20	                lda #AscSP
.9a86		20 bb 86	jsr $86bb	                jsr emit_a
.9a89		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; 1+
.9a8c		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; 1+
.9a8f		20 11 88	jsr $8811	                jsr w_fetch            ; @ ( nt+1 )
.9a92		b5 00		lda $00,x	                lda 0,x
.9a94		15 01		ora $01,x	                ora 1,x
.9a96		d0 d3		bne $9a6b	                bne _loop
.9a98		e6 29		inc $29		                inc tmp3
.9a9a		80 b1		bra $9a4d	                bra _wordlist_loop
.9a9c						_words_done:
.9a9c		68		pla		                pla                     ; dump counter
.9a9d		e8		inx		                inx
.9a9e		e8		inx		                inx
.9a9f		60		rts		z_words:        rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tali.asm

.9aa0						xt_allow_native:
.9aa0						w_allow_native:
.9aa0		20 4b d7	jsr $d74b	                jsr current_to_dp
.9aa3		a0 01		ldy #$01	                ldy #1          ; offset for header flag byte
.9aa5		b1 02		lda ($02),y	                lda (dp),y
.9aa7		29 f3		and #$f3	                and #$FF-NN-AN  ; AN and NN flag is clear.
.9aa9		91 02		sta ($02),y	                sta (dp),y
.9aab						z_allow_native:
.9aab		60		rts		                rts
.9aac						xt_always_native:
.9aac						w_always_native:
.9aac		20 4b d7	jsr $d74b	                jsr current_to_dp
.9aaf		a0 01		ldy #$01	                ldy #1          ; offset for header flag byte
.9ab1		b1 02		lda ($02),y	                lda (dp),y
.9ab3		09 04		ora #$04	                ora #AN         ; Make sure AN flag is set
.9ab5		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.9ab7		91 02		sta ($02),y	                sta (dp),y
.9ab9						z_always_native:
.9ab9		60		rts		                rts
.9aba						xt_bell:
.9aba						w_bell:
.9aba		a9 07		lda #$07	                lda #7          ; ASCII value for BELL (aka ctrl-G)
.9abc		20 bb 86	jsr $86bb	                jsr emit_a
.9abf		60		rts		z_bell:         rts
.9ac0						xt_bounds:
.9ac0		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9ac3						w_bounds:
.9ac3		18		clc		                clc
.9ac4		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.9ac6		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.9ac8		75 02		adc $02,x	                adc 2,x
.9aca		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.9acc		94 00		sty $00,x	                sty 0,x
.9ace		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.9ad0		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.9ad2		75 03		adc $03,x	                adc 3,x
.9ad4		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.9ad6		94 01		sty $01,x	                sty 1,x
.9ad8		60		rts		z_bounds:       rts
.9ad9						xt_cleave:
.9ad9		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9adc						w_cleave:
.9adc		20 4d a1	jsr $a14d	                jsr w_minus_leading    ; -LEADING ( addr u )
.9adf		20 3a 9c	jsr $9c3a	                jsr w_input_to_r       ; save old imput state
.9ae2		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.9ae4		85 0e		sta $0e		                sta ciblen
.9ae6		b5 01		lda $01,x	                lda 1,x
.9ae8		85 0f		sta $0f		                sta ciblen+1
.9aea		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.9aec		85 0c		sta $0c		                sta cib
.9aee		b5 03		lda $03,x	                lda 3,x
.9af0		85 0d		sta $0d		                sta cib+1
.9af2		64 10		stz $10		                stz toin        ; >IN pointer is zero
.9af4		64 11		stz $11		                stz toin+1
.9af6		20 4c 8d	jsr $8d4c	                jsr w_parse_name       ; ( addr u addr-s u-s )
.9af9		b5 00		lda $00,x	                lda 0,x
.9afb		15 01		ora $01,x	                ora 1,x
.9afd		f0 23		beq $9b22	                beq _done
.9aff		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.9b01		38		sec		                sec
.9b02		f5 00		sbc $00,x	                sbc 0,x
.9b04		95 04		sta $04,x	                sta 4,x
.9b06		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.9b08		f5 01		sbc $01,x	                sbc 1,x
.9b0a		95 05		sta $05,x	                sta 5,x
.9b0c		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.9b0e		18		clc		                clc
.9b0f		75 00		adc $00,x	                adc 0,x
.9b11		95 06		sta $06,x	                sta 6,x
.9b13		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.9b15		75 01		adc $01,x	                adc 1,x
.9b17		95 07		sta $07,x	                sta 7,x
.9b19		20 98 94	jsr $9498	                jsr w_two_swap         ; ( addr-s u-s addr u )
.9b1c		20 4d a1	jsr $a14d	                jsr w_minus_leading
.9b1f		20 98 94	jsr $9498	                jsr w_two_swap         ; ( addr u addr-s u-s )
.9b22						_done:
.9b22		20 47 9e	jsr $9e47	                jsr w_r_to_input
.9b25		60		rts		z_cleave:       rts
.9b26						xt_digit_question:
.9b26		20 f2 d7	jsr $d7f2	                jsr underflow_1
.9b29						w_digit_question:
.9b29		ca		dex		                dex
.9b2a		ca		dex		                dex
.9b2b		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.9b2d		74 01		stz $01,x	                stz 1,x
.9b2f		74 03		stz $03,x	                stz 3,x                 ; paranoid
.9b31		b5 02		lda $02,x	                lda 2,x
.9b33		c9 30		cmp #$30	                cmp #'0'
.9b35		90 23		bcc $9b5a	                bcc _done               ; failure flag already set
.9b37		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.9b39		90 12		bcc $9b4d	                bcc _checkbase
.9b3b		c9 41		cmp #$41	                cmp #'A'
.9b3d		90 1b		bcc $9b5a	                bcc _done               ; failure flag is already set
.9b3f		c9 61		cmp #$61	                cmp #'a'
.9b41		90 07		bcc $9b4a	                bcc _case_done          ; not lower case, too low
.9b43		c9 7b		cmp #$7b	                cmp #'z'+1
.9b45		b0 03		bcs $9b4a	                bcs _case_done          ; not lower case, too high
.9b47		18		clc		                clc                     ; just right
.9b48		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.9b4a						_case_done:
.9b4a		38		sec		                sec
.9b4b		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.9b4d						_checkbase:
.9b4d		38		sec		                sec
.9b4e		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.9b50		c5 18		cmp $18		                cmp base
.9b52		b0 06		bcs $9b5a	                bcs _done               ; already have false flag
.9b54		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.9b56		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.9b58		d6 01		dec $01,x	                dec 1,x
.9b5a						_done:
.9b5a						z_digit_question:
.9b5a		60		rts		                rts
.9b5b						xt_execute_parsing:
.9b5b		20 fc d7	jsr $d7fc	                jsr underflow_3
.9b5e						w_execute_parsing:
.9b5e		20 3a 9c	jsr $9c3a	                jsr w_input_to_r       ; save normal input for later
.9b61		20 20 9d	jsr $9d20	                jsr w_not_rot          ; -ROT ( xt addr u )
.9b64		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.9b66		85 0e		sta $0e		                sta ciblen
.9b68		b5 01		lda $01,x	                lda 1,x
.9b6a		85 0f		sta $0f		                sta ciblen+1
.9b6c		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.9b6e		85 0c		sta $0c		                sta cib
.9b70		b5 03		lda $03,x	                lda 3,x
.9b72		85 0d		sta $0d		                sta cib+1
.9b74		64 10		stz $10		                stz toin                ; Set >IN to zero
.9b76		64 11		stz $11		                stz toin+1
.9b78		20 bf 93	jsr $93bf	                jsr w_two_drop         ; 2DROP ( xt )
.9b7b		20 fc 87	jsr $87fc	                jsr w_execute
.9b7e		20 47 9e	jsr $9e47	                jsr w_r_to_input
.9b81						z_execute_parsing:
.9b81		60		rts		                rts
.9b82						xt_find_name:
.9b82		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9b85						w_find_name:
.9b85		b5 00		lda $00,x	                lda 0,x
.9b87		15 01		ora $01,x	                ora 1,x
.9b89		d0 03		bne $9b8e	                bne _nonempty
.9b8b		4c ca 9b	jmp $9bca	                jmp _fail_done
.9b8e						_nonempty:
.9b8e		ca		dex		                dex
.9b8f		ca		dex		                dex
.9b90		a9 1f		lda #$1f	                lda #31
.9b92		95 00		sta $00,x	                sta 0,x
.9b94		74 01		stz $01,x	                stz 1,x
.9b96		20 c7 8b	jsr $8bc7	                jsr w_min
.9b99		64 29		stz $29		                stz tmp3                ; Start at the beginning
.9b9b						_wordlist_loop:
.9b9b		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9b9d		a5 29		lda $29		                lda tmp3
.9b9f		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.9ba1		f0 27		beq $9bca	                beq _fail_done
.9ba3		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9ba4		69 23		adc #$23	                adc #search_order_offset
.9ba6		a8		tay		                tay
.9ba7		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.9ba9		0a		asl a		                asl                     ; Turn offset into cells offset.
.9baa		18		clc		                clc
.9bab		69 0a		adc #$0a	                adc #wordlists_offset
.9bad		a8		tay		                tay
.9bae		b1 08		lda ($08),y	                lda (up),y
.9bb0		85 25		sta $25		                sta tmp1
.9bb2		c8		iny		                iny
.9bb3		b1 08		lda ($08),y	                lda (up),y
.9bb5		85 26		sta $26		                sta tmp1+1
.9bb7		20 d6 d6	jsr $d6d6	                jsr find_header_name
.9bba		d0 04		bne $9bc0	                bne _success
.9bbc		e6 29		inc $29		                inc tmp3
.9bbe		80 db		bra $9b9b	                bra _wordlist_loop
.9bc0						_success:
.9bc0		a5 25		lda $25		                lda tmp1
.9bc2		95 02		sta $02,x	                sta 2,x
.9bc4		a5 26		lda $26		                lda tmp1+1
.9bc6		95 03		sta $03,x	                sta 3,x
.9bc8		80 04		bra $9bce	                bra _done
.9bca						_fail_done:
.9bca		74 02		stz $02,x	                stz 2,x         ; failure flag
.9bcc		74 03		stz $03,x	                stz 3,x
.9bce						_done:
.9bce		e8		inx		                inx
.9bcf		e8		inx		                inx
.9bd0		60		rts		z_find_name:    rts
.9bd1						xt_havekey:
.9bd1						w_havekey:
.9bd1		ca		dex		                dex
.9bd2		ca		dex		                dex
.9bd3		a9 16		lda #$16	                lda #<havekey
.9bd5		95 00		sta $00,x	                sta 0,x
.9bd7		a9 00		lda #$00	                lda #>havekey
.9bd9		95 01		sta $01,x	                sta 1,x
.9bdb		60		rts		z_havekey:      rts
.9bdc						xt_hexstore:
.9bdc		20 fc d7	jsr $d7fc	                jsr underflow_3
.9bdf						w_hexstore:
.9bdf		20 91 86	jsr $8691	                jsr w_dup              ; Save copy of original address
.9be2		20 b9 94	jsr $94b9	                jsr w_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9be5						_loop:
.9be5		b5 00		lda $00,x	                lda 0,x
.9be7		15 01		ora $01,x	                ora 1,x
.9be9		f0 36		beq $9c21	                beq _done
.9beb		20 dc 9a	jsr $9adc	                jsr w_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9bee		20 b9 94	jsr $94b9	                jsr w_two_to_r
.9bf1		20 99 9e	jsr $9e99	                jsr w_zero
.9bf4		20 99 9e	jsr $9e99	                jsr w_zero
.9bf7		20 3f 94	jsr $943f	                jsr w_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9bfa		20 e4 92	jsr $92e4	                jsr w_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9bfd		b5 00		lda $00,x	                lda 0,x
.9bff		15 01		ora $01,x	                ora 1,x
.9c01		d0 17		bne $9c1a	                bne _have_chars_left
.9c03		20 bf 93	jsr $93bf	                jsr w_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9c06		20 e5 9e	jsr $9ee5	                jsr w_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9c09		20 c6 8e	jsr $8ec6	                jsr w_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9c0c		20 65 83	jsr $8365	                jsr w_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9c0f		20 dd 8e	jsr $8edd	                jsr w_r_from           ; R>
.9c12		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; 1+
.9c15		20 81 93	jsr $9381	                jsr w_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9c18		80 cb		bra $9be5	                bra _loop
.9c1a						_have_chars_left:
.9c1a		8a		txa		                txa
.9c1b		18		clc		                clc
.9c1c		69 08		adc #$08	                adc #8
.9c1e		aa		tax		                tax
.9c1f		80 c4		bra $9be5	                bra _loop
.9c21						_done:
.9c21		e8		inx		                inx
.9c22		e8		inx		                inx
.9c23		e8		inx		                inx
.9c24		e8		inx		                inx                     ; 2DROP
.9c25		20 3f 94	jsr $943f	                jsr w_two_r_from       ; ( addr2+n addr2 )
.9c28		20 46 92	jsr $9246	                jsr w_swap
.9c2b		20 e3 8b	jsr $8be3	                jsr w_minus            ; ( n )
.9c2e		60		rts		z_hexstore:     rts
.9c2f						xt_input:
.9c2f						w_input:
.9c2f		ca		dex		                dex
.9c30		ca		dex		                dex
.9c31		a9 14		lda #$14	                lda #<input
.9c33		95 00		sta $00,x	                sta 0,x
.9c35		a9 00		lda #$00	                lda #>input
.9c37		95 01		sta $01,x	                sta 1,x
.9c39		60		rts		z_input:        rts
.9c3a						xt_input_to_r:
.9c3a						w_input_to_r:
.9c3a		68		pla		                pla
.9c3b		85 25		sta $25		                sta tmp1
.9c3d		68		pla		                pla
.9c3e		85 26		sta $26		                sta tmp1+1
.9c40		a0 07		ldy #$07	                ldy #7
.9c42						_loop:
.9c42		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9c45		48		pha		                pha
.9c46		88		dey		                dey
.9c47		10 f9		bpl $9c42	                bpl _loop
.9c49		a5 26		lda $26		                lda tmp1+1
.9c4b		48		pha		                pha
.9c4c		a5 25		lda $25		                lda tmp1
.9c4e		48		pha		                pha
.9c4f		60		rts		z_input_to_r: 	rts
.9c50						xt_int_to_name:
.9c50		20 f2 d7	jsr $d7f2	                jsr underflow_1
.9c53						w_int_to_name:
.9c53		ca		dex		                dex
.9c54		ca		dex		                dex
.9c55		74 00		stz $00,x	                stz 0,x
.9c57		74 01		stz $01,x	                stz 1,x
.9c59						_wordlist_loop:
.9c59		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9c5b		0a		asl a		                asl                     ; Turn offset into cells offset.
.9c5c		18		clc		                clc
.9c5d		69 0a		adc #$0a	                adc #wordlists_offset
.9c5f		a8		tay		                tay
.9c60		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9c62		85 27		sta $27		                sta tmp2                ; into tmp2
.9c64		c8		iny		                iny
.9c65		b1 08		lda ($08),y	                lda (up),y
.9c67		85 28		sta $28		                sta tmp2+1
.9c69		a5 27		lda $27		                lda tmp2
.9c6b		05 28		ora $28		                ora tmp2+1
.9c6d		f0 36		beq $9ca5	                beq _next_wordlist
.9c6f		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9c71		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9c73		b5 03		lda $03,x	                lda 3,x
.9c75		85 2a		sta $2a		                sta tmp3+1
.9c77						_loop:
.9c77		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9c79		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.9c7b		c5 29		cmp $29		                cmp tmp3
.9c7d		d0 07		bne $9c86	                bne _no_match
.9c7f		c8		iny		                iny
.9c80		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9c82		c5 2a		cmp $2a		                cmp tmp3+1
.9c84		f0 30		beq $9cb6	                beq _match
.9c86						_no_match:
.9c86		18		clc		                clc
.9c87		a5 27		lda $27		                lda tmp2
.9c89		69 02		adc #$02	                adc #2
.9c8b		85 27		sta $27		                sta tmp2
.9c8d		90 02		bcc $9c91	                bcc +
.9c8f		e6 28		inc $28		                inc tmp2+1
.9c91						+
.9c91		a0 00		ldy #$00	                ldy #0
.9c93		b1 27		lda ($27),y	                lda (tmp2),y
.9c95		48		pha		                pha
.9c96		c8		iny		                iny
.9c97		11 27		ora ($27),y	                ora (tmp2),y
.9c99		f0 09		beq $9ca4	                beq _zero
.9c9b		b1 27		lda ($27),y	                lda (tmp2),y
.9c9d		85 28		sta $28		                sta tmp2+1
.9c9f		68		pla		                pla
.9ca0		85 27		sta $27		                sta tmp2
.9ca2		80 d3		bra $9c77	                bra _loop
.9ca4						_zero:
.9ca4		68		pla		                pla             ; Leftover from above loop
.9ca5						_next_wordlist:
.9ca5		b5 00		lda $00,x	                lda 0,x
.9ca7		1a		inc a		                ina
.9ca8		95 00		sta $00,x	                sta 0,x
.9caa		c9 0c		cmp #$0c	                cmp #max_wordlists
.9cac		d0 ab		bne $9c59	                bne _wordlist_loop
.9cae		e8		inx		                inx
.9caf		e8		inx		                inx
.9cb0		74 00		stz $00,x	                stz 0,x
.9cb2		74 01		stz $01,x	                stz 1,x
.9cb4		80 0a		bra $9cc0	                bra z_int_to_name
.9cb6						_match:
.9cb6		e8		inx		                inx
.9cb7		e8		inx		                inx
.9cb8		a5 27		lda $27		                lda tmp2
.9cba		95 00		sta $00,x	                sta 0,x
.9cbc		a5 28		lda $28		                lda tmp2+1
.9cbe		95 01		sta $01,x	                sta 1,x
.9cc0		60		rts		z_int_to_name:  rts
.9cc1						xt_latestnt:
.9cc1						w_latestnt:
.9cc1		ca		dex		                dex
.9cc2		ca		dex		                dex
.9cc3		20 4b d7	jsr $d74b	                jsr current_to_dp
.9cc6		a5 02		lda $02		                lda dp
.9cc8		95 00		sta $00,x	                sta 0,x
.9cca		a5 03		lda $03		                lda dp+1
.9ccc		95 01		sta $01,x	                sta 1,x
.9cce		60		rts		z_latestnt:     rts
.9ccf						xt_latestxt:
.9ccf						w_latestxt:
.9ccf		20 c1 9c	jsr $9cc1	                jsr w_latestnt         ; ( nt )
.9cd2		20 d9 9c	jsr $9cd9	                jsr w_name_to_int      ; ( xt )
.9cd5		60		rts		z_latestxt:     rts
.9cd6						xt_name_to_int:
.9cd6		20 f2 d7	jsr $d7f2	                jsr underflow_1
.9cd9						w_name_to_int:
.9cd9		b5 00		lda $00,x	                lda 0,x
.9cdb		18		clc		                clc
.9cdc		69 04		adc #$04	                adc #4
.9cde		85 29		sta $29		                sta tmp3
.9ce0		b5 01		lda $01,x	                lda 1,x
.9ce2		90 01		bcc $9ce5	                bcc _done
.9ce4		1a		inc a		                ina
.9ce5						_done:
.9ce5		85 2a		sta $2a		                sta tmp3+1
.9ce7		a0 00		ldy #$00	                ldy #0
.9ce9		b1 29		lda ($29),y	                lda (tmp3),y
.9ceb		95 00		sta $00,x	                sta 0,x
.9ced		c8		iny		                iny
.9cee		b1 29		lda ($29),y	                lda (tmp3),y
.9cf0		95 01		sta $01,x	                sta 1,x
.9cf2		60		rts		z_name_to_int:  rts
.9cf3						xt_name_to_string:
.9cf3		20 f2 d7	jsr $d7f2	                jsr underflow_1
.9cf6						w_name_to_string:
.9cf6		ca		dex		                dex
.9cf7		ca		dex		                dex
.9cf8		a1 02		lda ($02,x)	                lda (2,x)
.9cfa		95 00		sta $00,x	                sta 0,x
.9cfc		74 01		stz $01,x	                stz 1,x
.9cfe		b5 02		lda $02,x	                lda 2,x         ; LSB
.9d00		18		clc		                clc
.9d01		69 08		adc #$08	                adc #8
.9d03		95 02		sta $02,x	                sta 2,x
.9d05		90 02		bcc $9d09	                bcc z_name_to_string
.9d07		f6 03		inc $03,x	                inc 3,x         ; MSB
.9d09						z_name_to_string:
.9d09		60		rts		                rts
.9d0a						xt_nc_limit:
.9d0a						w_nc_limit:
.9d0a		a9 00		lda #$00	                lda #nc_limit_offset
.9d0c		4c b0 d6	jmp $d6b0	                jmp push_upvar_tos
.9d0f						z_nc_limit:
.9d0f						xt_never_native:
.9d0f						w_never_native:
.9d0f		20 4b d7	jsr $d74b	                jsr current_to_dp
.9d12		a0 01		ldy #$01	                ldy #1          ; offset for header flag byte
.9d14		b1 02		lda ($02),y	                lda (dp),y
.9d16		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9d18		29 fb		and #$fb	                and #$FF-AN     ; and AN flag is clear.
.9d1a		91 02		sta ($02),y	                sta (dp),y
.9d1c						z_never_native:
.9d1c		60		rts		                rts
.9d1d						xt_not_rot:
.9d1d		20 fc d7	jsr $d7fc	                jsr underflow_3
.9d20						w_not_rot:
.9d20		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9d22		b5 03		lda $03,x	                lda 3,x
.9d24		95 01		sta $01,x	                sta 1,x
.9d26		b5 05		lda $05,x	                lda 5,x
.9d28		95 03		sta $03,x	                sta 3,x
.9d2a		94 05		sty $05,x	                sty 5,x
.9d2c		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9d2e		b5 02		lda $02,x	                lda 2,x
.9d30		95 00		sta $00,x	                sta 0,x
.9d32		b5 04		lda $04,x	                lda 4,x
.9d34		95 02		sta $02,x	                sta 2,x
.9d36		94 04		sty $04,x	                sty 4,x
.9d38		60		rts		z_not_rot:      rts
.9d39						xt_number:
.9d39		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9d3c						w_number:
.9d3c		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.9d3e		a5 18		lda $18		                lda base
.9d40		48		pha		                pha
.9d41		20 c7 93	jsr $93c7	                jsr w_two_dup
.9d44		a1 02		lda ($02,x)	                lda (2,x)
.9d46		c9 23		cmp #$23	                cmp #'#'                ; decimal?
.9d48		d0 04		bne $9d4e	                bne _check_hex
.9d4a		a9 0a		lda #$0a	                lda #10
.9d4c		80 42		bra $9d90	                bra _base_changed
.9d4e						_check_hex:
.9d4e		c9 24		cmp #$24	                cmp #'$'
.9d50		d0 04		bne $9d56	                bne _check_binary
.9d52		a9 10		lda #$10	                lda #16
.9d54		80 3a		bra $9d90	                bra _base_changed
.9d56						_check_binary:
.9d56		c9 25		cmp #$25	                cmp #'%'
.9d58		d0 04		bne $9d5e	                bne _check_char
.9d5a		a9 02		lda #$02	                lda #2
.9d5c		80 32		bra $9d90	                bra _base_changed
.9d5e						_check_char:
.9d5e		c9 27		cmp #$27	                cmp #"'"
.9d60		d0 3a		bne $9d9c	                bne _check_minus
.9d62		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9d64		c9 03		cmp #$03	                cmp #3
.9d66		d0 26		bne $9d8e	                bne _not_a_char
.9d68		b5 01		lda $01,x	                lda 1,x
.9d6a		d0 22		bne $9d8e	                bne _not_a_char ; No compare needed to check for non-zero.
.9d6c		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9d6e		18		clc		                clc
.9d6f		69 02		adc #$02	                adc #2          ; length of string
.9d71		85 23		sta $23		                sta tmptos
.9d73		b5 03		lda $03,x	                lda 3,x
.9d75		69 00		adc #$00	                adc #0          ; only need carry
.9d77		85 24		sta $24		                sta tmptos+1
.9d79		b2 23		lda ($23)	                lda (tmptos)
.9d7b		c9 27		cmp #$27	                cmp #"'"
.9d7d		d0 0f		bne $9d8e	                bne _not_a_char
.9d7f		f6 02		inc $02,x	                inc 2,x
.9d81		d0 02		bne $9d85	                bne +
.9d83		f6 03		inc $03,x	                inc 3,x
.9d85						+
.9d85		a1 02		lda ($02,x)	                lda (2,x)
.9d87		95 02		sta $02,x	                sta 2,x
.9d89		74 03		stz $03,x	                stz 3,x
.9d8b		4c 0e 9e	jmp $9e0e	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9d8e						_not_a_char:
.9d8e		80 5c		bra $9dec	                bra _number_error
.9d90						_base_changed:
.9d90		85 18		sta $18		                sta base        ; Switch to the new base
.9d92		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9d94		d0 02		bne $9d98	                bne +
.9d96		f6 03		inc $03,x	                inc 3,x
.9d98						+
.9d98		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d9a		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9d9c						_check_minus:
.9d9c		c9 2d		cmp #$2d	                cmp #'-'
.9d9e		d0 0c		bne $9dac	                bne _check_dot
.9da0		a9 80		lda #$80	                lda #$80
.9da2		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.9da4		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9da6		d0 02		bne $9daa	                bne +
.9da8		f6 03		inc $03,x	                inc 3,x
.9daa						+
.9daa		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9dac						_check_dot:
.9dac		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9dae		18		clc		                clc
.9daf		75 00		adc $00,x	                adc 0,x         ; length of string
.9db1		85 23		sta $23		                sta tmptos
.9db3		b5 03		lda $03,x	                lda 3,x
.9db5		69 00		adc #$00	                adc #0          ; only need carry
.9db7		85 24		sta $24		                sta tmptos+1
.9db9		a5 23		lda $23		                lda tmptos
.9dbb		d0 02		bne $9dbf	                bne +
.9dbd		c6 24		dec $24		                dec tmptos+1
.9dbf						+
.9dbf		c6 23		dec $23		                dec tmptos
.9dc1		b2 23		lda ($23)	                lda (tmptos)
.9dc3		c9 2e		cmp #$2e	                cmp #'.'
.9dc5		d0 04		bne $9dcb	                bne _main
.9dc7		e6 1e		inc $1e		                inc tmpdsp
.9dc9		d6 00		dec $00,x	                dec 0,x
.9dcb						_main:
.9dcb		ca		dex		                dex
.9dcc		ca		dex		                dex
.9dcd		ca		dex		                dex
.9dce		ca		dex		                dex
.9dcf		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9dd1		95 00		sta $00,x	                sta 0,x
.9dd3		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9dd5		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9dd7		95 02		sta $02,x	                sta 2,x
.9dd9		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9ddb		95 03		sta $03,x	                sta 3,x
.9ddd		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9ddf		74 05		stz $05,x	                stz 5,x
.9de1		74 06		stz $06,x	                stz 6,x
.9de3		74 07		stz $07,x	                stz 7,x
.9de5		20 e4 92	jsr $92e4	                jsr w_to_number        ; (ud addr u -- ud addr u )
.9de8		b5 00		lda $00,x	                lda 0,x
.9dea		f0 1e		beq $9e0a	                beq _all_converted
.9dec						_number_error:
.9dec		20 bf 93	jsr $93bf	                jsr w_two_drop ; >NUMBER modified addr u
.9def		20 bf 93	jsr $93bf	                jsr w_two_drop ; ud   (partially converted number)
.9df2		a9 3e		lda #$3e	                lda #'>'
.9df4		20 bb 86	jsr $86bb	                jsr emit_a
.9df7		20 dc 94	jsr $94dc	                jsr w_type
.9dfa		a9 3c		lda #$3c	                lda #'<'
.9dfc		20 bb 86	jsr $86bb	                jsr emit_a
.9dff		20 dd 91	jsr $91dd	                jsr w_space
.9e02		68		pla		                pla
.9e03		85 18		sta $18		                sta base
.9e05		a9 08		lda #$08	                lda #err_syntax
.9e07		4c 08 d8	jmp $d808	                jmp error
.9e0a						_all_converted:
.9e0a		e8		inx		                inx ; Drop the current addr u
.9e0b		e8		inx		                inx
.9e0c		e8		inx		                inx
.9e0d		e8		inx		                inx
.9e0e						_drop_original_string:
.9e0e		20 98 94	jsr $9498	                jsr w_two_swap  ; Drop the original addr u
.9e11		20 bf 93	jsr $93bf	                jsr w_two_drop  ; (was saved for unknown word error message)
.9e14		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9e16		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9e18		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9e19		f0 0a		beq $9e25	                beq _single
.9e1b		98		tya		                tya
.9e1c		04 1c		tsb $1c		                tsb status
.9e1e		90 0f		bcc $9e2f	                bcc _done       ; no minus, all done
.9e20		20 0a 9f	jsr $9f0a	                jsr w_dnegate
.9e23		80 0a		bra $9e2f	                bra _done
.9e25						_single:
.9e25		e8		inx		                inx
.9e26		e8		inx		                inx
.9e27		98		tya		                tya
.9e28		14 1c		trb $1c		                trb status
.9e2a		90 03		bcc $9e2f	                bcc _done       ; no minus, all done
.9e2c		20 21 8c	jsr $8c21	                jsr w_negate
.9e2f						_done:
.9e2f		68		pla		                pla
.9e30		85 18		sta $18		                sta base
.9e32		60		rts		z_number:       rts
.9e33						xt_editor_wordlist:
.9e33						xt_one:
.9e33						w_editor_wordlist:
.9e33						w_one:
.9e33		ca		dex		                dex
.9e34		ca		dex		                dex
.9e35		a9 01		lda #$01	                lda #1
.9e37		95 00		sta $00,x	                sta 0,x
.9e39		74 01		stz $01,x	                stz 1,x
.9e3b						z_editor_wordlist:
.9e3b						z_one:
.9e3b		60		rts		                rts
.9e3c						xt_output:
.9e3c						w_output:
.9e3c		ca		dex		                dex
.9e3d		ca		dex		                dex
.9e3e		a9 12		lda #$12	                lda #<output
.9e40		95 00		sta $00,x	                sta 0,x
.9e42		a9 00		lda #$00	                lda #>output
.9e44		95 01		sta $01,x	                sta 1,x
.9e46		60		rts		z_output:       rts
.9e47						xt_r_to_input:
.9e47						w_r_to_input:
.9e47		68		pla		                pla
.9e48		85 25		sta $25		                sta tmp1
.9e4a		68		pla		                pla
.9e4b		85 26		sta $26		                sta tmp1+1
.9e4d		a0 00		ldy #$00	                ldy #0
.9e4f						_loop:
.9e4f		68		pla		                pla
.9e50		99 0a 00	sta $000a,y	                sta insrc,y
.9e53		c8		iny		                iny
.9e54		c0 08		cpy #$08	                cpy #8
.9e56		d0 f7		bne $9e4f	                bne _loop
.9e58		a5 26		lda $26		                lda tmp1+1
.9e5a		48		pha		                pha
.9e5b		a5 25		lda $25		                lda tmp1
.9e5d		48		pha		                pha
.9e5e		60		rts		z_r_to_input: 	rts
.9e5f						xt_strip_underflow:
.9e5f						w_strip_underflow:
.9e5f		a9 02		lda #$02	                lda #uf_strip_offset
.9e61		4c b0 d6	jmp $d6b0	                jmp push_upvar_tos
.9e64						z_strip_underflow:
.9e64						xt_assembler_wordlist:
.9e64						xt_two:
.9e64						w_assembler_wordlist:
.9e64						w_two:
.9e64		ca		dex		                dex
.9e65		ca		dex		                dex
.9e66		a9 02		lda #$02	                lda #2
.9e68		95 00		sta $00,x	                sta 0,x
.9e6a		74 01		stz $01,x	                stz 1,x
.9e6c						z_assembler_wordlist:
.9e6c		60		rts		z_two:          rts
.9e6d						xt_useraddr:
.9e6d						w_useraddr:
.9e6d		ca		dex		                dex
.9e6e		ca		dex		                dex
.9e6f		a9 08		lda #$08	                lda #<up
.9e71		95 00		sta $00,x	                sta 0,x
.9e73		a9 00		lda #$00	                lda #>up
.9e75		95 01		sta $01,x	                sta 1,x
.9e77		60		rts		z_useraddr:     rts
.9e78						xt_wordsize:
.9e78		20 f2 d7	jsr $d7f2	                jsr underflow_1
.9e7b						w_wordsize:
.9e7b		b5 00		lda $00,x	                lda 0,x
.9e7d		85 25		sta $25		                sta tmp1
.9e7f		b5 01		lda $01,x	                lda 1,x
.9e81		85 26		sta $26		                sta tmp1+1
.9e83		a0 06		ldy #$06	                ldy #6
.9e85		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.9e87		88		dey		                dey
.9e88		88		dey		                dey
.9e89		38		sec		                sec
.9e8a		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.9e8c		95 00		sta $00,x	                sta 0,x
.9e8e		a0 07		ldy #$07	                ldy #7
.9e90		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.9e92		88		dey		                dey
.9e93		88		dey		                dey
.9e94		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.9e96		95 01		sta $01,x	                sta 1,x
.9e98		60		rts		z_wordsize:     rts
.9e99						xt_case:
.9e99						xt_false:
.9e99						xt_forth_wordlist:
.9e99						xt_zero:
.9e99						w_case:
.9e99						w_false:
.9e99						w_forth_wordlist:
.9e99						w_zero:
.9e99		ca		dex		                dex             ; push
.9e9a		ca		dex		                dex
.9e9b		74 00		stz $00,x	                stz 0,x
.9e9d		74 01		stz $01,x	                stz 1,x
.9e9f						z_case:
.9e9f						z_false:
.9e9f						z_forth_wordlist:
.9e9f						z_zero:
.9e9f		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/double.asm

.9ea0						xt_d_minus:
.9ea0		20 01 d8	jsr $d801	                jsr underflow_4 ; two double numbers
.9ea3						w_d_minus:
.9ea3		38		sec		                sec
.9ea4		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.9ea6		f5 02		sbc $02,x	                sbc 2,x
.9ea8		95 06		sta $06,x	                sta 6,x
.9eaa		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.9eac		f5 03		sbc $03,x	                sbc 3,x
.9eae		95 07		sta $07,x	                sta 7,x
.9eb0		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.9eb2		f5 00		sbc $00,x	                sbc 0,x
.9eb4		95 04		sta $04,x	                sta 4,x
.9eb6		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.9eb8		f5 01		sbc $01,x	                sbc 1,x
.9eba		95 05		sta $05,x	                sta 5,x
.9ebc		e8		inx		                inx
.9ebd		e8		inx		                inx
.9ebe		e8		inx		                inx
.9ebf		e8		inx		                inx
.9ec0		60		rts		z_d_minus:      rts
.9ec1						xt_d_plus:
.9ec1		20 01 d8	jsr $d801	                jsr underflow_4 ; two double numbers
.9ec4						w_d_plus:
.9ec4		18		clc		                clc
.9ec5		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.9ec7		75 06		adc $06,x	                adc 6,x
.9ec9		95 06		sta $06,x	                sta 6,x
.9ecb		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.9ecd		75 07		adc $07,x	                adc 7,x
.9ecf		95 07		sta $07,x	                sta 7,x
.9ed1		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.9ed3		75 04		adc $04,x	                adc 4,x
.9ed5		95 04		sta $04,x	                sta 4,x
.9ed7		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.9ed9		75 05		adc $05,x	                adc 5,x
.9edb		95 05		sta $05,x	                sta 5,x
.9edd		e8		inx		                inx
.9ede		e8		inx		                inx
.9edf		e8		inx		                inx
.9ee0		e8		inx		                inx
.9ee1		60		rts		z_d_plus:       rts
.9ee2						xt_d_to_s:
.9ee2		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9ee5						w_d_to_s:
.9ee5		e8		inx		                inx
.9ee6		e8		inx		                inx
.9ee7		60		rts		z_d_to_s:       rts
.9ee8						xt_dabs:
.9ee8		20 f7 d7	jsr $d7f7	                jsr underflow_2 ; double number
.9eeb						w_dabs:
.9eeb		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.9eed		10 17		bpl $9f06	                bpl _done       ; positive, we get off light
.9eef		a0 00		ldy #$00	                ldy #0
.9ef1		38		sec		                sec
.9ef2		98		tya		                tya
.9ef3		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9ef5		95 02		sta $02,x	                sta 2,x
.9ef7		98		tya		                tya
.9ef8		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9efa		95 03		sta $03,x	                sta 3,x
.9efc		98		tya		                tya
.9efd		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9eff		95 00		sta $00,x	                sta 0,x
.9f01		98		tya		                tya
.9f02		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9f04		95 01		sta $01,x	                sta 1,x
.9f06						_done:
.9f06		60		rts		z_dabs:         rts
.9f07						xt_dnegate:
.9f07		20 f7 d7	jsr $d7f7	                jsr underflow_2 ; double number
.9f0a						w_dnegate:
.9f0a		a0 00		ldy #$00	     		ldy #0
.9f0c		38		sec		                sec
.9f0d		98		tya		                tya
.9f0e		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9f10		95 02		sta $02,x	                sta 2,x
.9f12		98		tya		                tya
.9f13		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9f15		95 03		sta $03,x	                sta 3,x
.9f17		98		tya		                tya
.9f18		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9f1a		95 00		sta $00,x	                sta 0,x
.9f1c		98		tya		                tya
.9f1d		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9f1f		95 01		sta $01,x	                sta 1,x
.9f21		60		rts		z_dnegate:      rts
.9f22						xt_d_dot:
.9f22		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9f25						w_d_dot:
.9f25		20 a5 93	jsr $93a5	                jsr w_tuck
.9f28		20 eb 9e	jsr $9eeb	                jsr w_dabs
.9f2b		20 d5 89	jsr $89d5	                jsr w_less_number_sign
.9f2e		20 b1 8c	jsr $8cb1	                jsr w_number_sign_s
.9f31		20 84 8f	jsr $8f84	                jsr w_rot
.9f34		20 60 91	jsr $9160	                jsr w_sign
.9f37		20 8f 8c	jsr $8c8f	                jsr w_number_sign_greater
.9f3a		20 dc 94	jsr $94dc	                jsr w_type
.9f3d		20 dd 91	jsr $91dd	                jsr w_space
.9f40		60		rts		z_d_dot:        rts
.9f41						xt_d_dot_r:
.9f41		20 fc d7	jsr $d7fc	                jsr underflow_3
.9f44						w_d_dot_r:
.9f44		20 81 93	jsr $9381	                jsr w_to_r
.9f47		20 a5 93	jsr $93a5	                jsr w_tuck
.9f4a		20 eb 9e	jsr $9eeb	                jsr w_dabs
.9f4d		20 d5 89	jsr $89d5	                jsr w_less_number_sign
.9f50		20 b1 8c	jsr $8cb1	                jsr w_number_sign_s
.9f53		20 84 8f	jsr $8f84	                jsr w_rot
.9f56		20 60 91	jsr $9160	                jsr w_sign
.9f59		20 8f 8c	jsr $8c8f	                jsr w_number_sign_greater
.9f5c		20 dd 8e	jsr $8edd	                jsr w_r_from
.9f5f		20 03 8d	jsr $8d03	                jsr w_over
.9f62		20 e3 8b	jsr $8be3	                jsr w_minus
.9f65		20 e6 91	jsr $91e6	                jsr w_spaces
.9f68		20 dc 94	jsr $94dc	                jsr w_type
.9f6b		60		rts		z_d_dot_r:      rts
.9f6c						xt_m_star_slash:
.9f6c		20 01 d8	jsr $d801	                jsr underflow_4
.9f6f						w_m_star_slash:
.9f6f		20 c7 93	jsr $93c7	                jsr w_two_dup
.9f72		20 80 96	jsr $9680	                jsr w_xor
.9f75		20 46 92	jsr $9246	                jsr w_swap
.9f78		20 d5 80	jsr $80d5	                jsr w_abs
.9f7b		20 81 93	jsr $9381	                jsr w_to_r
.9f7e		20 46 92	jsr $9246	                jsr w_swap
.9f81		20 d5 80	jsr $80d5	                jsr w_abs
.9f84		20 81 93	jsr $9381	                jsr w_to_r
.9f87		20 03 8d	jsr $8d03	                jsr w_over
.9f8a		20 80 96	jsr $9680	                jsr w_xor
.9f8d		20 20 9d	jsr $9d20	                jsr w_not_rot          ; rot rot
.9f90		20 eb 9e	jsr $9eeb	                jsr w_dabs
.9f93		20 46 92	jsr $9246	                jsr w_swap
.9f96		20 c6 8e	jsr $8ec6	                jsr w_r_fetch
.9f99		20 a3 95	jsr $95a3	                jsr w_um_star
.9f9c		20 84 8f	jsr $8f84	                jsr w_rot
.9f9f		20 dd 8e	jsr $8edd	                jsr w_r_from
.9fa2		20 a3 95	jsr $95a3	                jsr w_um_star
.9fa5		20 84 8f	jsr $8f84	                jsr w_rot
.9fa8		20 99 9e	jsr $9e99	                jsr w_zero
.9fab		20 c4 9e	jsr $9ec4	                jsr w_d_plus
.9fae		20 c6 8e	jsr $8ec6	                jsr w_r_fetch
.9fb1		20 61 95	jsr $9561	                jsr w_um_slash_mod
.9fb4		20 20 9d	jsr $9d20	                jsr w_not_rot          ; rot rot
.9fb7		20 dd 8e	jsr $8edd	                jsr w_r_from
.9fba		20 61 95	jsr $9561	                jsr w_um_slash_mod
.9fbd		20 46 92	jsr $9246	                jsr w_swap
.9fc0		20 8b 86	jsr $868b	                jsr w_drop
.9fc3		20 46 92	jsr $9246	                jsr w_swap
.9fc6		20 84 8f	jsr $8f84	                jsr w_rot
.9fc9		e8		inx		                inx                     ; pre-drop TOS
.9fca		e8		inx		                inx
.9fcb		b5 ff		lda $ff,x	                lda $ff,x               ; and check sign bit MSB
.9fcd		10 03		bpl $9fd2	                bpl z_m_star_slash      ; ... 0< if ...
.9fcf		20 0a 9f	jsr $9f0a	                jsr w_dnegate
.9fd2		60		rts		z_m_star_slash: rts
.9fd3						xt_two_constant:
.9fd3		20 f7 d7	jsr $d7f7	                jsr underflow_2
.9fd6						w_two_constant:
.9fd6		a9 04		lda #$04	                lda #4
.9fd8		85 1e		sta $1e		                sta tmpdsp              ; PFA size 4
.9fda		20 21 84	jsr $8421	                jsr create_dovar
.9fdd		20 d9 83	jsr $83d9	                jsr w_comma
.9fe0		20 d9 83	jsr $83d9	                jsr w_comma
.9fe3		20 ec 85	jsr $85ec	                jsr does_runtime    ; does> turns into these two routines.
.9fe6		20 89 d6	jsr $d689	                jsr dodoes
.9fe9		20 df 93	jsr $93df	                jsr w_two_fetch
.9fec		60		rts		z_two_constant: rts
.9fed						xt_two_literal:
.9fed		20 f7 d7	jsr $d7f7	                jsr underflow_2 ; double number
.9ff0						w_two_literal:
.9ff0		a9 14		lda #$14	                lda #2 * template_push_tos_size
.9ff2		20 ed 97	jsr $97ed	                jsr check_nc_limit
.9ff5		b0 09		bcs $a000	                bcs _no_inline
.9ff7		20 46 92	jsr $9246	                jsr w_swap
.9ffa		20 fb 89	jsr $89fb	                jsr w_literal
.9ffd		4c fb 89	jmp $89fb	                jmp w_literal
.a000						_no_inline:
.a000		a0 a0		ldy #$a0	                ldy #>two_literal_runtime
.a002		a9 13		lda #$13	                lda #<two_literal_runtime
.a004		20 d9 97	jsr $97d9	                jsr cmpl_subroutine
.a007		a0 04		ldy #$04	                ldy #4
.a009						-
.a009		b5 00		lda $00,x	                lda 0,x         ; move four bytes from the stack to cp
.a00b		20 e4 97	jsr $97e4	                jsr cmpl_a
.a00e		e8		inx		                inx
.a00f		88		dey		                dey
.a010		d0 f7		bne $a009	                bne -
.a012		60		rts		z_two_literal:  rts
.a013						two_literal_runtime:
.a013		68		pla		                pla             ; LSB of address
.a014		85 25		sta $25		                sta tmp1
.a016		7a		ply		                ply             ; MSB of address
.a017		84 26		sty $26		                sty tmp1+1
.a019		18		clc		                clc             ; add four to the return address
.a01a		69 04		adc #$04	                adc #4
.a01c		90 01		bcc $a01f	                bcc +
.a01e		c8		iny		                iny
.a01f						+
.a01f		5a		phy		                phy             ; and re-stack
.a020		48		pha		                pha
.a021		a0 04		ldy #$04	                ldy #4
.a023						-
.a023		b1 25		lda ($25),y	                lda (tmp1),y    ; copy trailing four bytes to the stack
.a025		ca		dex		                dex
.a026		95 00		sta $00,x	                sta 0,x
.a028		88		dey		                dey
.a029		d0 f8		bne $a023	                bne -
.a02b		60		rts		                rts
.a02c						xt_two_variable:
.a02c						w_two_variable:
.a02c		ca		dex		                dex
.a02d		ca		dex		                dex
.a02e		a9 04		lda #$04	                lda #4
.a030		95 00		sta $00,x	                sta 0,x
.a032		74 01		stz $01,x	                stz 1,x
.a034		85 1e		sta $1e		                sta tmpdsp              ; PFA size 4
.a036		20 21 84	jsr $8421	                jsr create_dovar
.a039		20 55 82	jsr $8255	                jsr w_allot
.a03c		60		rts		z_two_variable: rts
.a03d						xt_ud_dot:
.a03d		20 f7 d7	jsr $d7f7	                jsr underflow_2 ; double number
.a040						w_ud_dot:
.a040		20 d5 89	jsr $89d5	                jsr w_less_number_sign
.a043		20 b1 8c	jsr $8cb1	                jsr w_number_sign_s
.a046		20 8f 8c	jsr $8c8f	                jsr w_number_sign_greater
.a049		20 dc 94	jsr $94dc	                jsr w_type
.a04c		20 dd 91	jsr $91dd	                jsr w_space
.a04f		60		rts		z_ud_dot:        rts
.a050						xt_ud_dot_r:
.a050		20 fc d7	jsr $d7fc	                jsr underflow_3
.a053						w_ud_dot_r:
.a053		20 81 93	jsr $9381	                jsr w_to_r
.a056		20 d5 89	jsr $89d5	                jsr w_less_number_sign
.a059		20 b1 8c	jsr $8cb1	                jsr w_number_sign_s
.a05c		20 8f 8c	jsr $8c8f	                jsr w_number_sign_greater
.a05f		20 dd 8e	jsr $8edd	                jsr w_r_from
.a062		20 03 8d	jsr $8d03	                jsr w_over
.a065		20 e3 8b	jsr $8be3	                jsr w_minus
.a068		20 e6 91	jsr $91e6	                jsr w_spaces
.a06b		20 dc 94	jsr $94dc	                jsr w_type
.a06e		60		rts		z_ud_dot_r:      rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/string.asm

.a06f						xt_cmove:
.a06f		20 fc d7	jsr $d7fc	                jsr underflow_3
.a072						w_cmove:
.a072		b5 02		lda $02,x	                lda 2,x
.a074		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.a076		b5 03		lda $03,x	                lda 3,x
.a078		85 28		sta $28		                sta tmp2+1
.a07a		b5 04		lda $04,x	                lda 4,x
.a07c		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.a07e		b5 05		lda $05,x	                lda 5,x
.a080		85 26		sta $26		                sta tmp1+1
.a082		a0 00		ldy #$00	                ldy #0
.a084		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.a086		f0 0f		beq $a097	                beq _dopartial
.a088						_page:
.a088		b1 25		lda ($25),y	                lda (tmp1),y
.a08a		91 27		sta ($27),y	                sta (tmp2),y
.a08c		c8		iny		                iny
.a08d		d0 f9		bne $a088	                bne _page
.a08f		e6 26		inc $26		                inc tmp1+1
.a091		e6 28		inc $28		                inc tmp2+1
.a093		d6 01		dec $01,x	                dec 1,x
.a095		d0 f1		bne $a088	                bne _page
.a097						_dopartial:
.a097		b5 00		lda $00,x	                lda 0,x         ; length of last page
.a099		f0 09		beq $a0a4	                beq _done
.a09b						_partial:
.a09b		b1 25		lda ($25),y	                lda (tmp1),y
.a09d		91 27		sta ($27),y	                sta (tmp2),y
.a09f		c8		iny		                iny
.a0a0		d6 00		dec $00,x	                dec 0,x
.a0a2		d0 f7		bne $a09b	                bne _partial
.a0a4						_done:
.a0a4		8a		txa		                txa
.a0a5		18		clc		                clc
.a0a6		69 06		adc #$06	                adc #6
.a0a8		aa		tax		                tax
.a0a9		60		rts		z_cmove:        rts
.a0aa						xt_cmove_up:
.a0aa		20 fc d7	jsr $d7fc	                jsr underflow_3
.a0ad						w_cmove_up:
.a0ad		b5 02		lda $02,x	                lda 2,x
.a0af		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.a0b1		b5 03		lda $03,x	                lda 3,x
.a0b3		18		clc		                clc
.a0b4		75 01		adc $01,x	                adc 1,x
.a0b6		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.a0b8		b5 04		lda $04,x	                lda 4,x
.a0ba		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.a0bc		b5 05		lda $05,x	                lda 5,x
.a0be		18		clc		                clc
.a0bf		75 01		adc $01,x	                adc 1,x
.a0c1		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.a0c3		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.a0c5		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.a0c7		f0 0e		beq $a0d7	                beq _nopartial
.a0c9						_outerloop:
.a0c9		88		dey		                dey
.a0ca		f0 07		beq $a0d3	                beq _finishpage
.a0cc						_innerloop:
.a0cc		b1 25		lda ($25),y	                lda (tmp1),y
.a0ce		91 27		sta ($27),y	                sta (tmp2),y
.a0d0		88		dey		                dey
.a0d1		d0 f9		bne $a0cc	                bne _innerloop
.a0d3						_finishpage:
.a0d3		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.a0d5		92 27		sta ($27)	                sta (tmp2)
.a0d7						_nopartial:
.a0d7		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.a0d9		c6 28		dec $28		                dec tmp2+1
.a0db		d6 01		dec $01,x	                dec 1,x
.a0dd		d0 ea		bne $a0c9	                bne _outerloop
.a0df		8a		txa		                txa
.a0e0		18		clc		                clc
.a0e1		69 06		adc #$06	                adc #6
.a0e3		aa		tax		                tax
.a0e4		60		rts		z_cmove_up:     rts
.a0e5						xt_compare:
.a0e5		20 01 d8	jsr $d801	                jsr underflow_4
.a0e8						w_compare:
.a0e8		b5 02		lda $02,x	                lda 2,x
.a0ea		85 27		sta $27		                sta tmp2
.a0ec		b5 03		lda $03,x	                lda 3,x
.a0ee		85 28		sta $28		                sta tmp2+1
.a0f0		b5 06		lda $06,x	                lda 6,x
.a0f2		85 25		sta $25		                sta tmp1
.a0f4		b5 07		lda $07,x	                lda 7,x
.a0f6		85 26		sta $26		                sta tmp1+1
.a0f8						_compare_loop:
.a0f8		b5 04		lda $04,x	                lda 4,x
.a0fa		15 05		ora $05,x	                ora 5,x
.a0fc		f0 2c		beq $a12a	                beq _str1_done
.a0fe		b5 00		lda $00,x	                lda 0,x
.a100		15 01		ora $01,x	                ora 1,x
.a102		f0 3a		beq $a13e	                beq _greater    ; Str2 empty first
.a104		b2 25		lda ($25)	                lda (tmp1)
.a106		d2 27		cmp ($27)	                cmp (tmp2)
.a108		90 26		bcc $a130	                bcc _less
.a10a		d0 32		bne $a13e	                bne _greater
.a10c		e6 25		inc $25		                inc tmp1
.a10e		d0 02		bne $a112	                bne +
.a110		e6 26		inc $26		                inc tmp1+1
.a112						+
.a112		e6 27		inc $27		                inc tmp2
.a114		d0 02		bne $a118	                bne +
.a116		e6 28		inc $28		                inc tmp2+1
.a118						+
.a118		b5 04		lda $04,x	                lda 4,x
.a11a		d0 02		bne $a11e	                bne +
.a11c		d6 05		dec $05,x	                dec 5,x
.a11e						+
.a11e		d6 04		dec $04,x	                dec 4,x
.a120		b5 00		lda $00,x	                lda 0,x
.a122		d0 02		bne $a126	                bne +
.a124		d6 01		dec $01,x	                dec 1,x
.a126						+
.a126		d6 00		dec $00,x	                dec 0,x
.a128		80 ce		bra $a0f8	                bra _compare_loop
.a12a						_str1_done:
.a12a		b5 00		lda $00,x	                lda 0,x
.a12c		15 01		ora $01,x	                ora 1,x
.a12e		f0 08		beq $a138	                beq _equal      ; Both out of letters
.a130						_less:
.a130		a9 ff		lda #$ff	                lda #$FF
.a132		95 06		sta $06,x	                sta 6,x
.a134		95 07		sta $07,x	                sta 7,x
.a136		80 0c		bra $a144	                bra _done
.a138						_equal:
.a138		74 06		stz $06,x	                stz 6,x
.a13a		74 07		stz $07,x	                stz 7,x
.a13c		80 06		bra $a144	                bra _done
.a13e						_greater:
.a13e		a9 01		lda #$01	                lda #1
.a140		95 06		sta $06,x	                sta 6,x
.a142		74 07		stz $07,x	                stz 7,x
.a144						_done:
.a144		8a		txa		                txa
.a145		18		clc		                clc
.a146		69 06		adc #$06	                adc #6
.a148		aa		tax		                tax
.a149		60		rts		z_compare:      rts
.a14a						xt_minus_leading:
.a14a		20 f7 d7	jsr $d7f7	                jsr underflow_2
.a14d						w_minus_leading:
.a14d						_loop:
.a14d		b5 00		lda $00,x	                lda 0,x
.a14f		15 01		ora $01,x	                ora 1,x
.a151		f0 0f		beq $a162	                beq _done
.a153		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.a155		20 e5 d7	jsr $d7e5	                jsr is_whitespace
.a158		90 08		bcc $a162	                bcc _done
.a15a		20 33 9e	jsr $9e33	                jsr w_one              ; ( addr u 1 )
.a15d		20 42 a2	jsr $a242	                jsr w_slash_string     ; ( addr+ u-1 )
.a160		80 eb		bra $a14d	                bra _loop
.a162						_done:
.a162						z_minus_leading:
.a162		60		rts		                rts
.a163						xt_minus_trailing:
.a163		20 f7 d7	jsr $d7f7	                jsr underflow_2
.a166						w_minus_trailing:
.a166		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.a168		15 01		ora $01,x	                ora 1,x         ; MSB of n
.a16a		f0 33		beq $a19f	                beq _done
.a16c		18		clc		                clc
.a16d		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.a16f		75 00		adc $00,x	                adc 0,x
.a171		85 25		sta $25		                sta tmp1
.a173		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.a175		75 01		adc $01,x	                adc 1,x
.a177		85 26		sta $26		                sta tmp1+1
.a179		a5 25		lda $25		                lda tmp1
.a17b		d0 02		bne $a17f	                bne +
.a17d		c6 26		dec $26		                dec tmp1+1
.a17f						+
.a17f		c6 25		dec $25		                dec tmp1
.a181						_loop:
.a181		b2 25		lda ($25)	                lda (tmp1)
.a183		c9 20		cmp #$20	                cmp #AscSP
.a185		d0 18		bne $a19f	                bne _done
.a187		a5 25		lda $25		                lda tmp1
.a189		d0 02		bne $a18d	                bne +
.a18b		c6 26		dec $26		                dec tmp1+1
.a18d						+
.a18d		c6 25		dec $25		                dec tmp1
.a18f		b5 00		lda $00,x	                lda 0,x
.a191		d0 02		bne $a195	                bne +
.a193		d6 01		dec $01,x	                dec 1,x
.a195						+
.a195		d6 00		dec $00,x	                dec 0,x
.a197		b5 00		lda $00,x	                lda 0,x
.a199		15 01		ora $01,x	                ora 1,x
.a19b		f0 02		beq $a19f	                beq _done       ; Count has reached zero - we're done!
.a19d		80 e2		bra $a181	                bra _loop
.a19f						_done:
.a19f						z_minus_trailing:
.a19f		60		rts		                rts
.a1a0						xt_search:
.a1a0		20 01 d8	jsr $d801	                jsr underflow_4
.a1a3						w_search:
.a1a3		b5 00		lda $00,x	                lda 0,x
.a1a5		15 01		ora $01,x	                ora 1,x
.a1a7		d0 0b		bne $a1b4	                bne _start_search
.a1a9		e8		inx		                inx             ; Remove u2
.a1aa		e8		inx		                inx
.a1ab		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.a1ad		95 00		sta $00,x	                sta 0,x
.a1af		95 01		sta $01,x	                sta 1,x
.a1b1		4c 3e a2	jmp $a23e	                jmp z_search
.a1b4						_start_search:
.a1b4		20 99 9e	jsr $9e99	                jsr w_zero
.a1b7						_search_loop:
.a1b7		18		clc		                clc
.a1b8		b5 00		lda $00,x	                lda 0,x
.a1ba		75 02		adc $02,x	                adc 2,x
.a1bc		85 25		sta $25		                sta tmp1
.a1be		b5 01		lda $01,x	                lda 1,x
.a1c0		75 03		adc $03,x	                adc 3,x
.a1c2		d5 07		cmp $07,x	                cmp 7,x
.a1c4		90 12		bcc $a1d8	                bcc _init_comparison ; Obviously less
.a1c6		d0 06		bne $a1ce	                bne _not_found
.a1c8		b5 06		lda $06,x	                lda 6,x
.a1ca		c5 25		cmp $25		                cmp tmp1
.a1cc		b0 0a		bcs $a1d8	                bcs _init_comparison
.a1ce						_not_found:
.a1ce		e8		inx		                inx             ; Remove offset
.a1cf		e8		inx		                inx
.a1d0		e8		inx		                inx             ; Remove u2
.a1d1		e8		inx		                inx
.a1d2		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.a1d4		74 01		stz $01,x	                stz 1,x
.a1d6		80 66		bra $a23e	                bra z_search
.a1d8						_init_comparison:
.a1d8		18		clc		                clc
.a1d9		b5 08		lda $08,x	                lda 8,x
.a1db		75 00		adc $00,x	                adc 0,x
.a1dd		85 25		sta $25		                sta tmp1
.a1df		b5 09		lda $09,x	                lda 9,x
.a1e1		75 01		adc $01,x	                adc 1,x
.a1e3		85 26		sta $26		                sta tmp1+1
.a1e5		b5 04		lda $04,x	                lda 4,x
.a1e7		85 27		sta $27		                sta tmp2
.a1e9		b5 05		lda $05,x	                lda 5,x
.a1eb		85 28		sta $28		                sta tmp2+1
.a1ed		b5 02		lda $02,x	                lda 2,x
.a1ef		85 29		sta $29		                sta tmp3
.a1f1		b5 03		lda $03,x	                lda 3,x
.a1f3		85 2a		sta $2a		                sta tmp3+1
.a1f5						_comparison_loop:
.a1f5		b2 25		lda ($25)	                lda (tmp1)
.a1f7		d2 27		cmp ($27)	                cmp (tmp2)
.a1f9		f0 05		beq $a200	                beq _letters_match
.a1fb		20 e7 8c	jsr $8ce7	                jsr w_one_plus
.a1fe		80 b7		bra $a1b7	                bra _search_loop
.a200						_letters_match:
.a200		e6 25		inc $25		                inc tmp1
.a202		d0 02		bne $a206	                bne +
.a204		e6 26		inc $26		                inc tmp1+1
.a206						+
.a206		e6 27		inc $27		                inc tmp2
.a208		d0 02		bne $a20c	                bne +
.a20a		e6 28		inc $28		                inc tmp2+1
.a20c						+
.a20c		a5 29		lda $29		                lda tmp3
.a20e		d0 02		bne $a212	                bne +
.a210		c6 2a		dec $2a		                dec tmp3+1
.a212						+
.a212		c6 29		dec $29		                dec tmp3
.a214		a5 29		lda $29		                lda tmp3
.a216		05 2a		ora $2a		                ora tmp3+1
.a218		d0 db		bne $a1f5	                bne _comparison_loop ; Check the next letter
.a21a		18		clc		                clc
.a21b		b5 00		lda $00,x	                lda 0,x
.a21d		75 08		adc $08,x	                adc 8,x
.a21f		95 08		sta $08,x	                sta 8,x
.a221		b5 01		lda $01,x	                lda 1,x
.a223		75 09		adc $09,x	                adc 9,x
.a225		95 09		sta $09,x	                sta 9,x
.a227		38		sec		                sec
.a228		b5 06		lda $06,x	                lda 6,x
.a22a		f5 00		sbc $00,x	                sbc 0,x
.a22c		95 06		sta $06,x	                sta 6,x
.a22e		b5 07		lda $07,x	                lda 7,x
.a230		f5 01		sbc $01,x	                sbc 1,x
.a232		95 07		sta $07,x	                sta 7,x
.a234		e8		inx		                inx             ; drop offset
.a235		e8		inx		                inx
.a236		e8		inx		                inx             ; drop u2
.a237		e8		inx		                inx
.a238		a9 ff		lda #$ff	                lda #$FF
.a23a		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.a23c		95 01		sta $01,x	                sta 1,x
.a23e		60		rts		z_search:       rts
.a23f						xt_slash_string:
.a23f		20 fc d7	jsr $d7fc	                jsr underflow_3
.a242						w_slash_string:
.a242		18		clc		                clc             ; 3OS+TOS
.a243		b5 00		lda $00,x	                lda 0,x
.a245		75 04		adc $04,x	                adc 4,x
.a247		95 04		sta $04,x	                sta 4,x
.a249		b5 01		lda $01,x	                lda 1,x
.a24b		75 05		adc $05,x	                adc 5,x
.a24d		95 05		sta $05,x	                sta 5,x
.a24f		38		sec		                sec             ; NOS-TOS
.a250		b5 02		lda $02,x	                lda 2,x
.a252		f5 00		sbc $00,x	                sbc 0,x
.a254		95 02		sta $02,x	                sta 2,x
.a256		b5 03		lda $03,x	                lda 3,x
.a258		f5 01		sbc $01,x	                sbc 1,x
.a25a		95 03		sta $03,x	                sta 3,x
.a25c		e8		inx		                inx
.a25d		e8		inx		                inx
.a25e		60		rts		z_slash_string: rts
.a25f						xt_sliteral:
.a25f		20 f7 d7	jsr $d7f7	                jsr underflow_2
.a262						w_sliteral:
.a262		a0 a2		ldy #$a2	                ldy #>sliteral_runtime
.a264		a9 80		lda #$80	                lda #<sliteral_runtime
.a266		20 d9 97	jsr $97d9	                jsr cmpl_subroutine     ; jsr sliteral_runtime
.a269		b5 00		lda $00,x	                lda 0,x
.a26b		b4 01		ldy $01,x	                ldy 1,x
.a26d		20 e0 97	jsr $97e0	                jsr cmpl_word           ; .word u
.a270		20 0f 89	jsr $890f	                jsr w_here
.a273		20 46 92	jsr $9246	                jsr w_swap
.a276		20 91 86	jsr $8691	                jsr w_dup               ; allocate space for the string
.a279		20 55 82	jsr $8255	                jsr w_allot
.a27c		20 ff 8b	jsr $8bff	                jsr w_move              ; .text < u bytes >
.a27f		60		rts		z_sliteral:     rts
.a280						sliteral_runtime:
.a280		ca		dex		                dex             ; make space on the stack
.a281		ca		dex		                dex
.a282		ca		dex		                dex
.a283		ca		dex		                dex
.a284		18		clc		                clc
.a285		68		pla		                pla             ; LSB of return address
.a286		85 25		sta $25		                sta tmp1
.a288		69 03		adc #$03	                adc #3          ; calculate string offset
.a28a		95 02		sta $02,x	                sta 2,x         ; LSB of string address
.a28c		7a		ply		                ply             ; MSB of address
.a28d		84 26		sty $26		                sty tmp1+1
.a28f		90 01		bcc $a292	                bcc +
.a291		c8		iny		                iny
.a292						+
.a292		94 03		sty $03,x	                sty 3,x         ; MSB of string address
.a294		a0 02		ldy #$02	                ldy #2          ; copy u to TOS
.a296		b1 25		lda ($25),y	                lda (tmp1),y
.a298		95 01		sta $01,x	                sta 1,x         ; MSB of u
.a29a		88		dey		                dey
.a29b		b1 25		lda ($25),y	                lda (tmp1),y
.a29d		95 00		sta $00,x	                sta 0,x         ; LSB of u
.a29f		18		clc		                clc             ; A still has LSB of u
.a2a0		75 02		adc $02,x	                adc 2,x         ; LSB of continuation address
.a2a2		85 25		sta $25		                sta tmp1
.a2a4		b5 01		lda $01,x	                lda 1,x
.a2a6		75 03		adc $03,x	                adc 3,x
.a2a8		85 26		sta $26		                sta tmp1+1
.a2aa		6c 25 00	jmp ($0025)	                jmp (tmp1)

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/disasm.asm

.a2ad						xt_disasm:
.a2ad		20 f7 d7	jsr $d7f7	                jsr underflow_2
.a2b0						w_disasm:
.a2b0		20 b4 a2	jsr $a2b4	                jsr disassembler
.a2b3		60		rts		z_disasm:       rts
.a2b4						disassembler:
.a2b4		20 17 84	jsr $8417	                jsr w_cr       ; ( addr u )
.a2b7						_byte_loop:
.a2b7		20 03 8d	jsr $8d03	                jsr w_over     ; ( addr u addr )
.a2ba		20 07 95	jsr $9507	                jsr w_u_dot    ; ( addr u )
.a2bd		20 dd 91	jsr $91dd	                jsr w_space
.a2c0		a9 13		lda #$13	                lda #<oc_index_table
.a2c2		85 27		sta $27		                sta tmp2
.a2c4		a9 b4		lda #$b4	                lda #>oc_index_table
.a2c6		85 28		sta $28		                sta tmp2+1
.a2c8		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.a2ca		85 2d		sta $2d		                sta scratch     ; Save opcode
.a2cc		0a		asl a		                asl             ; multiply by two for offset
.a2cd		90 02		bcc $a2d1	                bcc +
.a2cf		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.a2d1						+
.a2d1		a8		tay		                tay             ; use Y as the index
.a2d2		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a2d4		85 29		sta $29		                sta tmp3
.a2d6		48		pha		                pha
.a2d7		c8		iny		                iny
.a2d8		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a2da		85 2a		sta $2a		                sta tmp3+1
.a2dc		48		pha		                pha
.a2dd		b2 29		lda ($29)	                lda (tmp3)
.a2df		a8		tay		                tay                     ; save copy of lengths byte
.a2e0		10 2f		bpl $a311	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.a2e2		20 33 9e	jsr $9e33	                jsr w_one
.a2e5		20 42 a2	jsr $a242	                jsr w_slash_string
.a2e8		20 99 9e	jsr $9e99	                jsr w_zero             ; ( addr+1 u-1 0 ) ZERO does not use Y
.a2eb		a1 04		lda ($04,x)	                lda (4,x)
.a2ed		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.a2ef		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.a2f1		98		tya		                tya                     ; retrieve copy of lengths byte
.a2f2		2a		rol a		                rol                     ; shift bit 6 to bit 7
.a2f3		10 12		bpl $a307	                bpl _print_operand
.a2f5		20 20 9d	jsr $9d20	                jsr w_not_rot           ; ( LSB addr u )
.a2f8		20 33 9e	jsr $9e33	                jsr w_one
.a2fb		20 42 a2	jsr $a242	                jsr w_slash_string
.a2fe		20 84 8f	jsr $8f84	                jsr w_rot               ; ( addr+2 u-2 LSB )
.a301		a1 04		lda ($04,x)	                lda (4,x)
.a303		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.a305		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.a307						_print_operand:
.a307		a9 05		lda #$05	                lda #5
.a309		20 a7 a4	jsr $a4a7	                jsr push_a_tos               ; ( addr+n u-n opr 5 )
.a30c		20 13 95	jsr $9513	                jsr w_u_dot_r           ; U.R ( addr+n u-n )
.a30f		80 08		bra $a319	                bra _print_mnemonic
.a311						_no_operand:
.a311		a9 05		lda #$05	                lda #5
.a313		20 a7 a4	jsr $a4a7	                jsr push_a_tos               ; ( addr u 5 )
.a316		20 e6 91	jsr $91e6	                jsr w_spaces            ; ( addr u )
.a319						_print_mnemonic:
.a319		20 dd 91	jsr $91dd	                jsr w_space
.a31c		ca		dex		                dex
.a31d		ca		dex		                dex                     ; ( addr u ? )
.a31e		68		pla		                pla                     ; MSB
.a31f		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.a321		68		pla		                pla                     ; LSB
.a322		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.a324		20 06 84	jsr $8406	                jsr w_count            ; ( addr u addr-o u-o )
.a327		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a329		b5 00		lda $00,x	                lda 0,x
.a32b		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.a32d		95 00		sta $00,x	                sta 0,x
.a32f		20 dc 94	jsr $94dc	                jsr w_type             ; ( addr u )
.a332		a5 2d		lda $2d		                lda scratch
.a334		c9 20		cmp #$20	                cmp #OpJSR
.a336		d0 12		bne $a34a	                bne _not_jsr
.a338		a9 05		lda #$05	                lda #5
.a33a		20 a7 a4	jsr $a4a7	                jsr push_a_tos
.a33d		20 e6 91	jsr $91e6	                jsr w_spaces
.a340		20 d4 a3	jsr $a3d4	                jsr disasm_special
.a343		b0 39		bcs $a37e	                bcs _printing_done
.a345		20 97 a3	jsr $a397	                jsr disasm_jsr
.a348		b0 34		bcs $a37e	                bcs _printing_done
.a34a						_not_jsr:
.a34a		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.a34c		f0 06		beq $a354	                beq _is_rel
.a34e		29 1f		and #$1f	                and #$1F
.a350		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.a352		d0 2a		bne $a37e	                bne _printing_done
.a354						_is_rel:
.a354		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.a356		a5 2e		lda $2e		                lda scratch+1
.a358		20 a7 a4	jsr $a4a7	                jsr push_a_tos
.a35b		10 04		bpl $a361	                bpl +
.a35d		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.a35f		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.a361		38		sec		+               sec                 ; start counting from address after opcode
.a362		75 04		adc $04,x	                adc 4,x
.a364		95 00		sta $00,x	                sta 0,x
.a366		b5 01		lda $01,x	                lda 1,x
.a368		75 05		adc $05,x	                adc 5,x
.a36a		95 01		sta $01,x	                sta 1,x
.a36c		5a		phy		                phy                 ; save the direction indicator
.a36d		a9 09		lda #$09	                lda #9
.a36f		20 a7 a4	jsr $a4a7	                jsr push_a_tos
.a372		20 13 95	jsr $9513	                jsr w_u_dot_r      ; print the destination with 5 leading spaces
.a375		a9 20		lda #$20	                lda #AscSP          ; print space and branch direction indicator
.a377		20 bb 86	jsr $86bb	                jsr emit_a
.a37a		68		pla		                pla
.a37b		20 bb 86	jsr $86bb	                jsr emit_a
.a37e						_printing_done:
.a37e		20 17 84	jsr $8417	                jsr w_cr
.a381		20 33 9e	jsr $9e33	                jsr w_one
.a384		20 42 a2	jsr $a242	                jsr w_slash_string      ; ( addr u -- addr+1 u-1 )
.a387		b5 00		lda $00,x	                lda 0,x                 ; All done?
.a389		15 01		ora $01,x	                ora 1,x
.a38b		f0 07		beq $a394	                beq _done
.a38d		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.a38f		30 03		bmi $a394	                bmi _done
.a391		4c b7 a2	jmp $a2b7	                jmp _byte_loop          ; out of range for BRA
.a394						_done:
.a394		4c bf 93	jmp $93bf	                jmp w_two_drop         ; JSR/RTS
.a397						disasm_jsr:
.a397		ca		dex		                dex
.a398		ca		dex		                dex
.a399		a5 2e		lda $2e		                lda scratch+1
.a39b		95 00		sta $00,x	                sta 0,x
.a39d		a5 2f		lda $2f		                lda scratch+2
.a39f		95 01		sta $01,x	                sta 1,x
.a3a1		20 53 9c	jsr $9c53	                jsr w_int_to_name
.a3a4		b5 00		lda $00,x	                lda 0,x
.a3a6		15 01		ora $01,x	                ora 1,x
.a3a8		d0 1e		bne $a3c8	                bne _found_nt
.a3aa		a5 2e		lda $2e		                lda scratch+1
.a3ac		38		sec		                sec
.a3ad		e9 03		sbc #$03	                sbc #3         ; Subtract 3 this time.
.a3af		95 00		sta $00,x	                sta 0,x
.a3b1		a5 2f		lda $2f		                lda scratch+2
.a3b3		e9 00		sbc #$00	                sbc #0         ; Subtract the carry if needed.
.a3b5		95 01		sta $01,x	                sta 1,x
.a3b7		20 91 86	jsr $8691	                jsr w_dup
.a3ba		20 97 97	jsr $9797	                jsr has_uf_check
.a3bd		90 11		bcc $a3d0	                bcc _no_nt
.a3bf		20 53 9c	jsr $9c53	                jsr w_int_to_name     ; Try looking again
.a3c2		b5 00		lda $00,x	                lda 0,x
.a3c4		15 01		ora $01,x	                ora 1,x
.a3c6		f0 08		beq $a3d0	                beq _no_nt
.a3c8						_found_nt:
.a3c8		20 f6 9c	jsr $9cf6	                jsr w_name_to_string
.a3cb		20 dc 94	jsr $94dc	                jsr w_type
.a3ce		38		sec		                sec
.a3cf		60		rts		                rts
.a3d0						_no_nt:
.a3d0		e8		inx		                inx
.a3d1		e8		inx		                inx
.a3d2		18		clc		                clc
.a3d3		60		rts		                rts
.a3d4						disasm_special:
.a3d4		a0 2c		ldy #$2c	                ldy #(_end_handlers - _special_handlers - 4)
.a3d6		b9 77 a4	lda $a477,y	_check:         lda _special_handlers,y
.a3d9		c5 2e		cmp $2e		                cmp scratch+1
.a3db		d0 07		bne $a3e4	                bne _next
.a3dd		b9 78 a4	lda $a478,y	                lda _special_handlers+1,y
.a3e0		c5 2f		cmp $2f		                cmp scratch+2
.a3e2		f0 08		beq $a3ec	                beq _found_handler
.a3e4		88		dey		_next:          dey
.a3e5		88		dey		                dey
.a3e6		88		dey		                dey
.a3e7		88		dey		                dey
.a3e8		10 ec		bpl $a3d6	                bpl _check
.a3ea		18		clc		                clc
.a3eb		60		rts		                rts
.a3ec						_found_handler:
.a3ec		84 32		sty $32		                sty scratch+5               ; store the offset for later
.a3ee		b9 7a a4	lda $a47a,y	                lda _special_handlers+3,y   ; payload + prefix
.a3f1		48		pha		                pha                         ; stash a copy for payload later
.a3f2		4a		lsr a		                lsr
.a3f3		4a		lsr a		                lsr
.a3f4		f0 06		beq $a3fc	                beq _no_prefix
.a3f6		18		clc		                clc
.a3f7		69 20		adc #$20	                adc #32
.a3f9		20 bb 86	jsr $86bb	                jsr emit_a                  ; print the char stored as (ch - 32) << 2
.a3fc						_no_prefix:
.a3fc		b9 79 a4	lda $a479,y	                lda _special_handlers+2,y   ; string index
.a3ff		20 2e d8	jsr $d82e	                jsr print_string_no_lf
.a402		68		pla		                pla
.a403		29 03		and #$03	                and #3                      ; payload is 0, 1 or 2 words
.a405		f0 4b		beq $a452	                beq _done
.a407		c9 03		cmp #$03	                cmp #3                      ; where 3 means a double-word
.a409		d0 05		bne $a410	                bne _show_payload
.a40b		20 63 a4	jsr $a463	                jsr _print_2literal
.a40e		80 42		bra $a452	                bra _done
.a410						_show_payload:
.a410		48		pha		                pha
.a411		20 54 a4	jsr $a454	                jsr _print_literal
.a414		68		pla		                pla
.a415		3a		dec a		                dea
.a416		d0 f8		bne $a410	                bne _show_payload
.a418		a5 32		lda $32		                lda scratch+5
.a41a		c9 14		cmp #$14	                cmp #_sliteral_handler - _special_handlers
.a41c		d0 34		bne $a452	                bne _done
.a41e		20 03 8d	jsr $8d03	                jsr w_over
.a421		20 db 8c	jsr $8cdb	                jsr w_one_minus
.a424		20 11 88	jsr $8811	                jsr w_fetch         ; ( addr n u )
.a427		b5 01		lda $01,x	                lda 1,x
.a429		d0 06		bne $a431	                bne _truncate
.a42b		b5 00		lda $00,x	                lda 0,x
.a42d		c9 10		cmp #$10	                cmp #16
.a42f		90 02		bcc $a433	                bcc +               ; length < 16?
.a431						_truncate:
.a431		a9 12		lda #$12	                lda #18             ; extra chars for ellipses
.a433						+
.a433		85 1e		sta $1e		                sta tmpdsp
.a435		b5 04		lda $04,x	                lda 4,x             ; tmp1 points 1 before string
.a437		85 25		sta $25		                sta tmp1
.a439		b5 05		lda $05,x	                lda 5,x
.a43b		85 26		sta $26		                sta tmp1+1
.a43d		a0 01		ldy #$01	                ldy #1
.a43f						_snippet:
.a43f		b1 25		lda ($25),y	                lda (tmp1),y
.a441		c0 10		cpy #$10	                cpy #16
.a443		90 02		bcc $a447	                bcc +
.a445		a9 2e		lda #$2e	                lda #'.'
.a447						+
.a447		20 bb 86	jsr $86bb	                jsr emit_a
.a44a		c8		iny		                iny
.a44b		c6 1e		dec $1e		                dec tmpdsp
.a44d		d0 f0		bne $a43f	                bne _snippet
.a44f		20 42 a2	jsr $a242	                jsr w_slash_string
.a452		38		sec		_done:          sec
.a453		60		rts		                rts
.a454						_print_literal:
.a454		20 03 8d	jsr $8d03	                jsr w_over
.a457		20 e7 8c	jsr $8ce7	                jsr w_one_plus              ; ( addr u addr+1 )
.a45a		20 67 99	jsr $9967	                jsr w_question              ; Print the value at the address
.a45d		20 64 9e	jsr $9e64	                jsr w_two
.a460		4c 42 a2	jmp $a242	                jmp w_slash_string          ; leaving (addr+2 u-2)
.a463						_print_2literal:
.a463		20 03 8d	jsr $8d03	                jsr w_over                  ; ( addr u addr+1 )
.a466		20 e7 8c	jsr $8ce7	                jsr w_one_plus
.a469		20 df 93	jsr $93df	                jsr w_two_fetch
.a46c		20 25 9f	jsr $9f25	                jsr w_d_dot                 ; fetch and print double word
.a46f		a9 04		lda #$04	                lda #4
.a471		20 a7 a4	jsr $a4a7	                jsr push_a_tos
.a474		4c 42 a2	jmp $a242	                jmp w_slash_string          ; ( addr+4 u-4 )
.a477						_special_handlers:
>a477		f2 d7				    .word underflow_1
>a479		0b 44				        .byte str_disasm_sdc, 0 + ('1'-32)*4
>a47b		f7 d7				    .word underflow_2
>a47d		0b 48				        .byte str_disasm_sdc, 0 + ('2'-32)*4
>a47f		fc d7				    .word underflow_3
>a481		0b 4c				        .byte str_disasm_sdc, 0 + ('3'-32)*4
>a483		01 d8				    .word underflow_4
>a485		0b 50				        .byte str_disasm_sdc, 0 + ('4'-32)*4
>a487		40 8a				    .word literal_runtime
>a489		0c 01				        .byte str_disasm_lit, 1
.a48b						_sliteral_handler:
>a48b		80 a2				    .word sliteral_runtime
>a48d		0c cd				        .byte str_disasm_lit, 1 + ('S'-32)*4
>a48f		13 a0				    .word two_literal_runtime
>a491		0c 4b				        .byte str_disasm_lit, 3 + ('2'-32)*4
>a493		76 98				    .word zero_branch_runtime
>a495		0d 01				        .byte str_disasm_0bra, 1
>a497		d8 8a				    .word loop_runtime
>a499		0e 01				        .byte str_disasm_loop, 1
>a49b		f1 8a				    .word plus_loop_runtime
>a49d		0e 2d				        .byte str_disasm_loop, 1 + ('+'-32)*4
>a49f		aa 85				    .word do_runtime
>a4a1		0f 00				        .byte str_disasm_do, 0
>a4a3		92 85				    .word question_do_runtime
>a4a5		0f 7d				        .byte str_disasm_do, 1 + ('?'-32)*4
.a4a7						_end_handlers:
.a4a7						push_a_tos:
.a4a7		ca		dex		                dex
.a4a8		ca		dex		                dex
.a4a9		95 00		sta $00,x	                sta 0,x
.a4ab		74 01		stz $01,x	                stz 1,x
.a4ad						z_push_a_tos:
.a4ad		60		rts		                rts
.a4ae						disassembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/assembler.asm

.a4ae						assembler:
.a4ae						xt_asm_adc_h:
.a4ae		a9 69		lda #$69	                lda #$69
.a4b0		4c 07 a8	jmp $a807	                jmp asm_common
.a4b3						z_asm_adc_h:
.a4b3						xt_asm_adc_x:
.a4b3		a9 7d		lda #$7d	                lda #$7D
.a4b5		4c 07 a8	jmp $a807	                jmp asm_common
.a4b8						z_asm_adc_x:
.a4b8						xt_asm_adc_y:
.a4b8		a9 79		lda #$79	                lda #$79
.a4ba		4c 07 a8	jmp $a807	                jmp asm_common
.a4bd						z_asm_adc_y:
.a4bd						xt_asm_adc_z:
.a4bd		a9 65		lda #$65	                lda #$65
.a4bf		4c 07 a8	jmp $a807	                jmp asm_common
.a4c2						z_asm_adc_z:
.a4c2						xt_asm_adc_zi:
.a4c2		a9 72		lda #$72	                lda #$72
.a4c4		4c 07 a8	jmp $a807	                jmp asm_common
.a4c7						z_asm_adc_zi:
.a4c7						xt_asm_adc_ziy:
.a4c7		a9 71		lda #$71	                lda #$71
.a4c9		4c 07 a8	jmp $a807	                jmp asm_common
.a4cc						z_asm_adc_ziy:
.a4cc						xt_asm_adc_zx:
.a4cc		a9 75		lda #$75	                lda #$75
.a4ce		4c 07 a8	jmp $a807	                jmp asm_common
.a4d1						z_asm_adc_zx:
.a4d1						xt_asm_adc_zxi:
.a4d1		a9 61		lda #$61	                lda #$61
.a4d3		4c 07 a8	jmp $a807	                jmp asm_common
.a4d6						z_asm_adc_zxi:
.a4d6						xt_asm_and:
.a4d6		a9 2d		lda #$2d	                lda #$2D
.a4d8		4c 07 a8	jmp $a807	                jmp asm_common
.a4db						z_asm_and:
.a4db						xt_asm_and_h:
.a4db		a9 29		lda #$29	                lda #$29
.a4dd		4c 07 a8	jmp $a807	                jmp asm_common
.a4e0						z_asm_and_h:
.a4e0						xt_asm_and_x:
.a4e0		a9 3d		lda #$3d	                lda #$3D
.a4e2		4c 07 a8	jmp $a807	                jmp asm_common
.a4e5						z_asm_and_x:
.a4e5						xt_asm_and_y:
.a4e5		a9 39		lda #$39	                lda #$39
.a4e7		4c 07 a8	jmp $a807	                jmp asm_common
.a4ea						z_asm_and_y:
.a4ea						xt_asm_and_z:
.a4ea		a9 25		lda #$25	                lda #$25
.a4ec		4c 07 a8	jmp $a807	                jmp asm_common
.a4ef						z_asm_and_z:
.a4ef						xt_asm_and_zi:
.a4ef		a9 32		lda #$32	                lda #$32
.a4f1		4c 07 a8	jmp $a807	                jmp asm_common
.a4f4						z_asm_and_zi:
.a4f4						xt_asm_and_ziy:
.a4f4		a9 31		lda #$31	                lda #$31
.a4f6		4c 07 a8	jmp $a807	                jmp asm_common
.a4f9						z_asm_and_ziy:
.a4f9						xt_asm_and_zx:
.a4f9		a9 35		lda #$35	                lda #$35
.a4fb		4c 07 a8	jmp $a807	                jmp asm_common
.a4fe						z_asm_and_zx:
.a4fe						xt_asm_and_zxi:
.a4fe		a9 21		lda #$21	                lda #$21
.a500		4c 07 a8	jmp $a807	                jmp asm_common
.a503						z_asm_and_zxi:
.a503						xt_asm_asl:
.a503		a9 0e		lda #$0e	                lda #$0E
.a505		4c 07 a8	jmp $a807	                jmp asm_common
.a508						z_asm_asl:
.a508						xt_asm_asl_a:
.a508		a9 0a		lda #$0a	                lda #$0A
.a50a		4c 07 a8	jmp $a807	                jmp asm_common
.a50d						z_asm_asl_a:
.a50d						xt_asm_asl_x:
.a50d		a9 1e		lda #$1e	                lda #$1E
.a50f		4c 07 a8	jmp $a807	                jmp asm_common
.a512						z_asm_asl_x:
.a512						xt_asm_asl_z:
.a512		a9 06		lda #$06	                lda #$06
.a514		4c 07 a8	jmp $a807	                jmp asm_common
.a517						z_asm_asl_z:
.a517						xt_asm_asl_zx:
.a517		a9 16		lda #$16	                lda #$16
.a519		4c 07 a8	jmp $a807	                jmp asm_common
.a51c						z_asm_asl_zx:
.a51c						xt_asm_bcc:
.a51c		a9 90		lda #$90	                lda #$90
.a51e		4c 07 a8	jmp $a807	                jmp asm_common
.a521						z_asm_bcc:
.a521						xt_asm_bcs:
.a521		a9 b0		lda #$b0	                lda #$B0
.a523		a0 02		ldy #$02	                ldy #2
.a525		4c 07 a8	jmp $a807	                jmp asm_common
.a528						z_asm_bcs:
.a528						xt_asm_beq:
.a528		a9 f0		lda #$f0	                lda #$F0
.a52a		4c 07 a8	jmp $a807	                jmp asm_common
.a52d						z_asm_beq:
.a52d						xt_asm_bit:
.a52d		a9 2c		lda #$2c	                lda #$2C
.a52f		4c 07 a8	jmp $a807	                jmp asm_common
.a532						z_asm_bit:
.a532						xt_asm_bit_h:
.a532		a9 89		lda #$89	                lda #$89
.a534		4c 07 a8	jmp $a807	                jmp asm_common
.a537						z_asm_bit_h:
.a537						xt_asm_bit_x:
.a537		a9 3c		lda #$3c	                lda #$3C
.a539		4c 07 a8	jmp $a807	                jmp asm_common
.a53c						z_asm_bit_x:
.a53c						xt_asm_bit_z:
.a53c		a9 24		lda #$24	                lda #$24
.a53e		4c 07 a8	jmp $a807	                jmp asm_common
.a541						z_asm_bit_z:
.a541						xt_asm_bit_zx:
.a541		a9 34		lda #$34	                lda #$34
.a543		4c 07 a8	jmp $a807	                jmp asm_common
.a546						z_asm_bit_zx:
.a546						xt_asm_bmi:
.a546		a9 30		lda #$30	                lda #$30
.a548		4c 07 a8	jmp $a807	                jmp asm_common
.a54b						z_asm_bmi:
.a54b						xt_asm_bne:
.a54b		a9 d0		lda #$d0	                lda #$D0
.a54d		4c 07 a8	jmp $a807	                jmp asm_common
.a550						z_asm_bne:
.a550						xt_asm_bpl:
.a550		a9 10		lda #$10	                lda #$10
.a552		4c 07 a8	jmp $a807	                jmp asm_common
.a555						z_asm_bpl:
.a555						xt_asm_bra:
.a555		a9 80		lda #$80	                lda #$80
.a557		4c 07 a8	jmp $a807	                jmp asm_common
.a55a						z_asm_bra:
.a55a						xt_asm_brk:
.a55a		a9 00		lda #$00	                lda #$00
.a55c		4c 07 a8	jmp $a807	                jmp asm_common
.a55f						z_asm_brk:
.a55f						xt_asm_bvc:
.a55f		a9 50		lda #$50	                lda #$50
.a561		4c 07 a8	jmp $a807	                jmp asm_common
.a564						z_asm_bvc:
.a564						xt_asm_bvs:
.a564		a9 70		lda #$70	                lda #$70
.a566		4c 07 a8	jmp $a807	                jmp asm_common
.a569						z_asm_bvs:
.a569						xt_asm_clc:
.a569		a9 18		lda #$18	                lda #$18
.a56b		4c 07 a8	jmp $a807	                jmp asm_common
.a56e						z_asm_clc:
.a56e						xt_asm_cld:
.a56e		a9 d8		lda #$d8	                lda #$D8
.a570		4c 07 a8	jmp $a807	                jmp asm_common
.a573						z_asm_cld:
.a573						xt_asm_cli:
.a573		a9 58		lda #$58	                lda #$58
.a575		4c 07 a8	jmp $a807	                jmp asm_common
.a578						z_asm_cli:
.a578						xt_asm_clv:
.a578		a9 b8		lda #$b8	                lda #$B8
.a57a		4c 07 a8	jmp $a807	                jmp asm_common
.a57d						z_asm_clv:
.a57d						xt_asm_cmp:
.a57d		a9 cd		lda #$cd	                lda #$CD
.a57f		4c 07 a8	jmp $a807	                jmp asm_common
.a582						z_asm_cmp:
.a582						xt_asm_cmp_h:
.a582		a9 c9		lda #$c9	                lda #$C9
.a584		4c 07 a8	jmp $a807	                jmp asm_common
.a587						z_asm_cmp_h:
.a587						xt_asm_cmp_x:
.a587		a9 dd		lda #$dd	                lda #$DD
.a589		4c 07 a8	jmp $a807	                jmp asm_common
.a58c						z_asm_cmp_x:
.a58c						xt_asm_cmp_y:
.a58c		a9 d9		lda #$d9	                lda #$D9
.a58e		4c 07 a8	jmp $a807	                jmp asm_common
.a591						z_asm_cmp_y:
.a591						xt_asm_cmp_z:
.a591		a9 c5		lda #$c5	                lda #$C5
.a593		4c 07 a8	jmp $a807	                jmp asm_common
.a596						z_asm_cmp_z:
.a596						xt_asm_cmp_zi:
.a596		a9 d2		lda #$d2	                lda #$D2
.a598		4c 07 a8	jmp $a807	                jmp asm_common
.a59b						z_asm_cmp_zi:
.a59b						xt_asm_cmp_ziy:
.a59b		a9 d1		lda #$d1	                lda #$D1
.a59d		4c 07 a8	jmp $a807	                jmp asm_common
.a5a0						z_asm_cmp_ziy:
.a5a0						xt_asm_cmp_zx:
.a5a0		a9 d5		lda #$d5	                lda #$D5
.a5a2		4c 07 a8	jmp $a807	                jmp asm_common
.a5a5						z_asm_cmp_zx:
.a5a5						xt_asm_cmp_zxi:
.a5a5		a9 c1		lda #$c1	                lda #$C1
.a5a7		4c 07 a8	jmp $a807	                jmp asm_common
.a5aa						z_asm_cmp_zxi:
.a5aa						xt_asm_cpx:
.a5aa		a9 ec		lda #$ec	                lda #$EC
.a5ac		4c 07 a8	jmp $a807	                jmp asm_common
.a5af						z_asm_cpx:
.a5af						xt_asm_cpx_h:
.a5af		a9 e0		lda #$e0	                lda #$E0
.a5b1		4c 07 a8	jmp $a807	                jmp asm_common
.a5b4						z_asm_cpx_h:
.a5b4						xt_asm_cpx_z:
.a5b4		a9 e4		lda #$e4	                lda #$E4
.a5b6		4c 07 a8	jmp $a807	                jmp asm_common
.a5b9						z_asm_cpx_z:
.a5b9						xt_asm_cpy:
.a5b9		a9 cc		lda #$cc	                lda #$CC
.a5bb		a0 03		ldy #$03	                ldy #3
.a5bd		4c 07 a8	jmp $a807	                jmp asm_common
.a5c0						z_asm_cpy:
.a5c0						xt_asm_cpy_h:
.a5c0		a9 c0		lda #$c0	                lda #$C0
.a5c2		4c 07 a8	jmp $a807	                jmp asm_common
.a5c5						z_asm_cpy_h:
.a5c5						xt_asm_cpy_z:
.a5c5		a9 c4		lda #$c4	                lda #$C4
.a5c7		4c 07 a8	jmp $a807	                jmp asm_common
.a5ca						z_asm_cpy_z:
.a5ca						xt_asm_dec:
.a5ca		a9 ce		lda #$ce	                lda #$CE
.a5cc		4c 07 a8	jmp $a807	                jmp asm_common
.a5cf						z_asm_dec:
.a5cf						xt_asm_dec_a:
.a5cf		a9 3a		lda #$3a	                lda #$3A
.a5d1		4c 07 a8	jmp $a807	                jmp asm_common
.a5d4						z_asm_dec_a:
.a5d4						xt_asm_dec_x:
.a5d4		a9 de		lda #$de	                lda #$DE
.a5d6		4c 07 a8	jmp $a807	                jmp asm_common
.a5d9						z_asm_dec_x:
.a5d9						xt_asm_dec_z:
.a5d9		a9 c6		lda #$c6	                lda #$C6
.a5db		4c 07 a8	jmp $a807	                jmp asm_common
.a5de						z_asm_dec_z:
.a5de						xt_asm_dec_zx:
.a5de		a9 d6		lda #$d6	                lda #$D6
.a5e0		4c 07 a8	jmp $a807	                jmp asm_common
.a5e3						z_asm_dec_zx:
.a5e3						xt_asm_dex:
.a5e3		a9 ca		lda #$ca	                lda #$CA
.a5e5		4c 07 a8	jmp $a807	                jmp asm_common
.a5e8						z_asm_dex:
.a5e8						xt_asm_dey:
.a5e8		a9 88		lda #$88	                lda #$88
.a5ea		4c 07 a8	jmp $a807	                jmp asm_common
.a5ed						z_asm_dey:
.a5ed						xt_asm_eor:
.a5ed		a9 4d		lda #$4d	                lda #$4D
.a5ef		4c 07 a8	jmp $a807	                jmp asm_common
.a5f2						z_asm_eor:
.a5f2						xt_asm_eor_h:
.a5f2		a9 49		lda #$49	                lda #$49
.a5f4		4c 07 a8	jmp $a807	                jmp asm_common
.a5f7						z_asm_eor_h:
.a5f7						xt_asm_eor_x:
.a5f7		a9 5d		lda #$5d	                lda #$5D
.a5f9		4c 07 a8	jmp $a807	                jmp asm_common
.a5fc						z_asm_eor_x:
.a5fc						xt_asm_eor_y:
.a5fc		a9 59		lda #$59	                lda #$59
.a5fe		4c 07 a8	jmp $a807	                jmp asm_common
.a601						z_asm_eor_y:
.a601						xt_asm_eor_z:
.a601		a9 45		lda #$45	                lda #$45
.a603		4c 07 a8	jmp $a807	                jmp asm_common
.a606						z_asm_eor_z:
.a606						xt_asm_eor_zi:
.a606		a9 52		lda #$52	                lda #$52
.a608		4c 07 a8	jmp $a807	                jmp asm_common
.a60b						z_asm_eor_zi:
.a60b						xt_asm_eor_ziy:
.a60b		a9 51		lda #$51	                lda #$51
.a60d		4c 07 a8	jmp $a807	                jmp asm_common
.a610						z_asm_eor_ziy:
.a610						xt_asm_eor_zx:
.a610		a9 55		lda #$55	                lda #$55
.a612		4c 07 a8	jmp $a807	                jmp asm_common
.a615						z_asm_eor_zx:
.a615						xt_asm_eor_zxi:
.a615		a9 41		lda #$41	                lda #$41
.a617		4c 07 a8	jmp $a807	                jmp asm_common
.a61a						z_asm_eor_zxi:
.a61a						xt_asm_inc:
.a61a		a9 ee		lda #$ee	                lda #$EE
.a61c		4c 07 a8	jmp $a807	                jmp asm_common
.a61f						z_asm_inc:
.a61f						xt_asm_inc_a:
.a61f		a9 1a		lda #$1a	                lda #$1A
.a621		4c 07 a8	jmp $a807	                jmp asm_common
.a624						z_asm_inc_a:
.a624						xt_asm_inc_x:
.a624		a9 fe		lda #$fe	                lda #$FE
.a626		4c 07 a8	jmp $a807	                jmp asm_common
.a629						z_asm_inc_x:
.a629						xt_asm_inc_z:
.a629		a9 e6		lda #$e6	                lda #$E6
.a62b		4c 07 a8	jmp $a807	                jmp asm_common
.a62e						z_asm_inc_z:
.a62e						xt_asm_inc_zx:
.a62e		a9 f6		lda #$f6	                lda #$F6
.a630		4c 07 a8	jmp $a807	                jmp asm_common
.a633						z_asm_inc_zx:
.a633						xt_asm_inx:
.a633		a9 e8		lda #$e8	                lda #$E8
.a635		4c 07 a8	jmp $a807	                jmp asm_common
.a638						z_asm_inx:
.a638						xt_asm_iny:
.a638		a9 c8		lda #$c8	                lda #$C8
.a63a		4c 07 a8	jmp $a807	                jmp asm_common
.a63d						z_asm_iny:
.a63d						xt_asm_jmp:
.a63d		4c ca 97	jmp $97ca	                jmp cmpl_jump_tos
.a640						z_asm_jmp:
.a640						xt_asm_jmp_i:
.a640		a9 6c		lda #$6c	                lda #$6C
.a642		4c 07 a8	jmp $a807	                jmp asm_common
.a645						z_asm_jmp_i:
.a645						xt_asm_jmp_xi:
.a645		a9 7c		lda #$7c	                lda #$7C
.a647		4c 07 a8	jmp $a807	                jmp asm_common
.a64a						z_asm_jmp_xi:
.a64a						xt_asm_jsr:
.a64a		a9 20		lda #$20	                lda #$20
.a64c		4c 07 a8	jmp $a807	                jmp asm_common
.a64f						z_asm_jsr:
.a64f						xt_asm_lda:
.a64f		a9 ad		lda #$ad	                lda #$AD
.a651		4c 07 a8	jmp $a807	                jmp asm_common
.a654						z_asm_lda:
.a654						xt_asm_lda_h:
.a654		a9 a9		lda #$a9	                lda #$A9
.a656		4c 07 a8	jmp $a807	                jmp asm_common
.a659						z_asm_lda_h:
.a659						xt_asm_lda_x:
.a659		a9 bd		lda #$bd	                lda #$BD
.a65b		4c 07 a8	jmp $a807	                jmp asm_common
.a65e						z_asm_lda_x:
.a65e						xt_asm_lda_y:
.a65e		a9 b9		lda #$b9	                lda #$B9
.a660		4c 07 a8	jmp $a807	                jmp asm_common
.a663						z_asm_lda_y:
.a663						xt_asm_lda_z:
.a663		a9 a5		lda #$a5	                lda #$A5
.a665		4c 07 a8	jmp $a807	                jmp asm_common
.a668						z_asm_lda_z:
.a668						xt_asm_lda_zi:
.a668		a9 b2		lda #$b2	                lda #$B2
.a66a		4c 07 a8	jmp $a807	                jmp asm_common
.a66d						z_asm_lda_zi:
.a66d						xt_asm_lda_ziy:
.a66d		a9 b1		lda #$b1	                lda #$B1
.a66f		4c 07 a8	jmp $a807	                jmp asm_common
.a672						z_asm_lda_ziy:
.a672						xt_asm_lda_zx:
.a672		a9 b5		lda #$b5	                lda #$B5
.a674		4c 07 a8	jmp $a807	                jmp asm_common
.a677						z_asm_lda_zx:
.a677						xt_asm_lda_zxi:
.a677		a9 a1		lda #$a1	                lda #$A1
.a679		4c 07 a8	jmp $a807	                jmp asm_common
.a67c						z_asm_lda_zxi:
.a67c						xt_asm_ldx:
.a67c		a9 ae		lda #$ae	                lda #$AE
.a67e		4c 07 a8	jmp $a807	                jmp asm_common
.a681						z_asm_ldx:
.a681						xt_asm_ldx_h:
.a681		a9 a2		lda #$a2	                lda #$A2
.a683		4c 07 a8	jmp $a807	                jmp asm_common
.a686						z_asm_ldx_h:
.a686						xt_asm_ldx_y:
.a686		a9 be		lda #$be	                lda #$BE
.a688		4c 07 a8	jmp $a807	                jmp asm_common
.a68b						z_asm_ldx_y:
.a68b						xt_asm_ldx_z:
.a68b		a9 a6		lda #$a6	                lda #$A6
.a68d		4c 07 a8	jmp $a807	                jmp asm_common
.a690						z_asm_ldx_z:
.a690						xt_asm_ldx_zy:
.a690		a9 b6		lda #$b6	                lda #$B6
.a692		4c 07 a8	jmp $a807	                jmp asm_common
.a695						z_asm_ldx_zy:
.a695						xt_asm_ldy:
.a695		a9 ac		lda #$ac	                lda #$AC
.a697		4c 07 a8	jmp $a807	                jmp asm_common
.a69a						z_asm_ldy:
.a69a						xt_asm_ldy_h:
.a69a		a9 a0		lda #$a0	                lda #$A0
.a69c		4c 07 a8	jmp $a807	                jmp asm_common
.a69f						z_asm_ldy_h:
.a69f						xt_asm_ldy_x:
.a69f		a9 bc		lda #$bc	                lda #$BC
.a6a1		4c 07 a8	jmp $a807	                jmp asm_common
.a6a4						z_asm_ldy_x:
.a6a4						xt_asm_ldy_z:
.a6a4		a9 a4		lda #$a4	                lda #$A4
.a6a6		4c 07 a8	jmp $a807	                jmp asm_common
.a6a9						z_asm_ldy_z:
.a6a9						xt_asm_ldy_zx:
.a6a9		a9 b4		lda #$b4	                lda #$B4
.a6ab		4c 07 a8	jmp $a807	                jmp asm_common
.a6ae						z_asm_ldy_zx:
.a6ae						xt_asm_lsr:
.a6ae		a9 4e		lda #$4e	                lda #$4E
.a6b0		4c 07 a8	jmp $a807	                jmp asm_common
.a6b3						z_asm_lsr:
.a6b3						xt_asm_lsr_a:
.a6b3		a9 4a		lda #$4a	                lda #$4A
.a6b5		4c 07 a8	jmp $a807	                jmp asm_common
.a6b8						z_asm_lsr_a:
.a6b8						xt_asm_lsr_x:
.a6b8		a9 5e		lda #$5e	                lda #$5E
.a6ba		4c 07 a8	jmp $a807	                jmp asm_common
.a6bd						z_asm_lsr_x:
.a6bd						xt_asm_lsr_z:
.a6bd		a9 46		lda #$46	                lda #$46
.a6bf		4c 07 a8	jmp $a807	                jmp asm_common
.a6c2						z_asm_lsr_z:
.a6c2						xt_asm_lsr_zx:
.a6c2		a9 56		lda #$56	                lda #$56
.a6c4		4c 07 a8	jmp $a807	                jmp asm_common
.a6c7						z_asm_lsr_zx:
.a6c7						xt_asm_nop:
.a6c7		a9 ea		lda #$ea	                lda #$EA
.a6c9		4c 07 a8	jmp $a807	                jmp asm_common
.a6cc						z_asm_nop:
.a6cc						xt_asm_ora:
.a6cc		a9 0d		lda #$0d	                lda #$0D
.a6ce		4c 07 a8	jmp $a807	                jmp asm_common
.a6d1						z_asm_ora:
.a6d1						xt_asm_ora_h:
.a6d1		a9 09		lda #$09	                lda #$09
.a6d3		4c 07 a8	jmp $a807	                jmp asm_common
.a6d6						z_asm_ora_h:
.a6d6						xt_asm_ora_x:
.a6d6		a9 1d		lda #$1d	                lda #$1D
.a6d8		4c 07 a8	jmp $a807	                jmp asm_common
.a6db						z_asm_ora_x:
.a6db						xt_asm_ora_y:
.a6db		a9 19		lda #$19	                lda #$19
.a6dd		4c 07 a8	jmp $a807	                jmp asm_common
.a6e0						z_asm_ora_y:
.a6e0						xt_asm_ora_z:
.a6e0		a9 05		lda #$05	                lda #$05
.a6e2		4c 07 a8	jmp $a807	                jmp asm_common
.a6e5						z_asm_ora_z:
.a6e5						xt_asm_ora_zi:
.a6e5		a9 12		lda #$12	                lda #$12
.a6e7		a0 02		ldy #$02	                ldy #2
.a6e9		4c 07 a8	jmp $a807	                jmp asm_common
.a6ec						z_asm_ora_zi:
.a6ec						xt_asm_ora_ziy:
.a6ec		a9 11		lda #$11	                lda #$11
.a6ee		4c 07 a8	jmp $a807	                jmp asm_common
.a6f1						z_asm_ora_ziy:
.a6f1						xt_asm_ora_zx:
.a6f1		a9 15		lda #$15	                lda #$15
.a6f3		4c 07 a8	jmp $a807	                jmp asm_common
.a6f6						z_asm_ora_zx:
.a6f6						xt_asm_ora_zxi:
.a6f6		a9 01		lda #$01	                lda #$01
.a6f8		4c 07 a8	jmp $a807	                jmp asm_common
.a6fb						z_asm_ora_zxi:
.a6fb						xt_asm_pha:
.a6fb		a9 48		lda #$48	                lda #$48
.a6fd		4c 07 a8	jmp $a807	                jmp asm_common
.a700						z_asm_pha:
.a700						xt_asm_php:
.a700		a9 08		lda #$08	                lda #$08
.a702		4c 07 a8	jmp $a807	                jmp asm_common
.a705						z_asm_php:
.a705						xt_asm_phx:
.a705		a9 da		lda #$da	                lda #$DA
.a707		4c 07 a8	jmp $a807	                jmp asm_common
.a70a						z_asm_phx:
.a70a						xt_asm_phy:
.a70a		a9 5a		lda #$5a	                lda #$5A
.a70c		4c 07 a8	jmp $a807	                jmp asm_common
.a70f						z_asm_phy:
.a70f						xt_asm_pla:
.a70f		a9 68		lda #$68	                lda #$68
.a711		4c 07 a8	jmp $a807	                jmp asm_common
.a714						z_asm_pla:
.a714						xt_asm_plp:
.a714		a9 28		lda #$28	                lda #$28
.a716		4c 07 a8	jmp $a807	                jmp asm_common
.a719						z_asm_plp:
.a719						xt_asm_plx:
.a719		a9 fa		lda #$fa	                lda #$FA
.a71b		4c 07 a8	jmp $a807	                jmp asm_common
.a71e						z_asm_plx:
.a71e						xt_asm_ply:
.a71e		a9 7a		lda #$7a	                lda #$7A
.a720		4c 07 a8	jmp $a807	                jmp asm_common
.a723						z_asm_ply:
.a723						xt_asm_rol:
.a723		a9 2e		lda #$2e	                lda #$2E
.a725		4c 07 a8	jmp $a807	                jmp asm_common
.a728						z_asm_rol:
.a728						xt_asm_rol_a:
.a728		a9 2a		lda #$2a	                lda #$2A
.a72a		4c 07 a8	jmp $a807	                jmp asm_common
.a72d						z_asm_rol_a:
.a72d						xt_asm_rol_x:
.a72d		a9 3e		lda #$3e	                lda #$3E
.a72f		4c 07 a8	jmp $a807	                jmp asm_common
.a732						z_asm_rol_x:
.a732						xt_asm_rol_z:
.a732		a9 26		lda #$26	                lda #$26
.a734		4c 07 a8	jmp $a807	                jmp asm_common
.a737						z_asm_rol_z:
.a737						xt_asm_rol_zx:
.a737		a9 36		lda #$36	                lda #$36
.a739		4c 07 a8	jmp $a807	                jmp asm_common
.a73c						z_asm_rol_zx:
.a73c						xt_asm_ror:
.a73c		a9 6e		lda #$6e	                lda #$6E
.a73e		4c 07 a8	jmp $a807	                jmp asm_common
.a741						z_asm_ror:
.a741						xt_asm_ror_a:
.a741		a9 6a		lda #$6a	                lda #$6A
.a743		4c 07 a8	jmp $a807	                jmp asm_common
.a746						z_asm_ror_a:
.a746						xt_asm_ror_x:
.a746		a9 7e		lda #$7e	                lda #$7E
.a748		4c 07 a8	jmp $a807	                jmp asm_common
.a74b						z_asm_ror_x:
.a74b						xt_asm_ror_z:
.a74b		a9 66		lda #$66	                lda #$66
.a74d		4c 07 a8	jmp $a807	                jmp asm_common
.a750						z_asm_ror_z:
.a750						xt_asm_ror_zx:
.a750		a9 76		lda #$76	                lda #$76
.a752		4c 07 a8	jmp $a807	                jmp asm_common
.a755						z_asm_ror_zx:
.a755						xt_asm_rti:
.a755		a9 40		lda #$40	                lda #$40
.a757		4c 07 a8	jmp $a807	                jmp asm_common
.a75a						z_asm_rti:
.a75a						xt_asm_rts:
.a75a		a9 60		lda #$60	                lda #$60
.a75c		4c 07 a8	jmp $a807	                jmp asm_common
.a75f						z_asm_rts:
.a75f						xt_asm_sbc:
.a75f		a9 ed		lda #$ed	                lda #$ED
.a761		4c 07 a8	jmp $a807	                jmp asm_common
.a764						z_asm_sbc:
.a764						xt_asm_sbc_h:
.a764		a9 e9		lda #$e9	                lda #$E9
.a766		4c 07 a8	jmp $a807	                jmp asm_common
.a769						z_asm_sbc_h:
.a769						xt_asm_sbc_x:
.a769		a9 fd		lda #$fd	                lda #$FD
.a76b		4c 07 a8	jmp $a807	                jmp asm_common
.a76e						z_asm_sbc_x:
.a76e						xt_asm_sbc_y:
.a76e		a9 f9		lda #$f9	                lda #$F9
.a770		4c 07 a8	jmp $a807	                jmp asm_common
.a773						z_asm_sbc_y:
.a773						xt_asm_sbc_z:
.a773		a9 e5		lda #$e5	                lda #$E5
.a775		4c 07 a8	jmp $a807	                jmp asm_common
.a778						z_asm_sbc_z:
.a778						xt_asm_sbc_zi:
.a778		a9 f2		lda #$f2	                lda #$F2
.a77a		4c 07 a8	jmp $a807	                jmp asm_common
.a77d						z_asm_sbc_zi:
.a77d						xt_asm_sbc_ziy:
.a77d		a9 f1		lda #$f1	                lda #$F1
.a77f		4c 07 a8	jmp $a807	                jmp asm_common
.a782						z_asm_sbc_ziy:
.a782						xt_asm_sbc_zx:
.a782		a9 f5		lda #$f5	                lda #$F5
.a784		4c 07 a8	jmp $a807	                jmp asm_common
.a787						z_asm_sbc_zx:
.a787						xt_asm_sbc_zxi:
.a787		a9 e1		lda #$e1	                lda #$E1
.a789		80 7c		bra $a807	                bra asm_common  ; <-- limit for BRA instead of JMP
.a78b						z_asm_sbc_zxi:
.a78b						xt_asm_sec:
.a78b		a9 38		lda #$38	                lda #$38
.a78d		80 78		bra $a807	                bra asm_common
.a78f						z_asm_sec:
.a78f						xt_asm_sed:
.a78f		a9 f8		lda #$f8	                lda #$F8
.a791		80 74		bra $a807	                bra asm_common
.a793						z_asm_sed:
.a793						xt_asm_sei:
.a793		a9 78		lda #$78	                lda #$78
.a795		80 70		bra $a807	                bra asm_common
.a797						z_asm_sei:
.a797						xt_asm_sta:
.a797		a9 8d		lda #$8d	                lda #$8D
.a799		80 6c		bra $a807	                bra asm_common
.a79b						z_asm_sta:
.a79b						xt_asm_sta_x:
.a79b		a9 9d		lda #$9d	                lda #$9D
.a79d		80 68		bra $a807	                bra asm_common
.a79f						z_asm_sta_x:
.a79f						xt_asm_sta_y:
.a79f		a9 99		lda #$99	                lda #$99
.a7a1		80 64		bra $a807	                bra asm_common
.a7a3						z_asm_sta_y:
.a7a3						xt_asm_sta_z:
.a7a3		a9 85		lda #$85	                lda #$85
.a7a5		80 60		bra $a807	                bra asm_common
.a7a7						z_asm_sta_z:
.a7a7						xt_asm_sta_zi:
.a7a7		a9 92		lda #$92	                lda #$92
.a7a9		80 5c		bra $a807	                bra asm_common
.a7ab						z_asm_sta_zi:
.a7ab						xt_asm_sta_ziy:
.a7ab		a9 91		lda #$91	                lda #$91
.a7ad		80 58		bra $a807	                bra asm_common
.a7af						z_asm_sta_ziy:
.a7af						xt_asm_sta_zx:
.a7af		a9 95		lda #$95	                lda #$95
.a7b1		80 54		bra $a807	                bra asm_common
.a7b3						z_asm_sta_zx:
.a7b3						xt_asm_sta_zxi:
.a7b3		a9 81		lda #$81	                lda #$81
.a7b5		80 50		bra $a807	                bra asm_common
.a7b7						z_asm_sta_zxi:
.a7b7						xt_asm_stx:
.a7b7		a9 8e		lda #$8e	                lda #$8E
.a7b9		80 4c		bra $a807	                bra asm_common
.a7bb						z_asm_stx:
.a7bb						xt_asm_stx_z:
.a7bb		a9 86		lda #$86	                lda #$86
.a7bd		80 48		bra $a807	                bra asm_common
.a7bf						z_asm_stx_z:
.a7bf						xt_asm_stx_zy:
.a7bf		a9 96		lda #$96	                lda #$96
.a7c1		80 44		bra $a807	                bra asm_common
.a7c3						z_asm_stx_zy:
.a7c3						xt_asm_sty:
.a7c3		a9 8c		lda #$8c	                lda #$8C
.a7c5		80 40		bra $a807	                bra asm_common
.a7c7						z_asm_sty:
.a7c7						xt_asm_sty_z:
.a7c7		a9 84		lda #$84	                lda #$84
.a7c9		80 3c		bra $a807	                bra asm_common
.a7cb						z_asm_sty_z:
.a7cb						xt_asm_sty_zx:
.a7cb		a9 94		lda #$94	                lda #$94
.a7cd		80 38		bra $a807	                bra asm_common
.a7cf						z_asm_sty_zx:
.a7cf						xt_asm_stz:
.a7cf		a9 9c		lda #$9c	                lda #$9C
.a7d1		80 34		bra $a807	                bra asm_common
.a7d3						z_asm_stz:
.a7d3						xt_asm_stz_x:
.a7d3		a9 9e		lda #$9e	                lda #$9E
.a7d5		80 30		bra $a807	                bra asm_common
.a7d7						z_asm_stz_x:
.a7d7						xt_asm_stz_z:
.a7d7		a9 64		lda #$64	                lda #$64
.a7d9		80 2c		bra $a807	                bra asm_common
.a7db						z_asm_stz_z:
.a7db						xt_asm_stz_zx:
.a7db		a9 74		lda #$74	                lda #$74
.a7dd		80 28		bra $a807	                bra asm_common
.a7df						z_asm_stz_zx:
.a7df						xt_asm_tax:
.a7df		a9 aa		lda #$aa	                lda #$AA
.a7e1		80 24		bra $a807	                bra asm_common
.a7e3						z_asm_tax:
.a7e3						xt_asm_tay:
.a7e3		a9 a8		lda #$a8	                lda #$A8
.a7e5		80 20		bra $a807	                bra asm_common
.a7e7						z_asm_tay:
.a7e7						xt_asm_trb:
.a7e7		a9 1c		lda #$1c	                lda #$1C
.a7e9		80 1c		bra $a807	                bra asm_common
.a7eb						z_asm_trb:
.a7eb						xt_asm_trb_z:
.a7eb		a9 14		lda #$14	                lda #$14
.a7ed		80 18		bra $a807	                bra asm_common
.a7ef						z_asm_trb_z:
.a7ef						xt_asm_tsb:
.a7ef		a9 0c		lda #$0c	                lda #$0C
.a7f1		80 14		bra $a807	                bra asm_common
.a7f3						z_asm_tsb:
.a7f3						xt_asm_tsb_z:
.a7f3		a9 04		lda #$04	                lda #$04
.a7f5		80 10		bra $a807	                bra asm_common
.a7f7						z_asm_tsb_z:
.a7f7						xt_asm_tsx:
.a7f7		a9 ba		lda #$ba	                lda #$BA
.a7f9		80 0c		bra $a807	                bra asm_common
.a7fb						z_asm_tsx:
.a7fb						xt_asm_txa:
.a7fb		a9 8a		lda #$8a	                lda #$8A
.a7fd		80 08		bra $a807	                bra asm_common
.a7ff						z_asm_txa:
.a7ff						xt_asm_txs:
.a7ff		a9 9a		lda #$9a	                lda #$9A
.a801		80 04		bra $a807	                bra asm_common
.a803						z_asm_txs:
.a803						xt_asm_tya:
.a803		a9 98		lda #$98	                lda #$98
.a805		80 00		bra $a807	                bra asm_common
.a807						z_asm_tya:
.a807						asm_common:
.a807		a8		tay		                tay
.a808		20 e4 97	jsr $97e4	                jsr cmpl_a
.a80b		a9 13		lda #$13	                lda #<oc_index_table
.a80d		85 27		sta $27		                sta tmp2
.a80f		a9 b4		lda #$b4	                lda #>oc_index_table
.a811		85 28		sta $28		                sta tmp2+1
.a813		98		tya		                tya             ; retrieve opcode
.a814		0a		asl a		                asl             ; times two for offset
.a815		90 02		bcc $a819	                bcc +
.a817		e6 28		inc $28		                inc tmp2+1
.a819						+
.a819		a8		tay		                tay             ; use Y as the index
.a81a		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a81c		85 29		sta $29		                sta tmp3
.a81e		c8		iny		                iny
.a81f		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a821		85 2a		sta $2a		                sta tmp3+1
.a823		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.a825		2a		rol a		                rol
.a826		2a		rol a		                rol
.a827		2a		rol a		                rol             ; Three times because we go through Carry
.a828		29 03		and #$03	                and #%00000011
.a82a		a8		tay		                tay
.a82b		88		dey		                dey
.a82c		f0 12		beq $a840	                beq _done
.a82e		20 f2 d7	jsr $d7f2	                jsr underflow_1
.a831		b5 00		lda $00,x	                lda 0,x
.a833		20 e4 97	jsr $97e4	                jsr cmpl_a      ; does not use Y
.a836		88		dey		                dey
.a837		f0 05		beq $a83e	                beq _done_drop
.a839		b5 01		lda $01,x	                lda 1,x
.a83b		20 e4 97	jsr $97e4	                jsr cmpl_a      ; Fall through to _done_drop
.a83e						_done_drop:
.a83e		e8		inx		                inx
.a83f		e8		inx		                inx             ; Fall through to _done
.a840						_done:
.a840		60		rts		                rts             ; Returns to original caller
.a841						xt_asm_push_a:
.a841		a0 00		ldy #$00	                ldy #0
.a843						_loop:
.a843		b9 a7 a4	lda $a4a7,y	                lda push_a_tos,y
.a846		20 e4 97	jsr $97e4	                jsr cmpl_a      ; does not change Y
.a849		c8		iny		                iny
.a84a		c0 06		cpy #$06	                cpy #z_push_a_tos - push_a_tos
.a84c		d0 f5		bne $a843	                bne _loop
.a84e						_done:
.a84e						z_asm_push_a:
.a84e		60		rts		                rts
.a84f						xt_asm_back_jump:
.a84f						z_asm_back_jump:
.a84f		60		rts		                rts
.a850						xt_asm_back_branch:
.a850		20 0f 89	jsr $890f	                jsr w_here             ; ( addr-l addr-h )
.a853		20 e3 8b	jsr $8be3	                jsr w_minus            ; ( offset )
.a856		3a		dec a		                dea
.a857		3a		dec a		                dea
.a858						z_asm_back_branch:
.a858		60		rts		                rts
.a859						assembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/ed.asm

.a859						xt_ed:
.a859						w_ed:
.a859		20 5d a8	jsr $a85d	                jsr ed6502      ; kept in separate file
.a85c		60		rts		z_ed:           rts
=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.a85d						ed6502:
.a85d		a5 18		lda $18		                lda base
.a85f		85 3a		sta $3a		                sta ed_base
.a861		a9 0a		lda #$0a	                lda #10
.a863		85 18		sta $18		                sta base
.a865		64 35		stz $35		                stz ed_head
.a867		64 36		stz $36		                stz ed_head+1
.a869		64 37		stz $37		                stz ed_cur
.a86b		64 38		stz $38		                stz ed_cur+1
.a86d		64 39		stz $39		                stz ed_flags
.a86f		20 99 9e	jsr $9e99	                jsr w_zero
.a872		20 99 9e	jsr $9e99	                jsr w_zero             ; ( addr-t u-t )
.a875		20 17 84	jsr $8417	                jsr w_cr
.a878						ed_input_loop:
.a878		a9 81		lda #$81	                lda #%10000001
.a87a		14 39		trb $39		                trb ed_flags
.a87c		20 57 ad	jsr $ad57	                jsr ed_get_input
.a87f		a5 0e		lda $0e		                lda ciblen
.a881		d0 1f		bne $a8a2	                bne _command_mode
.a883		ca		dex		                dex
.a884		ca		dex		                dex                     ; ( addr-t u-t ? )
.a885		a5 37		lda $37		                lda ed_cur
.a887		95 00		sta $00,x	                sta 0,x
.a889		a5 38		lda $38		                lda ed_cur+1
.a88b		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.a88d		a9 80		lda #$80	                lda #%10000000
.a88f		04 39		tsb $39		                tsb ed_flags
.a891		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; ( addr-t u-t u+1 )
.a894		20 73 ad	jsr $ad73	                jsr ed_is_valid_line
.a897		b0 03		bcs $a89c	                bcs +
.a899		4c 47 ad	jmp $ad47	                jmp ed_error_1drop
.a89c						+
.a89c		20 99 9e	jsr $9e99	                jsr w_zero             ; ( addr-t u-t u+1 0 )
.a89f		4c 6d a9	jmp $a96d	                jmp _line_number_only_from_external
.a8a2						_command_mode:
.a8a2		20 99 9e	jsr $9e99	                jsr w_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.a8a5		20 99 9e	jsr $9e99	                jsr w_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.a8a8		b2 0c		lda ($0c)	                lda (cib)
.a8aa		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.a8ac		d0 3a		bne $a8e8	                bne _prefix_dollar
.a8ae		20 68 ad	jsr $ad68	                jsr ed_have_text
.a8b1		a5 37		lda $37		                lda ed_cur
.a8b3		95 02		sta $02,x	                sta 2,x
.a8b5		a5 38		lda $38		                lda ed_cur+1
.a8b7		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a8b9		a9 80		lda #$80	                lda #%10000000
.a8bb		04 39		tsb $39		                tsb ed_flags
.a8bd		a5 0e		lda $0e		                lda ciblen
.a8bf		3a		dec a		                dea                     ; sets Z if A was 1
.a8c0		d0 03		bne $a8c5	                bne +
.a8c2		4c 6d a9	jmp $a96d	                jmp _line_number_only_from_external
.a8c5						+
.a8c5		ca		dex		                dex
.a8c6		ca		dex		                dex
.a8c7		ca		dex		                dex
.a8c8		ca		dex		                dex
.a8c9		a5 0c		lda $0c		                lda cib
.a8cb		95 02		sta $02,x	                sta 2,x
.a8cd		a5 0d		lda $0d		                lda cib+1
.a8cf		95 03		sta $03,x	                sta 3,x
.a8d1		a5 0e		lda $0e		                lda ciblen
.a8d3		95 00		sta $00,x	                sta 0,x
.a8d5		a5 0f		lda $0f		                lda ciblen+1
.a8d7		95 01		sta $01,x	                sta 1,x
.a8d9		20 db 8c	jsr $8cdb	                jsr w_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.a8dc		20 46 92	jsr $9246	                jsr w_swap             ; ( addr-t u-t para1 0 u-1 addr )
.a8df		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.a8e2		20 46 92	jsr $9246	                jsr w_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.a8e5		4c c5 a9	jmp $a9c5	                jmp _check_for_para2
.a8e8						_prefix_dollar:
.a8e8		b2 0c		lda ($0c)	                lda (cib)
.a8ea		c9 24		cmp #$24	                cmp #'$'
.a8ec		d0 1c		bne $a90a	                bne _prefix_percent
.a8ee		20 68 ad	jsr $ad68	                jsr ed_have_text
.a8f1		e8		inx		                inx
.a8f2		e8		inx		                inx                     ; ( addr-t u-t 0 )
.a8f3		20 95 ad	jsr $ad95	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.a8f6		20 46 92	jsr $9246	                jsr w_swap             ; SWAP ( addr-t u-t para1 0 )
.a8f9		a9 80		lda #$80	                lda #%10000000
.a8fb		04 39		tsb $39		                tsb ed_flags
.a8fd		a5 0e		lda $0e		                lda ciblen
.a8ff		3a		dec a		                dea                     ; sets Z if A was 1
.a900		d0 03		bne $a905	                bne +
.a902		4c 6d a9	jmp $a96d	                jmp _line_number_only_from_external
.a905						+
.a905		a0 01		ldy #$01	                ldy #01
.a907		4c 41 aa	jmp $aa41	                jmp _check_command
.a90a						_prefix_percent:
.a90a		b2 0c		lda ($0c)	                lda (cib)
.a90c		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.a90e		f0 04		beq $a914	                beq _whole_text
.a910		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.a912		d0 17		bne $a92b	                bne _prefix_semicolon
.a914						_whole_text:
.a914		20 68 ad	jsr $ad68	                jsr ed_have_text
.a917		a9 01		lda #$01	                lda #01
.a919		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.a91b		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.a91d						_semicolon_entry:
.a91d		e8		inx		                inx
.a91e		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.a91f		20 95 ad	jsr $ad95	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a922		a9 80		lda #$80	                lda #%10000000
.a924		04 39		tsb $39		                tsb ed_flags
.a926		a0 01		ldy #$01	                ldy #01
.a928		4c 41 aa	jmp $aa41	                jmp _check_command
.a92b						_prefix_semicolon:
.a92b		b2 0c		lda ($0c)	                lda (cib)
.a92d		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.a92f		d0 0d		bne $a93e	                bne _prefix_number
.a931		20 68 ad	jsr $ad68	                jsr ed_have_text
.a934		a5 37		lda $37		                lda ed_cur
.a936		95 02		sta $02,x	                sta 2,x
.a938		a5 38		lda $38		                lda ed_cur+1
.a93a		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a93c		80 df		bra $a91d	                bra _semicolon_entry
.a93e						_prefix_number:
.a93e		20 99 9e	jsr $9e99	                jsr w_zero
.a941		20 99 9e	jsr $9e99	                jsr w_zero             ; ( addr-t u-t 0 0 0 0 )
.a944		ca		dex		                dex
.a945		ca		dex		                dex
.a946		ca		dex		                dex
.a947		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.a948		a5 0c		lda $0c		                lda cib
.a94a		95 02		sta $02,x	                sta 2,x
.a94c		a5 0d		lda $0d		                lda cib+1
.a94e		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.a950		a5 0e		lda $0e		                lda ciblen
.a952		95 00		sta $00,x	                sta 0,x
.a954		a5 0f		lda $0f		                lda ciblen+1
.a956		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.a958		20 e4 92	jsr $92e4	                jsr w_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.a95b		b5 00		lda $00,x	                lda 0,x
.a95d		15 01		ora $01,x	                ora 1,x
.a95f		d0 24		bne $a985	                bne _have_unconverted_chars
.a961		e8		inx		                inx
.a962		e8		inx		                inx
.a963		e8		inx		                inx
.a964		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.a965		20 e5 9e	jsr $9ee5	                jsr w_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.a968		20 20 9d	jsr $9d20	                jsr w_not_rot          ; -ROT ( addr-t u-t u 0 0 )
.a96b		e8		inx		                inx
.a96c		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.a96d						_line_number_only_from_external:
.a96d		20 46 92	jsr $9246	                jsr w_swap             ; ( addr-t u-t 0 u )
.a970		20 73 ad	jsr $ad73	                jsr ed_is_valid_line
.a973		b0 03		bcs $a978	                bcs +
.a975		4c 45 ad	jmp $ad45	                jmp ed_error_2drop
.a978						+
.a978		20 46 92	jsr $9246	                jsr w_swap             ; ( addr-t u-t u 0 )
.a97b		20 02 ae	jsr $ae02	                jsr ed_para1_to_cur
.a97e		a9 80		lda #$80	                lda #%10000000
.a980		04 39		tsb $39		                tsb ed_flags
.a982		4c 20 ac	jmp $ac20	                jmp ed_cmd_p_from_external
.a985						_have_unconverted_chars:
.a985		20 91 86	jsr $8691	                jsr w_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.a988		ca		dex		                dex
.a989		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.a98a		a5 0e		lda $0e		                lda ciblen
.a98c		95 00		sta $00,x	                sta 0,x
.a98e		a5 0f		lda $0f		                lda ciblen+1
.a990		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.a992		20 85 87	jsr $8785	                jsr w_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.a995		b5 00		lda $00,x	                lda 0,x
.a997		15 01		ora $01,x	                ora 1,x
.a999		f0 0e		beq $a9a9	                beq _no_command_yet
.a99b		8a		txa		                txa
.a99c		18		clc		                clc
.a99d		69 0a		adc #$0a	                adc #10
.a99f		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.a9a0		a9 80		lda #$80	                lda #%10000000
.a9a2		14 39		trb $39		                trb ed_flags
.a9a4		a0 00		ldy #$00	                ldy #00
.a9a6		4c 41 aa	jmp $aa41	                jmp _check_command
.a9a9						_no_command_yet:
.a9a9		e8		inx		                inx
.a9aa		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.a9ab		20 81 93	jsr $9381	                jsr w_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.a9ae		20 20 9d	jsr $9d20	                jsr w_not_rot          ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.a9b1		20 e5 9e	jsr $9ee5	                jsr w_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.a9b4		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a9b6		95 06		sta $06,x	                sta 6,x
.a9b8		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a9ba		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.a9bc		e8		inx		                inx
.a9bd		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.a9be		20 dd 8e	jsr $8edd	                jsr w_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.a9c1		a9 80		lda #$80	                lda #%10000000
.a9c3		04 39		tsb $39		                tsb ed_flags
.a9c5						_check_for_para2:
.a9c5		a1 02		lda ($02,x)	                lda (2,x)
.a9c7		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.a9c9		f0 0d		beq $a9d8	                beq _got_comma
.a9cb		38		sec		                sec
.a9cc		a5 0e		lda $0e		                lda ciblen
.a9ce		f5 00		sbc $00,x	                sbc 0,x
.a9d0		a8		tay		                tay
.a9d1		e8		inx		                inx
.a9d2		e8		inx		                inx
.a9d3		e8		inx		                inx
.a9d4		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.a9d5		4c 41 aa	jmp $aa41	                jmp _check_command
.a9d8						_got_comma:
.a9d8		f6 02		inc $02,x	                inc 2,x
.a9da		d0 02		bne $a9de	                bne +
.a9dc		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.a9de						+
.a9de		b5 01		lda $01,x	                lda 1,x
.a9e0		f0 02		beq $a9e4	                beq +
.a9e2		d6 01		dec $01,x	                dec 1,x
.a9e4						+
.a9e4		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.a9e6		a1 02		lda ($02,x)	                lda (2,x)
.a9e8		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.a9ea		d0 14		bne $aa00	                bne _para2_not_dollar
.a9ec		38		sec		                sec
.a9ed		a5 0e		lda $0e		                lda ciblen
.a9ef		f5 02		sbc $02,x	                sbc 2,x
.a9f1		a8		tay		                tay
.a9f2		c8		iny		                iny
.a9f3		5a		phy		                phy
.a9f4		8a		txa		                txa
.a9f5		18		clc		                clc
.a9f6		69 06		adc #$06	                adc #06
.a9f8		aa		tax		                tax                     ; ( addr-t u-t para1 )
.a9f9		20 95 ad	jsr $ad95	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a9fc		7a		ply		                ply
.a9fd		4c 41 aa	jmp $aa41	                jmp _check_command
.aa00						_para2_not_dollar:
.aa00		20 81 93	jsr $9381	                jsr w_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.aa03		20 99 9e	jsr $9e99	                jsr w_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.aa06		20 99 9e	jsr $9e99	                jsr w_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.aa09		20 84 8f	jsr $8f84	                jsr w_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.aa0c		20 dd 8e	jsr $8edd	                jsr w_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.aa0f		20 91 86	jsr $8691	                jsr w_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.aa12		20 81 93	jsr $9381	                jsr w_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.aa15		20 e4 92	jsr $92e4	                jsr w_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.aa18		20 91 86	jsr $8691	                jsr w_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.aa1b		20 dd 8e	jsr $8edd	                jsr w_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.aa1e		20 85 87	jsr $8785	                jsr w_equal            ; = ( ... para1 0 ud addr3 u3 f )
.aa21		b5 00		lda $00,x	                lda 0,x
.aa23		15 01		ora $01,x	                ora 1,x
.aa25		f0 08		beq $aa2f	                beq _second_number
.aa27		8a		txa		                txa
.aa28		18		clc		                clc
.aa29		69 0c		adc #$0c	                adc #12
.aa2b		aa		tax		                tax                     ; back to ( addr-t u-t )
.aa2c		4c 49 ad	jmp $ad49	                jmp ed_error
.aa2f						_second_number:
.aa2f		e8		inx		                inx
.aa30		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.aa31		38		sec		                sec
.aa32		a5 0e		lda $0e		                lda ciblen
.aa34		f5 00		sbc $00,x	                sbc 0,x
.aa36		48		pha		                pha
.aa37		20 bf 93	jsr $93bf	                jsr w_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.aa3a		20 e5 9e	jsr $9ee5	                jsr w_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.aa3d		20 32 8c	jsr $8c32	                jsr w_nip              ; NIP ( addr-t u-t para1 para2 )
.aa40		7a		ply		                ply
.aa41						_check_command:
.aa41		24 39		bit $39		                bit ed_flags
.aa43		30 08		bmi $aa4d	                bmi _check_command_have_arg
.aa45		a5 37		lda $37		                lda ed_cur
.aa47		95 02		sta $02,x	                sta 2,x
.aa49		a5 38		lda $38		                lda ed_cur+1
.aa4b		95 03		sta $03,x	                sta 3,x
.aa4d						_check_command_have_arg:
.aa4d		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.aa4f		85 25		sta $25		                sta tmp1
.aa51		da		phx		                phx
.aa52		a2 00		ldx #$00	                ldx #00
.aa54						_cmd_loop:
.aa54		bd 2d ae	lda $ae2d,x	                lda ed_cmd_list,x
.aa57		f0 07		beq $aa60	                beq _illegal_command    ; zero marks end of list
.aa59		c5 25		cmp $25		                cmp tmp1
.aa5b		f0 07		beq $aa64	                beq _found_cmd
.aa5d		e8		inx		                inx
.aa5e		80 f4		bra $aa54	                bra _cmd_loop
.aa60						_illegal_command:
.aa60		fa		plx		                plx
.aa61		4c 45 ad	jmp $ad45	                jmp ed_error_2drop
.aa64						_found_cmd:
.aa64		8a		txa		                txa
.aa65		0a		asl a		                asl
.aa66		aa		tax		                tax                     ; X * 2 for table
.aa67		7c 38 ae	jmp ($ae38,x)	                jmp (ed_cmd_table,x)
.aa6a						ed_next_command:
.aa6a		e8		inx		                inx
.aa6b		e8		inx		                inx
.aa6c		e8		inx		                inx
.aa6d		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.aa6e		4c 78 a8	jmp $a878	                jmp ed_input_loop
.aa71						ed_all_done:
.aa71		64 0e		stz $0e		                stz ciblen
.aa73		64 0f		stz $0f		                stz ciblen+1
.aa75		20 bf 93	jsr $93bf	                jsr w_two_drop                 ; 2DROP ( addr-t u-t )
.aa78		a5 3a		lda $3a		                lda ed_base
.aa7a		85 18		sta $18		                sta base
.aa7c		60		rts		                rts
.aa7d						ed_cmd_a:
.aa7d		fa		plx		                plx
.aa7e		e8		inx		                inx
.aa7f		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.aa80						ed_entry_cmd_i:
.aa80		20 cb ad	jsr $adcb	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.aa83		20 17 84	jsr $8417	                jsr w_cr
.aa86						_next_string_loop:
.aa86		20 57 ad	jsr $ad57	                jsr ed_get_input
.aa89		b2 0c		lda ($0c)	                lda (cib)
.aa8b		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.aa8d		d0 16		bne $aaa5	                bne _add_line
.aa8f		a4 0e		ldy $0e		                ldy ciblen
.aa91		c0 01		cpy #$01	                cpy #01
.aa93		d0 10		bne $aaa5	                bne _add_line
.aa95		a4 0f		ldy $0f		                ldy ciblen+1
.aa97		d0 0c		bne $aaa5	                bne _add_line
.aa99		e8		inx		                inx
.aa9a		e8		inx		                inx
.aa9b		a9 40		lda #$40	                lda #%01000000
.aa9d		04 39		tsb $39		                tsb ed_flags
.aa9f		20 17 84	jsr $8417	                jsr w_cr
.aaa2		4c 78 a8	jmp $a878	                jmp ed_input_loop
.aaa5						_add_line:
.aaa5		20 91 86	jsr $8691	                jsr w_dup              ; DUP ( addr-t u-t addr1 addr1 )
.aaa8		20 0f 89	jsr $890f	                jsr w_here             ; HERE ( addr-t u-t addr1 addr1 here )
.aaab		20 46 92	jsr $9246	                jsr w_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.aaae		20 11 88	jsr $8811	                jsr w_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.aab1		20 d9 83	jsr $83d9	                jsr w_comma            ; ,  ( addr-t u-t addr1 here )
.aab4		20 a5 93	jsr $93a5	                jsr w_tuck             ; TUCK ( addr-t u-t here addr1 here )
.aab7		20 46 92	jsr $9246	                jsr w_swap             ; SWAP ( addr-t u-t here here addr1 )
.aaba		20 30 92	jsr $9230	                jsr w_store            ; ! ( addr-t u-t here )
.aabd		20 0f 89	jsr $890f	                jsr w_here             ; HERE ( addr-t u-t here here2)
.aac0		a5 00		lda $00		                lda cp
.aac2		18		clc		                clc
.aac3		69 04		adc #$04	                adc #04
.aac5		85 00		sta $00		                sta cp
.aac7		90 02		bcc $aacb	                bcc +
.aac9		e6 01		inc $01		                inc cp+1
.aacb						+
.aacb		e6 37		inc $37		                inc ed_cur
.aacd		d0 02		bne $aad1	                bne +
.aacf		e6 38		inc $38		                inc ed_cur+1
.aad1						+
.aad1		20 0f 89	jsr $890f	                jsr w_here     ; HERE ( addr-t u-t here here2 here3 )
.aad4		20 91 86	jsr $8691	                jsr w_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.aad7		ca		dex		                dex
.aad8		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.aad9		a5 0c		lda $0c		                lda cib
.aadb		95 00		sta $00,x	                sta 0,x
.aadd		a5 0d		lda $0d		                lda cib+1
.aadf		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.aae1		20 46 92	jsr $9246	                jsr w_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.aae4		ca		dex		                dex
.aae5		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.aae6		a5 0e		lda $0e		                lda ciblen
.aae8		95 00		sta $00,x	                sta 0,x
.aaea		a5 0f		lda $0f		                lda ciblen+1
.aaec		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.aaee		20 ff 8b	jsr $8bff	                jsr w_move     ; ( addr-t u-t here here2 here3 )
.aaf1		18		clc		                clc
.aaf2		a5 00		lda $00		                lda cp
.aaf4		65 0e		adc $0e		                adc ciblen
.aaf6		85 00		sta $00		                sta cp
.aaf8		90 06		bcc $ab00	                bcc +
.aafa		a5 01		lda $01		                lda cp+1
.aafc		65 0f		adc $0f		                adc ciblen+1
.aafe		85 01		sta $01		                sta cp+1
.ab00						+
.ab00		20 03 8d	jsr $8d03	                jsr w_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.ab03		20 30 92	jsr $9230	                jsr w_store            ; ! ( addr-t u-t here here2 )
.ab06		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; 1+
.ab09		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.ab0c		20 91 86	jsr $8691	                jsr w_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.ab0f		a5 0e		lda $0e		                lda ciblen
.ab11		95 02		sta $02,x	                sta 2,x
.ab13		a5 0f		lda $0f		                lda ciblen+1
.ab15		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.ab17		20 30 92	jsr $9230	                jsr w_store            ; ! ( addr-t u-t here )
.ab1a		20 17 84	jsr $8417	                jsr w_cr
.ab1d		4c 86 aa	jmp $aa86	                jmp _next_string_loop
.ab20						ed_cmd_d:
.ab20		fa		plx		                plx
.ab21		20 68 ad	jsr $ad68	                jsr ed_have_text
.ab24		20 bd ad	jsr $adbd	                jsr ed_no_line_zero
.ab27		b5 00		lda $00,x	                lda 0,x
.ab29		15 01		ora $01,x	                ora 1,x
.ab2b		d0 08		bne $ab35	                bne +
.ab2d		20 03 8d	jsr $8d03	                jsr w_over             ; ( addr-t u-t para1 0 para1 )
.ab30		20 72 ab	jsr $ab72	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.ab33		80 33		bra $ab68	                bra _cmd_d_done
.ab35						+
.ab35		20 73 ad	jsr $ad73	                jsr ed_is_valid_line      ; result is in C flag
.ab38		b0 03		bcs $ab3d	                bcs _cmd_d_loop
.ab3a		4c 45 ad	jmp $ad45	                jmp ed_error_2drop
.ab3d						_cmd_d_loop:
.ab3d		20 c7 93	jsr $93c7	                jsr w_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ab40		20 fd 88	jsr $88fd	                jsr w_greater_than     ; > ( addr-t u-t para1 para2 f )
.ab43		b5 00		lda $00,x	                lda 0,x
.ab45		15 01		ora $01,x	                ora 1,x
.ab47		d0 0d		bne $ab56	                bne _cmd_d_done_with_flag
.ab49		e8		inx		                inx
.ab4a		e8		inx		                inx                     ; Get rid of the flag from >
.ab4b		20 91 86	jsr $8691	                jsr w_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.ab4e		20 72 ab	jsr $ab72	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.ab51		20 db 8c	jsr $8cdb	                jsr w_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.ab54		80 e7		bra $ab3d	                bra _cmd_d_loop
.ab56						_cmd_d_done_with_flag:
.ab56		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.ab57		e8		inx		                inx
.ab58		b5 02		lda $02,x	                lda 2,x
.ab5a		d0 02		bne $ab5e	                bne +
.ab5c		d6 03		dec $03,x	                dec 3,x
.ab5e						+
.ab5e		d6 02		dec $02,x	                dec 2,x
.ab60		b5 02		lda $02,x	                lda 2,x
.ab62		85 37		sta $37		                sta ed_cur
.ab64		b5 03		lda $03,x	                lda 3,x
.ab66		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.ab68						_cmd_d_done:
.ab68		a9 40		lda #$40	                lda #%01000000
.ab6a		04 39		tsb $39		                tsb ed_flags
.ab6c		20 17 84	jsr $8417	                jsr w_cr
.ab6f		4c 6a aa	jmp $aa6a	                jmp ed_next_command
.ab72						_cmd_d_common:
.ab72		20 91 86	jsr $8691	                jsr w_dup              ; DUP ( addr-t u-t u u )
.ab75		20 cb ad	jsr $adcb	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.ab78		20 11 88	jsr $8811	                jsr w_fetch            ; @ ( addr-t u-t u addr1 )
.ab7b		20 46 92	jsr $9246	                jsr w_swap             ; SWAP ( addr-t u-t addr1 u )
.ab7e		20 db 8c	jsr $8cdb	                jsr w_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.ab81		20 cb ad	jsr $adcb	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.ab84		20 30 92	jsr $9230	                jsr w_store            ; ! ( addr-t u-t )
.ab87		60		rts		                rts
.ab88						ed_cmd_equ:
.ab88		fa		plx		                plx
.ab89		a5 35		lda $35		                lda ed_head
.ab8b		05 36		ora $36		                ora ed_head+1
.ab8d		d0 08		bne $ab97	                bne _cmd_equ_have_text
.ab8f		ca		dex		                dex
.ab90		ca		dex		                dex
.ab91		74 00		stz $00,x	                stz 0,x
.ab93		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.ab95		80 21		bra $abb8	                bra _cmd_equ_done
.ab97						_cmd_equ_have_text:
.ab97		20 bd ad	jsr $adbd	                jsr ed_no_line_zero
.ab9a		24 39		bit $39		                bit ed_flags
.ab9c		30 0c		bmi $abaa	                bmi _cmd_equ_have_para
.ab9e		ca		dex		                dex
.ab9f		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.aba0		a5 37		lda $37		                lda ed_cur
.aba2		95 00		sta $00,x	                sta 0,x
.aba4		a5 38		lda $38		                lda ed_cur+1
.aba6		95 01		sta $01,x	                sta 1,x
.aba8		80 0e		bra $abb8	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.abaa						_cmd_equ_have_para:
.abaa		b5 00		lda $00,x	                lda 0,x
.abac		15 01		ora $01,x	                ora 1,x
.abae		d0 05		bne $abb5	                bne _cmd_equ_two_paras
.abb0		20 03 8d	jsr $8d03	                jsr w_over             ; ( addr-t u-t para1 para2 para1)
.abb3		80 03		bra $abb8	                bra _cmd_equ_done
.abb5						_cmd_equ_two_paras:
.abb5		20 91 86	jsr $8691	                jsr w_dup              ; ( addr-t u-t para1 para2 para2) drop through
.abb8						_cmd_equ_done:
.abb8		20 17 84	jsr $8417	                jsr w_cr               ; number goes on new line
.abbb		20 07 95	jsr $9507	                jsr w_u_dot            ; ( addr-t u-t para1 para2 )
.abbe		20 17 84	jsr $8417	                jsr w_cr
.abc1		4c 6a aa	jmp $aa6a	                jmp ed_next_command
.abc4						ed_cmd_f:
.abc4		fa		plx		                plx
.abc5		24 39		bit $39		                bit ed_flags
.abc7		30 17		bmi $abe0	                bmi _cmd_f_have_para
.abc9		20 17 84	jsr $8417	                jsr w_cr
.abcc		20 81 93	jsr $9381	                jsr w_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.abcf		20 84 8f	jsr $8f84	                jsr w_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.abd2		20 91 86	jsr $8691	                jsr w_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.abd5		20 07 95	jsr $9507	                jsr w_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.abd8		20 20 9d	jsr $9d20	                jsr w_not_rot          ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.abdb		20 dd 8e	jsr $8edd	                jsr w_r_from           ; R>   ( addr-t u-t 0 0 )
.abde		80 11		bra $abf1	                bra _cmd_f_done
.abe0						_cmd_f_have_para:
.abe0		20 03 8d	jsr $8d03	                jsr w_over
.abe3		20 17 84	jsr $8417	                jsr w_cr
.abe6		20 07 95	jsr $9507	                jsr w_u_dot
.abe9		b5 02		lda $02,x	                lda 2,x
.abeb		95 06		sta $06,x	                sta 6,x
.abed		b5 03		lda $03,x	                lda 3,x
.abef		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.abf1						_cmd_f_done:
.abf1		20 17 84	jsr $8417	                jsr w_cr
.abf4		4c 6a aa	jmp $aa6a	                jmp ed_next_command
.abf7						ed_cmd_i:
.abf7		fa		plx		                plx
.abf8		e8		inx		                inx
.abf9		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.abfa		24 39		bit $39		                bit ed_flags
.abfc		30 08		bmi $ac06	                bmi _cmd_i_have_para
.abfe		a5 37		lda $37		                lda ed_cur
.ac00		95 00		sta $00,x	                sta 0,x
.ac02		a5 38		lda $38		                lda ed_cur+1
.ac04		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.ac06						_cmd_i_have_para:
.ac06		b5 00		lda $00,x	                lda 0,x
.ac08		15 01		ora $01,x	                ora 1,x
.ac0a		f0 09		beq $ac15	                beq _cmd_i_done
.ac0c		20 db 8c	jsr $8cdb	                jsr w_one_minus        ; 1-  ( addr-t u-t para1-1 )
.ac0f		20 99 9e	jsr $9e99	                jsr w_zero             ; 0   ( addr-t u-t para1-1 0 )
.ac12		20 ab 8b	jsr $8bab	                jsr w_max              ; MAX ( addr-t u-t para1-1 | 0 )
.ac15						_cmd_i_done:
.ac15		4c 80 aa	jmp $aa80	                jmp ed_entry_cmd_i
.ac18						ed_cmd_n:
.ac18		fa		plx		                plx
.ac19		a9 01		lda #$01	                lda #%00000001
.ac1b		04 39		tsb $39		                tsb ed_flags
.ac1d		80 05		bra $ac24	                bra ed_cmd_p_entry_for_cmd_n
.ac1f						ed_cmd_p:
.ac1f		fa		plx		                plx
.ac20						ed_cmd_p_from_external:
.ac20		a9 01		lda #$01	                lda #%00000001
.ac22		14 39		trb $39		                trb ed_flags
.ac24						ed_cmd_p_entry_for_cmd_n:
.ac24		20 68 ad	jsr $ad68	                jsr ed_have_text
.ac27		20 bd ad	jsr $adbd	                jsr ed_no_line_zero
.ac2a		20 17 84	jsr $8417	                jsr w_cr
.ac2d		b5 00		lda $00,x	                lda 0,x
.ac2f		15 01		ora $01,x	                ora 1,x
.ac31		d0 10		bne $ac43	                bne _cmd_p_loop
.ac33		b5 02		lda $02,x	                lda 2,x
.ac35		85 37		sta $37		                sta ed_cur
.ac37		b5 03		lda $03,x	                lda 3,x
.ac39		85 38		sta $38		                sta ed_cur+1
.ac3b		20 03 8d	jsr $8d03	                jsr w_over             ; OVER ( addr-t u-t para1 para2 para1 )
.ac3e		20 6c ac	jsr $ac6c	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ac41		80 26		bra $ac69	                bra _cmd_p_all_done
.ac43						_cmd_p_loop:
.ac43		20 c7 93	jsr $93c7	                jsr w_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ac46		20 fd 88	jsr $88fd	                jsr w_greater_than     ; > ( addr-t u-t para1 para2 f )
.ac49		b5 00		lda $00,x	                lda 0,x
.ac4b		15 01		ora $01,x	                ora 1,x
.ac4d		d0 10		bne $ac5f	                bne _cmd_p_done
.ac4f		e8		inx		                inx
.ac50		e8		inx		                inx                     ; Get rid of the flag from >
.ac51		20 03 8d	jsr $8d03	                jsr w_over             ; ( addr-t u-t para1 para2 para1 )
.ac54		20 6c ac	jsr $ac6c	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ac57		f6 02		inc $02,x	                inc 2,x
.ac59		d0 02		bne $ac5d	                bne +
.ac5b		f6 03		inc $03,x	                inc 3,x
.ac5d						+
.ac5d		80 e4		bra $ac43	                bra _cmd_p_loop
.ac5f						_cmd_p_done:
.ac5f		e8		inx		                inx
.ac60		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.ac61		b5 00		lda $00,x	                lda 0,x
.ac63		85 37		sta $37		                sta ed_cur
.ac65		b5 01		lda $01,x	                lda 1,x
.ac67		85 38		sta $38		                sta ed_cur+1
.ac69						_cmd_p_all_done:
.ac69		4c 6a aa	jmp $aa6a	                jmp ed_next_command
.ac6c						_cmd_p_common:
.ac6c		a5 39		lda $39		                lda ed_flags
.ac6e		4a		lsr a		                lsr                     ; bit 0 now in carry
.ac6f		90 0b		bcc $ac7c	                bcc _cmd_p_common_no_num
.ac71		20 91 86	jsr $8691	                jsr w_dup              ; DUP ( addr-t u-t para1 para1 )
.ac74		20 07 95	jsr $9507	                jsr w_u_dot            ; U. ( addr-t u-t para1 )
.ac77		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.ac79		20 bb 86	jsr $86bb	                jsr emit_a
.ac7c						_cmd_p_common_no_num:
.ac7c		20 cb ad	jsr $adcb	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.ac7f		20 0b ae	jsr $ae0b	                jsr ed_print_addr
.ac82		60		rts		                rts
.ac83						ed_cmd_q:
.ac83		fa		plx		                plx
.ac84		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.ac86		50 03		bvc $ac8b	                bvc +
.ac88		4c 45 ad	jmp $ad45	                jmp ed_error_2drop
.ac8b						+
.ac8b		4c 71 aa	jmp $aa71	                jmp ed_all_done            ; can't fall thru because of PLX
.ac8e						ed_cmd_qq:
.ac8e		fa		plx		                plx
.ac8f		4c 71 aa	jmp $aa71	                jmp ed_all_done
.ac92						ed_cmd_w:
.ac92		fa		plx		                plx
.ac93		20 68 ad	jsr $ad68	                jsr ed_have_text
.ac96		24 39		bit $39		                bit ed_flags
.ac98		30 13		bmi $acad	                bmi _cmd_w_have_para
.ac9a		b5 06		lda $06,x	                lda 6,x
.ac9c		15 07		ora $07,x	                ora 7,x
.ac9e		d0 03		bne $aca3	                bne +
.aca0		4c 45 ad	jmp $ad45	                jmp ed_error_2drop
.aca3						+
.aca3		b5 06		lda $06,x	                lda 6,x
.aca5		95 02		sta $02,x	                sta 2,x
.aca7		b5 07		lda $07,x	                lda 7,x
.aca9		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.acab		80 08		bra $acb5	                bra _cmd_w_para_ready
.acad						_cmd_w_have_para:
.acad		b5 02		lda $02,x	                lda 2,x
.acaf		95 06		sta $06,x	                sta 6,x
.acb1		b5 03		lda $03,x	                lda 3,x
.acb3		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.acb5						_cmd_w_para_ready:
.acb5		a9 35		lda #$35	                lda #<ed_head
.acb7		95 00		sta $00,x	                sta 0,x
.acb9		a9 00		lda #$00	                lda #>ed_head
.acbb		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.acbd		20 03 8d	jsr $8d03	                jsr w_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.acc0		20 81 93	jsr $9381	                jsr w_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.acc3						_cmd_w_loop:
.acc3		20 11 88	jsr $8811	                jsr w_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.acc6		b5 00		lda $00,x	                lda 0,x
.acc8		15 01		ora $01,x	                ora 1,x
.acca		f0 55		beq $ad21	                beq _cmd_w_eol
.accc		20 c7 93	jsr $93c7	                jsr w_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.accf		20 b9 94	jsr $94b9	                jsr w_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.acd2		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.acd5		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.acd8		20 91 86	jsr $8691	                jsr w_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.acdb		20 11 88	jsr $8811	                jsr w_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.acde		20 46 92	jsr $9246	                jsr w_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ace1		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ace4		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ace7		20 11 88	jsr $8811	                jsr w_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.acea		20 20 9d	jsr $9d20	                jsr w_not_rot          ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.aced		20 46 92	jsr $9246	                jsr w_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.acf0		20 84 8f	jsr $8f84	                jsr w_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.acf3		20 91 86	jsr $8691	                jsr w_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.acf6		20 81 93	jsr $9381	                jsr w_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.acf9		20 ff 8b	jsr $8bff	                jsr w_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.acfc		20 dd 8e	jsr $8edd	                jsr w_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.acff		20 3f 94	jsr $943f	                jsr w_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ad02		20 20 9d	jsr $9d20	                jsr w_not_rot          ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ad05		20 51 8e	jsr $8e51	                jsr w_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ad08		20 91 86	jsr $8691	                jsr w_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ad0b		ca		dex		                dex
.ad0c		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ad0d		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ad0f		95 00		sta $00,x	                sta 0,x
.ad11		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ad13		20 46 92	jsr $9246	                jsr w_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ad16		20 30 92	jsr $9230	                jsr w_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ad19		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ad1c		20 46 92	jsr $9246	                jsr w_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ad1f		80 a2		bra $acc3	                bra _cmd_w_loop
.ad21						_cmd_w_eol:
.ad21		20 46 92	jsr $9246	                jsr w_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ad24		20 dd 8e	jsr $8edd	                jsr w_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ad27		20 e3 8b	jsr $8be3	                jsr w_minus            ; - ( addr-t u-t addr-n u )
.ad2a		b5 00		lda $00,x	                lda 0,x
.ad2c		95 04		sta $04,x	                sta 4,x
.ad2e		b5 01		lda $01,x	                lda 1,x
.ad30		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ad32		20 17 84	jsr $8417	                jsr w_cr
.ad35		20 91 86	jsr $8691	                jsr w_dup              ; DUP ( addr-t u addr-n u u )
.ad38		20 07 95	jsr $9507	                jsr w_u_dot            ; U. ( addr-t u addr-n u )
.ad3b		20 17 84	jsr $8417	                jsr w_cr
.ad3e		a9 40		lda #$40	                lda #%01000000
.ad40		14 39		trb $39		                trb ed_flags
.ad42		4c 6a aa	jmp $aa6a	                jmp ed_next_command
.ad45						ed_error_2drop:
.ad45		e8		inx		                inx
.ad46		e8		inx		                inx                     ; drop through to _error_1drop
.ad47						ed_error_1drop:
.ad47		e8		inx		                inx
.ad48		e8		inx		                inx                     ; drop through to _error
.ad49						ed_error:
.ad49		20 17 84	jsr $8417	                jsr w_cr
.ad4c		a9 3f		lda #$3f	                lda #'?'
.ad4e		20 bb 86	jsr $86bb	                jsr emit_a
.ad51		20 17 84	jsr $8417	                jsr w_cr
.ad54		4c 78 a8	jmp $a878	                jmp ed_input_loop
.ad57						ed_get_input:
.ad57		20 2f 8f	jsr $8f2f	                jsr w_refill           ;  ( addr-t u-t f )
.ad5a		b5 00		lda $00,x	                lda 0,x
.ad5c		15 01		ora $01,x	                ora 1,x
.ad5e		d0 05		bne $ad65	                bne +
.ad60		7a		ply		                ply
.ad61		7a		ply		                ply
.ad62		4c 47 ad	jmp $ad47	                jmp ed_error_1drop
.ad65						+
.ad65		e8		inx		                inx
.ad66		e8		inx		                inx
.ad67		60		rts		                rts
.ad68						ed_have_text:
.ad68		a5 35		lda $35		                lda ed_head
.ad6a		05 36		ora $36		                ora ed_head+1
.ad6c		d0 04		bne $ad72	                bne +
.ad6e		7a		ply		                ply
.ad6f		7a		ply		                ply
.ad70		80 d7		bra $ad49	                bra ed_error
.ad72						+
.ad72		60		rts		                rts
.ad73						ed_is_valid_line:
.ad73		38		sec		                sec                             ; default is legal line number
.ad74		b5 00		lda $00,x	                lda 0,x
.ad76		15 01		ora $01,x	                ora 1,x
.ad78		f0 19		beq $ad93	                beq _is_valid_line_nope_zero    ; ( n )
.ad7a		20 91 86	jsr $8691	                jsr w_dup                      ; DUP ( n n )
.ad7d		20 95 ad	jsr $ad95	                jsr ed_last_line                  ; ( n n last )
.ad80		20 46 92	jsr $9246	                jsr w_swap                     ; SWAP ( n last n )
.ad83		20 e6 89	jsr $89e6	                jsr w_less_than                ; < ( n f )
.ad86		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.ad88		15 01		ora $01,x	                ora 1,x
.ad8a		d0 05		bne $ad91	                bne _is_valid_line_too_small
.ad8c		e8		inx		                inx
.ad8d		e8		inx		                inx                     ; DROP flag ( n )
.ad8e		38		sec		                sec                     ; Who knows what's happened to C by now
.ad8f		80 03		bra $ad94	                bra _is_valid_line_done ; only one exit from this routine
.ad91						_is_valid_line_too_small:
.ad91		e8		inx		                inx
.ad92		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.ad93						_is_valid_line_nope_zero:
.ad93		18		clc		                clc                     ; drop through to _is_valid_line_done
.ad94						_is_valid_line_done:
.ad94		60		rts		                rts
.ad95						ed_last_line:
.ad95		64 25		stz $25		                stz tmp1
.ad97		64 26		stz $26		                stz tmp1+1
.ad99		ca		dex		                dex
.ad9a		ca		dex		                dex                     ; ( ? )
.ad9b		a9 35		lda #$35	                lda #<ed_head
.ad9d		95 00		sta $00,x	                sta 0,x
.ad9f		a9 00		lda #$00	                lda #>ed_head
.ada1		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.ada3						_last_line_loop:
.ada3		20 11 88	jsr $8811	                jsr w_fetch            ; ( addr | 0 )
.ada6		b5 00		lda $00,x	                lda 0,x
.ada8		15 01		ora $01,x	                ora 1,x
.adaa		f0 08		beq $adb4	                beq _last_line_done
.adac		e6 25		inc $25		                inc tmp1
.adae		d0 02		bne $adb2	                bne +
.adb0		e6 26		inc $26		                inc tmp1+1
.adb2						+
.adb2		80 ef		bra $ada3	                bra _last_line_loop
.adb4						_last_line_done:
.adb4		a5 25		lda $25		                lda tmp1
.adb6		95 00		sta $00,x	                sta 0,x
.adb8		a5 26		lda $26		                lda tmp1+1
.adba		95 01		sta $01,x	                sta 1,x                 ; ( u )
.adbc		60		rts		                rts
.adbd						ed_no_line_zero:
.adbd		b5 02		lda $02,x	                lda 2,x
.adbf		15 03		ora $03,x	                ora 3,x
.adc1		d0 07		bne $adca	                bne _no_line_zero_done
.adc3		24 39		bit $39		                bit ed_flags
.adc5		10 03		bpl $adca	                bpl _no_line_zero_done
.adc7		4c 45 ad	jmp $ad45	                jmp ed_error_2drop
.adca						_no_line_zero_done:
.adca		60		rts		                rts
.adcb						ed_num_to_addr:
.adcb		ca		dex		                dex
.adcc		ca		dex		                dex                     ; ( u ? )
.adcd		a9 35		lda #$35	                lda #<ed_head
.adcf		95 00		sta $00,x	                sta 0,x
.add1		a9 00		lda #$00	                lda #>ed_head
.add3		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.add5		b5 02		lda $02,x	                lda 2,x
.add7		15 03		ora $03,x	                ora 3,x
.add9		d0 05		bne $ade0	                bne _num_to_addr_loop
.addb		20 32 8c	jsr $8c32	                jsr w_nip              ; ( addr-h )
.adde		80 21		bra $ae01	                bra _num_to_addr_done
.ade0						_num_to_addr_loop:
.ade0		20 11 88	jsr $8811	                jsr w_fetch            ; @ ( u addr1 )
.ade3		b5 00		lda $00,x	                lda 0,x
.ade5		15 01		ora $01,x	                ora 1,x
.ade7		d0 05		bne $adee	                bne +
.ade9		20 32 8c	jsr $8c32	                jsr w_nip              ; NIP ( addr1 )
.adec		80 13		bra $ae01	                bra _num_to_addr_done
.adee						+
.adee		20 46 92	jsr $9246	                jsr w_swap             ; SWAP ( addr1 u )
.adf1		20 db 8c	jsr $8cdb	                jsr w_one_minus        ; 1- ( addr1 u-1 )
.adf4		b5 00		lda $00,x	                lda 0,x
.adf6		15 01		ora $01,x	                ora 1,x
.adf8		f0 05		beq $adff	                beq _num_to_addr_finished
.adfa		20 46 92	jsr $9246	                jsr w_swap             ; SWAP ( u-1 addr1 )
.adfd		80 e1		bra $ade0	                bra _num_to_addr_loop
.adff						_num_to_addr_finished:
.adff		e8		inx		                inx
.ae00		e8		inx		                inx                     ; ( addr )
.ae01						_num_to_addr_done:
.ae01		60		rts		                rts
.ae02						ed_para1_to_cur:
.ae02		b5 02		lda $02,x	                lda 2,x
.ae04		85 37		sta $37		                sta ed_cur
.ae06		b5 03		lda $03,x	                lda 3,x
.ae08		85 38		sta $38		                sta ed_cur+1
.ae0a		60		rts		                rts
.ae0b						ed_print_addr:
.ae0b		20 e7 8c	jsr $8ce7	                jsr w_one_plus
.ae0e		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; ( addr+2 )
.ae11		20 91 86	jsr $8691	                jsr w_dup              ; ( addr+2 addr+2 )
.ae14		20 e7 8c	jsr $8ce7	                jsr w_one_plus
.ae17		20 e7 8c	jsr $8ce7	                jsr w_one_plus         ; ( addr+2 addr+4 )
.ae1a		20 11 88	jsr $8811	                jsr w_fetch            ; ( addr+2 u-s )
.ae1d		20 46 92	jsr $9246	                jsr w_swap             ; ( u-s addr+2 )
.ae20		20 11 88	jsr $8811	                jsr w_fetch            ; ( u-s addr-s )
.ae23		20 46 92	jsr $9246	                jsr w_swap             ; ( addr-s u-s )
.ae26		20 dc 94	jsr $94dc	                jsr w_type
.ae29		20 17 84	jsr $8417	                jsr w_cr
.ae2c		60		rts		                rts
>ae2d		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>ae35		71 51 00
.ae38						ed_cmd_table:
>ae38		7d aa c4 ab f7 ab 20 ab		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>ae40		1f ac 18 ac
>ae44		88 ab 92 ac 83 ac 8e ac		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ae4c						ed6502_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/block.asm

.ae4c						xt_blk:
.ae4c						w_blk:
.ae4c		a9 04		lda #$04	                lda #blk_offset
.ae4e		4c b0 d6	jmp $d6b0	                jmp push_upvar_tos
.ae51						z_blk:
.ae51						xt_blkbuffer:
.ae51						w_blkbuffer:
.ae51		ca		dex		                dex
.ae52		ca		dex		                dex
.ae53		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ae55		b1 08		lda ($08),y	                lda (up),y
.ae57		95 00		sta $00,x	                sta 0,x
.ae59		c8		iny		                iny             ; Move along to the next byte
.ae5a		b1 08		lda ($08),y	                lda (up),y
.ae5c		95 01		sta $01,x	                sta 1,x
.ae5e		60		rts		z_blkbuffer:    rts
.ae5f						xt_block:
.ae5f						w_block:
.ae5f		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ae61		b1 08		lda ($08),y	                lda (up),y
.ae63		d5 00		cmp $00,x	                cmp 0,x
.ae65		d0 0f		bne $ae76	                bne _not_in_buffer
.ae67		c8		iny		                iny
.ae68		b1 08		lda ($08),y	                lda (up),y
.ae6a		d5 01		cmp $01,x	                cmp 1,x
.ae6c		d0 08		bne $ae76	                bne _not_in_buffer
.ae6e		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae70		b1 08		lda ($08),y	                lda (up),y
.ae72		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.ae74		d0 30		bne $aea6	                bne _done       ; It's already in the buffer and in use.
.ae76						_not_in_buffer:
.ae76		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae78		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.ae7a		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.ae7c		d0 0c		bne $ae8a	                bne _buffer_available ; Unused or not dirty = available
.ae7e		20 51 ae	jsr $ae51	                jsr w_blkbuffer
.ae81		20 01 b0	jsr $b001	                jsr w_buffblocknum
.ae84		20 11 88	jsr $8811	                jsr w_fetch
.ae87		20 ee af	jsr $afee	                jsr w_block_write
.ae8a						_buffer_available:
.ae8a		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ae8c		b5 00		lda $00,x	                lda 0,x
.ae8e		91 08		sta ($08),y	                sta (up),y
.ae90		c8		iny		                iny
.ae91		b5 01		lda $01,x	                lda 1,x
.ae93		91 08		sta ($08),y	                sta (up),y
.ae95		20 51 ae	jsr $ae51	                jsr w_blkbuffer
.ae98		20 46 92	jsr $9246	                jsr w_swap
.ae9b		20 d6 af	jsr $afd6	                jsr w_block_read
.ae9e		a9 01		lda #$01	                lda #1
.aea0		a0 30		ldy #$30	                ldy #buffstatus_offset
.aea2		91 08		sta ($08),y	                sta (up),y
.aea4		ca		dex		                dex
.aea5		ca		dex		                dex
.aea6						_done:
.aea6		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.aea8		b1 08		lda ($08),y	                lda (up),y
.aeaa		95 00		sta $00,x	                sta 0,x
.aeac		c8		iny		                iny
.aead		b1 08		lda ($08),y	                lda (up),y
.aeaf		95 01		sta $01,x	                sta 1,x
.aeb1		60		rts		z_block:        rts
.aeb2						xt_block_ramdrive_init:
.aeb2		20 f2 d7	jsr $d7f2	                jsr underflow_1
.aeb5						w_block_ramdrive_init:
.aeb5		20 80 a2	jsr $a280	                jsr sliteral_runtime
>aeb8		18 01				                .word ramdrive_code_end-ramdrive_code
.aeba						ramdrive_code:
>aeba		62 61 73 65 20 40 20 73		                .text "base @ swap decimal"
>aec2		77 61 70 20 64 65 63 69 6d 61 6c
>aecd		20 31 30 32 34 20 2a		                .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>aed4		20 64 75 70			                .text " dup"    ; ( Save a copy for formatting it at the end )
>aed8		20 62 75 66 66 65 72 3a		                .text " buffer: ramdrive" ; ( Create ramdrive )
>aee0		20 72 61 6d 64 72 69 76 65
>aee9		20 3a 20 62 6c 6f 63 6b		                .text " : block-read-ramdrive"  ; ( addr u -- )
>aef1		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>aeff		20 72 61 6d 64 72 69 76		                .text " ramdrive swap 1024 * + swap 1024 move ;"
>af07		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>af17		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>af27		20 3a 20 62 6c 6f 63 6b		                .text " : block-write-ramdrive" ; ( addr u -- )
>af2f		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>af3e		20 72 61 6d 64 72 69 76		                .text " ramdrive swap 1024 * + 1024 move ;"
>af46		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>af56		31 30 32 34 20 6d 6f 76 65 20 3b
>af61		20 27 20 62 6c 6f 63 6b		                .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>af69		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>af79		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>af89		20 21
>af8b		20 27 20 62 6c 6f 63 6b		                .text " ' block-write-ramdrive block-write-vector !"
>af93		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>afa3		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>afb3		6f 72 20 21
>afb7		20 72 61 6d 64 72 69 76		                .text " ramdrive swap blank base !"
>afbf		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>afcf		65 20 21
.afd2						ramdrive_code_end:
.afd2		20 a9 88	jsr $88a9	                jsr w_evaluate
.afd5						z_block_ramdrive_init:
.afd5		60		rts		                rts
.afd6						xt_block_read:
.afd6						w_block_read:
.afd6		a0 32		ldy #$32	                ldy #blockread_offset
.afd8		b1 08		lda ($08),y	                lda (up),y
.afda		85 25		sta $25		                sta tmp1
.afdc		c8		iny		                iny
.afdd		b1 08		lda ($08),y	                lda (up),y
.afdf		85 26		sta $26		                sta tmp1+1
.afe1		6c 25 00	jmp ($0025)	                jmp (tmp1)
.afe4						z_block_read:
.afe4						xt_block_read_vector:
.afe4						w_block_read_vector:
.afe4		a9 32		lda #$32	                lda #blockread_offset
.afe6		4c b0 d6	jmp $d6b0	                jmp push_upvar_tos
.afe9						z_block_read_vector:
.afe9						xt_block_word_error:
.afe9						w_block_word_error:
.afe9		a9 0c		lda #$0c	                lda #err_blockwords
.afeb		4c 08 d8	jmp $d808	                jmp error       ; no RTS needed
.afee						xt_block_write:
.afee						w_block_write:
.afee		a0 34		ldy #$34	                ldy #blockwrite_offset
.aff0		b1 08		lda ($08),y	                lda (up),y
.aff2		85 25		sta $25		                sta tmp1
.aff4		c8		iny		                iny
.aff5		b1 08		lda ($08),y	                lda (up),y
.aff7		85 26		sta $26		                sta tmp1+1
.aff9		6c 25 00	jmp ($0025)	                jmp (tmp1)
.affc						z_block_write:
.affc						xt_block_write_vector:
.affc						w_block_write_vector:
.affc		a9 34		lda #$34	                lda #blockwrite_offset
.affe		4c b0 d6	jmp $d6b0	                jmp push_upvar_tos
.b001						z_block_write_vector:
.b001						xt_buffblocknum:
.b001						w_buffblocknum:
.b001		a9 2e		lda #$2e	                lda #buffblocknum_offset
.b003		4c b0 d6	jmp $d6b0	                jmp push_upvar_tos
.b006						z_buffblocknum:
.b006						xt_buffer:
.b006						w_buffer:
.b006		a0 30		ldy #$30	                ldy #buffstatus_offset
.b008		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b00a		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b00c		d0 0c		bne $b01a	                bne _buffer_available ; Unused or not dirty = available
.b00e		20 51 ae	jsr $ae51	                jsr w_blkbuffer
.b011		20 01 b0	jsr $b001	                jsr w_buffblocknum
.b014		20 11 88	jsr $8811	                jsr w_fetch
.b017		20 ee af	jsr $afee	                jsr w_block_write
.b01a						_buffer_available:
.b01a		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.b01c		b5 00		lda $00,x	                lda 0,x
.b01e		91 08		sta ($08),y	                sta (up),y
.b020		c8		iny		                iny
.b021		b5 01		lda $01,x	                lda 1,x
.b023		91 08		sta ($08),y	                sta (up),y
.b025		a9 01		lda #$01	                lda #1
.b027		a0 30		ldy #$30	                ldy #buffstatus_offset
.b029		91 08		sta ($08),y	                sta (up),y
.b02b		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.b02d		b1 08		lda ($08),y	                lda (up),y
.b02f		95 00		sta $00,x	                sta 0,x
.b031		c8		iny		                iny
.b032		b1 08		lda ($08),y	                lda (up),y
.b034		95 01		sta $01,x	                sta 1,x
.b036		60		rts		z_buffer:       rts
.b037						xt_buffstatus:
.b037						w_buffstatus:
.b037		a9 30		lda #$30	                lda #buffstatus_offset
.b039		4c b0 d6	jmp $d6b0	                jmp push_upvar_tos
.b03c						z_buffstatus:
.b03c						xt_empty_buffers:
.b03c						w_empty_buffers:
.b03c		a0 30		ldy #$30	                ldy #buffstatus_offset
.b03e		a9 00		lda #$00	                lda #0
.b040		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b042						z_empty_buffers:
.b042		60		rts		                rts
.b043						xt_flush:
.b043						w_flush:
.b043		20 9e b0	jsr $b09e	                jsr w_save_buffers
.b046		a0 30		ldy #$30	                ldy #buffstatus_offset
.b048		a9 00		lda #$00	                lda #0
.b04a		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b04c						z_flush:
.b04c		60		rts		                rts
.b04d						xt_list:
.b04d		20 f2 d7	jsr $d7f2	                jsr underflow_1
.b050						w_list:
.b050		20 b9 b0	jsr $b0b9	                jsr w_scr
.b053		20 30 92	jsr $9230	                jsr w_store
.b056		20 58 b1	jsr $b158	                jsr w_editor_l
.b059		60		rts		z_list:         rts
.b05a						xt_load:
.b05a		20 f2 d7	jsr $d7f2	                jsr underflow_1
.b05d						w_load:
.b05d		a0 05		ldy #$05	                ldy #blk_offset+1
.b05f		b1 08		lda ($08),y	                lda (up),y
.b061		48		pha		                pha
.b062		88		dey		                dey
.b063		b1 08		lda ($08),y	                lda (up),y
.b065		48		pha		                pha
.b066		b5 00		lda $00,x	                lda 0,x
.b068		91 08		sta ($08),y	                sta (up),y
.b06a		c8		iny		                iny
.b06b		b5 01		lda $01,x	                lda 1,x
.b06d		91 08		sta ($08),y	                sta (up),y
.b06f		20 5f ae	jsr $ae5f	                jsr w_block
.b072		ca		dex		                dex
.b073		ca		dex		                dex
.b074		a9 04		lda #$04	                lda #4
.b076		95 01		sta $01,x	                sta 1,x
.b078		74 00		stz $00,x	                stz 0,x
.b07a		20 a0 88	jsr $88a0	                jsr load_evaluate
.b07d		a0 04		ldy #$04	                ldy #blk_offset
.b07f		68		pla		                pla
.b080		91 08		sta ($08),y	                sta (up),y
.b082		c8		iny		                iny
.b083		68		pla		                pla
.b084		91 08		sta ($08),y	                sta (up),y
.b086		88		dey		                dey
.b087		11 08		ora ($08),y	                ora (up),y
.b089		f0 12		beq $b09d	                beq _done
.b08b		ca		dex		                dex
.b08c		ca		dex		                dex
.b08d		a0 04		ldy #$04	                ldy #blk_offset
.b08f		b1 08		lda ($08),y	                lda (up),y
.b091		95 00		sta $00,x	                sta 0,x
.b093		c8		iny		                iny
.b094		b1 08		lda ($08),y	                lda (up),y
.b096		95 01		sta $01,x	                sta 1,x
.b098		20 5f ae	jsr $ae5f	                jsr w_block
.b09b		e8		inx		                inx
.b09c		e8		inx		                inx
.b09d						_done:
.b09d		60		rts		z_load:         rts
.b09e						xt_save_buffers:
.b09e						w_save_buffers:
.b09e		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0a0		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b0a2		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b0a4		d0 12		bne $b0b8	                bne _done       ; Either not used or not dirty = done!
.b0a6		20 51 ae	jsr $ae51	                jsr w_blkbuffer
.b0a9		20 01 b0	jsr $b001	                jsr w_buffblocknum
.b0ac		20 11 88	jsr $8811	                jsr w_fetch
.b0af		20 ee af	jsr $afee	                jsr w_block_write
.b0b2		a9 01		lda #$01	                lda #1
.b0b4		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0b6		91 08		sta ($08),y	                sta (up),y
.b0b8						_done:
.b0b8		60		rts		z_save_buffers: rts
.b0b9						xt_scr:
.b0b9						w_scr:
.b0b9		a9 06		lda #$06	                lda #scr_offset
.b0bb		4c b0 d6	jmp $d6b0	                jmp push_upvar_tos
.b0be						z_scr:
.b0be						xt_thru:
.b0be		20 f7 d7	jsr $d7f7	                jsr underflow_2
.b0c1						w_thru:
.b0c1		b5 01		lda $01,x	                lda 1,x
.b0c3		48		pha		                pha
.b0c4		b5 00		lda $00,x	                lda 0,x
.b0c6		48		pha		                pha
.b0c7		e8		inx		                inx
.b0c8		e8		inx		                inx
.b0c9						_thru_loop:
.b0c9		b5 01		lda $01,x	                lda 1,x
.b0cb		48		pha		                pha
.b0cc		b5 00		lda $00,x	                lda 0,x
.b0ce		48		pha		                pha
.b0cf		20 5d b0	jsr $b05d	                jsr w_load
.b0d2		68		pla		                pla
.b0d3		85 25		sta $25		                sta tmp1
.b0d5		68		pla		                pla
.b0d6		85 26		sta $26		                sta tmp1+1
.b0d8		68		pla		                pla
.b0d9		85 27		sta $27		                sta tmp2
.b0db		68		pla		                pla
.b0dc		85 28		sta $28		                sta tmp2+1
.b0de		c5 26		cmp $26		                cmp tmp1+1
.b0e0		d0 08		bne $b0ea	                bne _next_screen
.b0e2		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.b0e4		c5 25		cmp $25		                cmp tmp1
.b0e6		d0 02		bne $b0ea	                bne _next_screen
.b0e8		80 18		bra $b102	                bra _done       ; We just did the last screen.
.b0ea						_next_screen:
.b0ea		a5 28		lda $28		                lda tmp2+1
.b0ec		48		pha		                pha
.b0ed		a5 27		lda $27		                lda tmp2
.b0ef		48		pha		                pha
.b0f0		e6 25		inc $25		                inc tmp1
.b0f2		d0 02		bne $b0f6	                bne +
.b0f4		e6 26		inc $26		                inc tmp1+1
.b0f6						+
.b0f6		ca		dex		                dex
.b0f7		ca		dex		                dex
.b0f8		a5 25		lda $25		                lda tmp1
.b0fa		95 00		sta $00,x	                sta 0,x
.b0fc		a5 26		lda $26		                lda tmp1+1
.b0fe		95 01		sta $01,x	                sta 1,x
.b100		80 c7		bra $b0c9	                bra _thru_loop
.b102						_done:
.b102		60		rts		z_thru:         rts
.b103						xt_update:
.b103						w_update:
.b103		a0 30		ldy #$30	                ldy #buffstatus_offset
.b105		b1 08		lda ($08),y	                lda (up),y
.b107		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.b109		91 08		sta ($08),y	                sta (up),y
.b10b		60		rts		z_update:       rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/editor.asm

.b10c						xt_editor_screen_helper:
.b10c						w_editor_screen_helper:
.b10c		20 91 86	jsr $8691	                jsr w_dup
.b10f		20 b9 b0	jsr $b0b9	                jsr w_scr
.b112		20 30 92	jsr $9230	                jsr w_store
.b115		4c 06 b0	jmp $b006	                jmp w_buffer
.b118						xt_editor_enter_screen:
.b118						w_editor_enter_screen:
.b118		20 0c b1	jsr $b10c	                jsr w_editor_screen_helper
.b11b		20 8b 86	jsr $868b	                jsr w_drop
.b11e		64 35		stz $35		                stz ed_head
.b120						_prompt_loop:
.b120		ca		dex		                dex
.b121		ca		dex		                dex
.b122		a5 35		lda $35		                lda ed_head
.b124		95 00		sta $00,x	                sta 0,x
.b126		74 01		stz $01,x	                stz 1,x
.b128		20 e7 b1	jsr $b1e7	                jsr w_editor_o
.b12b		e6 35		inc $35		                inc ed_head
.b12d		a9 10		lda #$10	                lda #16
.b12f		c5 35		cmp $35		                cmp ed_head
.b131		d0 ed		bne $b120	                bne _prompt_loop
.b133						z_editor_enter_screen:
.b133		60		rts		                rts
.b134						xt_editor_erase_screen:
.b134						w_editor_erase_screen:
.b134		20 0c b1	jsr $b10c	                jsr w_editor_screen_helper
.b137		ca		dex		                dex
.b138		ca		dex		                dex
.b139		74 00		stz $00,x	                stz 0,x
.b13b		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.b13d		95 01		sta $01,x	                sta 1,x
.b13f		20 a1 87	jsr $87a1	                jsr w_blank
.b142		20 03 b1	jsr $b103	                jsr w_update
.b145						z_editor_erase_screen:
.b145		60		rts		                rts
.b146						xt_editor_el:
.b146						w_editor_el:
.b146		20 d1 b1	jsr $b1d1	                jsr w_editor_line
.b149		ca		dex		                dex
.b14a		ca		dex		                dex
.b14b		a9 40		lda #$40	                lda #64
.b14d		95 00		sta $00,x	                sta 0,x
.b14f		74 01		stz $01,x	                stz 1,x
.b151		20 a1 87	jsr $87a1	                jsr w_blank
.b154		20 03 b1	jsr $b103	                jsr w_update
.b157		60		rts		z_editor_el:    rts
.b158						xt_editor_l:
.b158						w_editor_l:
.b158		ca		dex		                dex             ; Put SCR on the stack.
.b159		ca		dex		                dex
.b15a		a0 06		ldy #$06	                ldy #scr_offset
.b15c		b1 08		lda ($08),y	                lda (up),y
.b15e		95 00		sta $00,x	                sta 0,x
.b160		c8		iny		                iny
.b161		b1 08		lda ($08),y	                lda (up),y
.b163		95 01		sta $01,x	                sta 1,x
.b165		20 5f ae	jsr $ae5f	                jsr w_block    ; Get the current screen.
.b168		20 17 84	jsr $8417	                jsr w_cr
.b16b		20 80 a2	jsr $a280	                jsr sliteral_runtime
>b16e		08 00				                .word _after_screen_msg-_screen_msg
.b170						_screen_msg:
>b170		53 63 72 65 65 6e 20 23		                .text "Screen #"
.b178						_after_screen_msg:
.b178		20 dc 94	jsr $94dc	                jsr w_type
.b17b		20 b9 b0	jsr $b0b9	                jsr w_scr
.b17e		20 11 88	jsr $8811	                jsr w_fetch
.b181		ca		dex		                dex
.b182		ca		dex		                dex
.b183		a9 04		lda #$04	                lda #4          ; four spaces
.b185		95 00		sta $00,x	                sta 0,x
.b187		74 01		stz $01,x	                stz 1,x
.b189		20 13 95	jsr $9513	                jsr w_u_dot_r
.b18c		64 29		stz $29		                stz tmp3
.b18e						_line_loop:
.b18e		20 17 84	jsr $8417	                jsr w_cr
.b191		ca		dex		                dex
.b192		ca		dex		                dex
.b193		ca		dex		                dex
.b194		ca		dex		                dex
.b195		74 03		stz $03,x	                stz 3,x
.b197		a5 29		lda $29		                lda tmp3
.b199		95 02		sta $02,x	                sta 2,x
.b19b		74 01		stz $01,x	                stz 1,x
.b19d		a9 02		lda #$02	                lda #2
.b19f		95 00		sta $00,x	                sta 0,x
.b1a1		20 13 95	jsr $9513	                jsr w_u_dot_r
.b1a4		20 dd 91	jsr $91dd	                jsr w_space
.b1a7		20 91 86	jsr $8691	                jsr w_dup
.b1aa		ca		dex		                dex
.b1ab		ca		dex		                dex
.b1ac		a9 40		lda #$40	                lda #64
.b1ae		95 00		sta $00,x	                sta 0,x
.b1b0		74 01		stz $01,x	                stz 1,x
.b1b2		20 dc 94	jsr $94dc	                jsr w_type
.b1b5		18		clc		                clc
.b1b6		a9 40		lda #$40	                lda #64
.b1b8		75 00		adc $00,x	                adc 0,x
.b1ba		95 00		sta $00,x	                sta 0,x
.b1bc		90 02		bcc $b1c0	                bcc +
.b1be		f6 01		inc $01,x	                inc 1,x
.b1c0						+
.b1c0		e6 29		inc $29		                inc tmp3
.b1c2		a5 29		lda $29		                lda tmp3
.b1c4		c9 10		cmp #$10	                cmp #16
.b1c6		d0 c6		bne $b18e	                bne _line_loop
.b1c8		20 17 84	jsr $8417	                jsr w_cr
.b1cb		e8		inx		                inx
.b1cc		e8		inx		                inx
.b1cd		60		rts		z_editor_l:     rts
.b1ce						xt_editor_line:
.b1ce		20 f2 d7	jsr $d7f2	                jsr underflow_1
.b1d1						w_editor_line:
.b1d1		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.b1d3						_shift_tos_left:
.b1d3		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.b1d5		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.b1d7		88		dey		                dey
.b1d8		d0 f9		bne $b1d3	                bne _shift_tos_left
.b1da		20 b9 b0	jsr $b0b9	                jsr w_scr
.b1dd		20 11 88	jsr $8811	                jsr w_fetch
.b1e0		20 5f ae	jsr $ae5f	                jsr w_block
.b1e3		20 51 8e	jsr $8e51	                jsr w_plus
.b1e6		60		rts		z_editor_line:  rts
.b1e7						xt_editor_o:
.b1e7						w_editor_o:
.b1e7		20 17 84	jsr $8417	                jsr w_cr
.b1ea		20 91 86	jsr $8691	                jsr w_dup
.b1ed		20 64 9e	jsr $9e64	                jsr w_two
.b1f0		20 13 95	jsr $9513	                jsr w_u_dot_r
.b1f3		20 dd 91	jsr $91dd	                jsr w_space
.b1f6		a9 2a		lda #$2a	                lda #'*'
.b1f8		20 bb 86	jsr $86bb	                jsr emit_a
.b1fb		20 dd 91	jsr $91dd	                jsr w_space
.b1fe		20 d1 b1	jsr $b1d1	                jsr w_editor_line
.b201		20 91 86	jsr $8691	                jsr w_dup      ; Save a copy of the line address for later.
.b204		ca		dex		                dex
.b205		ca		dex		                dex
.b206		a9 40		lda #$40	                lda #64         ; chars/line
.b208		95 00		sta $00,x	                sta 0,x
.b20a		74 01		stz $01,x	                stz 1,x
.b20c		20 ea 80	jsr $80ea	                jsr w_accept
.b20f		20 91 86	jsr $8691	                jsr w_dup
.b212		20 20 9d	jsr $9d20	                jsr w_not_rot  ; -rot
.b215		20 51 8e	jsr $8e51	                jsr w_plus
.b218		ca		dex		                dex
.b219		ca		dex		                dex
.b21a		a9 40		lda #$40	                lda #64         ; chars/line
.b21c		95 00		sta $00,x	                sta 0,x
.b21e		74 01		stz $01,x	                stz 1,x
.b220		20 84 8f	jsr $8f84	                jsr w_rot
.b223		20 e3 8b	jsr $8be3	                jsr w_minus
.b226		20 a1 87	jsr $87a1	                jsr w_blank
.b229		20 03 b1	jsr $b103	                jsr w_update
.b22c		60		rts		z_editor_o:     rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/wordlist.asm

.b22d						xt_also:
.b22d						w_also:
.b22d		20 58 b2	jsr $b258	                jsr w_get_order
.b230		20 03 8d	jsr $8d03	                jsr w_over
.b233		20 46 92	jsr $9246	                jsr w_swap
.b236		20 e7 8c	jsr $8ce7	                jsr w_one_plus
.b239		20 61 b3	jsr $b361	                jsr w_set_order
.b23c		60		rts		z_also:         rts
.b23d						xt_definitions:
.b23d						w_definitions:
.b23d		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.b23f		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.b241		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.b243		91 08		sta ($08),y	                sta (up),y
.b245		60		rts		z_definitions:  rts
.b246						xt_forth:
.b246						w_forth:
.b246		a0 23		ldy #$23	                ldy #search_order_offset
.b248		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.b24a		91 08		sta ($08),y	                sta (up),y
.b24c						z_forth:
.b24c		60		rts		                rts
.b24d						xt_get_current:
.b24d						w_get_current:
.b24d		ca		dex		                dex
.b24e		ca		dex		                dex
.b24f		a0 08		ldy #$08	                ldy #current_offset
.b251		b1 08		lda ($08),y	                lda (up),y
.b253		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.b255		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.b257		60		rts		z_get_current:  rts
.b258						xt_get_order:
.b258						w_get_order:
.b258		a0 22		ldy #$22	                ldy #num_order_offset
.b25a		b1 08		lda ($08),y	                lda (up),y
.b25c		85 25		sta $25		                sta tmp1
.b25e		f0 16		beq $b276	                beq _done       ; If zero, there are no wordlists.
.b260						_loop:
.b260		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.b262		a9 23		lda #$23	                lda #search_order_offset
.b264		18		clc		                clc
.b265		65 25		adc $25		                adc tmp1
.b267		a8		tay		                tay
.b268		ca		dex		                dex
.b269		ca		dex		                dex
.b26a		b1 08		lda ($08),y	                lda (up),y
.b26c		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.b26e		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.b270		a9 00		lda #$00	                lda #0
.b272		c5 25		cmp $25		                cmp tmp1
.b274		d0 ea		bne $b260	                bne _loop
.b276						_done:
.b276		ca		dex		                dex
.b277		ca		dex		                dex
.b278		a0 22		ldy #$22	                ldy #num_order_offset
.b27a		b1 08		lda ($08),y	                lda (up),y
.b27c		95 00		sta $00,x	                sta 0,x
.b27e		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.b280		60		rts		z_get_order:    rts
.b281						xt_only:
.b281						w_only:
.b281		20 99 93	jsr $9399	                jsr w_true
.b284		20 61 b3	jsr $b361	                jsr w_set_order
.b287		60		rts		z_only:         rts
.b288						xt_order:
.b288						w_order:
.b288		20 17 84	jsr $8417	                jsr w_cr
.b28b		20 58 b2	jsr $b258	                jsr w_get_order         ; ( wid_n ... wid_1 n )
.b28e		e8		inx		                inx                     ; pre-drop n
.b28f		e8		inx		                inx
.b290		b5 fe		lda $fe,x	                lda $fe,x                 ; assumes no more than 255 wordlists
.b292		f0 1e		beq $b2b2	                beq _done
.b294		85 1e		sta $1e		                sta tmpdsp
.b296						_loop:
.b296		b5 00		lda $00,x	                lda 0,x                 ; fetch wid to A and drop it
.b298		e8		inx		                inx
.b299		e8		inx		                inx
.b29a		20 b3 b2	jsr $b2b3	                jsr order_print_wid_string   ; internal helper function
.b29d		c6 1e		dec $1e		                dec tmpdsp
.b29f		d0 f5		bne $b296	                bne _loop
.b2a1		20 dd 91	jsr $91dd	                jsr w_space
.b2a4		20 dd 91	jsr $91dd	                jsr w_space
.b2a7		20 4d b2	jsr $b24d	                jsr w_get_current      ; ( wid )
.b2aa		b5 00		lda $00,x	                lda 0,x
.b2ac		20 b3 b2	jsr $b2b3	                jsr order_print_wid_string
.b2af		20 17 84	jsr $8417	                jsr w_cr
.b2b2						_done:
.b2b2						z_order:
.b2b2		60		rts		                rts
.b2b3						order_print_wid_string:
.b2b3		c9 04		cmp #$04	                cmp #4
.b2b5		90 09		bcc $b2c0	                bcc _output_string      ; less than 4, print a real string
.b2b7		ca		dex		                dex
.b2b8		ca		dex		                dex
.b2b9		95 00		sta $00,x	                sta 0,x
.b2bb		74 01		stz $01,x	                stz 1,x
.b2bd		4c 07 95	jmp $9507	                jmp w_u_dot            ; JSR/RTS as this routine is not compiled
.b2c0						_output_string:
.b2c0		a8		tay		                tay
.b2c1		b9 c7 b2	lda $b2c7,y	                lda _wid_data,y
.b2c4		4c 2e d8	jmp $d82e	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.b2c7						_wid_data:
>b2c7		03				        .byte str_wid_forth            ; WID 0: "Forth "
>b2c8		04				        .byte str_wid_editor           ; WID 1: "Editor "
>b2c9		05				        .byte str_wid_assembler        ; WID 2: "Assembler "
>b2ca		06				        .byte str_wid_root             ; WID 3: "Root "
.b2cb						xt_previous:
.b2cb						w_previous:
.b2cb		20 58 b2	jsr $b258	                jsr w_get_order
.b2ce		20 32 8c	jsr $8c32	                jsr w_nip
.b2d1		20 db 8c	jsr $8cdb	                jsr w_one_minus
.b2d4		20 61 b3	jsr $b361	                jsr w_set_order
.b2d7		60		rts		z_previous:     rts
.b2d8						xt_root_wordlist:
.b2d8						w_root_wordlist:
.b2d8		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.b2d9		ca		dex		                dex
.b2da		a9 03		lda #$03	                lda #3
.b2dc		95 00		sta $00,x	                sta 0,x
.b2de		74 01		stz $01,x	                stz 1,x
.b2e0						z_root_wordlist:
.b2e0		60		rts		                rts
.b2e1						xt_search_wordlist:
.b2e1		20 fc d7	jsr $d7fc	                jsr underflow_3
.b2e4						w_search_wordlist:
.b2e4		a5 08		lda $08		                lda up
.b2e6		18		clc		                clc
.b2e7		69 0a		adc #$0a	                adc #wordlists_offset
.b2e9		85 27		sta $27		                sta tmp2
.b2eb		a5 09		lda $09		                lda up+1
.b2ed		69 00		adc #$00	                adc #0          ; Adding carry
.b2ef		85 28		sta $28		                sta tmp2+1
.b2f1		b5 00		lda $00,x	                lda 0,x
.b2f3		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.b2f4		65 27		adc $27		                adc tmp2
.b2f6		85 27		sta $27		                sta tmp2
.b2f8		90 02		bcc $b2fc	                bcc +
.b2fa		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.b2fc						+
.b2fc		e8		inx		                inx
.b2fd		e8		inx		                inx
.b2fe		b5 00		lda $00,x	                lda 0,x
.b300		15 01		ora $01,x	                ora 1,x
.b302		f0 4e		beq $b352	                beq _done
.b304		a5 27		lda $27		                lda tmp2
.b306		05 28		ora $28		                ora tmp2+1
.b308		f0 48		beq $b352	                beq _done
.b30a		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.b30c		85 25		sta $25		                sta tmp1
.b30e		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.b310		d0 02		bne $b314	                bne +
.b312		e6 28		inc $28		                inc tmp2+1
.b314						+
.b314		b2 27		lda ($27)	                lda (tmp2)
.b316		85 26		sta $26		                sta tmp1+1
.b318		20 d6 d6	jsr $d6d6	                jsr find_header_name
.b31b		f0 31		beq $b34e	                beq _fail_done
.b31d		e8		inx		                inx
.b31e		e8		inx		                inx
.b31f		a5 25		lda $25		                lda tmp1
.b321		95 00		sta $00,x	                sta 0,x
.b323		a5 26		lda $26		                lda tmp1+1
.b325		95 01		sta $01,x	                sta 1,x
.b327		20 91 86	jsr $8691	                jsr w_dup              ; ( nt nt )
.b32a		20 d9 9c	jsr $9cd9	                jsr w_name_to_int      ; ( nt xt )
.b32d		20 46 92	jsr $9246	                jsr w_swap             ; ( xt nt )
.b330		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.b332		f6 00		inc $00,x	                inc 0,x
.b334		d0 02		bne $b338	                bne +
.b336		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.b338						+
.b338		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.b33a		29 02		and #$02	                and #IM
.b33c		d0 08		bne $b346	                bne _immediate          ; bit set, we're immediate
.b33e		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.b340		95 00		sta $00,x	                sta 0,x
.b342		95 01		sta $01,x	                sta 1,x
.b344		80 0e		bra $b354	                bra _done_nodrop
.b346						_immediate:
.b346		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.b348		95 00		sta $00,x	                sta 0,x
.b34a		74 01		stz $01,x	                stz 1,x
.b34c		80 06		bra $b354	                bra _done_nodrop
.b34e						_fail_done:
.b34e		74 02		stz $02,x	                stz 2,x         ; failure flag
.b350		74 03		stz $03,x	                stz 3,x
.b352						_done:
.b352		e8		inx		                inx
.b353		e8		inx		                inx
.b354						_done_nodrop:
.b354						z_search_wordlist:
.b354		60		rts		                rts
.b355						xt_set_current:
.b355		20 f2 d7	jsr $d7f2	                jsr underflow_1
.b358						w_set_current:
.b358		a0 08		ldy #$08	                ldy #current_offset
.b35a		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.b35c		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.b35e		e8		inx		                inx
.b35f		e8		inx		                inx
.b360		60		rts		z_set_current:  rts
.b361						xt_set_order:
.b361						w_set_order:
.b361		a9 ff		lda #$ff	                lda #$FF
.b363		d5 01		cmp $01,x	                cmp 1,x
.b365		d0 12		bne $b379	                bne _start
.b367		d5 00		cmp $00,x	                cmp 0,x
.b369		d0 0e		bne $b379	                bne _start
.b36b		ca		dex		                dex             ; Make room for the count.
.b36c		ca		dex		                dex
.b36d		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.b36f		a9 03		lda #$03	                lda #3
.b371		95 02		sta $02,x	                sta 2,x
.b373		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.b375		a9 01		lda #$01	                lda #1
.b377		95 00		sta $00,x	                sta 0,x
.b379						_start:
.b379		a0 22		ldy #$22	                ldy #num_order_offset
.b37b		b5 00		lda $00,x	                lda 0,x
.b37d		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.b37f		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.b381		e8		inx		                inx             ; Drop the count off the data stack.
.b382		e8		inx		                inx
.b383		a5 25		lda $25		                lda tmp1
.b385		f0 0d		beq $b394	                beq _done       ; If zero, there are no wordlists.
.b387		a0 23		ldy #$23	                ldy #search_order_offset
.b389						_loop:
.b389		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.b38b		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.b38d		c8		iny		                iny
.b38e		e8		inx		                inx
.b38f		e8		inx		                inx
.b390		c6 25		dec $25		                dec tmp1
.b392		d0 f5		bne $b389	                bne _loop
.b394						_done:
.b394		60		rts		z_set_order:    rts
.b395						xt_to_order:
.b395						w_to_order:
.b395		20 81 93	jsr $9381	                jsr w_to_r
.b398		20 58 b2	jsr $b258	                jsr w_get_order
.b39b		20 dd 8e	jsr $8edd	                jsr w_r_from
.b39e		20 46 92	jsr $9246	                jsr w_swap
.b3a1		20 e7 8c	jsr $8ce7	                jsr w_one_plus
.b3a4		20 61 b3	jsr $b361	                jsr w_set_order
.b3a7		60		rts		z_to_order:     rts
.b3a8						xt_wordlist:
.b3a8						w_wordlist:
.b3a8		a0 09		ldy #$09	                ldy #num_wordlists_offset
.b3aa		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.b3ac		c9 0c		cmp #$0c	                cmp #max_wordlists
.b3ae		d0 05		bne $b3b5	                bne _ok
.b3b0		a9 0b		lda #$0b	                lda #err_wordlist
.b3b2		4c 08 d8	jmp $d808	                jmp error
.b3b5						_ok:
.b3b5		1a		inc a		                ina             ; Increment the wordlist#
.b3b6		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.b3b8		ca		dex		                dex             ; and put it on the stack.
.b3b9		ca		dex		                dex
.b3ba		95 00		sta $00,x	                sta 0,x
.b3bc		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.b3be		60		rts		z_wordlist:     rts

;******  Return to file: platform/../words/all.asm


;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=$0000						ram_start = $0000          ; start of installed RAM, must include zpage
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=32767						ram_end   = $8000-1        ; end of installed RAM
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=512						buffer0   = stack0+$100      ; input buffer ($0200-$02ff)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.b3bf						cold_zp_table:
>b3bf	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>b3c1	0002	a2 bb				dp:         .word dictionary_start  ; Dictionary Pointer
>b3c3	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>b3c5	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>b3c7	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>b3c9	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>b3cb	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>b3cd	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>b3cf	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>b3d1	0012	22 f0				output:     .word kernel_putc       ; vector for EMIT
>b3d3	0014	26 f0				input:      .word kernel_getc       ; vector for KEY
>b3d5	0016	34 f0				havekey:    .word kernel_kbhit      ; vector for KEY?
>b3d7	0018	0a 00				base:       .word 10                ; number radix, default decimal
>b3d9	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>b3db	001c	00 00				status:     .word 0                 ; internal status used by CREATE : :NONAME ; ACCEPT NUMBER
>b3dd	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>b3de	001f					loopctrl:   .byte ?         ; Offset from lcbstack0 to current loop control block for DO/LOOP/+LOOP
>b3df	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$0100						lcbstack0 = stack0
=256						loopindex = lcbstack0+0     ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack0+2     ; loop control block offset for limit fudge factor
>b3e0	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>b3e2	0023					tmptos:     .word ?         ; temporary TOS storage
>b3e4	0025					tmp1:       .word ?         ; temporary storage
>b3e6	0027					tmp2:       .word ?         ; temporary storage
>b3e8	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>b3ea	002b					tohold:     .word ?         ; pointer for formatted output
>b3ec	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>b3f4	0035					tmped:      .word ?,?,?     ; temporary for editors
.b3dd						cold_zp_table_end:
.b3dd						cold_user_table:
>b3dd	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>b3df	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>b3e1	0004	00 00				blk_offset:             .word 0         ; BLK
>b3e3	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
.b3e5	0008					marker_start_offset:
>b3e5	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>b3e6	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.b3e7	000a					wordlists_offset:
>b3e7	000a	a2 bb				    .word dictionary_start              ; FORTH-WORDLIST
>b3e9	000c	11 ca				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>b3eb	000e	61 ca				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>b3ed	0010	d0 c9				    .word root_dictionary_start         ; ROOT-WORDLIST
>b3ef	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>b3f7	001a	00 00 00 00 00 00 00 00
>b3ff	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.b400	0023					search_order_offset:
>b400	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>b408	002b	00
.b409	002c					marker_end_offset:
>b409	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>b40b	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>b40d	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>b40f	0032	e9 af				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>b411	0034	e9 af				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.b413						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$d0						OpBNE   = $D0
=$f0						OpBEQ   = $F0
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=$24						OpBITzp = $24   ; used to save a branch occasionally
=5						N_FLAGS = 5                 ; Bits 5-7 are currently unused.
=1						CO = 1                      ; Compile Only
=2						IM = 2                      ; Immediate Word
=4						AN = 4                      ; Always Native Compile
=8						NN = 8                      ; Never Native Compile
=12						ST = AN+NN                  ; Stack juggling to be stripped for native compile
=16						HC = 16                     ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../opcodes.asm

.b413						oc_index_table:
>b413		13 b6 17 b6 be ba be ba		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc07
>b41b		1f b6 25 b6 2b b6 31 b6
>b423		38 b6 3c b6 42 b6 be ba		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>b42b		48 b6 4c b6 50 b6 54 b6
>b433		59 b6 5d b6 65 b6 be ba		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>b43b		6c b6 72 b6 79 b6 80 b6
>b443		87 b6 8b b6 91 b6 be ba		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc1E, oc1F
>b44b		97 b6 9b b6 a1 b6 a7 b6
>b453		ac b6 b0 b6 be ba be ba		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>b45b		b8 b6 be b6 c4 b6 ca b6
>b463		d1 b6 d5 b6 db b6 be ba		        .word oc28, oc29, oc2A, oc__, oc2C, oc2D, oc2E, oc2F
>b46b		e1 b6 e5 b6 ea b6 ee b6
>b473		f3 b6 f7 b6 ff b6 be ba		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>b47b		06 b7 0e b7 15 b7 1c b7
>b483		23 b7 27 b7 2d b7 be ba		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc3F
>b48b		33 b7 39 b7 3f b7 45 b7
>b493		4a b7 4e b7 be ba be ba		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>b49b		be ba 56 b7 5c b7 62 b7
>b4a3		69 b7 6d b7 73 b7 be ba		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>b4ab		79 b7 7d b7 81 b7 85 b7
>b4b3		8a b7 8e b7 96 b7 be ba		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>b4bb		be ba 9d b7 a4 b7 ab b7
>b4c3		b2 b7 b6 b7 bc b7 be ba		        .word oc58, oc59, oc5A, oc__, oc__, oc5D, oc5E, oc5F
>b4cb		be ba c0 b7 c6 b7 cc b7
>b4d3		d1 b7 d5 b7 be ba be ba		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b4db		dd b7 e3 b7 e9 b7 ef b7
>b4e3		f6 b7 fa b7 00 b8 be ba		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>b4eb		06 b8 0c b8 10 b8 14 b8
>b4f3		19 b8 1d b8 25 b8 be ba		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b4fb		2c b8 33 b8 3a b8 41 b8
>b503		48 b8 4c b8 52 b8 be ba		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>b50b		56 b8 5d b8 63 b8 69 b8
>b513		6e b8 72 b8 be ba be ba		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc87
>b51b		7a b8 80 b8 86 b8 8c b8
>b523		93 b8 97 b8 9d b8 be ba		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>b52b		a1 b8 a5 b8 a9 b8 ad b8
>b533		b2 b8 b6 b8 be b8 be ba		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b53b		c5 b8 cc b8 d3 b8 da b8
>b543		e1 b8 e5 b8 eb b8 be ba		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>b54b		ef b8 f3 b8 f9 b8 ff b8
>b553		04 b9 0a b9 12 b9 be ba		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>b55b		18 b9 1e b9 24 b9 2a b9
>b563		31 b9 35 b9 3b b9 be ba		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>b56b		3f b9 43 b9 47 b9 4b b9
>b573		50 b9 54 b9 5c b9 be ba		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>b57b		63 b9 6a b9 71 b9 78 b9
>b583		7f b9 83 b9 89 b9 be ba		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>b58b		8d b9 93 b9 99 b9 9f b9
>b593		a4 b9 aa b9 be ba be ba		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>b59b		b2 b9 b8 b9 be b9 c4 b9
>b5a3		cb b9 cf b9 d5 b9 be ba		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>b5ab		d9 b9 dd b9 e1 b9 e5 b9
>b5b3		ea b9 ee b9 f6 b9 be ba		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>b5bb		be ba fd b9 04 ba 0b ba
>b5c3		12 ba 16 ba 1c ba be ba		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>b5cb		be ba 20 ba 26 ba 2c ba
>b5d3		31 ba 37 ba be ba be ba		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>b5db		3f ba 45 ba 4b ba 51 ba
>b5e3		58 ba 5c ba 62 ba be ba		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>b5eb		66 ba 6a ba 6e ba 72 ba
>b5f3		77 ba 7b ba 83 ba be ba		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>b5fb		be ba 8a ba 91 ba 98 ba
>b603		9f ba a3 ba a9 ba be ba		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>b60b		be ba ad ba b3 ba b9 ba
>b613		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b617		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b61f		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b625		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b62b		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b631		86 72 6d 62 30 2e 7a			oc07:	.text 2*64+6, "rmb0.z"
>b638		43 70 68 70				oc08:	.text 1*64+3, "php"
>b63c		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b642		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>b648		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>b64c		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>b650		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>b654		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>b659		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b65d		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b665		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b66c		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b672		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b679		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b680		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b687		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b68b		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b691		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b697		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b69b		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b6a1		c5 61 73 6c 2e 78			oc1E:	.text 3*64+5, "asl.x"
>b6a7		c4 62 62 72 31				oc1F:	.text 3*64+4, "bbr1"
>b6ac		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b6b0		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b6b8		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b6be		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b6c4		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b6ca		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b6d1		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b6d5		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b6db		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b6e1		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b6e5		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b6ea		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b6ee		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b6f3		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b6f7		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b6ff		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b706		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b70e		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b715		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b71c		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b723		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b727		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b72d		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b733		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b739		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b73f		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b745		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b74a		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b74e		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b756		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b75c		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b762		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b769		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b76d		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b773		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b779		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b77d		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b781		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b785		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b78a		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b78e		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b796		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b79d		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b7a4		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b7ab		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b7b2		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b7b6		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b7bc		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b7c0		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b7c6		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b7cc		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b7d1		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b7d5		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b7dd		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b7e3		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b7e9		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b7ef		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b7f6		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b7fa		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b800		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b806		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b80c		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b810		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b814		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b819		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b81d		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b825		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b82c		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b833		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b83a		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b841		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b848		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b84c		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b852		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b856		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b85d		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b863		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b869		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b86e		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b872		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b87a		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b880		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b886		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b88c		86 73 6d 62 30 2e 7a			oc87:	.text 2*64+6, "smb0.z"
>b893		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b897		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b89d		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b8a1		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b8a5		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b8a9		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b8ad		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b8b2		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b8b6		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b8be		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b8c5		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b8cc		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b8d3		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b8da		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b8e1		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b8e5		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b8eb		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b8ef		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b8f3		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b8f9		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b8ff		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b904		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b90a		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b912		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b918		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b91e		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b924		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b92a		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b931		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b935		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b93b		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b93f		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b943		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b947		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b94b		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b950		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b954		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b95c		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b963		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b96a		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b971		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b978		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b97f		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b983		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b989		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>b98d		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>b993		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>b999		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>b99f		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>b9a4		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>b9aa		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>b9b2		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>b9b8		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>b9be		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>b9c4		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>b9cb		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>b9cf		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>b9d5		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>b9d9		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>b9dd		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>b9e1		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>b9e5		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>b9ea		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>b9ee		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>b9f6		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>b9fd		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>ba04		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>ba0b		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>ba12		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>ba16		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>ba1c		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>ba20		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>ba26		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>ba2c		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>ba31		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>ba37		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>ba3f		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>ba45		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>ba4b		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>ba51		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>ba58		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>ba5c		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>ba62		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>ba66		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>ba6a		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>ba6e		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>ba72		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>ba77		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>ba7b		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>ba83		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>ba8a		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>ba91		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>ba98		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>ba9f		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>baa3		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>baa9		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>baad		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>bab3		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>bab9		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>babe		01 3f					oc__:	.text 1, "?"

;******  Return to file: platform/../taliforth.asm

.bac0						forth_words_start:
>bac0		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bac8		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bad8		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bae8		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>baf8		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>bb08		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bb18		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>bb28		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bb38		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>bb48		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>bb58		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>bb68		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>bb78		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bb88		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bb98		78 69 74 29 20 63 72 20
.bba0						forth_words_end:
.bba0						user_words_start:
>bba0		20 20				.binary "user_words.asc"
.bba2						user_words_end:

;******  Processing file: platform/../words/headers.asm

.bba2						dictionary_start:
.bba2						nt_drop:
>bba2		04 00				        .byte 4, 0
>bba4		ae bb 88 86 8d 86		        .word nt_dup, xt_drop, z_drop
>bbaa		64 72 6f 70			        .text "drop"
.bbae						nt_dup:
>bbae		03 00				        .byte 3, 0
>bbb0		b9 bb 8e 86 9b 86		        .word nt_swap, xt_dup, z_dup
>bbb6		64 75 70			        .text "dup"
.bbb9						nt_swap:
>bbb9		04 00				        .byte 4, 0
>bbbb		c5 bb 43 92 56 92		        .word nt_store, xt_swap, z_swap
>bbc1		73 77 61 70			        .text "swap"
.bbc5						nt_store:
>bbc5		01 00				        .byte 1, 0
>bbc7		ce bb 2d 92 42 92		        .word nt_fetch, xt_store, z_store
>bbcd		21				        .text "!"
.bbce						nt_fetch:
>bbce		01 00				        .byte 1, 0
>bbd0		d7 bb 0e 88 20 88		        .word nt_over, xt_fetch, z_fetch
>bbd6		40				        .text "@"
.bbd7						nt_over:
>bbd7		04 00				        .byte 4, 0
>bbd9		e3 bb 00 8d 0d 8d		        .word nt_to_r, xt_over, z_over
>bbdf		6f 76 65 72			        .text "over"
.bbe3						nt_to_r:
>bbe3		02 0d				        .byte 2, CO+ST       ; native skips stack juggling
>bbe5		ed bb 81 93 96 93		        .word nt_r_from, xt_to_r, z_to_r
>bbeb		3e 72				        .text ">r"
.bbed						nt_r_from:
>bbed		02 0d				        .byte 2, CO+ST          ; native skips stack juggling
>bbef		f7 bb dd 8e ef 8e		        .word nt_r_fetch, xt_r_from, z_r_from
>bbf5		72 3e				        .text "r>"
.bbf7						nt_r_fetch:
>bbf7		02 0d				        .byte 2, CO+ST          ; native skips stack juggling
>bbf9		01 bc c6 8e da 8e		        .word nt_nip, xt_r_fetch, z_r_fetch
>bbff		72 40				        .text "r@"
.bc01						nt_nip:
>bc01		03 00				        .byte 3, 0
>bc03		0c bc 2f 8c 3c 8c		        .word nt_rot, xt_nip, z_nip
>bc09		6e 69 70			        .text "nip"
.bc0c						nt_rot:
>bc0c		03 00				        .byte 3, 0
>bc0e		17 bc 81 8f 9c 8f		        .word nt_not_rot, xt_rot, z_rot
>bc14		72 6f 74			        .text "rot"
.bc17						nt_not_rot:
>bc17		04 00				        .byte 4, 0
>bc19		23 bc 1d 9d 38 9d		        .word nt_tuck, xt_not_rot, z_not_rot
>bc1f		2d 72 6f 74			        .text "-rot"
.bc23						nt_tuck:
>bc23		04 00				        .byte 4, 0
>bc25		2f bc a2 93 bb 93		        .word nt_comma, xt_tuck, z_tuck
>bc2b		74 75 63 6b			        .text "tuck"
.bc2f						nt_comma:
>bc2f		01 00				        .byte 1, 0
>bc31		38 bc d6 83 e4 83		        .word nt_c_fetch, xt_comma, z_comma
>bc37		2c				        .text ","
.bc38						nt_c_fetch:
>bc38		02 00				        .byte 2, 0
>bc3a		42 bc 58 83 61 83		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bc40		63 40				        .text "c@"
.bc42						nt_c_store:
>bc42		02 00				        .byte 2, 0
>bc44		4c bc 62 83 6d 83		        .word nt_plus_store, xt_c_store, z_c_store
>bc4a		63 21				        .text "c!"
.bc4c						nt_plus_store:
>bc4c		02 00				        .byte 2, 0
>bc4e		56 bc 61 8e 7b 8e		        .word nt_zero, xt_plus_store, z_plus_store
>bc54		2b 21				        .text "+!"
.bc56						nt_zero:
>bc56		01 00				        .byte 1, 0
>bc58		5f bc 99 9e 9f 9e		        .word nt_one, xt_zero, z_zero
>bc5e		30				        .text "0"
.bc5f						nt_one:
>bc5f		01 00				        .byte 1, 0
>bc61		68 bc 33 9e 3b 9e		        .word nt_two, xt_one, z_one
>bc67		31				        .text "1"
.bc68						nt_two:
>bc68		01 00				        .byte 1, 0
>bc6a		71 bc 64 9e 6c 9e		        .word nt_execute, xt_two, z_two
>bc70		32				        .text "2"
.bc71						nt_execute:
>bc71		07 00				        .byte 7, 0
>bc73		80 bc f9 87 ff 87		        .word nt_emit, xt_execute, z_execute
>bc79		65 78 65 63 75 74 65		        .text "execute"
.bc80						nt_emit:
>bc80		04 08				        .byte 4, NN
>bc82		8c bc b4 86 be 86		        .word nt_type, xt_emit, z_emit
>bc88		65 6d 69 74			        .text "emit"
.bc8c						nt_type:
>bc8c		04 00				        .byte 4, 0
>bc8e		98 bc d9 94 03 95		        .word nt_dot, xt_type, z_type
>bc94		74 79 70 65			        .text "type"
.bc98						nt_dot:
>bc98		01 00				        .byte 1, 0
>bc9a		a1 bc 1e 86 3f 86		        .word nt_u_dot, xt_dot, z_dot
>bca0		2e				        .text "."
.bca1						nt_u_dot:
>bca1		02 00				        .byte 2, 0
>bca3		ab bc 04 95 0f 95		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bca9		75 2e				        .text "u."
.bcab						nt_u_dot_r:
>bcab		03 00				        .byte 3, 0
>bcad		b6 bc 10 95 31 95		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bcb3		75 2e 72			        .text "u.r"
.bcb6						nt_dot_r:
>bcb6		02 00				        .byte 2, 0
>bcb8		c0 bc 5a 86 87 86		        .word nt_d_dot, xt_dot_r, z_dot_r
>bcbe		2e 72				        .text ".r"
.bcc0						nt_d_dot:
>bcc0		02 00				        .byte 2, 0
>bcc2		ca bc 22 9f 40 9f		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bcc8		64 2e				        .text "d."
.bcca						nt_d_dot_r:
>bcca		03 00				        .byte 3, 0
>bccc		d5 bc 41 9f 6b 9f		        .word nt_m_star_slash, xt_d_dot_r, z_d_dot_r
>bcd2		64 2e 72			        .text "d.r"
.bcd5						nt_m_star_slash:
>bcd5		03 00				        .byte 3, 0
>bcd7		e0 bc 6c 9f d2 9f		        .word nt_ud_dot, xt_m_star_slash, z_m_star_slash
>bcdd		6d 2a 2f			        .text "m*/"
.bce0						nt_ud_dot:
>bce0		03 00				        .byte 3, 0
>bce2		eb bc 3d a0 4f a0		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bce8		75 64 2e			        .text "ud."
.bceb						nt_ud_dot_r:
>bceb		04 00				        .byte 4, 0
>bced		f7 bc 50 a0 6e a0		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bcf3		75 64 2e 72			        .text "ud.r"
.bcf7						nt_question:
>bcf7		01 00				        .byte 1, 0
>bcf9		00 bd 67 99 6d 99		        .word nt_false, xt_question, z_question
>bcff		3f				        .text "?"
.bd00						nt_false:
>bd00		05 00				        .byte 5, 0
>bd02		0d bd 99 9e 9f 9e		        .word nt_true, xt_false, z_false
>bd08		66 61 6c 73 65			        .text "false"
.bd0d						nt_true:
>bd0d		04 00				        .byte 4, 0
>bd0f		19 bd 99 93 a1 93		        .word nt_space, xt_true, z_true
>bd15		74 72 75 65			        .text "true"
.bd19						nt_space:
>bd19		05 00				        .byte 5, 0
>bd1b		26 bd dd 91 e2 91		        .word nt_two_dup, xt_space, z_space
>bd21		73 70 61 63 65			        .text "space"
.bd26						nt_two_dup:
>bd26		04 00				        .byte 4, 0
>bd28		32 bd c4 93 db 93		        .word nt_question_dup, xt_two_dup, z_two_dup
>bd2e		32 64 75 70			        .text "2dup"
.bd32						nt_question_dup:
>bd32		04 00				        .byte 4, 0
>bd34		3e bd b2 8e c5 8e		        .word nt_plus, xt_question_dup, z_question_dup
>bd3a		3f 64 75 70			        .text "?dup"
.bd3e						nt_plus:
>bd3e		01 00				        .byte 1, 0
>bd40		47 bd 4e 8e 60 8e		        .word nt_minus, xt_plus, z_plus
>bd46		2b				        .text "+"
.bd47						nt_minus:
>bd47		01 00				        .byte 1, 0
>bd49		50 bd e0 8b f2 8b		        .word nt_one_minus, xt_minus, z_minus
>bd4f		2d				        .text "-"
.bd50						nt_one_minus:
>bd50		02 00				        .byte 2, 0
>bd52		5a bd d8 8c e3 8c		        .word nt_one_plus, xt_one_minus, z_one_minus
>bd58		31 2d				        .text "1-"
.bd5a						nt_one_plus:
>bd5a		02 00				        .byte 2, 0
>bd5c		64 bd e4 8c ed 8c		        .word nt_two_star, xt_one_plus, z_one_plus
>bd62		31 2b				        .text "1+"
.bd64						nt_two_star:
>bd64		02 00				        .byte 2, 0
>bd66		6e bd 67 94 6e 94		        .word nt_two_slash, xt_two_star, z_two_star
>bd6c		32 2a				        .text "2*"
.bd6e						nt_two_slash:
>bd6e		02 00				        .byte 2, 0
>bd70		78 bd 5c 94 66 94		        .word nt_abs, xt_two_slash, z_two_slash
>bd76		32 2f				        .text "2/"
.bd78						nt_abs:
>bd78		03 00				        .byte 3, 0
>bd7a		83 bd d2 80 e6 80		        .word nt_dabs, xt_abs, z_abs
>bd80		61 62 73			        .text "abs"
.bd83						nt_dabs:
>bd83		04 00				        .byte 4, 0
>bd85		8f bd e8 9e 06 9f		        .word nt_and, xt_dabs, z_dabs
>bd8b		64 61 62 73			        .text "dabs"
.bd8f						nt_and:
>bd8f		03 00				        .byte 3, 0
>bd91		9a bd bb 82 cc 82		        .word nt_or, xt_and, z_and
>bd97		61 6e 64			        .text "and"
.bd9a						nt_or:
>bd9a		02 00				        .byte 2, 0
>bd9c		a4 bd ee 8c ff 8c		        .word nt_xor, xt_or, z_or
>bda2		6f 72				        .text "or"
.bda4						nt_xor:
>bda4		03 00				        .byte 3, 0
>bda6		af bd 7d 96 8e 96		        .word nt_rshift, xt_xor, z_xor
>bdac		78 6f 72			        .text "xor"
.bdaf						nt_rshift:
>bdaf		06 00				        .byte 6, 0
>bdb1		bd bd 9d 8f b0 8f		        .word nt_lshift, xt_rshift, z_rshift
>bdb7		72 73 68 69 66 74		        .text "rshift"
.bdbd						nt_lshift:
>bdbd		06 00				        .byte 6, 0
>bdbf		cb bd 13 8b 26 8b		        .word nt_pick, xt_lshift, z_lshift
>bdc5		6c 73 68 69 66 74		        .text "lshift"
.bdcb						nt_pick:
>bdcb		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bdcd		d7 bd 3d 8e 4d 8e		        .word nt_char, xt_pick, z_pick
>bdd3		70 69 63 6b			        .text "pick"
.bdd7						nt_char:
>bdd7		04 00				        .byte 4, 0
>bdd9		e3 bd 7e 83 94 83		        .word nt_bracket_char, xt_char, z_char
>bddf		63 68 61 72			        .text "char"
.bde3						nt_bracket_char:
>bde3		06 03				        .byte 6, CO+IM
>bde5		f1 bd 38 83 3e 83		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bdeb		5b 63 68 61 72 5d		        .text "[char]"
.bdf1						nt_char_plus:
>bdf1		05 00				        .byte 5, 0
>bdf3		fe bd e4 8c ed 8c		        .word nt_chars, xt_char_plus, z_char_plus ; same as 1+
>bdf9		63 68 61 72 2b			        .text "char+"
.bdfe						nt_chars:
>bdfe		05 00				        .byte 5, 0      ; deleted during compile
>be00		0b be 95 83 98 83		        .word nt_cells, xt_chars, z_chars
>be06		63 68 61 72 73			        .text "chars"
.be0b						nt_cells:
>be0b		05 00				        .byte 5, 0
>be0d		18 be 67 94 6e 94		        .word nt_cell_plus, xt_cells, z_cells  ; same as 2*
>be13		63 65 6c 6c 73			        .text "cells"
.be18						nt_cell_plus:
>be18		05 00				        .byte 5, 0
>be1a		25 be 6e 83 7d 83		        .word nt_here, xt_cell_plus, z_cell_plus
>be20		63 65 6c 6c 2b			        .text "cell+"
.be25						nt_here:
>be25		04 00				        .byte 4, 0
>be27		31 be 0f 89 19 89		        .word nt_equal, xt_here, z_here
>be2d		68 65 72 65			        .text "here"
.be31						nt_equal:
>be31		01 00				        .byte 1, 0
>be33		3a be 82 87 9d 87		        .word nt_not_equals, xt_equal, z_equal
>be39		3d				        .text "="
.be3a						nt_not_equals:
>be3a		02 00				        .byte 2, 0
>be3c		44 be 3d 8c 5a 8c		        .word nt_less_than, xt_not_equals, z_not_equals
>be42		3c 3e				        .text "<>"
.be44						nt_less_than:
>be44		01 00				        .byte 1, 0
>be46		4d be e3 89 f7 89		        .word nt_u_less_than, xt_less_than, z_less_than
>be4c		3c				        .text "<"
.be4d						nt_u_less_than:
>be4d		02 00				        .byte 2, 0
>be4f		57 be 48 95 5d 95		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>be55		75 3c				        .text "u<"
.be57						nt_u_greater_than:
>be57		02 00				        .byte 2, 0
>be59		61 be 32 95 47 95		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>be5f		75 3e				        .text "u>"
.be61						nt_greater_than:
>be61		01 00				        .byte 1, 0
>be63		6a be fa 88 0e 89		        .word nt_zero_equal, xt_greater_than, z_greater_than
>be69		3e				        .text ">"
.be6a						nt_zero_equal:
>be6a		02 00				        .byte 2, 0
>be6c		74 be 8f 96 a0 96		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>be72		30 3d				        .text "0="
.be74						nt_zero_unequal:
>be74		03 00				        .byte 3, 0
>be76		7f be c5 96 d4 96		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>be7c		30 3c 3e			        .text "0<>"
.be7f						nt_zero_greater:
>be7f		02 00				        .byte 2, 0
>be81		89 be a1 96 b4 96		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>be87		30 3e				        .text "0>"
.be89						nt_zero_less:
>be89		02 00				        .byte 2, 0
>be8b		93 be b5 96 c4 96		        .word nt_min, xt_zero_less, z_zero_less
>be91		30 3c				        .text "0<"
.be93						nt_min:
>be93		03 00				        .byte 3, 0
>be95		9e be c4 8b df 8b		        .word nt_max, xt_min, z_min
>be9b		6d 69 6e			        .text "min"
.be9e						nt_max:
>be9e		03 00				        .byte 3, 0
>bea0		a9 be a8 8b c3 8b		        .word nt_two_drop, xt_max, z_max
>bea6		6d 61 78			        .text "max"
.bea9						nt_two_drop:
>bea9		05 00				        .byte 5, 0
>beab		b6 be bc 93 c3 93		        .word nt_two_swap, xt_two_drop, z_two_drop
>beb1		32 64 72 6f 70			        .text "2drop"
.beb6						nt_two_swap:
>beb6		05 00				        .byte 5, 0
>beb8		c3 be 95 94 b8 94		        .word nt_two_over, xt_two_swap, z_two_swap
>bebe		32 73 77 61 70			        .text "2swap"
.bec3						nt_two_over:
>bec3		05 00				        .byte 5, 0
>bec5		d0 be fe 93 15 94		        .word nt_two_store, xt_two_over, z_two_over
>becb		32 6f 76 65 72			        .text "2over"
.bed0						nt_two_store:
>bed0		02 00				        .byte 2, 0
>bed2		da be 6f 94 94 94		        .word nt_two_fetch, xt_two_store, z_two_store
>bed8		32 21				        .text "2!"
.beda						nt_two_fetch:
>beda		02 00				        .byte 2, 0
>bedc		e4 be dc 93 fd 93		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bee2		32 40				        .text "2@"
.bee4						nt_two_variable:
>bee4		09 00				        .byte 9, 0
>bee6		f5 be 2c a0 3c a0		        .word nt_two_constant, xt_two_variable, z_two_variable
>beec		32 76 61 72 69 61 62 6c		        .text "2variable"
>bef4		65
.bef5						nt_two_constant:
>bef5		09 00				        .byte 9, 0
>bef7		06 bf d3 9f ec 9f		        .word nt_two_literal, xt_two_constant, z_two_constant
>befd		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bf05		74
.bf06						nt_two_literal:
>bf06		08 02				        .byte 8, IM
>bf08		16 bf ed 9f 12 a0		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bf0e		32 6c 69 74 65 72 61 6c		        .text "2literal"
.bf16						nt_two_r_fetch:
>bf16		03 0d				        .byte 3, CO+ST          ; native skips stack juggling
>bf18		21 bf 16 94 3c 94		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bf1e		32 72 40			        .text "2r@"
.bf21						nt_two_r_from:
>bf21		03 0d				        .byte 3, CO+ST          ; native skips stack juggling
>bf23		2c bf 3f 94 59 94		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bf29		32 72 3e			        .text "2r>"
.bf2c						nt_two_to_r:
>bf2c		03 0d				        .byte 3, CO+ST       ; native skips stack juggling
>bf2e		37 bf b9 94 d6 94		        .word nt_invert, xt_two_to_r, z_two_to_r
>bf34		32 3e 72			        .text "2>r"
.bf37						nt_invert:
>bf37		06 00				        .byte 6, 0
>bf39		45 bf 58 89 67 89		        .word nt_negate, xt_invert, z_invert
>bf3f		69 6e 76 65 72 74		        .text "invert"
.bf45						nt_negate:
>bf45		06 00				        .byte 6, 0
>bf47		53 bf 1e 8c 2e 8c		        .word nt_dnegate, xt_negate, z_negate
>bf4d		6e 65 67 61 74 65		        .text "negate"
.bf53						nt_dnegate:
>bf53		07 00				        .byte 7, 0
>bf55		62 bf 07 9f 21 9f		        .word nt_c_comma, xt_dnegate, z_dnegate
>bf5b		64 6e 65 67 61 74 65		        .text "dnegate"
.bf62						nt_c_comma:
>bf62		02 00				        .byte 2, 0
>bf64		6c bf 4d 83 57 83		        .word nt_bounds, xt_c_comma, z_c_comma
>bf6a		63 2c				        .text "c,"
.bf6c						nt_bounds:
>bf6c		06 00				        .byte 6, 0
>bf6e		7a bf c0 9a d8 9a		        .word nt_spaces, xt_bounds, z_bounds
>bf74		62 6f 75 6e 64 73		        .text "bounds"
.bf7a						nt_spaces:
>bf7a		06 00				        .byte 6, 0
>bf7c		88 bf e3 91 fc 91		        .word nt_bl, xt_spaces, z_spaces
>bf82		73 70 61 63 65 73		        .text "spaces"
.bf88						nt_bl:
>bf88		02 00				        .byte 2, 0
>bf8a		92 bf 2f 83 37 83		        .word nt_minus_trailing, xt_bl, z_bl
>bf90		62 6c				        .text "bl"
.bf92						nt_minus_trailing:
>bf92		09 00				        .byte 9, 0
>bf94		a3 bf 63 a1 9f a1		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>bf9a		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>bfa2		67
.bfa3						nt_minus_leading:
>bfa3		08 00				        .byte 8, 0
>bfa5		b3 bf 4a a1 62 a1		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>bfab		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.bfb3						nt_slash_string:
>bfb3		07 00				        .byte 7, 0
>bfb5		c2 bf 3f a2 5e a2		        .word nt_refill, xt_slash_string, z_slash_string
>bfbb		2f 73 74 72 69 6e 67		        .text "/string"
.bfc2						nt_refill:
>bfc2		06 00				        .byte 6, 0
>bfc4		d0 bf 2f 8f 70 8f		        .word nt_accept, xt_refill, z_refill
>bfca		72 65 66 69 6c 6c		        .text "refill"
.bfd0						nt_accept:
>bfd0		06 08				        .byte 6, NN
>bfd2		de bf e7 80 07 82		        .word nt_input_to_r, xt_accept, z_accept
>bfd8		61 63 63 65 70 74		        .text "accept"
.bfde						nt_input_to_r:
>bfde		07 08				        .byte 7, NN
>bfe0		ed bf 3a 9c 4f 9c		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>bfe6		69 6e 70 75 74 3e 72		        .text "input>r"
.bfed						nt_r_to_input:
>bfed		07 08				        .byte 7, NN
>bfef		fc bf 47 9e 5e 9e		        .word nt_unused, xt_r_to_input, z_r_to_input
>bff5		72 3e 69 6e 70 75 74		        .text "r>input"
.bffc						nt_unused:
>bffc		06 00				        .byte 6, 0
>bffe		0a c0 fd 95 0c 96		        .word nt_depth, xt_unused, z_unused
>c004		75 6e 75 73 65 64		        .text "unused"
.c00a						nt_depth:
>c00a		05 00				        .byte 5, 0
>c00c		17 c0 40 85 4e 85		        .word nt_key, xt_depth, z_depth
>c012		64 65 70 74 68			        .text "depth"
.c017						nt_key:
>c017		03 00				        .byte 3, 0
>c019		22 c0 9b 89 a4 89		        .word nt_keyq, xt_key, z_key
>c01f		6b 65 79			        .text "key"
.c022						nt_keyq:
>c022		04 00				        .byte 4, 0
>c024		2e c0 a8 89 b6 89		        .word nt_allot, xt_keyq, z_keyq
>c02a		6b 65 79 3f			        .text "key?"
.c02e						nt_allot:
>c02e		05 00				        .byte 5, 0
>c030		3b c0 52 82 ba 82		        .word nt_create, xt_allot, z_allot
>c036		61 6c 6c 6f 74			        .text "allot"
.c03b						nt_create:
>c03b		06 00				        .byte 6, 0
>c03d		49 c0 1d 84 0c 85		        .word nt_does, xt_create, z_create
>c043		63 72 65 61 74 65		        .text "create"
.c049						nt_does:
>c049		05 03				        .byte 5, CO+IM
>c04b		56 c0 dd 85 eb 85		        .word nt_variable, xt_does, z_does
>c051		64 6f 65 73 3e			        .text "does>"
.c056						nt_variable:
>c056		08 00				        .byte 8, 0
>c058		66 c0 0d 96 18 96		        .word nt_constant, xt_variable, z_variable
>c05e		76 61 72 69 61 62 6c 65		        .text "variable"
.c066						nt_constant:
>c066		08 00				        .byte 8, 0
>c068		76 c0 f1 83 02 84		        .word nt_value, xt_constant, z_constant
>c06e		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c076						nt_value:
>c076		05 00				        .byte 5, 0
>c078		83 c0 f1 83 02 84		        .word nt_to, xt_value, z_value          ; same code as CONSTANT
>c07e		76 61 6c 75 65			        .text "value"
.c083						nt_to:
>c083		02 0a				        .byte 2, NN+IM
>c085		8d c0 77 92 b2 92		        .word nt_s_to_d, xt_to, z_to
>c08b		74 6f				        .text "to"
.c08d						nt_s_to_d:
>c08d		03 00				        .byte 3, 0
>c08f		98 c0 de 90 ef 90		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c095		73 3e 64			        .text "s>d"
.c098						nt_d_to_s:
>c098		03 00				        .byte 3, 0
>c09a		a3 c0 e2 9e e7 9e		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c0a0		64 3e 73			        .text "d>s"
.c0a3						nt_d_minus:
>c0a3		02 00				        .byte 2, 0
>c0a5		ad c0 a0 9e c0 9e		        .word nt_d_plus, xt_d_minus, z_d_minus
>c0ab		64 2d				        .text "d-"
.c0ad						nt_d_plus:
>c0ad		02 00				        .byte 2, 0
>c0af		b7 c0 c1 9e e1 9e		        .word nt_erase, xt_d_plus, z_d_plus
>c0b5		64 2b				        .text "d+"
.c0b7						nt_erase:
>c0b7		05 00				        .byte 5, 0
>c0b9		c4 c0 ab 87 f8 87		        .word nt_blank, xt_erase, z_erase
>c0bf		65 72 61 73 65			        .text "erase"
.c0c4						nt_blank:
>c0c4		05 00				        .byte 5, 0
>c0c6		d1 c0 9e 87 f8 87		        .word nt_fill, xt_blank, z_blank
>c0cc		62 6c 61 6e 6b			        .text "blank"
.c0d1						nt_fill:
>c0d1		04 00				        .byte 4, 0
>c0d3		dd c0 b6 87 f8 87		        .word nt_find_name, xt_fill, z_fill
>c0d9		66 69 6c 6c			        .text "fill"
.c0dd						nt_find_name:
>c0dd		09 00				        .byte 9, 0
>c0df		ee c0 82 9b d0 9b		        .word nt_tick, xt_find_name, z_find_name
>c0e5		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c0ed		65
.c0ee						nt_tick:
>c0ee		01 00				        .byte 1, 0
>c0f0		f7 c0 57 92 76 92		        .word nt_bracket_tick, xt_tick, z_tick
>c0f6		27				        .text "'"
.c0f7						nt_bracket_tick:
>c0f7		03 03				        .byte 3, CO+IM
>c0f9		02 c1 3f 83 45 83		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c0ff		5b 27 5d			        .text "[']"
.c102						nt_name_to_int:
>c102		08 00				        .byte 8, 0
>c104		12 c1 d6 9c f2 9c		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c10a		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c112						nt_int_to_name:
>c112		08 00				        .byte 8, 0
>c114		22 c1 50 9c c0 9c		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c11a		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c122						nt_name_to_string:
>c122		0b 00				        .byte 11, 0
>c124		35 c1 f3 9c 09 9d		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c12a		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c132		69 6e 67
.c135						nt_to_body:
>c135		05 00				        .byte 5, 0
>c137		42 c1 b3 92 d5 92		        .word nt_defer, xt_to_body, z_to_body
>c13d		3e 62 6f 64 79			        .text ">body"
.c142						nt_defer:
>c142		05 00				        .byte 5, 0
>c144		4f c1 14 85 26 85		        .word nt_latestxt, xt_defer, z_defer
>c14a		64 65 66 65 72			        .text "defer"
.c14f						nt_latestxt:
>c14f		08 00				        .byte 8, 0
>c151		5f c1 cf 9c d5 9c		        .word nt_latestnt, xt_latestxt, z_latestxt
>c157		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c15f						nt_latestnt:
>c15f		08 00				        .byte 8, 0
>c161		6f c1 c1 9c ce 9c		        .word nt_parse_name, xt_latestnt, z_latestnt
>c167		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c16f						nt_parse_name:
>c16f		0a 08				        .byte 10, NN
>c171		81 c1 4c 8d 3c 8e		        .word nt_parse, xt_parse_name, z_parse_name
>c177		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c17f		6d 65
.c181						nt_parse:
>c181		05 00				        .byte 5, 0
>c183		8e c1 a7 8d 3c 8e		        .word nt_execute_parsing, xt_parse, z_parse
>c189		70 61 72 73 65			        .text "parse"
.c18e						nt_execute_parsing:
>c18e		0f 00				        .byte 15, 0
>c190		a5 c1 5b 9b 81 9b		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c196		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c19e		70 61 72 73 69 6e 67
.c1a5						nt_source:
>c1a5		06 00				        .byte 6, 0
>c1a7		b3 c1 bd 91 d1 91		        .word nt_source_id, xt_source, z_source
>c1ad		73 6f 75 72 63 65		        .text "source"
.c1b3						nt_source_id:
>c1b3		09 00				        .byte 9, 0
>c1b5		c4 c1 d2 91 dc 91		        .word nt_colon, xt_source_id, z_source_id
>c1bb		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c1c3		64
.c1c4						nt_colon:
>c1c4		01 00				        .byte 1, 0
>c1c6		cd c1 99 83 b9 83		        .word nt_semicolon, xt_colon, z_colon
>c1cc		3a				        .text ":"
.c1cd						nt_semicolon:
>c1cd		01 03				        .byte 1, CO+IM
>c1cf		d6 c1 f0 90 5c 91		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c1d5		3b				        .text ";"
.c1d6						nt_colon_noname:
>c1d6		07 00				        .byte 7, 0
>c1d8		e5 c1 ba 83 d5 83		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c1de		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c1e5						nt_compile_comma:
>c1e5		08 08				        .byte 8, NN
>c1e7		f5 c1 e3 96 96 97		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c1ed		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c1f5						nt_left_bracket:
>c1f5		01 03				        .byte 1, IM+CO
>c1f7		fe c1 d0 89 d4 89		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c1fd		5b				        .text "["
.c1fe						nt_right_bracket:
>c1fe		01 02				        .byte 1, IM
>c200		07 c2 7a 8f 80 8f		        .word nt_literal, xt_right_bracket, z_right_bracket
>c206		5d				        .text "]"
.c207						nt_literal:
>c207		07 03				        .byte 7, IM+CO
>c209		16 c2 f8 89 35 8a		        .word nt_sliteral, xt_literal, z_literal
>c20f		6c 69 74 65 72 61 6c		        .text "literal"
.c216						nt_sliteral:
>c216		08 03				        .byte 8, CO+IM
>c218		26 c2 5f a2 7f a2		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c21e		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c226						nt_dot_quote:
>c226		02 03				        .byte 2, CO+IM
>c228		30 c2 4f 86 59 86		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c22e		2e 22				        .text ".", $22
.c230						nt_s_quote:
>c230		02 0a				        .byte 2, IM+NN
>c232		3a c2 ca 8f c3 90		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c238		73 22				        .text "s", $22
.c23a						nt_s_backslash_quote:
>c23a		03 02				        .byte 3, IM
>c23c		45 c2 b1 8f ba 8f		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c242		73 5c 22			        .text "s", $5C, $22
.c245						nt_postpone:
>c245		08 03				        .byte 8, IM+CO
>c247		55 c2 7c 8e b1 8e		        .word nt_immediate, xt_postpone, z_postpone
>c24d		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c255						nt_immediate:
>c255		09 00				        .byte 9, 0
>c257		66 c2 4c 89 57 89		        .word nt_compile_only, xt_immediate, z_immediate
>c25d		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c265		65
.c266						nt_compile_only:
>c266		0c 00				        .byte 12, 0
>c268		7a c2 e5 83 f0 83		        .word nt_never_native, xt_compile_only, z_compile_only
>c26e		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c276		6f 6e 6c 79
.c27a						nt_never_native:
>c27a		0c 00				        .byte 12, 0
>c27c		8e c2 0f 9d 1c 9d		        .word nt_always_native, xt_never_native, z_never_native
>c282		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c28a		74 69 76 65
.c28e						nt_always_native:
>c28e		0d 00				        .byte 13, 0
>c290		a3 c2 ac 9a b9 9a		        .word nt_allow_native, xt_always_native, z_always_native
>c296		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c29e		61 74 69 76 65
.c2a3						nt_allow_native:
>c2a3		0c 00				        .byte 12, 0
>c2a5		b7 c2 a0 9a ab 9a		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c2ab		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c2b3		74 69 76 65
.c2b7						nt_nc_limit:
>c2b7		08 08				        .byte 8, NN
>c2b9		c7 c2 0a 9d 0f 9d		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c2bf		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c2c7						nt_strip_underflow:
>c2c7		0f 08				        .byte 15, NN
>c2c9		de c2 5f 9e 64 9e		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c2cf		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c2d7		64 65 72 66 6c 6f 77
.c2de						nt_abort:
>c2de		05 00				        .byte 5, 0
>c2e0		eb c2 5e 80 b2 80		        .word nt_abort_quote, xt_abort, z_abort
>c2e6		61 62 6f 72 74			        .text "abort"
.c2eb						nt_abort_quote:
>c2eb		06 0b				        .byte 6, CO+IM+NN
>c2ed		f9 c2 b2 80 bc 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c2f3		61 62 6f 72 74 22		        .text "abort", $22
.c2f9						nt_do:
>c2f9		02 0b				        .byte 2, CO+IM+NN
>c2fb		03 c3 79 85 92 85		        .word nt_question_do, xt_do, z_do
>c301		64 6f				        .text "do"
.c303						nt_question_do:
>c303		03 0b				        .byte 3, CO+IM+NN
>c305		0e c3 4f 85 92 85		        .word nt_i, xt_question_do, z_question_do
>c30b		3f 64 6f			        .text "?do"
.c30e						nt_i:
>c30e		01 01				        .byte 1, CO
>c310		17 c3 33 89 47 89		        .word nt_j, xt_i, z_i
>c316		69				        .text "i"
.c317						nt_j:
>c317		01 01				        .byte 1, CO
>c319		20 c3 81 89 9a 89		        .word nt_loop, xt_j, z_j
>c31f		6a				        .text "j"
.c320						nt_loop:
>c320		04 03				        .byte 4, CO+IM
>c322		2c c3 5f 8a d7 8a		        .word nt_plus_loop, xt_loop, z_loop
>c328		6c 6f 6f 70			        .text "loop"
.c32c						nt_plus_loop:
>c32c		05 03				        .byte 5, CO+IM
>c32e		39 c3 73 8a d7 8a		        .word nt_exit, xt_plus_loop, z_plus_loop
>c334		2b 6c 6f 6f 70			        .text "+loop"
.c339						nt_exit:
>c339		04 05				        .byte 4, AN+CO
>c33b		45 c3 0d 88 0e 88		        .word nt_unloop, xt_exit, z_exit
>c341		65 78 69 74			        .text "exit"
.c345						nt_unloop:
>c345		06 01				        .byte 6, CO
>c347		53 c3 e6 95 f5 95		        .word nt_leave, xt_unloop, z_unloop
>c34d		75 6e 6c 6f 6f 70		        .text "unloop"
.c353						nt_leave:
>c353		05 03				        .byte 5, CO+IM
>c355		60 c3 ba 89 cf 89		        .word nt_recurse, xt_leave, z_leave
>c35b		6c 65 61 76 65			        .text "leave"
.c360						nt_recurse:
>c360		07 0b				        .byte 7, CO+IM+NN
>c362		6f c3 f2 8e 2e 8f		        .word nt_quit, xt_recurse, z_recurse
>c368		72 65 63 75 72 73 65		        .text "recurse"
.c36f						nt_quit:
>c36f		04 00				        .byte 4, 0
>c371		7b c3 60 80 b2 80		        .word nt_begin, xt_quit, z_quit
>c377		71 75 69 74			        .text "quit"
.c37b						nt_begin:
>c37b		05 03				        .byte 5, CO+IM
>c37d		88 c3 0f 89 19 89		        .word nt_again, xt_begin, z_begin
>c383		62 65 67 69 6e			        .text "begin"
.c388						nt_again:
>c388		05 03				        .byte 5, CO+IM
>c38a		95 c3 4a 82 50 82		        .word nt_state, xt_again, z_again
>c390		61 67 61 69 6e			        .text "again"
.c395						nt_state:
>c395		05 00				        .byte 5, 0
>c397		a2 c3 22 92 2c 92		        .word nt_evaluate, xt_state, z_state
>c39d		73 74 61 74 65			        .text "state"
.c3a2						nt_evaluate:
>c3a2		08 00				        .byte 8, 0
>c3a4		b2 c3 a6 88 f9 88		        .word nt_base, xt_evaluate, z_evaluate
>c3aa		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c3b2						nt_base:
>c3b2		04 00				        .byte 4, 0
>c3b4		be c3 26 83 2e 83		        .word nt_digit_question, xt_base, z_base
>c3ba		62 61 73 65			        .text "base"
.c3be						nt_digit_question:
>c3be		06 00				        .byte 6, 0
>c3c0		cc c3 26 9b 5a 9b		        .word nt_number, xt_digit_question, z_digit_question
>c3c6		64 69 67 69 74 3f		        .text "digit?"
.c3cc						nt_number:
>c3cc		06 00				        .byte 6, 0
>c3ce		da c3 39 9d 32 9e		        .word nt_to_number, xt_number, z_number
>c3d4		6e 75 6d 62 65 72		        .text "number"
.c3da						nt_to_number:
>c3da		07 00				        .byte 7, 0
>c3dc		e9 c3 e1 92 80 93		        .word nt_hex, xt_to_number, z_to_number
>c3e2		3e 6e 75 6d 62 65 72		        .text ">number"
.c3e9						nt_hex:
>c3e9		03 00				        .byte 3, 0
>c3eb		f4 c3 1a 89 20 89		        .word nt_decimal, xt_hex, z_hex
>c3f1		68 65 78			        .text "hex"
.c3f4						nt_decimal:
>c3f4		07 00				        .byte 7, 0
>c3f6		03 c4 0d 85 13 85		        .word nt_count, xt_decimal, z_decimal
>c3fc		64 65 63 69 6d 61 6c		        .text "decimal"
.c403						nt_count:
>c403		05 00				        .byte 5, 0
>c405		10 c4 03 84 16 84		        .word nt_m_star, xt_count, z_count
>c40b		63 6f 75 6e 74			        .text "count"
.c410						nt_m_star:
>c410		02 00				        .byte 2, 0
>c412		1a c4 27 8b 41 8b		        .word nt_um_star, xt_m_star, z_m_star
>c418		6d 2a				        .text "m*"
.c41a						nt_um_star:
>c41a		03 00				        .byte 3, 0
>c41c		25 c4 a0 95 e5 95		        .word nt_star, xt_um_star, z_um_star
>c422		75 6d 2a			        .text "um*"
.c425						nt_star:
>c425		01 00				        .byte 1, 0
>c427		2e c4 fd 91 05 92		        .word nt_um_slash_mod, xt_star, z_star
>c42d		2a				        .text "*"
.c42e						nt_um_slash_mod:
>c42e		06 00				        .byte 6, 0
>c430		3c c4 5e 95 9f 95		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c436		75 6d 2f 6d 6f 64		        .text "um/mod"
.c43c						nt_sm_slash_rem:
>c43c		06 00				        .byte 6, 0
>c43e		4a c4 94 91 bc 91		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c444		73 6d 2f 72 65 6d		        .text "sm/rem"
.c44a						nt_fm_slash_mod:
>c44a		06 00				        .byte 6, 0
>c44c		58 c4 69 88 9f 88		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c452		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c458						nt_slash:
>c458		01 00				        .byte 1, 0
>c45a		61 c4 72 91 93 91		        .word nt_slash_mod, xt_slash, z_slash
>c460		2f				        .text "/"
.c461						nt_slash_mod:
>c461		04 00				        .byte 4, 0
>c463		6d c4 79 91 93 91		        .word nt_mod, xt_slash_mod, z_slash_mod
>c469		2f 6d 6f 64			        .text "/mod"
.c46d						nt_mod:
>c46d		03 00				        .byte 3, 0
>c46f		78 c4 f3 8b fb 8b		        .word nt_star_slash_mod, xt_mod, z_mod
>c475		6d 6f 64			        .text "mod"
.c478						nt_star_slash_mod:
>c478		05 00				        .byte 5, 0
>c47a		85 c4 12 92 21 92		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c480		2a 2f 6d 6f 64			        .text "*/mod"
.c485						nt_star_slash:
>c485		02 00				        .byte 2, 0
>c487		8f c4 06 92 11 92		        .word nt_backslash, xt_star_slash, z_star_slash
>c48d		2a 2f				        .text "*/"
.c48f						nt_backslash:
>c48f		01 02				        .byte 1, IM
>c491		98 c4 fb 82 25 83		        .word nt_move, xt_backslash, z_backslash
>c497		5c				        .byte '\'
.c498						nt_move:
>c498		04 08				        .byte 4, NN
>c49a		a4 c4 fc 8b 1d 8c		        .word nt_cmove_up, xt_move, z_move
>c4a0		6d 6f 76 65			        .text "move"
.c4a4						nt_cmove_up:
>c4a4		06 00				        .byte 6, 0
>c4a6		b2 c4 aa a0 e4 a0		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c4ac		63 6d 6f 76 65 3e		        .text "cmove>"
.c4b2						nt_cmove:
>c4b2		05 00				        .byte 5, 0
>c4b4		bf c4 6f a0 a9 a0		        .word nt_pad, xt_cmove, z_cmove
>c4ba		63 6d 6f 76 65			        .text "cmove"
.c4bf						nt_pad:
>c4bf		03 00				        .byte 3, 0
>c4c1		ca c4 0e 8d 1d 8d		        .word nt_cleave, xt_pad, z_pad
>c4c7		70 61 64			        .text "pad"
.c4ca						nt_cleave:
>c4ca		06 00				        .byte 6, 0
>c4cc		d8 c4 d9 9a 25 9b		        .word nt_hexstore, xt_cleave, z_cleave
>c4d2		63 6c 65 61 76 65		        .text "cleave"
.c4d8						nt_hexstore:
>c4d8		08 00				        .byte 8, 0
>c4da		e8 c4 dc 9b 2e 9c		        .word nt_within, xt_hexstore, z_hexstore
>c4e0		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c4e8						nt_within:
>c4e8		06 00				        .byte 6, 0
>c4ea		f6 c4 23 96 38 96		        .word nt_to_in, xt_within, z_within
>c4f0		77 69 74 68 69 6e		        .text "within"
.c4f6						nt_to_in:
>c4f6		03 00				        .byte 3, 0
>c4f8		01 c5 d6 92 e0 92		        .word nt_less_number_sign, xt_to_in, z_to_in
>c4fe		3e 69 6e			        .text ">in"
.c501						nt_less_number_sign:
>c501		02 00				        .byte 2, 0
>c503		0b c5 d5 89 e2 89		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c509		3c 23				        .text "<#"
.c50b						nt_number_sign:
>c50b		01 00				        .byte 1, 0
>c50d		14 c5 5b 8c 8b 8c		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c513		23				        .text "#"
.c514						nt_number_sign_s:
>c514		02 00				        .byte 2, 0
>c516		1e c5 ae 8c be 8c		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c51c		23 73				        .text "#s"
.c51e						nt_number_sign_greater:
>c51e		02 00				        .byte 2, 0
>c520		28 c5 8c 8c ad 8c		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c526		23 3e				        .text "#>"
.c528						nt_hold:
>c528		04 00				        .byte 4, 0
>c52a		34 c5 21 89 32 89		        .word nt_sign, xt_hold, z_hold
>c530		68 6f 6c 64			        .text "hold"
.c534						nt_sign:
>c534		04 00				        .byte 4, 0
>c536		40 c5 5d 91 71 91		        .word nt_output, xt_sign, z_sign
>c53c		73 69 67 6e			        .text "sign"
.c540						nt_output:
>c540		06 00				        .byte 6, 0
>c542		4e c5 3c 9e 46 9e		        .word nt_input, xt_output, z_output
>c548		6f 75 74 70 75 74		        .text "output"
.c54e						nt_input:
>c54e		05 00				        .byte 5, 0
>c550		5b c5 2f 9c 39 9c		        .word nt_havekey, xt_input, z_input
>c556		69 6e 70 75 74			        .text "input"
.c55b						nt_havekey:
>c55b		07 00				        .byte 7, 0
>c55d		6a c5 d1 9b db 9b		        .word nt_cr, xt_havekey, z_havekey
>c563		68 61 76 65 6b 65 79		        .text "havekey"
.c56a						nt_cr:
>c56a		02 00				        .byte 2, 0
>c56c		74 c5 17 84 1c 84		        .word nt_page, xt_cr, z_cr
>c572		63 72				        .text "cr"
.c574						nt_page:
>c574		04 00				        .byte 4, 0
>c576		80 c5 1e 8d 3b 8d		        .word nt_at_xy, xt_page, z_page
>c57c		70 61 67 65			        .text "page"
.c580						nt_at_xy:
>c580		05 00				        .byte 5, 0
>c582		8d c5 cd 82 fa 82		        .word nt_marker, xt_at_xy, z_at_xy
>c588		61 74 2d 78 79			        .text "at-xy"
.c58d						nt_marker:
>c58d		06 02				        .byte 6, IM
>c58f		9b c5 42 8b 72 8b		        .word nt_words, xt_marker, z_marker
>c595		6d 61 72 6b 65 72		        .text "marker"
.c59b						nt_words:
>c59b		05 00				        .byte 5, 0
>c59d		a8 c5 43 9a 9f 9a		        .word nt_wordsize, xt_words, z_words
>c5a3		77 6f 72 64 73			        .text "words"
.c5a8						nt_wordsize:
>c5a8		08 00				        .byte 8, 0
>c5aa		b8 c5 78 9e 98 9e		        .word nt_aligned, xt_wordsize, z_wordsize
>c5b0		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c5b8						nt_aligned:
>c5b8		07 00				        .byte 7, 0
>c5ba		c7 c5 51 82 51 82		        .word nt_align, xt_aligned, z_aligned   ; same code as ALIGN
>c5c0		61 6c 69 67 6e 65 64		        .text "aligned"
.c5c7						nt_align:
>c5c7		05 00				        .byte 5, 0
>c5c9		d4 c5 51 82 51 82		        .word nt_bell, xt_align, z_align
>c5cf		61 6c 69 67 6e			        .text "align"
.c5d4						nt_bell:
>c5d4		04 00				        .byte 4, 0
>c5d6		e0 c5 ba 9a bf 9a		        .word nt_dump, xt_bell, z_bell
>c5dc		62 65 6c 6c			        .text "bell"
.c5e0						nt_dump:
>c5e0		04 00				        .byte 4, 0
>c5e2		ec c5 e9 98 66 99		        .word nt_dot_s, xt_dump, z_dump
>c5e8		64 75 6d 70			        .text "dump"
.c5ec						nt_dot_s:
>c5ec		02 00				        .byte 2, 0
>c5ee		f6 c5 a5 98 e8 98		        .word +, xt_dot_s, z_dot_s
>c5f4		2e 73				        .text ".s"
.c5f6						+
.c5f6						nt_disasm:
>c5f6		06 00				        .byte 6, 0
>c5f8		04 c6 ad a2 b3 a2		        .word +, xt_disasm, z_disasm
>c5fe		64 69 73 61 73 6d		        .text "disasm"
.c604						+
.c604						nt_compare:
>c604		07 00				        .byte 7, 0
>c606		13 c6 e5 a0 49 a1		        .word nt_search, xt_compare, z_compare
>c60c		63 6f 6d 70 61 72 65		        .text "compare"
.c613						nt_search:
>c613		06 08				        .byte 6, NN
>c615		21 c6 a0 a1 3e a2		        .word +, xt_search, z_search
>c61b		73 65 61 72 63 68		        .text "search"
.c621						+
.c621						nt_environment_q:
>c621		0c 00				        .byte 12, 0
>c623		35 c6 d6 86 47 87		        .word +, xt_environment_q, z_environment_q
>c629		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c631		65 6e 74 3f
.c635						+
.c635						nt_find:
>c635		04 00				        .byte 4, 0
>c637		41 c6 21 88 68 88		        .word nt_word, xt_find, z_find
>c63d		66 69 6e 64			        .text "find"
.c641						nt_word:
>c641		04 00				        .byte 4, 0
>c643		4d c6 39 96 7c 96		        .word nt_paren, xt_word, z_word
>c649		77 6f 72 64			        .text "word"
.c64d						nt_paren:
>c64d		01 02				        .byte 1, IM
>c64f		56 c6 3c 8d 4b 8d		        .word nt_dot_paren, xt_paren, z_paren
>c655		28				        .text "("
.c656						nt_dot_paren:
>c656		02 02				        .byte 2, IM
>c658		60 c6 40 86 4e 86		        .word nt_if, xt_dot_paren, z_dot_paren
>c65e		2e 28				        .text ".("
.c660						nt_if:
>c660		02 0b				        .byte 2, IM+CO+NN
>c662		6a c6 48 89 4b 89		        .word nt_then, xt_if, z_if
>c668		69 66				        .text "if"
.c66a						nt_then:
>c66a		04 0b				        .byte 4, IM+CO+NN
>c66c		76 c6 a7 86 b3 86		        .word nt_else, xt_then, z_then
>c672		74 68 65 6e			        .text "then"
.c676						nt_else:
>c676		04 0b				        .byte 4, IM+CO+NN
>c678		82 c6 9c 86 b3 86		        .word nt_repeat, xt_else, z_else
>c67e		65 6c 73 65			        .text "else"
.c682						nt_repeat:
>c682		06 0b				        .byte 6, IM+CO+NN
>c684		90 c6 71 8f 7a 8f		        .word nt_until, xt_repeat, z_repeat
>c68a		72 65 70 65 61 74		        .text "repeat"
.c690						nt_until:
>c690		05 0b				        .byte 5, IM+CO+NN
>c692		9d c6 f6 95 fc 95		        .word nt_while, xt_until, z_until
>c698		75 6e 74 69 6c			        .text "until"
.c69d						nt_while:
>c69d		05 0b				        .byte 5, IM+CO+NN
>c69f		aa c6 19 96 22 96		        .word nt_case, xt_while, z_while
>c6a5		77 68 69 6c 65			        .text "while"
.c6aa						nt_case:
>c6aa		04 0b				        .byte 4, IM+CO+NN
>c6ac		b6 c6 99 9e 9f 9e		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c6b2		63 61 73 65			        .text "case"
.c6b6						nt_of:
>c6b6		02 0b				        .byte 2, IM+CO+NN
>c6b8		c0 c6 bf 8c d7 8c		        .word nt_endof, xt_of, z_of
>c6be		6f 66				        .text "of"
.c6c0						nt_endof:
>c6c0		05 0b				        .byte 5, IM+CO+NN
>c6c2		cd c6 9c 86 b3 86		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c6c8		65 6e 64 6f 66			        .text "endof"
.c6cd						nt_endcase:
>c6cd		07 0b				        .byte 7, IM+CO+NN
>c6cf		dc c6 be 86 d5 86		        .word nt_defer_fetch, xt_endcase, z_endcase
>c6d5		65 6e 64 63 61 73 65		        .text "endcase"
.c6dc						nt_defer_fetch:
>c6dc		06 00				        .byte 6, 0
>c6de		ea c6 2c 85 35 85		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c6e4		64 65 66 65 72 40		        .text "defer@"
.c6ea						nt_defer_store:
>c6ea		06 00				        .byte 6, 0
>c6ec		f8 c6 36 85 3f 85		        .word nt_is, xt_defer_store, z_defer_store
>c6f2		64 65 66 65 72 21		        .text "defer!"
.c6f8						nt_is:
>c6f8		02 02				        .byte 2, IM
>c6fa		02 c7 68 89 80 89		        .word nt_action_of, xt_is, z_is
>c700		69 73				        .text "is"
.c702						nt_action_of:
>c702		09 02				        .byte 9, IM
>c704		13 c7 31 82 49 82		        .word nt_useraddr, xt_action_of, z_action_of
>c70a		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c712		66
.c713						nt_useraddr:
>c713		08 00				        .byte 8, 0
>c715		23 c7 6d 9e 77 9e		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c71b		75 73 65 72 61 64 64 72		        .text "useraddr"
.c723						nt_buffer_colon:
>c723		07 00				        .byte 7, 0
>c725		32 c7 46 83 4c 83		        .word +, xt_buffer_colon, z_buffer_colon
>c72b		62 75 66 66 65 72 3a		        .text "buffer:"
.c732						+
.c732						nt_buffstatus:
>c732		0a 00				        .byte 10, 0
>c734		44 c7 37 b0 3c b0		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c73a		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c742		75 73
.c744						nt_buffblocknum:
>c744		0c 00				        .byte 12, 0
>c746		58 c7 01 b0 06 b0		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c74c		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c754		6b 6e 75 6d
.c758						nt_blkbuffer:
>c758		09 00				        .byte 9, 0
>c75a		69 c7 51 ae 5e ae		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c760		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c768		72
.c769						nt_scr:
>c769		03 08				        .byte 3, NN
>c76b		74 c7 b9 b0 be b0		        .word nt_blk, xt_scr, z_scr
>c771		73 63 72			        .text "scr"
.c774						nt_blk:
>c774		03 08				        .byte 3, NN
>c776		7f c7 4c ae 51 ae		        .word nt_block_write, xt_blk, z_blk
>c77c		62 6c 6b			        .text "blk"
.c77f						nt_block_write:
>c77f		0b 08				        .byte 11, NN
>c781		92 c7 ee af fc af		        .word nt_block_write_vector, xt_block_write, z_block_write
>c787		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c78f		69 74 65
.c792						nt_block_write_vector:
>c792		12 08				        .byte 18, NN
>c794		ac c7 fc af 01 b0		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c79a		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c7a2		69 74 65 2d 76 65 63 74 6f 72
.c7ac						nt_block_read:
>c7ac		0a 08				        .byte 10, NN
>c7ae		be c7 d6 af e4 af		        .word nt_block_read_vector, xt_block_read, z_block_read
>c7b4		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c7bc		61 64
.c7be						nt_block_read_vector:
>c7be		11 08				        .byte 17, NN
>c7c0		d7 c7 e4 af e9 af		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c7c6		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c7ce		61 64 2d 76 65 63 74 6f 72
.c7d7						nt_save_buffers:
>c7d7		0c 00				        .byte 12, 0
>c7d9		eb c7 9e b0 b8 b0		        .word nt_block, xt_save_buffers, z_save_buffers
>c7df		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c7e7		66 65 72 73
.c7eb						nt_block:
>c7eb		05 00				        .byte 5, 0
>c7ed		f8 c7 5f ae b1 ae		        .word nt_update, xt_block, z_block
>c7f3		62 6c 6f 63 6b			        .text "block"
.c7f8						nt_update:
>c7f8		06 00				        .byte 6, 0
>c7fa		06 c8 03 b1 0b b1		        .word nt_buffer, xt_update, z_update
>c800		75 70 64 61 74 65		        .text "update"
.c806						nt_buffer:
>c806		06 00				        .byte 6, 0
>c808		14 c8 06 b0 36 b0		        .word nt_empty_buffers, xt_buffer, z_buffer
>c80e		62 75 66 66 65 72		        .text "buffer"
.c814						nt_empty_buffers:
>c814		0d 00				        .byte 13, 0
>c816		29 c8 3c b0 42 b0		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c81c		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c824		66 66 65 72 73
.c829						nt_flush:
>c829		05 00				        .byte 5, 0
>c82b		36 c8 43 b0 4c b0		        .word nt_load, xt_flush, z_flush
>c831		66 6c 75 73 68			        .text "flush"
.c836						nt_load:
>c836		04 00				        .byte 4, 0
>c838		42 c8 5a b0 9d b0		        .word nt_thru, xt_load, z_load
>c83e		6c 6f 61 64			        .text "load"
.c842						nt_thru:
>c842		04 00				        .byte 4, 0
>c844		4e c8 be b0 02 b1		        .word +, xt_thru, z_thru
>c84a		74 68 72 75			        .text "thru"
.c84e						+
.c84e						nt_list:
>c84e		04 00				        .byte 4, 0
>c850		5a c8 4d b0 59 b0		        .word +, xt_list, z_list
>c856		6c 69 73 74			        .text "list"
.c85a						+
.c85a						nt_block_ramdrive_init:
>c85a		13 00				        .byte 19, 0
>c85c		75 c8 b2 ae d5 af		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c862		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c86a		6d 64 72 69 76 65 2d 69 6e 69 74
.c875						+
.c875						nt_definitions:
>c875		0b 00				        .byte 11, 0
>c877		88 c8 3d b2 45 b2		        .word nt_wordlist, xt_definitions, z_definitions
>c87d		64 65 66 69 6e 69 74 69		        .text "definitions"
>c885		6f 6e 73
.c888						nt_wordlist:
>c888		08 00				        .byte 8, 0
>c88a		98 c8 a8 b3 be b3		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c890		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c898						nt_search_wordlist:
>c898		0f 00				        .byte 15, 0
>c89a		af c8 e1 b2 54 b3		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c8a0		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c8a8		6f 72 64 6c 69 73 74
.c8af						nt_set_current:
>c8af		0b 00				        .byte 11, 0
>c8b1		c2 c8 55 b3 60 b3		        .word nt_get_current, xt_set_current, z_set_current
>c8b7		73 65 74 2d 63 75 72 72		        .text "set-current"
>c8bf		65 6e 74
.c8c2						nt_get_current:
>c8c2		0b 00				        .byte 11, 0
>c8c4		d5 c8 4d b2 57 b2		        .word nt_set_order, xt_get_current, z_get_current
>c8ca		67 65 74 2d 63 75 72 72		        .text "get-current"
>c8d2		65 6e 74
.c8d5						nt_set_order:
>c8d5		09 00				        .byte 9, 0
>c8d7		e6 c8 61 b3 94 b3		        .word nt_get_order, xt_set_order, z_set_order
>c8dd		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c8e5		72
.c8e6						nt_get_order:
>c8e6		09 00				        .byte 9, 0
>c8e8		f7 c8 58 b2 80 b2		        .word nt_root_wordlist, xt_get_order, z_get_order
>c8ee		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c8f6		72
.c8f7						nt_root_wordlist:
>c8f7		0d 00				        .byte 13, 0
>c8f9		0c c9 d8 b2 e0 b2		        .word +, xt_root_wordlist, z_root_wordlist
>c8ff		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c907		64 6c 69 73 74
.c90c						+
.c90c						nt_assembler_wordlist:
>c90c		12 00				        .byte 18, 0
>c90e		26 c9 64 9e 6c 9e		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c914		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c91c		72 2d 77 6f 72 64 6c 69 73 74
.c926						+
.c926						nt_editor_wordlist:
>c926		0f 00				        .byte 15, 0
>c928		3d c9 33 9e 3b 9e		        .word +, xt_editor_wordlist, z_editor_wordlist
>c92e		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c936		6f 72 64 6c 69 73 74
.c93d						+
.c93d						nt_forth_wordlist:
>c93d		0e 00				        .byte 14, 0
>c93f		53 c9 99 9e 9f 9e		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c945		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c94d		72 64 6c 69 73 74
.c953						nt_only:
>c953		04 00				        .byte 4, 0
>c955		5f c9 81 b2 87 b2		        .word nt_also, xt_only, z_only
>c95b		6f 6e 6c 79			        .text "only"
.c95f						nt_also:
>c95f		04 00				        .byte 4, 0
>c961		6b c9 2d b2 3c b2		        .word nt_previous, xt_also, z_also
>c967		61 6c 73 6f			        .text "also"
.c96b						nt_previous:
>c96b		08 00				        .byte 8, 0
>c96d		7b c9 cb b2 d7 b2		        .word nt_to_order, xt_previous, z_previous
>c973		70 72 65 76 69 6f 75 73		        .text "previous"
.c97b						nt_to_order:
>c97b		06 00				        .byte 6, 0
>c97d		89 c9 95 b3 a7 b3		        .word nt_order, xt_to_order, z_to_order
>c983		3e 6f 72 64 65 72		        .text ">order"
.c989						nt_order:
>c989		05 00				        .byte 5, 0
>c98b		96 c9 88 b2 b2 b2		        .word nt_forth, xt_order, z_order
>c991		6f 72 64 65 72			        .text "order"
.c996						nt_forth:
>c996		05 00				        .byte 5, 0
>c998		a3 c9 46 b2 4c b2		        .word +, xt_forth, z_forth
>c99e		66 6f 72 74 68			        .text "forth"
.c9a3						+
>c9a3		03 08				nt_see: .byte 3, NN
>c9a5		ae c9 6e 99 42 9a		        .word +, xt_see, z_see
>c9ab		73 65 65			        .text "see"
.c9ae						+
.c9ae						nt_ed:
>c9ae		03 08				        .byte 3, NN
>c9b0		b9 c9 59 a8 5c a8		        .word +, xt_ed, z_ed
>c9b6		65 64 3a			        .text "ed:"
.c9b9						+
.c9b9						nt_cold:
>c9b9		04 00				        .byte 4, 0
>c9bb		c5 c9 00 80 b2 80		        .word nt_bye, xt_cold, z_cold
>c9c1		63 6f 6c 64			        .text "cold"
.c9c5						nt_bye:
>c9c5		03				        .byte 3         ; length of word strings
>c9c6		00				        .byte 0         ; status byte
>c9c7		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>c9c9		a2 98				        .word xt_bye    ; start of code block (xt of this word)
>c9cb		a5 98				        .word z_bye     ; end of code (RTS)
>c9cd		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.c9d0						root_dictionary_start:
.c9d0						nt_root_set_order:
>c9d0		09 00				        .byte 9, 0
>c9d2		e1 c9 61 b3 94 b3		        .word nt_root_forth, xt_set_order, z_set_order
>c9d8		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c9e0		72
.c9e1						nt_root_forth:
>c9e1		05 00				        .byte 5, 0
>c9e3		ee c9 46 b2 4c b2		        .word nt_root_forth_wordlist, xt_forth, z_forth
>c9e9		66 6f 72 74 68			        .text "forth"
.c9ee						nt_root_forth_wordlist:
>c9ee		0e 00				        .byte 14, 0
>c9f0		04 ca 99 9e 9f 9e		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>c9f6		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9fe		72 64 6c 69 73 74
.ca04						nt_root_words:
>ca04		05 00				        .byte 5, 0
>ca06		00 00 43 9a 9f 9a		        .word 0000, xt_words, z_words
>ca0c		77 6f 72 64 73			        .text "words"
.ca11						editor_dictionary_start:
.ca11						nt_editor_o:
>ca11		01 00				        .byte 1, 0
>ca13		1a ca e7 b1 2c b2		        .word nt_editor_line, xt_editor_o, z_editor_o
>ca19		6f				        .text "o"
.ca1a						nt_editor_line:
>ca1a		04 00				        .byte 4, 0
>ca1c		26 ca ce b1 e6 b1		        .word nt_editor_l, xt_editor_line, z_editor_line
>ca22		6c 69 6e 65			        .text "line"
.ca26						nt_editor_l:
>ca26		01 00				        .byte 1, 0
>ca28		2f ca 58 b1 cd b1		        .word nt_editor_el, xt_editor_l, z_editor_l
>ca2e		6c				        .text "l"
.ca2f						nt_editor_el:
>ca2f		02 00				        .byte 2, 0
>ca31		39 ca 46 b1 57 b1		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>ca37		65 6c				        .text "el"
.ca39						nt_editor_erase_screen:
>ca39		0c 00				        .byte 12, 0
>ca3b		4d ca 34 b1 45 b1		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>ca41		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>ca49		72 65 65 6e
.ca4d						nt_editor_enter_screen:
>ca4d		0c 00				        .byte 12, 0
>ca4f		00 00 18 b1 33 b1		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>ca55		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>ca5d		72 65 65 6e
.ca61						assembler_dictionary_start:
.ca61						nt_asm_adc_h:
>ca61		05 0a						.byte 5, IM+NN
>ca63		6e ca				                .word nt_asm_adc_x
>ca65		ae a4 b3 a4					.word xt_asm_adc_h, z_asm_adc_h
>ca69		61 64 63 2e 23					.text "adc.#"
.ca6e						nt_asm_adc_x:
>ca6e		05 0a						.byte 5, IM+NN
>ca70		7b ca				                .word nt_asm_adc_y
>ca72		b3 a4 b8 a4					.word xt_asm_adc_x, z_asm_adc_x
>ca76		61 64 63 2e 78					.text "adc.x"
.ca7b						nt_asm_adc_y:
>ca7b		05 0a						.byte 5, IM+NN
>ca7d		88 ca				                .word nt_asm_adc_z
>ca7f		b8 a4 bd a4					.word xt_asm_adc_y, z_asm_adc_y
>ca83		61 64 63 2e 79					.text "adc.y"
.ca88						nt_asm_adc_z:
>ca88		05 0a						.byte 5, IM+NN
>ca8a		95 ca				                .word nt_asm_adc_zi
>ca8c		bd a4 c2 a4					.word xt_asm_adc_z, z_asm_adc_z
>ca90		61 64 63 2e 7a					.text "adc.z"
.ca95						nt_asm_adc_zi:
>ca95		06 0a						.byte 6, IM+NN
>ca97		a3 ca				                .word nt_asm_adc_ziy
>ca99		c2 a4 c7 a4					.word xt_asm_adc_zi, z_asm_adc_zi
>ca9d		61 64 63 2e 7a 69				.text "adc.zi"
.caa3						nt_asm_adc_ziy:
>caa3		07 0a						.byte 7, IM+NN
>caa5		b2 ca				                .word nt_asm_adc_zx
>caa7		c7 a4 cc a4					.word xt_asm_adc_ziy, z_asm_adc_ziy
>caab		61 64 63 2e 7a 69 79				.text "adc.ziy"
.cab2						nt_asm_adc_zx:
>cab2		06 0a						.byte 6, IM+NN
>cab4		c0 ca				                .word nt_asm_adc_zxi
>cab6		cc a4 d1 a4					.word xt_asm_adc_zx, z_asm_adc_zx
>caba		61 64 63 2e 7a 78				.text "adc.zx"
.cac0						nt_asm_adc_zxi:
>cac0		07 0a						.byte 7, IM+NN
>cac2		cf ca				                .word nt_asm_and
>cac4		d1 a4 d6 a4					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cac8		61 64 63 2e 7a 78 69				.text "adc.zxi"
.cacf						nt_asm_and:
>cacf		04 0a						.byte 4, IM+NN
>cad1		db ca				                .word nt_asm_and_h
>cad3		d6 a4 db a4					.word xt_asm_and, z_asm_and
>cad7		61 6e 64 2e					.text "and."
.cadb						nt_asm_and_h:
>cadb		05 0a						.byte 5, IM+NN
>cadd		e8 ca				                .word nt_asm_and_x
>cadf		db a4 e0 a4					.word xt_asm_and_h, z_asm_and_h
>cae3		61 6e 64 2e 23					.text "and.#"
.cae8						nt_asm_and_x:
>cae8		05 0a						.byte 5, IM+NN
>caea		f5 ca				                .word nt_asm_and_y
>caec		e0 a4 e5 a4					.word xt_asm_and_x, z_asm_and_x
>caf0		61 6e 64 2e 78					.text "and.x"
.caf5						nt_asm_and_y:
>caf5		05 0a						.byte 5, IM+NN
>caf7		02 cb				                .word nt_asm_and_z
>caf9		e5 a4 ea a4					.word xt_asm_and_y, z_asm_and_y
>cafd		61 6e 64 2e 79					.text "and.y"
.cb02						nt_asm_and_z:
>cb02		05 0a						.byte 5, IM+NN
>cb04		0f cb				                .word nt_asm_and_zi
>cb06		ea a4 ef a4					.word xt_asm_and_z, z_asm_and_z
>cb0a		61 6e 64 2e 7a					.text "and.z"
.cb0f						nt_asm_and_zi:
>cb0f		06 0a						.byte 6, IM+NN
>cb11		1d cb				                .word nt_asm_and_ziy
>cb13		ef a4 f4 a4					.word xt_asm_and_zi, z_asm_and_zi
>cb17		61 6e 64 2e 7a 69				.text "and.zi"
.cb1d						nt_asm_and_ziy:
>cb1d		07 0a						.byte 7, IM+NN
>cb1f		2c cb				                .word nt_asm_and_zx
>cb21		f4 a4 f9 a4					.word xt_asm_and_ziy, z_asm_and_ziy
>cb25		61 6e 64 2e 7a 69 79				.text "and.ziy"
.cb2c						nt_asm_and_zx:
>cb2c		06 0a						.byte 6, IM+NN
>cb2e		3a cb				                .word nt_asm_and_zxi
>cb30		f9 a4 fe a4					.word xt_asm_and_zx, z_asm_and_zx
>cb34		61 6e 64 2e 7a 78				.text "and.zx"
.cb3a						nt_asm_and_zxi:
>cb3a		07 0a						.byte 7, IM+NN
>cb3c		49 cb				                .word nt_asm_asl
>cb3e		fe a4 03 a5					.word xt_asm_and_zxi, z_asm_and_zxi
>cb42		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cb49						nt_asm_asl:
>cb49		03 0a						.byte 3, IM+NN
>cb4b		54 cb				                .word nt_asm_asl_a
>cb4d		03 a5 08 a5					.word xt_asm_asl, z_asm_asl
>cb51		61 73 6c					.text "asl"
.cb54						nt_asm_asl_a:
>cb54		05 0a						.byte 5, IM+NN
>cb56		61 cb				                .word nt_asm_asl_x
>cb58		08 a5 0d a5					.word xt_asm_asl_a, z_asm_asl_a
>cb5c		61 73 6c 2e 61					.text "asl.a"
.cb61						nt_asm_asl_x:
>cb61		05 0a						.byte 5, IM+NN
>cb63		6e cb				                .word nt_asm_asl_z
>cb65		0d a5 12 a5					.word xt_asm_asl_x, z_asm_asl_x
>cb69		61 73 6c 2e 78					.text "asl.x"
.cb6e						nt_asm_asl_z:
>cb6e		05 0a						.byte 5, IM+NN
>cb70		7b cb				                .word nt_asm_asl_zx
>cb72		12 a5 17 a5					.word xt_asm_asl_z, z_asm_asl_z
>cb76		61 73 6c 2e 7a					.text "asl.z"
.cb7b						nt_asm_asl_zx:
>cb7b		06 0a						.byte 6, IM+NN
>cb7d		89 cb				                .word nt_asm_bcc
>cb7f		17 a5 1c a5					.word xt_asm_asl_zx, z_asm_asl_zx
>cb83		61 73 6c 2e 7a 78				.text "asl.zx"
.cb89						nt_asm_bcc:
>cb89		03 0a						.byte 3, IM+NN
>cb8b		94 cb				                .word nt_asm_bcs
>cb8d		1c a5 21 a5					.word xt_asm_bcc, z_asm_bcc
>cb91		62 63 63					.text "bcc"
.cb94						nt_asm_bcs:
>cb94		03 0a						.byte 3, IM+NN
>cb96		9f cb				                .word nt_asm_beq
>cb98		21 a5 28 a5					.word xt_asm_bcs, z_asm_bcs
>cb9c		62 63 73					.text "bcs"
.cb9f						nt_asm_beq:
>cb9f		03 0a						.byte 3, IM+NN
>cba1		aa cb				                .word nt_asm_bit
>cba3		28 a5 2d a5					.word xt_asm_beq, z_asm_beq
>cba7		62 65 71					.text "beq"
.cbaa						nt_asm_bit:
>cbaa		03 0a						.byte 3, IM+NN
>cbac		b5 cb				                .word nt_asm_bit_h
>cbae		2d a5 32 a5					.word xt_asm_bit, z_asm_bit
>cbb2		62 69 74					.text "bit"
.cbb5						nt_asm_bit_h:
>cbb5		05 0a						.byte 5, IM+NN
>cbb7		c2 cb				                .word nt_asm_bit_x
>cbb9		32 a5 37 a5					.word xt_asm_bit_h, z_asm_bit_h
>cbbd		62 69 74 2e 23					.text "bit.#"
.cbc2						nt_asm_bit_x:
>cbc2		05 0a						.byte 5, IM+NN
>cbc4		cf cb				                .word nt_asm_bit_z
>cbc6		37 a5 3c a5					.word xt_asm_bit_x, z_asm_bit_x
>cbca		62 69 74 2e 78					.text "bit.x"
.cbcf						nt_asm_bit_z:
>cbcf		05 0a						.byte 5, IM+NN
>cbd1		dc cb				                .word nt_asm_bit_zx
>cbd3		3c a5 41 a5					.word xt_asm_bit_z, z_asm_bit_z
>cbd7		62 69 74 2e 7a					.text "bit.z"
.cbdc						nt_asm_bit_zx:
>cbdc		06 0a						.byte 6, IM+NN
>cbde		ea cb				                .word nt_asm_bmi
>cbe0		41 a5 46 a5					.word xt_asm_bit_zx, z_asm_bit_zx
>cbe4		62 69 74 2e 7a 78				.text "bit.zx"
.cbea						nt_asm_bmi:
>cbea		03 0a						.byte 3, IM+NN
>cbec		f5 cb				                .word nt_asm_bne
>cbee		46 a5 4b a5					.word xt_asm_bmi, z_asm_bmi
>cbf2		62 6d 69					.text "bmi"
.cbf5						nt_asm_bne:
>cbf5		03 0a						.byte 3, IM+NN
>cbf7		00 cc				                .word nt_asm_bpl
>cbf9		4b a5 50 a5					.word xt_asm_bne, z_asm_bne
>cbfd		62 6e 65					.text "bne"
.cc00						nt_asm_bpl:
>cc00		03 0a						.byte 3, IM+NN
>cc02		0b cc				                .word nt_asm_bra
>cc04		50 a5 55 a5					.word xt_asm_bpl, z_asm_bpl
>cc08		62 70 6c					.text "bpl"
.cc0b						nt_asm_bra:
>cc0b		03 0a						.byte 3, IM+NN
>cc0d		16 cc				                .word nt_asm_brk
>cc0f		55 a5 5a a5					.word xt_asm_bra, z_asm_bra
>cc13		62 72 61					.text "bra"
.cc16						nt_asm_brk:
>cc16		03 0a						.byte 3, IM+NN
>cc18		21 cc				                .word nt_asm_bvc
>cc1a		5a a5 5f a5					.word xt_asm_brk, z_asm_brk
>cc1e		62 72 6b					.text "brk"
.cc21						nt_asm_bvc:
>cc21		03 0a						.byte 3, IM+NN
>cc23		2c cc				                .word nt_asm_bvs
>cc25		5f a5 64 a5					.word xt_asm_bvc, z_asm_bvc
>cc29		62 76 63					.text "bvc"
.cc2c						nt_asm_bvs:
>cc2c		03 0a						.byte 3, IM+NN
>cc2e		37 cc				                .word nt_asm_clc
>cc30		64 a5 69 a5					.word xt_asm_bvs, z_asm_bvs
>cc34		62 76 73					.text "bvs"
.cc37						nt_asm_clc:
>cc37		03 0a						.byte 3, IM+NN
>cc39		42 cc				                .word nt_asm_cld
>cc3b		69 a5 6e a5					.word xt_asm_clc, z_asm_clc
>cc3f		63 6c 63					.text "clc"
.cc42						nt_asm_cld:
>cc42		03 0a						.byte 3, IM+NN
>cc44		4d cc				                .word nt_asm_cli
>cc46		6e a5 73 a5					.word xt_asm_cld, z_asm_cld
>cc4a		63 6c 64					.text "cld"
.cc4d						nt_asm_cli:
>cc4d		03 0a						.byte 3, IM+NN
>cc4f		58 cc				                .word nt_asm_clv
>cc51		73 a5 78 a5					.word xt_asm_cli, z_asm_cli
>cc55		63 6c 69					.text "cli"
.cc58						nt_asm_clv:
>cc58		03 0a						.byte 3, IM+NN
>cc5a		63 cc				                .word nt_asm_cmp
>cc5c		78 a5 7d a5					.word xt_asm_clv, z_asm_clv
>cc60		63 6c 76					.text "clv"
.cc63						nt_asm_cmp:
>cc63		03 0a						.byte 3, IM+NN
>cc65		6e cc				                .word nt_asm_cmp_h
>cc67		7d a5 82 a5					.word xt_asm_cmp, z_asm_cmp
>cc6b		63 6d 70					.text "cmp"
.cc6e						nt_asm_cmp_h:
>cc6e		05 0a						.byte 5, IM+NN
>cc70		7b cc				                .word nt_asm_cmp_x
>cc72		82 a5 87 a5					.word xt_asm_cmp_h, z_asm_cmp_h
>cc76		63 6d 70 2e 23					.text "cmp.#"
.cc7b						nt_asm_cmp_x:
>cc7b		05 0a						.byte 5, IM+NN
>cc7d		88 cc				                .word nt_asm_cmp_y
>cc7f		87 a5 8c a5					.word xt_asm_cmp_x, z_asm_cmp_x
>cc83		63 6d 70 2e 78					.text "cmp.x"
.cc88						nt_asm_cmp_y:
>cc88		05 0a						.byte 5, IM+NN
>cc8a		95 cc				                .word nt_asm_cmp_z
>cc8c		8c a5 91 a5					.word xt_asm_cmp_y, z_asm_cmp_y
>cc90		63 6d 70 2e 79					.text "cmp.y"
.cc95						nt_asm_cmp_z:
>cc95		05 0a						.byte 5, IM+NN
>cc97		a2 cc				                .word nt_asm_cmp_zi
>cc99		91 a5 96 a5					.word xt_asm_cmp_z, z_asm_cmp_z
>cc9d		63 6d 70 2e 7a					.text "cmp.z"
.cca2						nt_asm_cmp_zi:
>cca2		06 0a						.byte 6, IM+NN
>cca4		b0 cc				                .word nt_asm_cmp_ziy
>cca6		96 a5 9b a5					.word xt_asm_cmp_zi, z_asm_cmp_zi
>ccaa		63 6d 70 2e 7a 69				.text "cmp.zi"
.ccb0						nt_asm_cmp_ziy:
>ccb0		07 0a						.byte 7, IM+NN
>ccb2		bf cc				                .word nt_asm_cmp_zx
>ccb4		9b a5 a0 a5					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>ccb8		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.ccbf						nt_asm_cmp_zx:
>ccbf		06 0a						.byte 6, IM+NN
>ccc1		cd cc				                .word nt_asm_cmp_zxi
>ccc3		a0 a5 a5 a5					.word xt_asm_cmp_zx, z_asm_cmp_zx
>ccc7		63 6d 70 2e 7a 78				.text "cmp.zx"
.cccd						nt_asm_cmp_zxi:
>cccd		07 0a						.byte 7, IM+NN
>cccf		dc cc				                .word nt_asm_cpx
>ccd1		a5 a5 aa a5					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>ccd5		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.ccdc						nt_asm_cpx:
>ccdc		03 0a						.byte 3, IM+NN
>ccde		e7 cc				                .word nt_asm_cpx_h
>cce0		aa a5 af a5					.word xt_asm_cpx, z_asm_cpx
>cce4		63 70 78					.text "cpx"
.cce7						nt_asm_cpx_h:
>cce7		05 0a						.byte 5, IM+NN
>cce9		f4 cc				                .word nt_asm_cpx_z
>cceb		af a5 b4 a5					.word xt_asm_cpx_h, z_asm_cpx_h
>ccef		63 70 78 2e 23					.text "cpx.#"
.ccf4						nt_asm_cpx_z:
>ccf4		05 0a						.byte 5, IM+NN
>ccf6		01 cd				                .word nt_asm_cpy
>ccf8		b4 a5 b9 a5					.word xt_asm_cpx_z, z_asm_cpx_z
>ccfc		63 70 78 2e 7a					.text "cpx.z"
.cd01						nt_asm_cpy:
>cd01		03 0a						.byte 3, IM+NN
>cd03		0c cd				                .word nt_asm_cpy_h
>cd05		b9 a5 c0 a5					.word xt_asm_cpy, z_asm_cpy
>cd09		63 70 79					.text "cpy"
.cd0c						nt_asm_cpy_h:
>cd0c		05 0a						.byte 5, IM+NN
>cd0e		19 cd				                .word nt_asm_cpy_z
>cd10		c0 a5 c5 a5					.word xt_asm_cpy_h, z_asm_cpy_h
>cd14		63 70 79 2e 23					.text "cpy.#"
.cd19						nt_asm_cpy_z:
>cd19		05 0a						.byte 5, IM+NN
>cd1b		26 cd				                .word nt_asm_dec
>cd1d		c5 a5 ca a5					.word xt_asm_cpy_z, z_asm_cpy_z
>cd21		63 70 79 2e 7a					.text "cpy.z"
.cd26						nt_asm_dec:
>cd26		03 0a						.byte 3, IM+NN
>cd28		31 cd				                .word nt_asm_dec_a
>cd2a		ca a5 cf a5					.word xt_asm_dec, z_asm_dec
>cd2e		64 65 63					.text "dec"
.cd31						nt_asm_dec_a:
>cd31		05 0a						.byte 5, IM+NN
>cd33		3e cd				                .word nt_asm_dec_x
>cd35		cf a5 d4 a5					.word xt_asm_dec_a, z_asm_dec_a
>cd39		64 65 63 2e 61					.text "dec.a"
.cd3e						nt_asm_dec_x:
>cd3e		05 0a						.byte 5, IM+NN
>cd40		4b cd				                .word nt_asm_dec_z
>cd42		d4 a5 d9 a5					.word xt_asm_dec_x, z_asm_dec_x
>cd46		64 65 63 2e 78					.text "dec.x"
.cd4b						nt_asm_dec_z:
>cd4b		05 0a						.byte 5, IM+NN
>cd4d		58 cd				                .word nt_asm_dec_zx
>cd4f		d9 a5 de a5					.word xt_asm_dec_z, z_asm_dec_z
>cd53		64 65 63 2e 7a					.text "dec.z"
.cd58						nt_asm_dec_zx:
>cd58		06 0a						.byte 6, IM+NN
>cd5a		66 cd				                .word nt_asm_dex
>cd5c		de a5 e3 a5					.word xt_asm_dec_zx, z_asm_dec_zx
>cd60		64 65 63 2e 7a 78				.text "dec.zx"
.cd66						nt_asm_dex:
>cd66		03 0a						.byte 3, IM+NN
>cd68		71 cd				                .word nt_asm_dey
>cd6a		e3 a5 e8 a5					.word xt_asm_dex, z_asm_dex
>cd6e		64 65 78					.text "dex"
.cd71						nt_asm_dey:
>cd71		03 0a						.byte 3, IM+NN
>cd73		7c cd				                .word nt_asm_eor
>cd75		e8 a5 ed a5					.word xt_asm_dey, z_asm_dey
>cd79		64 65 79					.text "dey"
.cd7c						nt_asm_eor:
>cd7c		03 0a						.byte 3, IM+NN
>cd7e		87 cd				                .word nt_asm_eor_h
>cd80		ed a5 f2 a5					.word xt_asm_eor, z_asm_eor
>cd84		65 6f 72					.text "eor"
.cd87						nt_asm_eor_h:
>cd87		05 0a						.byte 5, IM+NN
>cd89		94 cd				                .word nt_asm_eor_x
>cd8b		f2 a5 f7 a5					.word xt_asm_eor_h, z_asm_eor_h
>cd8f		65 6f 72 2e 23					.text "eor.#"
.cd94						nt_asm_eor_x:
>cd94		05 0a						.byte 5, IM+NN
>cd96		a1 cd				                .word nt_asm_eor_y
>cd98		f7 a5 fc a5					.word xt_asm_eor_x, z_asm_eor_x
>cd9c		65 6f 72 2e 78					.text "eor.x"
.cda1						nt_asm_eor_y:
>cda1		05 0a						.byte 5, IM+NN
>cda3		ae cd				                .word nt_asm_eor_z
>cda5		fc a5 01 a6					.word xt_asm_eor_y, z_asm_eor_y
>cda9		65 6f 72 2e 79					.text "eor.y"
.cdae						nt_asm_eor_z:
>cdae		05 0a						.byte 5, IM+NN
>cdb0		bb cd				                .word nt_asm_eor_zi
>cdb2		01 a6 06 a6					.word xt_asm_eor_z, z_asm_eor_z
>cdb6		65 6f 72 2e 7a					.text "eor.z"
.cdbb						nt_asm_eor_zi:
>cdbb		06 0a						.byte 6, IM+NN
>cdbd		c9 cd				                .word nt_asm_eor_ziy
>cdbf		06 a6 0b a6					.word xt_asm_eor_zi, z_asm_eor_zi
>cdc3		65 6f 72 2e 7a 69				.text "eor.zi"
.cdc9						nt_asm_eor_ziy:
>cdc9		07 0a						.byte 7, IM+NN
>cdcb		d8 cd				                .word nt_asm_eor_zx
>cdcd		0b a6 10 a6					.word xt_asm_eor_ziy, z_asm_eor_ziy
>cdd1		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.cdd8						nt_asm_eor_zx:
>cdd8		06 0a						.byte 6, IM+NN
>cdda		e6 cd				                .word nt_asm_eor_zxi
>cddc		10 a6 15 a6					.word xt_asm_eor_zx, z_asm_eor_zx
>cde0		65 6f 72 2e 7a 78				.text "eor.zx"
.cde6						nt_asm_eor_zxi:
>cde6		07 0a						.byte 7, IM+NN
>cde8		f5 cd				                .word nt_asm_inc
>cdea		15 a6 1a a6					.word xt_asm_eor_zxi, z_asm_eor_zxi
>cdee		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.cdf5						nt_asm_inc:
>cdf5		03 0a						.byte 3, IM+NN
>cdf7		00 ce				                .word nt_asm_inc_a
>cdf9		1a a6 1f a6					.word xt_asm_inc, z_asm_inc
>cdfd		69 6e 63					.text "inc"
.ce00						nt_asm_inc_a:
>ce00		05 0a						.byte 5, IM+NN
>ce02		0d ce				                .word nt_asm_inc_x
>ce04		1f a6 24 a6					.word xt_asm_inc_a, z_asm_inc_a
>ce08		69 6e 63 2e 61					.text "inc.a"
.ce0d						nt_asm_inc_x:
>ce0d		05 0a						.byte 5, IM+NN
>ce0f		1a ce				                .word nt_asm_inc_z
>ce11		24 a6 29 a6					.word xt_asm_inc_x, z_asm_inc_x
>ce15		69 6e 63 2e 78					.text "inc.x"
.ce1a						nt_asm_inc_z:
>ce1a		05 0a						.byte 5, IM+NN
>ce1c		27 ce				                .word nt_asm_inc_zx
>ce1e		29 a6 2e a6					.word xt_asm_inc_z, z_asm_inc_z
>ce22		69 6e 63 2e 7a					.text "inc.z"
.ce27						nt_asm_inc_zx:
>ce27		06 0a						.byte 6, IM+NN
>ce29		35 ce				                .word nt_asm_inx
>ce2b		2e a6 33 a6					.word xt_asm_inc_zx, z_asm_inc_zx
>ce2f		69 6e 63 2e 7a 78				.text "inc.zx"
.ce35						nt_asm_inx:
>ce35		03 0a						.byte 3, IM+NN
>ce37		40 ce				                .word nt_asm_iny
>ce39		33 a6 38 a6					.word xt_asm_inx, z_asm_inx
>ce3d		69 6e 78					.text "inx"
.ce40						nt_asm_iny:
>ce40		03 0a						.byte 3, IM+NN
>ce42		4b ce				                .word nt_asm_jmp
>ce44		38 a6 3d a6					.word xt_asm_iny, z_asm_iny
>ce48		69 6e 79					.text "iny"
.ce4b						nt_asm_jmp:
>ce4b		03 0a						.byte 3, IM+NN
>ce4d		56 ce				                .word nt_asm_jmp_i
>ce4f		3d a6 40 a6					.word xt_asm_jmp, z_asm_jmp
>ce53		6a 6d 70					.text "jmp"
.ce56						nt_asm_jmp_i:
>ce56		05 0a						.byte 5, IM+NN
>ce58		63 ce				                .word nt_asm_jmp_xi
>ce5a		40 a6 45 a6					.word xt_asm_jmp_i, z_asm_jmp_i
>ce5e		6a 6d 70 2e 69					.text "jmp.i"
.ce63						nt_asm_jmp_xi:
>ce63		06 0a						.byte 6, IM+NN
>ce65		71 ce				                .word nt_asm_jsr
>ce67		45 a6 4a a6					.word xt_asm_jmp_xi, z_asm_jmp_xi
>ce6b		6a 6d 70 2e 78 69				.text "jmp.xi"
.ce71						nt_asm_jsr:
>ce71		03 0a						.byte 3, IM+NN
>ce73		7c ce				                .word nt_asm_lda
>ce75		4a a6 4f a6					.word xt_asm_jsr, z_asm_jsr
>ce79		6a 73 72					.text "jsr"
.ce7c						nt_asm_lda:
>ce7c		03 0a						.byte 3, IM+NN
>ce7e		87 ce				                .word nt_asm_lda_h
>ce80		4f a6 54 a6					.word xt_asm_lda, z_asm_lda
>ce84		6c 64 61					.text "lda"
.ce87						nt_asm_lda_h:
>ce87		05 0a						.byte 5, IM+NN
>ce89		94 ce				                .word nt_asm_lda_x
>ce8b		54 a6 59 a6					.word xt_asm_lda_h, z_asm_lda_h
>ce8f		6c 64 61 2e 23					.text "lda.#"
.ce94						nt_asm_lda_x:
>ce94		05 0a						.byte 5, IM+NN
>ce96		a1 ce				                .word nt_asm_lda_y
>ce98		59 a6 5e a6					.word xt_asm_lda_x, z_asm_lda_x
>ce9c		6c 64 61 2e 78					.text "lda.x"
.cea1						nt_asm_lda_y:
>cea1		05 0a						.byte 5, IM+NN
>cea3		ae ce				                .word nt_asm_lda_z
>cea5		5e a6 63 a6					.word xt_asm_lda_y, z_asm_lda_y
>cea9		6c 64 61 2e 79					.text "lda.y"
.ceae						nt_asm_lda_z:
>ceae		05 0a						.byte 5, IM+NN
>ceb0		bb ce				                .word nt_asm_lda_zi
>ceb2		63 a6 68 a6					.word xt_asm_lda_z, z_asm_lda_z
>ceb6		6c 64 61 2e 7a					.text "lda.z"
.cebb						nt_asm_lda_zi:
>cebb		06 0a						.byte 6, IM+NN
>cebd		c9 ce				                .word nt_asm_lda_ziy
>cebf		68 a6 6d a6					.word xt_asm_lda_zi, z_asm_lda_zi
>cec3		6c 64 61 2e 7a 69				.text "lda.zi"
.cec9						nt_asm_lda_ziy:
>cec9		07 0a						.byte 7, IM+NN
>cecb		d8 ce				                .word nt_asm_lda_zx
>cecd		6d a6 72 a6					.word xt_asm_lda_ziy, z_asm_lda_ziy
>ced1		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.ced8						nt_asm_lda_zx:
>ced8		06 0a						.byte 6, IM+NN
>ceda		e6 ce				                .word nt_asm_lda_zxi
>cedc		72 a6 77 a6					.word xt_asm_lda_zx, z_asm_lda_zx
>cee0		6c 64 61 2e 7a 78				.text "lda.zx"
.cee6						nt_asm_lda_zxi:
>cee6		07 0a						.byte 7, IM+NN
>cee8		f5 ce				                .word nt_asm_ldx
>ceea		77 a6 7c a6					.word xt_asm_lda_zxi, z_asm_lda_zxi
>ceee		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cef5						nt_asm_ldx:
>cef5		03 0a						.byte 3, IM+NN
>cef7		00 cf				                .word nt_asm_ldx_h
>cef9		7c a6 81 a6					.word xt_asm_ldx, z_asm_ldx
>cefd		6c 64 78					.text "ldx"
.cf00						nt_asm_ldx_h:
>cf00		05 0a						.byte 5, IM+NN
>cf02		0d cf				                .word nt_asm_ldx_y
>cf04		81 a6 86 a6					.word xt_asm_ldx_h, z_asm_ldx_h
>cf08		6c 64 78 2e 23					.text "ldx.#"
.cf0d						nt_asm_ldx_y:
>cf0d		05 0a						.byte 5, IM+NN
>cf0f		1a cf				                .word nt_asm_ldx_z
>cf11		86 a6 8b a6					.word xt_asm_ldx_y, z_asm_ldx_y
>cf15		6c 64 78 2e 79					.text "ldx.y"
.cf1a						nt_asm_ldx_z:
>cf1a		05 0a						.byte 5, IM+NN
>cf1c		27 cf				                .word nt_asm_ldx_zy
>cf1e		8b a6 90 a6					.word xt_asm_ldx_z, z_asm_ldx_z
>cf22		6c 64 78 2e 7a					.text "ldx.z"
.cf27						nt_asm_ldx_zy:
>cf27		06 0a						.byte 6, IM+NN
>cf29		35 cf				                .word nt_asm_ldy
>cf2b		90 a6 95 a6					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cf2f		6c 64 78 2e 7a 79				.text "ldx.zy"
.cf35						nt_asm_ldy:
>cf35		03 0a						.byte 3, IM+NN
>cf37		40 cf				                .word nt_asm_ldy_h
>cf39		95 a6 9a a6					.word xt_asm_ldy, z_asm_ldy
>cf3d		6c 64 79					.text "ldy"
.cf40						nt_asm_ldy_h:
>cf40		05 0a						.byte 5, IM+NN
>cf42		4d cf				                .word nt_asm_ldy_x
>cf44		9a a6 9f a6					.word xt_asm_ldy_h, z_asm_ldy_h
>cf48		6c 64 79 2e 23					.text "ldy.#"
.cf4d						nt_asm_ldy_x:
>cf4d		05 0a						.byte 5, IM+NN
>cf4f		5a cf				                .word nt_asm_ldy_z
>cf51		9f a6 a4 a6					.word xt_asm_ldy_x, z_asm_ldy_x
>cf55		6c 64 79 2e 78					.text "ldy.x"
.cf5a						nt_asm_ldy_z:
>cf5a		05 0a						.byte 5, IM+NN
>cf5c		67 cf				                .word nt_asm_ldy_zx
>cf5e		a4 a6 a9 a6					.word xt_asm_ldy_z, z_asm_ldy_z
>cf62		6c 64 79 2e 7a					.text "ldy.z"
.cf67						nt_asm_ldy_zx:
>cf67		06 0a						.byte 6, IM+NN
>cf69		75 cf				                .word nt_asm_lsr
>cf6b		a9 a6 ae a6					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cf6f		6c 64 79 2e 7a 78				.text "ldy.zx"
.cf75						nt_asm_lsr:
>cf75		03 0a						.byte 3, IM+NN
>cf77		80 cf				                .word nt_asm_lsr_a
>cf79		ae a6 b3 a6					.word xt_asm_lsr, z_asm_lsr
>cf7d		6c 73 72					.text "lsr"
.cf80						nt_asm_lsr_a:
>cf80		05 0a						.byte 5, IM+NN
>cf82		8d cf				                .word nt_asm_lsr_x
>cf84		b3 a6 b8 a6					.word xt_asm_lsr_a, z_asm_lsr_a
>cf88		6c 73 72 2e 61					.text "lsr.a"
.cf8d						nt_asm_lsr_x:
>cf8d		05 0a						.byte 5, IM+NN
>cf8f		9a cf				                .word nt_asm_lsr_z
>cf91		b8 a6 bd a6					.word xt_asm_lsr_x, z_asm_lsr_x
>cf95		6c 73 72 2e 78					.text "lsr.x"
.cf9a						nt_asm_lsr_z:
>cf9a		05 0a						.byte 5, IM+NN
>cf9c		a7 cf				                .word nt_asm_lsr_zx
>cf9e		bd a6 c2 a6					.word xt_asm_lsr_z, z_asm_lsr_z
>cfa2		6c 73 72 2e 7a					.text "lsr.z"
.cfa7						nt_asm_lsr_zx:
>cfa7		06 0a						.byte 6, IM+NN
>cfa9		b5 cf				                .word nt_asm_nop
>cfab		c2 a6 c7 a6					.word xt_asm_lsr_zx, z_asm_lsr_zx
>cfaf		6c 73 72 2e 7a 78				.text "lsr.zx"
.cfb5						nt_asm_nop:
>cfb5		03 0a						.byte 3, IM+NN
>cfb7		c0 cf				                .word nt_asm_ora
>cfb9		c7 a6 cc a6					.word xt_asm_nop, z_asm_nop
>cfbd		6e 6f 70					.text "nop"
.cfc0						nt_asm_ora:
>cfc0		03 0a						.byte 3, IM+NN
>cfc2		cb cf				                .word nt_asm_ora_h
>cfc4		cc a6 d1 a6					.word xt_asm_ora, z_asm_ora
>cfc8		6f 72 61					.text "ora"
.cfcb						nt_asm_ora_h:
>cfcb		05 0a						.byte 5, IM+NN
>cfcd		d8 cf				                .word nt_asm_ora_x
>cfcf		d1 a6 d6 a6					.word xt_asm_ora_h, z_asm_ora_h
>cfd3		6f 72 61 2e 23					.text "ora.#"
.cfd8						nt_asm_ora_x:
>cfd8		05 0a						.byte 5, IM+NN
>cfda		e5 cf				                .word nt_asm_ora_y
>cfdc		d6 a6 db a6					.word xt_asm_ora_x, z_asm_ora_x
>cfe0		6f 72 61 2e 78					.text "ora.x"
.cfe5						nt_asm_ora_y:
>cfe5		05 0a						.byte 5, IM+NN
>cfe7		f2 cf				                .word nt_asm_ora_z
>cfe9		db a6 e0 a6					.word xt_asm_ora_y, z_asm_ora_y
>cfed		6f 72 61 2e 79					.text "ora.y"
.cff2						nt_asm_ora_z:
>cff2		05 0a						.byte 5, IM+NN
>cff4		ff cf				                .word nt_asm_ora_zi
>cff6		e0 a6 e5 a6					.word xt_asm_ora_z, z_asm_ora_z
>cffa		6f 72 61 2e 7a					.text "ora.z"
.cfff						nt_asm_ora_zi:
>cfff		06 0a						.byte 6, IM+NN
>d001		0d d0				                .word nt_asm_ora_ziy
>d003		e5 a6 ec a6					.word xt_asm_ora_zi, z_asm_ora_zi
>d007		6f 72 61 2e 7a 69				.text "ora.zi"
.d00d						nt_asm_ora_ziy:
>d00d		07 0a						.byte 7, IM+NN
>d00f		1c d0				                .word nt_asm_ora_zx
>d011		ec a6 f1 a6					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d015		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d01c						nt_asm_ora_zx:
>d01c		06 0a						.byte 6, IM+NN
>d01e		2a d0				                .word nt_asm_ora_zxi
>d020		f1 a6 f6 a6					.word xt_asm_ora_zx, z_asm_ora_zx
>d024		6f 72 61 2e 7a 78				.text "ora.zx"
.d02a						nt_asm_ora_zxi:
>d02a		07 0a						.byte 7, IM+NN
>d02c		39 d0				                .word nt_asm_pha
>d02e		f6 a6 fb a6					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d032		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d039						nt_asm_pha:
>d039		03 0a						.byte 3, IM+NN
>d03b		44 d0				                .word nt_asm_php
>d03d		fb a6 00 a7					.word xt_asm_pha, z_asm_pha
>d041		70 68 61					.text "pha"
.d044						nt_asm_php:
>d044		03 0a						.byte 3, IM+NN
>d046		4f d0				                .word nt_asm_phx
>d048		00 a7 05 a7					.word xt_asm_php, z_asm_php
>d04c		70 68 70					.text "php"
.d04f						nt_asm_phx:
>d04f		03 0a						.byte 3, IM+NN
>d051		5a d0				                .word nt_asm_phy
>d053		05 a7 0a a7					.word xt_asm_phx, z_asm_phx
>d057		70 68 78					.text "phx"
.d05a						nt_asm_phy:
>d05a		03 0a						.byte 3, IM+NN
>d05c		65 d0				                .word nt_asm_pla
>d05e		0a a7 0f a7					.word xt_asm_phy, z_asm_phy
>d062		70 68 79					.text "phy"
.d065						nt_asm_pla:
>d065		03 0a						.byte 3, IM+NN
>d067		70 d0				                .word nt_asm_plp
>d069		0f a7 14 a7					.word xt_asm_pla, z_asm_pla
>d06d		70 6c 61					.text "pla"
.d070						nt_asm_plp:
>d070		03 0a						.byte 3, IM+NN
>d072		7b d0				                .word nt_asm_plx
>d074		14 a7 19 a7					.word xt_asm_plp, z_asm_plp
>d078		70 6c 70					.text "plp"
.d07b						nt_asm_plx:
>d07b		03 0a						.byte 3, IM+NN
>d07d		86 d0				                .word nt_asm_ply
>d07f		19 a7 1e a7					.word xt_asm_plx, z_asm_plx
>d083		70 6c 78					.text "plx"
.d086						nt_asm_ply:
>d086		03 0a						.byte 3, IM+NN
>d088		91 d0				                .word nt_asm_rol
>d08a		1e a7 23 a7					.word xt_asm_ply, z_asm_ply
>d08e		70 6c 79					.text "ply"
.d091						nt_asm_rol:
>d091		03 0a						.byte 3, IM+NN
>d093		9c d0				                .word nt_asm_rol_a
>d095		23 a7 28 a7					.word xt_asm_rol, z_asm_rol
>d099		72 6f 6c					.text "rol"
.d09c						nt_asm_rol_a:
>d09c		05 0a						.byte 5, IM+NN
>d09e		a9 d0				                .word nt_asm_rol_x
>d0a0		28 a7 2d a7					.word xt_asm_rol_a, z_asm_rol_a
>d0a4		72 6f 6c 2e 61					.text "rol.a"
.d0a9						nt_asm_rol_x:
>d0a9		05 0a						.byte 5, IM+NN
>d0ab		b6 d0				                .word nt_asm_rol_z
>d0ad		2d a7 32 a7					.word xt_asm_rol_x, z_asm_rol_x
>d0b1		72 6f 6c 2e 78					.text "rol.x"
.d0b6						nt_asm_rol_z:
>d0b6		05 0a						.byte 5, IM+NN
>d0b8		c3 d0				                .word nt_asm_rol_zx
>d0ba		32 a7 37 a7					.word xt_asm_rol_z, z_asm_rol_z
>d0be		72 6f 6c 2e 7a					.text "rol.z"
.d0c3						nt_asm_rol_zx:
>d0c3		06 0a						.byte 6, IM+NN
>d0c5		d1 d0				                .word nt_asm_ror
>d0c7		37 a7 3c a7					.word xt_asm_rol_zx, z_asm_rol_zx
>d0cb		72 6f 6c 2e 7a 78				.text "rol.zx"
.d0d1						nt_asm_ror:
>d0d1		03 0a						.byte 3, IM+NN
>d0d3		dc d0				                .word nt_asm_ror_a
>d0d5		3c a7 41 a7					.word xt_asm_ror, z_asm_ror
>d0d9		72 6f 72					.text "ror"
.d0dc						nt_asm_ror_a:
>d0dc		05 0a						.byte 5, IM+NN
>d0de		e9 d0				                .word nt_asm_ror_x
>d0e0		41 a7 46 a7					.word xt_asm_ror_a, z_asm_ror_a
>d0e4		72 6f 72 2e 61					.text "ror.a"
.d0e9						nt_asm_ror_x:
>d0e9		05 0a						.byte 5, IM+NN
>d0eb		f6 d0				                .word nt_asm_ror_z
>d0ed		46 a7 4b a7					.word xt_asm_ror_x, z_asm_ror_x
>d0f1		72 6f 72 2e 78					.text "ror.x"
.d0f6						nt_asm_ror_z:
>d0f6		05 0a						.byte 5, IM+NN
>d0f8		03 d1				                .word nt_asm_ror_zx
>d0fa		4b a7 50 a7					.word xt_asm_ror_z, z_asm_ror_z
>d0fe		72 6f 72 2e 7a					.text "ror.z"
.d103						nt_asm_ror_zx:
>d103		06 0a						.byte 6, IM+NN
>d105		11 d1				                .word nt_asm_rti
>d107		50 a7 55 a7					.word xt_asm_ror_zx, z_asm_ror_zx
>d10b		72 6f 72 2e 7a 78				.text "ror.zx"
.d111						nt_asm_rti:
>d111		03 0a						.byte 3, IM+NN
>d113		1c d1				                .word nt_asm_rts
>d115		55 a7 5a a7					.word xt_asm_rti, z_asm_rti
>d119		72 74 69					.text "rti"
.d11c						nt_asm_rts:
>d11c		03 0a						.byte 3, IM+NN
>d11e		27 d1				                .word nt_asm_sbc
>d120		5a a7 5f a7					.word xt_asm_rts, z_asm_rts
>d124		72 74 73					.text "rts"
.d127						nt_asm_sbc:
>d127		03 0a						.byte 3, IM+NN
>d129		32 d1				                .word nt_asm_sbc_h
>d12b		5f a7 64 a7					.word xt_asm_sbc, z_asm_sbc
>d12f		73 62 63					.text "sbc"
.d132						nt_asm_sbc_h:
>d132		05 0a						.byte 5, IM+NN
>d134		3f d1				                .word nt_asm_sbc_x
>d136		64 a7 69 a7					.word xt_asm_sbc_h, z_asm_sbc_h
>d13a		73 62 63 2e 23					.text "sbc.#"
.d13f						nt_asm_sbc_x:
>d13f		05 0a						.byte 5, IM+NN
>d141		4c d1				                .word nt_asm_sbc_y
>d143		69 a7 6e a7					.word xt_asm_sbc_x, z_asm_sbc_x
>d147		73 62 63 2e 78					.text "sbc.x"
.d14c						nt_asm_sbc_y:
>d14c		05 0a						.byte 5, IM+NN
>d14e		59 d1				                .word nt_asm_sbc_z
>d150		6e a7 73 a7					.word xt_asm_sbc_y, z_asm_sbc_y
>d154		73 62 63 2e 79					.text "sbc.y"
.d159						nt_asm_sbc_z:
>d159		05 0a						.byte 5, IM+NN
>d15b		66 d1				                .word nt_asm_sbc_zi
>d15d		73 a7 78 a7					.word xt_asm_sbc_z, z_asm_sbc_z
>d161		73 62 63 2e 7a					.text "sbc.z"
.d166						nt_asm_sbc_zi:
>d166		06 0a						.byte 6, IM+NN
>d168		74 d1				                .word nt_asm_sbc_ziy
>d16a		78 a7 7d a7					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d16e		73 62 63 2e 7a 69				.text "sbc.zi"
.d174						nt_asm_sbc_ziy:
>d174		07 0a						.byte 7, IM+NN
>d176		83 d1				                .word nt_asm_sbc_zx
>d178		7d a7 82 a7					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d17c		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d183						nt_asm_sbc_zx:
>d183		06 0a						.byte 6, IM+NN
>d185		91 d1				                .word nt_asm_sbc_zxi
>d187		82 a7 87 a7					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d18b		73 62 63 2e 7a 78				.text "sbc.zx"
.d191						nt_asm_sbc_zxi:
>d191		07 0a						.byte 7, IM+NN
>d193		a0 d1				                .word nt_asm_sec
>d195		87 a7 8b a7					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d199		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d1a0						nt_asm_sec:
>d1a0		03 0a						.byte 3, IM+NN
>d1a2		ab d1				                .word nt_asm_sed
>d1a4		8b a7 8f a7					.word xt_asm_sec, z_asm_sec
>d1a8		73 65 63					.text "sec"
.d1ab						nt_asm_sed:
>d1ab		03 0a						.byte 3, IM+NN
>d1ad		b6 d1				                .word nt_asm_sei
>d1af		8f a7 93 a7					.word xt_asm_sed, z_asm_sed
>d1b3		73 65 64					.text "sed"
.d1b6						nt_asm_sei:
>d1b6		03 0a						.byte 3, IM+NN
>d1b8		c1 d1				                .word nt_asm_sta
>d1ba		93 a7 97 a7					.word xt_asm_sei, z_asm_sei
>d1be		73 65 69					.text "sei"
.d1c1						nt_asm_sta:
>d1c1		03 0a						.byte 3, IM+NN
>d1c3		cc d1				                .word nt_asm_sta_x
>d1c5		97 a7 9b a7					.word xt_asm_sta, z_asm_sta
>d1c9		73 74 61					.text "sta"
.d1cc						nt_asm_sta_x:
>d1cc		05 0a						.byte 5, IM+NN
>d1ce		d9 d1				                .word nt_asm_sta_y
>d1d0		9b a7 9f a7					.word xt_asm_sta_x, z_asm_sta_x
>d1d4		73 74 61 2e 78					.text "sta.x"
.d1d9						nt_asm_sta_y:
>d1d9		05 0a						.byte 5, IM+NN
>d1db		e6 d1				                .word nt_asm_sta_z
>d1dd		9f a7 a3 a7					.word xt_asm_sta_y, z_asm_sta_y
>d1e1		73 74 61 2e 79					.text "sta.y"
.d1e6						nt_asm_sta_z:
>d1e6		05 0a						.byte 5, IM+NN
>d1e8		f3 d1				                .word nt_asm_sta_zi
>d1ea		a3 a7 a7 a7					.word xt_asm_sta_z, z_asm_sta_z
>d1ee		73 74 61 2e 7a					.text "sta.z"
.d1f3						nt_asm_sta_zi:
>d1f3		06 0a						.byte 6, IM+NN
>d1f5		01 d2				                .word nt_asm_sta_ziy
>d1f7		a7 a7 ab a7					.word xt_asm_sta_zi, z_asm_sta_zi
>d1fb		73 74 61 2e 7a 69				.text "sta.zi"
.d201						nt_asm_sta_ziy:
>d201		07 0a						.byte 7, IM+NN
>d203		10 d2				                .word nt_asm_sta_zx
>d205		ab a7 af a7					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d209		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d210						nt_asm_sta_zx:
>d210		06 0a						.byte 6, IM+NN
>d212		1e d2				                .word nt_asm_sta_zxi
>d214		af a7 b3 a7					.word xt_asm_sta_zx, z_asm_sta_zx
>d218		73 74 61 2e 7a 78				.text "sta.zx"
.d21e						nt_asm_sta_zxi:
>d21e		07 0a						.byte 7, IM+NN
>d220		2d d2				                .word nt_asm_stx
>d222		b3 a7 b7 a7					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d226		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d22d						nt_asm_stx:
>d22d		03 0a						.byte 3, IM+NN
>d22f		38 d2				                .word nt_asm_stx_z
>d231		b7 a7 bb a7					.word xt_asm_stx, z_asm_stx
>d235		73 74 78					.text "stx"
.d238						nt_asm_stx_z:
>d238		05 0a						.byte 5, IM+NN
>d23a		45 d2				                .word nt_asm_stx_zy
>d23c		bb a7 bf a7					.word xt_asm_stx_z, z_asm_stx_z
>d240		73 74 78 2e 7a					.text "stx.z"
.d245						nt_asm_stx_zy:
>d245		06 0a						.byte 6, IM+NN
>d247		53 d2				                .word nt_asm_sty
>d249		bf a7 c3 a7					.word xt_asm_stx_zy, z_asm_stx_zy
>d24d		73 74 78 2e 7a 79				.text "stx.zy"
.d253						nt_asm_sty:
>d253		03 0a						.byte 3, IM+NN
>d255		5e d2				                .word nt_asm_sty_z
>d257		c3 a7 c7 a7					.word xt_asm_sty, z_asm_sty
>d25b		73 74 79					.text "sty"
.d25e						nt_asm_sty_z:
>d25e		05 0a						.byte 5, IM+NN
>d260		6b d2				                .word nt_asm_sty_zx
>d262		c7 a7 cb a7					.word xt_asm_sty_z, z_asm_sty_z
>d266		73 74 79 2e 7a					.text "sty.z"
.d26b						nt_asm_sty_zx:
>d26b		06 0a						.byte 6, IM+NN
>d26d		79 d2				                .word nt_asm_stz
>d26f		cb a7 cf a7					.word xt_asm_sty_zx, z_asm_sty_zx
>d273		73 74 79 2e 7a 78				.text "sty.zx"
.d279						nt_asm_stz:
>d279		03 0a						.byte 3, IM+NN
>d27b		84 d2				                .word nt_asm_stz_x
>d27d		cf a7 d3 a7					.word xt_asm_stz, z_asm_stz
>d281		73 74 7a					.text "stz"
.d284						nt_asm_stz_x:
>d284		05 0a						.byte 5, IM+NN
>d286		91 d2				                .word nt_asm_stz_z
>d288		d3 a7 d7 a7					.word xt_asm_stz_x, z_asm_stz_x
>d28c		73 74 7a 2e 78					.text "stz.x"
.d291						nt_asm_stz_z:
>d291		05 0a						.byte 5, IM+NN
>d293		9e d2				                .word nt_asm_stz_zx
>d295		d7 a7 db a7					.word xt_asm_stz_z, z_asm_stz_z
>d299		73 74 7a 2e 7a					.text "stz.z"
.d29e						nt_asm_stz_zx:
>d29e		06 0a						.byte 6, IM+NN
>d2a0		ac d2				                .word nt_asm_tax
>d2a2		db a7 df a7					.word xt_asm_stz_zx, z_asm_stz_zx
>d2a6		73 74 7a 2e 7a 78				.text "stz.zx"
.d2ac						nt_asm_tax:
>d2ac		03 0a						.byte 3, IM+NN
>d2ae		b7 d2				                .word nt_asm_tay
>d2b0		df a7 e3 a7					.word xt_asm_tax, z_asm_tax
>d2b4		74 61 78					.text "tax"
.d2b7						nt_asm_tay:
>d2b7		03 0a						.byte 3, IM+NN
>d2b9		c2 d2				                .word nt_asm_trb
>d2bb		e3 a7 e7 a7					.word xt_asm_tay, z_asm_tay
>d2bf		74 61 79					.text "tay"
.d2c2						nt_asm_trb:
>d2c2		03 0a						.byte 3, IM+NN
>d2c4		cd d2				                .word nt_asm_trb_z
>d2c6		e7 a7 eb a7					.word xt_asm_trb, z_asm_trb
>d2ca		74 72 62					.text "trb"
.d2cd						nt_asm_trb_z:
>d2cd		05 0a						.byte 5, IM+NN
>d2cf		da d2				                .word nt_asm_tsb
>d2d1		eb a7 ef a7					.word xt_asm_trb_z, z_asm_trb_z
>d2d5		74 72 62 2e 7a					.text "trb.z"
.d2da						nt_asm_tsb:
>d2da		03 0a						.byte 3, IM+NN
>d2dc		e5 d2				                .word nt_asm_tsb_z
>d2de		ef a7 f3 a7					.word xt_asm_tsb, z_asm_tsb
>d2e2		74 73 62					.text "tsb"
.d2e5						nt_asm_tsb_z:
>d2e5		05 0a						.byte 5, IM+NN
>d2e7		f2 d2				                .word nt_asm_tsx
>d2e9		f3 a7 f7 a7					.word xt_asm_tsb_z, z_asm_tsb_z
>d2ed		74 73 62 2e 7a					.text "tsb.z"
.d2f2						nt_asm_tsx:
>d2f2		03 0a						.byte 3, IM+NN
>d2f4		fd d2				                .word nt_asm_txa
>d2f6		f7 a7 fb a7					.word xt_asm_tsx, z_asm_tsx
>d2fa		74 73 78					.text "tsx"
.d2fd						nt_asm_txa:
>d2fd		03 0a						.byte 3, IM+NN
>d2ff		08 d3				                .word nt_asm_txs
>d301		fb a7 ff a7					.word xt_asm_txa, z_asm_txa
>d305		74 78 61					.text "txa"
.d308						nt_asm_txs:
>d308		03 0a						.byte 3, IM+NN
>d30a		13 d3				                .word nt_asm_tya
>d30c		ff a7 03 a8					.word xt_asm_txs, z_asm_txs
>d310		74 78 73					.text "txs"
.d313						nt_asm_tya:
>d313		03 0a						.byte 3, IM+NN
>d315		1e d3				                .word nt_asm_arrow
>d317		03 a8 07 a8					.word xt_asm_tya, z_asm_tya
>d31b		74 79 61					.text "tya"
.d31e						nt_asm_arrow:
>d31e		03 02				                .byte 3, IM
>d320		29 d3				                .word nt_asm_back_jump
>d322		0f 89 19 89			                .word xt_asm_arrow, z_asm_arrow
>d326		2d 2d 3e			                .text "-->"
.d329						nt_asm_back_jump:
>d329		02 02				                .byte 2, IM
>d32b		33 d3				                .word nt_asm_back_branch
>d32d		4f a8 4f a8			                .word xt_asm_back_jump, z_asm_back_jump
>d331		3c 6a				                .text "<j"
.d333						nt_asm_back_branch:
>d333		02 02				                .byte 2, IM
>d335		3d d3				                .word nt_asm_push_a
>d337		50 a8 58 a8			                .word xt_asm_back_branch, z_asm_back_branch
>d33b		3c 62				                .text "<b"
.d33d						nt_asm_push_a:
>d33d		06 0a				                .byte 6, IM+NN
>d33f		00 00				                .word 0000
>d341		41 a8 4e a8			                .word xt_asm_push_a, z_asm_push_a
>d345		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

>d34b		30 31 32 33 34 35 36 37		alpha36:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d353		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d363		4f 50 51 52 53 54 55 56 57 58 59 5a
=0						ix := 0
=0						str_ok             = ix         ; referenced by QUIT via state=0
=1						ix += 1
=1						str_compile        = ix         ; referenced by QUIT via state=1
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_wid_forth      = ix
=4						ix += 1
=4						str_wid_editor     = ix
=5						ix += 1
=5						str_wid_assembler  = ix
=6						ix += 1
=6						str_wid_root       = ix
=7						ix += 1
=7						str_see_nt         = ix
=8						ix += 1
=8						str_see_xt         = ix
=9						ix += 1
=9						str_see_size       = ix
=10						ix += 1
=10						str_see_cfapfa     = ix
=11						ix += 1
=11						str_disasm_sdc     = ix
=12						ix += 1
=12						str_disasm_lit     = ix
=13						ix += 1
=13						str_disasm_0bra    = ix
=14						ix += 1
=14						str_disasm_loop    = ix
=15						ix += 1
=15						str_disasm_do      = ix
=16						ix += 1
.d36f						string_table:
>d36f		8f d3 92 d3 9b d3		        .word s_ok, s_compiled, s_redefined                     ; 0-2
>d375		b6 d3 af d3 a5 d3 bc d3		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root  ; 3-6
>d37d		c1 d3 c5 d3 c9 d3 d9 d3		        .word s_see_nt, s_see_xt, s_see_size, s_see_cfapfa            ; 7-10
>d385		02 d4 14 d4 1c d4 24 d4		        .word s_disasm_sdc, s_disasm_lit, s_disasm_0bra, s_disasm_loop, s_disasm_do ; 11-15
>d38d		29 d4
>d38f		20 6f eb			s_ok:         .shift " ok"              ; note space at beginning
>d392		20 63 6f 6d 70 69 6c 65		s_compiled:   .shift " compiled"        ; note space at beginning
>d39a		e4
>d39b		72 65 64 65 66 69 6e 65		s_redefined:  .shift "redefined "       ; note space at end
>d3a3		64 a0
>d3a5		41 73 73 65 6d 62 6c 65		s_wid_asm:    .shift "Assembler "       ; Wordlist ID 2, note space at end
>d3ad		72 a0
>d3af		45 64 69 74 6f 72 a0		s_wid_editor: .shift "Editor "     ; Wordlist ID 1, note space at end
>d3b6		46 6f 72 74 68 a0		s_wid_forth:  .shift "Forth "      ; Wordlist ID 0, note space at end
>d3bc		52 6f 6f 74 a0			s_wid_root:   .shift "Root "       ; Wordlist ID 3, note space at end
>d3c1		6e 74 3a a0			s_see_nt:     .shift "nt: "
>d3c5		78 74 3a a0			s_see_xt:     .shift "xt: "
>d3c9		73 69 7a 65 20 28 64 65		s_see_size:   .shift "size (decimal): "
>d3d1		63 69 6d 61 6c 29 3a a0
>d3d9		43 46 41 20 33 20 20 50		s_see_cfapfa: .shift "CFA 3  PFA "
>d3e1		46 41 a0
>d3e4		66 6c 61 67 73 3a 20 43		see_flags_template:     .shift "flags: CO",0,"IM",0,"AN",0,"NN",0,"HC",0,"| UF",0,"ST",0
>d3ec		4f 00 49 4d 00 41 4e 00 4e 4e 00 48 43 00 7c 20
>d3fc		55 46 00 53 54 80
>d402		20 53 54 41 43 4b 20 44		s_disasm_sdc: .shift " STACK DEPTH CHECK"
>d40a		45 50 54 48 20 43 48 45 43 cb
>d414		4c 49 54 45 52 41 4c a0		s_disasm_lit: .shift "LITERAL "
>d41c		30 42 52 41 4e 43 48 a0		s_disasm_0bra: .shift "0BRANCH "
>d424		4c 4f 4f 50 a0			s_disasm_loop: .shift "LOOP "
>d429		44 4f a0			s_disasm_do: .shift "DO "
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
=14						err_toolong      = 14
.d42c						error_table:
>d42c		4a d4 6a d4 89 d4 a9 d4		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d434		c5 d4 d5 d4 e4 d4 11 d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d43c		28 d5 48 d5 5c d5 77 d5		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d444		8d d5 cb d5 d8 d5		        .word es_blockwords, es_returnstack, es_toolong         ; 12-14
>d44a		41 4c 4c 4f 54 20 75 73		es_allot:       .shift "ALLOT using all available memory"
>d452		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d462		65 20 6d 65 6d 6f 72 f9
>d46a		49 6c 6c 65 67 61 6c 20		es_badsource:   .shift "Illegal SOURCE-ID during REFILL"
>d472		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d482		20 52 45 46 49 4c cc
>d489		49 6e 74 65 72 70 72 65		es_compileonly: .shift "Interpreting a compile-only word"
>d491		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d4a1		6e 6c 79 20 77 6f 72 e4
>d4a9		44 45 46 45 52 65 64 20		es_defer:       .shift "DEFERed word not defined yet"
>d4b1		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d4c1		20 79 65 f4
>d4c5		44 69 76 69 73 69 6f 6e		es_divzero:     .shift "Division by zero"
>d4cd		20 62 79 20 7a 65 72 ef
>d4d5		50 61 72 73 69 6e 67 20		es_noname:      .shift "Parsing failure"
>d4dd		66 61 69 6c 75 72 e5
>d4e4		51 55 49 54 20 63 6f 75		es_refill:      .shift "QUIT could not get input (REFILL returned -1)"
>d4ec		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d4fc		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d50c		64 20 2d 31 a9
>d511		41 6c 72 65 61 64 79 20		es_state:       .shift "Already in compile mode"
>d519		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 e5
>d528		55 6e 64 65 66 69 6e 65		es_syntax:      .shift "Undefined word or invalid number"
>d530		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d540		64 20 6e 75 6d 62 65 f2
>d548		44 61 74 61 20 73 74 61		es_underflow:   .shift "Data stack underflow"
>d550		63 6b 20 75 6e 64 65 72 66 6c 6f f7
>d55c		4d 61 78 20 6d 65 6d 6f		es_negallot:    .shift "Max memory freed with ALLOT"
>d564		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d574		4c 4f d4
>d577		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .shift "No wordlists available"
>d57f		69 73 74 73 20 61 76 61 69 6c 61 62 6c e5
>d58d		50 6c 65 61 73 65 20 61		es_blockwords:  .shift "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR"
>d595		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d5a5		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d5b5		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d5c5		56 45 43 54 4f d2
>d5cb		52 65 74 75 72 6e 20 73		es_returnstack: .shift "Return stack:"
>d5d3		74 61 63 6b ba
>d5d8		4e 61 6d 65 20 74 6f 6f		es_toolong:     .shift "Name too long (max 31)"
>d5e0		20 6c 6f 6e 67 20 28 6d 61 78 20 33 31 a9
>d5ee		2f 43 4f 55 4e 54 45 44		envs_cs:        .text "/COUNTED-STRING"
>d5f6		2d 53 54 52 49 4e 47
>d5fd		2f 48 4f 4c 44			envs_hold:      .text "/HOLD"
>d602		2f 50 41 44			envs_pad:       .text "/PAD"
>d606		41 44 44 52 45 53 53 2d		envs_aub:       .text "ADDRESS-UNIT-BITS"
>d60e		55 4e 49 54 2d 42 49 54 53
>d617		46 4c 4f 4f 52 45 44		envs_floored:   .text "FLOORED"
>d61e		4d 41 58 2d 43 48 41 52		envs_max_char:  .text "MAX-CHAR"
>d626		4d 41 58 2d 4e			envs_max_n:     .text "MAX-N"
>d62b		4d 41 58 2d 55			envs_max_u:     .text "MAX-U"
>d630		52 45 54 55 52 4e 2d 53		envs_rsc:       .text "RETURN-STACK-CELLS"
>d638		54 41 43 4b 2d 43 45 4c 4c 53
>d642		53 54 41 43 4b 2d 43 45		envs_sc:        .text "STACK-CELLS"
>d64a		4c 4c 53
>d64d		57 4f 52 44 4c 49 53 54		envs_wl:        .text "WORDLISTS"
>d655		53
>d656		4d 41 58 2d 44			envs_max_d:     .text "MAX-D"
>d65b		4d 41 58 2d 55 44		envs_max_ud:    .text "MAX-UD"
.d661						envs_eot:

;******  Return to file: platform/../taliforth.asm

.d661						doconst:
.d661		ca		dex		                dex             ; make room for constant
.d662		ca		dex		                dex
.d663		68		pla		                pla             ; LSB of return address
.d664		85 25		sta $25		                sta tmp1
.d666		68		pla		                pla             ; MSB of return address
.d667		85 26		sta $26		                sta tmp1+1
.d669		a0 01		ldy #$01	                ldy #1
.d66b		b1 25		lda ($25),y	                lda (tmp1),y
.d66d		95 00		sta $00,x	                sta 0,x
.d66f		c8		iny		                iny
.d670		b1 25		lda ($25),y	                lda (tmp1),y
.d672		95 01		sta $01,x	                sta 1,x
.d674		60		rts		                rts
.d675						dodefer:
.d675		68		pla		                pla             ; LSB
.d676		85 25		sta $25		                sta tmp1
.d678		68		pla		                pla             ; MSB
.d679		85 26		sta $26		                sta tmp1+1
.d67b		a0 01		ldy #$01	                ldy #1
.d67d		b1 25		lda ($25),y	                lda (tmp1),y
.d67f		85 27		sta $27		                sta tmp2
.d681		c8		iny		                iny
.d682		b1 25		lda ($25),y	                lda (tmp1),y
.d684		85 28		sta $28		                sta tmp2+1
.d686		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d689						dodoes:
.d689		7a		ply		                ply             ; LSB
.d68a		68		pla		                pla             ; MSB
.d68b		c8		iny		                iny
.d68c		d0 01		bne $d68f	                bne +
.d68e		1a		inc a		                ina
.d68f						+
.d68f		84 27		sty $27		                sty tmp2
.d691		85 28		sta $28		                sta tmp2+1
.d693		ca		dex		                dex
.d694		ca		dex		                dex
.d695		7a		ply		                ply
.d696		68		pla		                pla
.d697		c8		iny		                iny
.d698		d0 01		bne $d69b	                bne +
.d69a		1a		inc a		                ina
.d69b						+
.d69b		94 00		sty $00,x	                sty 0,x         ; LSB
.d69d		95 01		sta $01,x	                sta 1,x         ; MSB
.d69f		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d6a2						dovar:
.d6a2		7a		ply		                ply             ; LSB
.d6a3		68		pla		                pla             ; MSB
.d6a4		c8		iny		                iny
.d6a5		d0 01		bne $d6a8	                bne +
.d6a7		1a		inc a		                ina
.d6a8						+
.d6a8		ca		dex		                dex
.d6a9		ca		dex		                dex
.d6aa		95 01		sta $01,x	                sta 1,x
.d6ac		98		tya		                tya
.d6ad		95 00		sta $00,x	                sta 0,x
.d6af		60		rts		                rts
.d6b0						push_upvar_tos:
.d6b0		ca		dex		                dex
.d6b1		ca		dex		                dex
.d6b2		18		clc		                clc
.d6b3		65 08		adc $08		                adc up
.d6b5		95 00		sta $00,x	                sta 0,x
.d6b7		a5 09		lda $09		                lda up+1
.d6b9		90 01		bcc $d6bc	                bcc +
.d6bb		1a		inc a		                ina
.d6bc						+
.d6bc		95 01		sta $01,x	                sta 1,x
.d6be		60		rts		                rts
.d6bf						byte_to_ascii:
.d6bf		48		pha		                pha
.d6c0		4a		lsr a		                lsr             ; convert high nibble first
.d6c1		4a		lsr a		                lsr
.d6c2		4a		lsr a		                lsr
.d6c3		4a		lsr a		                lsr
.d6c4		20 c8 d6	jsr $d6c8	                jsr _nibble_to_ascii
.d6c7		68		pla		                pla
.d6c8						_nibble_to_ascii:
.d6c8		29 0f		and #$0f	                and #$F
.d6ca		09 30		ora #$30	                ora #'0'
.d6cc		c9 3a		cmp #$3a	                cmp #'9'+1
.d6ce		90 02		bcc $d6d2	                bcc +
.d6d0		69 06		adc #$06	                adc #6
.d6d2		4c bb 86	jmp $86bb	+               jmp emit_a
.d6d5		60		rts		                rts
.d6d6						find_header_name:
.d6d6		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d6d8		85 27		sta $27		                sta tmp2
.d6da		b5 03		lda $03,x	                lda 3,x
.d6dc		85 28		sta $28		                sta tmp2+1
.d6de						_loop:
.d6de		b2 25		lda ($25)	                lda (tmp1)
.d6e0		d5 00		cmp $00,x	                cmp 0,x
.d6e2		d0 3a		bne $d71e	                bne _next_entry
.d6e4		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d6e6		a0 08		ldy #$08	                ldy #8
.d6e8		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d6ea		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d6ec		d0 30		bne $d71e	                bne _next_entry ; definitely not equal if any bits differ
.d6ee		a5 25		lda $25		                lda tmp1
.d6f0		48		pha		                pha             ; Save original address on the stack
.d6f1		18		clc		                clc
.d6f2		69 08		adc #$08	                adc #8
.d6f4		85 25		sta $25		                sta tmp1
.d6f6		a5 26		lda $26		                lda tmp1+1
.d6f8		48		pha		                pha
.d6f9		90 03		bcc $d6fe	                bcc +
.d6fb		1a		inc a		                ina
.d6fc		85 26		sta $26		                sta tmp1+1
.d6fe						+
.d6fe		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d700		88		dey		                dey
.d701						_next_char:
.d701		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d703		c9 5b		cmp #$5b	                cmp #'Z'+1
.d705		b0 06		bcs $d70d	                bcs _check_char
.d707		c9 41		cmp #$41	                cmp #'A'
.d709		90 02		bcc $d70d	                bcc _check_char
.d70b		09 20		ora #$20	                ora #$20
.d70d						_check_char:
.d70d		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d70f		d0 03		bne $d714	                bne _reset_tmp1
.d711		88		dey		                dey
.d712		10 ed		bpl $d701	                bpl _next_char
.d714						_reset_tmp1:
.d714		68		pla		                pla
.d715		85 26		sta $26		                sta tmp1+1
.d717		68		pla		                pla
.d718		85 25		sta $25		                sta tmp1
.d71a		98		tya		                tya             ; leave A = $FF on success
.d71b		c8		iny		                iny             ; if Y was $FF, we succeeded
.d71c		f0 11		beq $d72f	                beq _done
.d71e						_next_entry:
.d71e		a0 02		ldy #$02	                ldy #2
.d720		b1 25		lda ($25),y	                lda (tmp1),y
.d722		48		pha		                pha
.d723		c8		iny		                iny
.d724		b1 25		lda ($25),y	                lda (tmp1),y
.d726		85 26		sta $26		                sta tmp1+1
.d728		68		pla		                pla
.d729		85 25		sta $25		                sta tmp1
.d72b		05 26		ora $26		                ora tmp1+1
.d72d		d0 af		bne $d6de	                bne _loop
.d72f		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d731		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d732						compare_16bit:
.d732		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d734		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d736		f0 08		beq $d740	                beq _equal
.d738		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d73a		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d73c		70 08		bvs $d746	                bvs _overflow
.d73e		80 08		bra $d748	                bra _not_equal
.d740						_equal:
.d740		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d742		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d744		50 04		bvc $d74a	                bvc _done
.d746						_overflow:
.d746		49 80		eor #$80	                eor #$80                ; complement negative flag
.d748						_not_equal:
.d748		09 01		ora #$01	                ora #1                  ; set Z=0 since we're not equal
.d74a						_done:
.d74a		60		rts		                rts
.d74b						current_to_dp:
.d74b		a0 08		ldy #$08	                ldy #current_offset
.d74d		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d74f		0a		asl a		                asl             ; turn it into an offset (in cells)
.d750		18		clc		                clc
.d751		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d753		a8		tay		                tay
.d754		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d756		85 02		sta $02		                sta dp
.d758		c8		iny		                iny
.d759		b1 08		lda ($08),y	                lda (up),y
.d75b		85 03		sta $03		                sta dp+1
.d75d		60		rts		                rts
.d75e						dp_to_current:
.d75e		a0 08		ldy #$08	                ldy #current_offset
.d760		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d762		0a		asl a		                asl             ; turn it into an offset (in cells)
.d763		18		clc		                clc
.d764		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d766		a8		tay		                tay
.d767		a5 02		lda $02		                lda dp
.d769		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d76b		c8		iny		                iny
.d76c		a5 03		lda $03		                lda dp+1
.d76e		91 08		sta ($08),y	                sta (up),y
.d770		60		rts		                rts
.d771						interpret:
.d771						_loop:
.d771		20 4c 8d	jsr $8d4c	                jsr w_parse_name       ; ( "string" -- addr u )
.d774		b5 00		lda $00,x	                lda 0,x
.d776		15 01		ora $01,x	                ora 1,x
.d778		f0 5a		beq $d7d4	                beq _line_done
.d77a		20 c7 93	jsr $93c7	                jsr w_two_dup          ; ( addr u -- addr u addr u )
.d77d		20 85 9b	jsr $9b85	                jsr w_find_name        ; ( addr u addr u -- addr u nt|0 )
.d780		b5 00		lda $00,x	                lda 0,x
.d782		15 01		ora $01,x	                ora 1,x
.d784		d0 19		bne $d79f	                bne _got_name_token
.d786		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d787		e8		inx		                inx
.d788		20 3c 9d	jsr $9d3c	                jsr w_number           ; ( addr u -- u|d )
.d78b		a5 1a		lda $1a		                lda state
.d78d		f0 e2		beq $d771	                beq _loop
.d78f		a9 20		lda #$20	                lda #%00100000
.d791		24 1c		bit $1c		                bit status
.d793		d0 05		bne $d79a	                bne _double_number
.d795		20 fb 89	jsr $89fb	                jsr w_literal
.d798		80 d7		bra $d771	                bra _loop
.d79a						_double_number:
.d79a		20 f0 9f	jsr $9ff0	                jsr w_two_literal
.d79d		80 d2		bra $d771	                bra _loop
.d79f						_got_name_token:
.d79f		b5 00		lda $00,x	                lda 0,x
.d7a1		95 04		sta $04,x	                sta 4,x
.d7a3		b5 01		lda $01,x	                lda 1,x
.d7a5		95 05		sta $05,x	                sta 5,x
.d7a7		e8		inx		                inx
.d7a8		e8		inx		                inx
.d7a9		e8		inx		                inx
.d7aa		e8		inx		                inx                     ; ( nt )
.d7ab		20 91 86	jsr $8691	                jsr w_dup
.d7ae		20 e7 8c	jsr $8ce7	                jsr w_one_plus
.d7b1		a1 00		lda ($00,x)	                lda (0,x)
.d7b3		e8		inx		                inx
.d7b4		e8		inx		                inx
.d7b5		a4 1a		ldy $1a		                ldy state
.d7b7		d0 12		bne $d7cb	                bne _compile
.d7b9		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d7bb		f0 05		beq $d7c2	                beq _interpret
.d7bd		a9 02		lda #$02	                lda #err_compileonly
.d7bf		4c 08 d8	jmp $d808	                jmp error
.d7c2						_interpret:
.d7c2		20 d9 9c	jsr $9cd9	                jsr w_name_to_int      ; ( nt - xt )
.d7c5		20 fc 87	jsr $87fc	                jsr w_execute
.d7c8		4c 71 d7	jmp $d771	                jmp _loop
.d7cb						_compile:
.d7cb		29 02		and #$02	                and #IM                 ; Mask all but IM bit
.d7cd		d0 f3		bne $d7c2	                bne _interpret          ; IMMEDIATE word, execute right now
.d7cf		20 d5 96	jsr $96d5	                jsr compile_nt_comma
.d7d2		80 9d		bra $d771	                bra _loop
.d7d4						_line_done:
.d7d4		e8		inx		                inx
.d7d5		e8		inx		                inx
.d7d6		e8		inx		                inx
.d7d7		e8		inx		                inx
.d7d8		60		rts		                rts
.d7d9						is_printable:
.d7d9		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d7db		90 07		bcc $d7e4	                bcc _done
.d7dd		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d7df		b0 02		bcs $d7e3	                bcs _failed
.d7e1		38		sec		                sec
>d7e2		24				                .byte OpBITzp
.d7e3						_failed:
.d7e3		18		clc		                clc
.d7e4						_done:
.d7e4		60		rts		                rts
.d7e5						is_whitespace:
.d7e5		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d7e7		90 08		bcc $d7f1	                bcc _done
.d7e9		c9 21		cmp #$21	                cmp #AscSP+1
.d7eb		b0 03		bcs $d7f0	                bcs _failed
.d7ed		38		sec		                sec
.d7ee		80 01		bra $d7f1	                bra _done
.d7f0						_failed:
.d7f0		18		clc		                clc
.d7f1						_done:
.d7f1		60		rts		                rts
.d7f2						underflow_1:
.d7f2		e0 77		cpx #$77	                cpx #dsp0-1
.d7f4		10 10		bpl $d806	                bpl underflow_error
.d7f6		60		rts		                rts
.d7f7						underflow_2:
.d7f7		e0 75		cpx #$75	                cpx #dsp0-3
.d7f9		10 0b		bpl $d806	                bpl underflow_error
.d7fb		60		rts		                rts
.d7fc						underflow_3:
.d7fc		e0 73		cpx #$73	                cpx #dsp0-5
.d7fe		10 06		bpl $d806	                bpl underflow_error
.d800		60		rts		                rts
.d801						underflow_4:
.d801		e0 71		cpx #$71	                cpx #dsp0-7
.d803		10 01		bpl $d806	                bpl underflow_error
.d805		60		rts		                rts
.d806						underflow_error:
.d806		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d808						error:
.d808		48		pha		                pha                     ; save error
.d809		20 4b d8	jsr $d84b	                jsr print_error
.d80c		20 17 84	jsr $8417	                jsr w_cr
.d80f		68		pla		                pla
.d810		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d812		d0 17		bne $d82b	                bne _no_underflow
.d814		a9 0d		lda #$0d	                lda #err_returnstack
.d816		20 4b d8	jsr $d84b	                jsr print_error
.d819		ba		tsx		                tsx
.d81a						-
.d81a		e8		inx		                inx
.d81b		f0 0b		beq $d828	                beq +
.d81d		20 dd 91	jsr $91dd	                jsr w_space
.d820		bd 00 01	lda $0100,x	                lda $100,x
.d823		20 bf d6	jsr $d6bf	                jsr byte_to_ascii
.d826		80 f2		bra $d81a	                bra -
.d828						+
.d828		20 17 84	jsr $8417	                jsr w_cr
.d82b						_no_underflow:
.d82b		4c 5e 80	jmp $805e	                jmp w_abort            ; no jsr, as we clobber return stack
.d82e						print_string_no_lf:
.d82e		0a		asl a		                asl
.d82f		a8		tay		                tay
.d830		b9 6f d3	lda $d36f,y	                lda string_table,y
.d833		85 29		sta $29		                sta tmp3                ; LSB
.d835		b9 70 d3	lda $d370,y	                lda string_table+1,y
.d838		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d83a						print_common:
.d83a		a0 00		ldy #$00	                ldy #0
.d83c						_loop:
.d83c		b1 29		lda ($29),y	                lda (tmp3),y
.d83e		10 04		bpl $d844	                bpl +                           ; strings are high-bit terminated
.d840		29 7f		and #$7f	                and #$7f                        ; last character, clear high bit
.d842		a0 ff		ldy #$ff	                ldy #$ff                        ; flag end of loop
.d844						+
.d844		20 bb 86	jsr $86bb	                jsr emit_a                      ; allows vectoring via output
.d847		c8		iny		                iny
.d848		d0 f2		bne $d83c	                bne _loop
.d84a		60		rts		                rts
.d84b						print_error:
.d84b		0a		asl a		                asl
.d84c		a8		tay		                tay
.d84d		b9 2c d4	lda $d42c,y	                lda error_table,y
.d850		85 29		sta $29		                sta tmp3                        ; LSB
.d852		c8		iny		                iny
.d853		b9 2c d4	lda $d42c,y	                lda error_table,y
.d856		85 2a		sta $2a		                sta tmp3+1                      ; MSB
.d858		80 e0		bra $d83a	                bra print_common
.d85a						print_u:
.d85a		20 99 9e	jsr $9e99	                jsr w_zero                     ; 0
.d85d		20 d5 89	jsr $89d5	                jsr w_less_number_sign         ; <#
.d860		20 b1 8c	jsr $8cb1	                jsr w_number_sign_s            ; #S
.d863		20 8f 8c	jsr $8c8f	                jsr w_number_sign_greater      ; #>
.d866		4c dc 94	jmp $94dc	                jmp w_type                     ; JSR/RTS because never compiled
.d869						code_end:

;******  Return to file: platform/simulator.asm

=$f000						io_start = $f000                ; virtual hardware addresses for the simulators
>f000						                .byte ?
>f001						io_putc:        .byte ?         ; $f001     write byte to stdout
>f002						                .byte ?
>f003						io_kbhit:       .byte ?         ; $f003     read non-zero on key ready (c65 only)
>f004						io_getc:        .byte ?         ; $f004     non-blocking read input character (0 if no key)
>f005						                .byte ?
>f006						io_clk_start:   .byte ?         ; $f006     *read* to start cycle counter
>f007						io_clk_stop:    .byte ?         ; $f007     *read* to stop the cycle counter
>f008						io_clk_cycles:  .word ?,?       ; $f008-b   32-bit cycle count in NUXI order
>f00c						                .word ?,?
.f010						kernel_init:
.f010		78		sei		                sei             ; Disable interrupts
.f011		a2 00		ldx #$00	                ldx #0
.f013		bd 40 f0	lda $f040,x	-               lda s_kernel_id,x
.f016		f0 06		beq $f01e	                beq _done
.f018		20 22 f0	jsr $f022	                jsr kernel_putc
.f01b		e8		inx		                inx
.f01c		80 f5		bra $f013	                bra -
.f01e						_done:
.f01e		4c 00 80	jmp $8000	                jmp forth
.f021						kernel_bye:
.f021		00		brk #		                brk
.f022						kernel_putc:
.f022		8d 01 f0	sta $f001	                sta io_putc
.f025		60		rts		                rts

;******  Return to file: platform/platform-py65mon.asm

=$f002						io_bufc = io_putc+1
.f026						kernel_getc:
.f026		ad 02 f0	lda $f002	                lda io_bufc             ; first check the buffer
.f029		9c 02 f0	stz $f002	                stz io_bufc
.f02c		d0 05		bne $f033	                bne _done
.f02e						_loop:
.f02e		ad 04 f0	lda $f004	                lda io_getc
.f031		f0 fb		beq $f02e	                beq _loop
.f033						_done:
.f033		60		rts		                rts
.f034						kernel_kbhit:
.f034		ad 02 f0	lda $f002	                lda io_bufc             ; do we already have a character?
.f037		d0 06		bne $f03f	                bne _done
.f039		ad 04 f0	lda $f004	                lda io_getc             ; otherwise check and buffer the result
.f03c		8d 02 f0	sta $f002	                sta io_bufc
.f03f						_done:
.f03f		60		rts		                rts
.f040						s_kernel_id:
>f040		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f048		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f058		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f068		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		10 f0				v_nmi   .word kernel_init
>fffc		10 f0				v_reset .word kernel_init
>fffe		10 f0				v_irq   .word kernel_init

;******  End of listing
