
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Tue Jun 11 13:51:09 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../words/all.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 2d		lda #$2d	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd 40 b3	lda $b340,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad 40 b3	lda $b340	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f						_load_user_vars_loop:
.801f		b9 5e b3	lda $b35e,y	                lda cold_user_table,y
.8022		91 08		sta ($08),y	                sta (up),y
.8024		88		dey		                dey
.8025		d0 f8		bne $801f	                bne _load_user_vars_loop
.8027		ad 5e b3	lda $b35e	                lda cold_user_table
.802a		92 08		sta ($08)	                sta (up)
.802c		20 3a 84	jsr $843a	                jsr xt_cr
.802f		ca		dex		                dex
.8030		ca		dex		                dex
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		a9 41		lda #$41	                lda #<forth_words_start
.8035		95 02		sta $02,x	                sta 2,x
.8037		a9 ba		lda #$ba	                lda #>forth_words_start
.8039		95 03		sta $03,x	                sta 3,x
.803b		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803d		95 00		sta $00,x	                sta 0,x
.803f		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8041		95 01		sta $01,x	                sta 1,x
.8043		20 b2 88	jsr $88b2	                jsr xt_evaluate
.8046		9c 00 7c	stz $7c00	                stz hist_buff
.8049		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804c		9c 00 7d	stz $7d00	                stz hist_buff+$100
.804f		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8052		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8055		9c 80 7e	stz $7e80	                stz hist_buff+$280
.8058		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805b		9c 80 7f	stz $7f80	                stz hist_buff+$380
.805e						xt_abort:
.805e		a2 78		ldx #$78	                ldx #dsp0
.8060						xt_quit:
.8060		8a		txa		                txa             ; Save the DSP that we just defined
.8061		a2 ff		ldx #$ff	                ldx #rsp0
.8063		9a		txs		                txs
.8064		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8065		64 04		stz $04		                stz ip
.8067		64 05		stz $05		                stz ip+1
.8069		64 0a		stz $0a		                stz insrc
.806b		64 0b		stz $0b		                stz insrc+1
.806d		a9 00		lda #$00	                lda #0
.806f		a0 04		ldy #$04	                ldy #blk_offset
.8071		91 08		sta ($08),y	                sta (up),y
.8073		c8		iny		                iny
.8074		91 08		sta ($08),y	                sta (up),y
.8076		a9 fc		lda #$fc	                lda #(256-4)
.8078		85 1f		sta $1f		                sta loopctrl
.807a		64 1a		stz $1a		                stz state
.807c		64 1b		stz $1b		                stz state+1
.807e						_get_line:
.807e		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8080		85 0c		sta $0c		                sta cib
.8082		a9 02		lda #$02	                lda #>buffer0
.8084		85 0d		sta $0d		                sta cib+1
.8086		64 0e		stz $0e		                stz ciblen
.8088		64 0f		stz $0f		                stz ciblen+1
.808a		20 3e 8f	jsr $8f3e	                jsr xt_refill           ; ( -- f )
.808d		b5 00		lda $00,x	                lda 0,x
.808f		d0 05		bne $8096	                bne _success
.8091		a9 06		lda #$06	                lda #err_refill
.8093		4c 87 d7	jmp $d787	                jmp error
.8096						_success:
.8096		e8		inx		                inx                     ; drop
.8097		e8		inx		                inx
.8098		20 ee d6	jsr $d6ee	                jsr interpret
.809b		e0 78		cpx #$78	                cpx #dsp0
.809d		f0 05		beq $80a4	                beq _stack_ok
.809f		90 03		bcc $80a4	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a1		4c 85 d7	jmp $d785	                jmp underflow_error
.80a4						_stack_ok:
.80a4		a5 1a		lda $1a		                lda state
.80a6		f0 02		beq $80aa	                beq _print
.80a8		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80aa						_print:
.80aa		20 d8 d7	jsr $d7d8	                jsr print_string
.80ad		80 cf		bra $807e	                bra _get_line
.80af						z_cold:
.80af						z_abort:
.80af						z_quit:

;******  Processing file: platform/../words/core.asm

.80af						xt_abort_quote:
.80af		20 d6 8f	jsr $8fd6	                jsr xt_s_quote          ; S"
.80b2		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b4		a9 ba		lda #$ba	                lda #<abort_quote_runtime
.80b6		20 61 97	jsr $9761	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80b9		60		rts		z_abort_quote:  rts
.80ba						abort_quote_runtime:
.80ba		b5 04		lda $04,x	                lda 4,x
.80bc		15 05		ora $05,x	                ora 5,x
.80be		f0 09		beq $80c9	                beq _done       ; if FALSE, we're done
.80c0		20 c0 94	jsr $94c0	                jsr xt_type
.80c3		20 3a 84	jsr $843a	                jsr xt_cr
.80c6		4c 5e 80	jmp $805e	                jmp xt_abort    ; not JSR, so never come back
.80c9						_done:
.80c9		8a		txa		                txa
.80ca		18		clc		                clc
.80cb		69 06		adc #$06	                adc #6
.80cd		aa		tax		                tax
.80ce		60		rts		                rts
.80cf						xt_abs:
.80cf		20 71 d7	jsr $d771	                jsr underflow_1
.80d2						w_abs:
.80d2		b5 01		lda $01,x	                lda 1,x
.80d4		10 0d		bpl $80e3	                bpl _done       ; positive number, easy money!
.80d6		38		sec		                sec
.80d7		a9 00		lda #$00	                lda #0
.80d9		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80db		95 00		sta $00,x	                sta 0,x
.80dd		a9 00		lda #$00	                lda #0          ; MSB
.80df		f5 01		sbc $01,x	                sbc 1,x
.80e1		95 01		sta $01,x	                sta 1,x
.80e3						_done:
.80e3		60		rts		z_abs:          rts
.80e4						xt_accept:
.80e4		20 76 d7	jsr $d776	                jsr underflow_2
.80e7		b5 00		lda $00,x	                lda 0,x
.80e9		15 01		ora $01,x	                ora 1,x
.80eb		d0 09		bne $80f6	                bne _not_zero
.80ed		e8		inx		                inx
.80ee		e8		inx		                inx
.80ef		74 00		stz $00,x	                stz 0,x
.80f1		74 01		stz $01,x	                stz 1,x
.80f3		4c c2 81	jmp $81c2	                jmp accept_done
.80f6						_not_zero:
.80f6		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80f8		85 27		sta $27		                sta tmp2
.80fa		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fc		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.80fe		85 25		sta $25		                sta tmp1
.8100		b5 03		lda $03,x	                lda 3,x
.8102		85 26		sta $26		                sta tmp1+1
.8104		e8		inx		                inx
.8105		e8		inx		                inx
.8106		a0 00		ldy #$00	                ldy #0
.8108		a5 1c		lda $1c		                lda status
.810a		29 f7		and #$f7	                and #$F7
.810c		1a		inc a		                ina
.810d		09 08		ora #$08	                ora #%00001000
.810f		85 1c		sta $1c		                sta status
.8111						accept_loop:
.8111		20 b1 89	jsr $89b1	                jsr key_a
.8114		c9 0a		cmp #$0a	                cmp #AscLF
.8116		f0 20		beq $8138	                beq _eol
.8118		c9 0d		cmp #$0d	                cmp #AscCR
.811a		f0 1c		beq $8138	                beq _eol
.811c		c9 08		cmp #$08	                cmp #AscBS
.811e		f0 22		beq $8142	                beq _backspace
.8120		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8122		f0 1e		beq $8142	                beq _backspace
.8124		c9 10		cmp #$10	                cmp #AscCP
.8126		f0 36		beq $815e	                beq _ctrl_p
.8128		c9 0e		cmp #$0e	                cmp #AscCN
.812a		f0 44		beq $8170	                beq _ctrl_n
.812c		91 25		sta ($25),y	                sta (tmp1),y
.812e		c8		iny		                iny
.812f		20 c5 86	jsr $86c5	                jsr emit_a
.8132		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8134		d0 db		bne $8111	                bne accept_loop       ; fall through if buffer limit reached
.8136		80 03		bra $813b	                bra _buffer_full
.8138						_eol:
.8138		20 c7 91	jsr $91c7	                jsr xt_space    ; print final space
.813b						_buffer_full:
.813b		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813d		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.813f		4c c2 81	jmp $81c2	                jmp accept_done
.8142						_backspace:
.8142		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8144		d0 06		bne $814c	                bne +
.8146		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8148		20 c5 86	jsr $86c5	                jsr emit_a
.814b		c8		iny		                iny
.814c						+
.814c		88		dey		                dey
.814d		a9 08		lda #$08	                lda #AscBS      ; move back one
.814f		20 c5 86	jsr $86c5	                jsr emit_a
.8152		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8154		20 c5 86	jsr $86c5	                jsr emit_a
.8157		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8159		20 c5 86	jsr $86c5	                jsr emit_a
.815c		80 b3		bra $8111	                bra accept_loop
.815e						_ctrl_p:
.815e		a5 1c		lda $1c		                lda status
.8160		29 07		and #$07	                and #7
.8162		d0 08		bne $816c	                bne _ctrl_p_dec
.8164		a5 1c		lda $1c		                lda status
.8166		09 07		ora #$07	                ora #7
.8168		85 1c		sta $1c		                sta status
.816a		80 11		bra $817d	                bra _recall_history
.816c						_ctrl_p_dec:
.816c		c6 1c		dec $1c		                dec status
.816e		80 0d		bra $817d	                bra _recall_history
.8170						_ctrl_n:
.8170		a9 08		lda #$08	                lda #$8
.8172		24 1c		bit $1c		                bit status
.8174		d0 07		bne $817d	                bne _recall_history
.8176		a5 1c		lda $1c		                lda status
.8178		29 f7		and #$f7	                and #$F7
.817a		1a		inc a		               ina
.817b		85 1c		sta $1c		                sta status
.817d						_recall_history:
.817d		a9 08		lda #$08	                lda #%00001000
.817f		14 1c		trb $1c		                trb status
.8181		20 dd 81	jsr $81dd	                jsr accept_total_recall
.8184		a9 0d		lda #$0d	                lda #AscCR
.8186		20 c5 86	jsr $86c5	                jsr emit_a
.8189						input_clear:
.8189		c0 00		cpy #$00	                cpy #0
.818b		f0 08		beq $8195	                beq input_cleared
.818d		a9 20		lda #$20	                lda #AscSP
.818f		20 c5 86	jsr $86c5	                jsr emit_a
.8192		88		dey		                dey
.8193		80 f4		bra $8189	                bra input_clear
.8195						input_cleared:
.8195		a9 0d		lda #$0d	                lda #AscCR
.8197		20 c5 86	jsr $86c5	                jsr emit_a
.819a		b1 29		lda ($29),y	                lda (tmp3),y
.819c		85 1d		sta $1d		                sta status+1
.819e		e6 29		inc $29		                inc tmp3
.81a0		d0 02		bne $81a4	                bne +           ; Increment the upper byte on carry.
.81a2		e6 2a		inc $2a		                inc tmp3+1
.81a4						+
.81a4		a9 0d		lda #$0d	                lda #AscCR
.81a6		20 c5 86	jsr $86c5	                jsr emit_a
.81a9						_history_loop:
.81a9		c4 1d		cpy $1d		                cpy status+1
.81ab		d0 03		bne $81b0	                bne +
.81ad		4c 11 81	jmp $8111	                jmp accept_loop       ; Needs a long jump
.81b0						+
.81b0		c4 27		cpy $27		                cpy tmp2
.81b2		f0 0a		beq $81be	                beq _hist_filled_buffer
.81b4		b1 29		lda ($29),y	                lda (tmp3),y
.81b6		91 25		sta ($25),y	                sta (tmp1),y
.81b8		20 c5 86	jsr $86c5	                jsr emit_a
.81bb		c8		iny		                iny
.81bc		80 eb		bra $81a9	                bra _history_loop
.81be						_hist_filled_buffer:
.81be		88		dey		                dey
.81bf		4c 11 81	jmp $8111	                jmp accept_loop
.81c2						accept_done:
.81c2		20 dd 81	jsr $81dd	                jsr accept_total_recall
.81c5		85 1d		sta $1d		                sta status+1
.81c7		a0 00		ldy #$00	                ldy #0
.81c9		91 29		sta ($29),y	                sta (tmp3),y
.81cb		e6 29		inc $29		                inc tmp3
.81cd		d0 02		bne $81d1	                bne +           ; Increment the upper byte on carry.
.81cf		e6 2a		inc $2a		                inc tmp3+1
.81d1						+
.81d1						_save_history_loop:
.81d1		c4 1d		cpy $1d		                cpy status+1
.81d3		f0 07		beq $81dc	                beq _save_history_done
.81d5		b1 25		lda ($25),y	                lda (tmp1),y
.81d7		91 29		sta ($29),y	                sta (tmp3),y
.81d9		c8		iny		                iny
.81da		80 f5		bra $81d1	                bra _save_history_loop
.81dc						_save_history_done:
.81dc						z_accept:
.81dc		60		rts		                rts
.81dd						accept_total_recall:
.81dd		a9 00		lda #$00	                lda #<hist_buff
.81df		85 29		sta $29		                sta tmp3
.81e1		a9 7c		lda #$7c	                lda #>hist_buff
.81e3		85 2a		sta $2a		                sta tmp3+1
.81e5		a5 1c		lda $1c		                lda status
.81e7		6a		ror a		                ror
.81e8		29 03		and #$03	                and #3
.81ea		18		clc		                clc
.81eb		65 2a		adc $2a		                adc tmp3+1
.81ed		85 2a		sta $2a		                sta tmp3+1
.81ef		a5 1c		lda $1c		                lda status
.81f1		6a		ror a		                ror             ; Rotate through carry into msb.
.81f2		6a		ror a		                ror
.81f3		29 80		and #$80	                and #$80
.81f5		18		clc		                clc
.81f6		65 29		adc $29		                adc tmp3
.81f8		85 29		sta $29		                sta tmp3
.81fa		90 02		bcc $81fe	                bcc +           ; Increment the upper byte on carry.
.81fc		e6 2a		inc $2a		                inc tmp3+1
.81fe						+
.81fe		98		tya		                tya
.81ff		c9 80		cmp #$80	                cmp #$80
.8201		90 02		bcc $8205	                bcc +
.8203		a9 7f		lda #$7f	                lda #$7F
.8205						+
.8205		60		rts		                rts
.8206						xt_action_of:
.8206		a5 1a		lda $1a		                lda state
.8208		05 1b		ora $1b		                ora state+1
.820a		f0 0c		beq $8218	                beq _interpreting
.820c		20 14 83	jsr $8314	                jsr xt_bracket_tick
.820f		a0 85		ldy #$85	                ldy #>xt_defer_fetch
.8211		a9 44		lda #$44	                lda #<xt_defer_fetch
.8213		20 61 97	jsr $9761	                jsr cmpl_subroutine
.8216		80 06		bra $821e	                bra _done
.8218						_interpreting:
.8218		20 3e 92	jsr $923e	                jsr xt_tick
.821b		20 44 85	jsr $8544	                jsr xt_defer_fetch
.821e						_done:
.821e		60		rts		z_action_of:           rts
.821f						xt_again:
.821f		20 71 d7	jsr $d771	                jsr underflow_1
.8222		20 7a 97	jsr $977a	                jsr cmpl_jump_tos
.8225		60		rts		z_again:        rts
.8226						xt_align:
.8226						xt_aligned:
.8226						z_align:
.8226						z_aligned:
.8226		60		rts		                rts             ; stripped out during native compile
.8227						xt_allot:
.8227		20 71 d7	jsr $d771	                jsr underflow_1
.822a		b5 01		lda $01,x	                lda 1,x
.822c		30 22		bmi $8250	                bmi _release
.822e		18		clc		                clc
.822f		a5 00		lda $00		                lda cp
.8231		75 00		adc $00,x	                adc 0,x
.8233		85 00		sta $00		                sta cp
.8235		a5 01		lda $01		                lda cp+1
.8237		75 01		adc $01,x	                adc 1,x
.8239		85 01		sta $01		                sta cp+1
.823b		a0 00		ldy #$00	                ldy #<cp_end
.823d		c4 00		cpy $00		                cpy cp
.823f		a9 7c		lda #$7c	                lda #>cp_end
.8241		e5 01		sbc $01		                sbc cp+1
.8243		b0 48		bcs $828d	                bcs _done               ; we're fine.
.8245		84 00		sty $00		                sty cp                  ; still #<cp_end
.8247		a9 7c		lda #$7c	                lda #>cp_end
.8249		85 01		sta $01		                sta cp+1
.824b		a9 00		lda #$00	                lda #err_allot
.824d		4c 87 d7	jmp $d787	                jmp error
.8250						_release:
.8250		ca		dex		                dex
.8251		ca		dex		                dex
.8252		a5 00		lda $00		                lda cp
.8254		95 00		sta $00,x	                sta 0,x
.8256		a5 01		lda $01		                lda cp+1
.8258		95 01		sta $01,x	                sta 1,x
.825a		20 4f 8e	jsr $8e4f	                jsr xt_plus                     ; new CP is now TOS
.825d		ca		dex		                dex
.825e		ca		dex		                dex                             ; new CP now NOS
.825f		a9 00		lda #$00	                lda #<cp0
.8261		95 00		sta $00,x	                sta 0,x
.8263		a9 03		lda #$03	                lda #>cp0
.8265		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8267		20 af d6	jsr $d6af	                jsr compare_16bit               ; still ( CP CP0 )
.826a		f0 17		beq $8283	                beq _nega_done
.826c		30 15		bmi $8283	                bmi _nega_done
.826e		a9 00		lda #$00	                lda #<cp0
.8270		85 00		sta $00		                sta cp
.8272		a9 03		lda #$03	                lda #>cp0
.8274		85 01		sta $01		                sta cp+1
.8276		a9 23		lda #$23	                lda #<dictionary_start
.8278		85 02		sta $02		                sta dp
.827a		a9 bb		lda #$bb	                lda #>dictionary_start
.827c		85 03		sta $03		                sta dp+1
.827e		a9 0a		lda #$0a	                lda #err_negallot
.8280		4c 87 d7	jmp $d787	                jmp error
.8283						_nega_done:
.8283		b5 02		lda $02,x	                lda 2,x
.8285		85 00		sta $00		                sta cp
.8287		b5 03		lda $03,x	                lda 3,x
.8289		85 01		sta $01		                sta cp+1
.828b		e8		inx		                inx
.828c		e8		inx		                inx                     ; drop through to _done
.828d						_done:
.828d		e8		inx		                inx
.828e		e8		inx		                inx
.828f						z_allot:
.828f		60		rts		                rts
.8290						xt_and:
.8290		20 76 d7	jsr $d776	                jsr underflow_2
.8293		b5 00		lda $00,x	                lda 0,x
.8295		35 02		and $02,x	                and 2,x
.8297		95 02		sta $02,x	                sta 2,x
.8299		b5 01		lda $01,x	                lda 1,x
.829b		35 03		and $03,x	                and 3,x
.829d		95 03		sta $03,x	                sta 3,x
.829f		e8		inx		                inx
.82a0		e8		inx		                inx
.82a1		60		rts		z_and:          rts
.82a2						xt_at_xy:
.82a2		20 76 d7	jsr $d776	                jsr underflow_2
.82a5		a5 18		lda $18		                lda base
.82a7		48		pha		                pha
.82a8		a9 0a		lda #$0a	                lda #10
.82aa		85 18		sta $18		                sta base
.82ac		a9 1b		lda #$1b	                lda #AscESC
.82ae		20 c5 86	jsr $86c5	                jsr emit_a
.82b1		a9 5b		lda #$5b	                lda #'['
.82b3		20 c5 86	jsr $86c5	                jsr emit_a
.82b6		20 e5 8c	jsr $8ce5	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82b9		20 de d7	jsr $d7de	                jsr print_u
.82bc		a9 3b		lda #$3b	                lda #';'
.82be		20 c5 86	jsr $86c5	                jsr emit_a
.82c1		20 e5 8c	jsr $8ce5	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82c4		20 de d7	jsr $d7de	                jsr print_u
.82c7		a9 48		lda #$48	                lda #'H'
.82c9		20 c5 86	jsr $86c5	                jsr emit_a
.82cc		68		pla		                pla
.82cd		85 18		sta $18		                sta base
.82cf		60		rts		z_at_xy:        rts
.82d0						xt_backslash:
.82d0		a0 04		ldy #$04	                ldy #blk_offset
.82d2		b1 08		lda ($08),y	                lda (up),y
.82d4		c8		iny		                iny
.82d5		11 08		ora ($08),y	                ora (up),y
.82d7		f0 19		beq $82f2	                beq backslash_not_block
.82d9		a5 10		lda $10		                lda toin
.82db		29 3f		and #$3f	                and #$3F
.82dd		f0 1b		beq $82fa	                beq z_backslash
.82df		c9 01		cmp #$01	                cmp #$1
.82e1		f0 17		beq $82fa	                beq z_backslash
.82e3		a5 10		lda $10		                lda toin
.82e5		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.82e7		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.82e8		69 40		adc #$40	                adc #$40
.82ea		85 10		sta $10		                sta toin
.82ec		90 0c		bcc $82fa	                bcc z_backslash
.82ee		e6 11		inc $11		                inc toin+1
.82f0		80 08		bra $82fa	                bra z_backslash
.82f2						backslash_not_block:
.82f2		a5 0e		lda $0e		                lda ciblen
.82f4		85 10		sta $10		                sta toin
.82f6		a5 0f		lda $0f		                lda ciblen+1
.82f8		85 11		sta $11		                sta toin+1
.82fa		60		rts		z_backslash:    rts
.82fb						xt_base:
.82fb						w_base:
.82fb		ca		dex		                dex
.82fc		ca		dex		                dex
.82fd		a9 18		lda #$18	                lda #<base
.82ff		95 00		sta $00,x	                sta 0,x         ; LSB
.8301		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8303		60		rts		z_base:         rts
.8304						xt_bl:
.8304		ca		dex		                dex
.8305		ca		dex		                dex
.8306		a9 20		lda #$20	                lda #AscSP
.8308		95 00		sta $00,x	                sta 0,x
.830a		74 01		stz $01,x	                stz 1,x
.830c		60		rts		z_bl:           rts
.830d						xt_bracket_char:
.830d		20 53 83	jsr $8353	                jsr xt_char
.8310		20 f2 89	jsr $89f2	                jsr xt_literal
.8313		60		rts		z_bracket_char: rts
.8314						xt_bracket_tick:
.8314		20 3e 92	jsr $923e	                jsr xt_tick
.8317		20 f2 89	jsr $89f2	                jsr xt_literal
.831a		60		rts		z_bracket_tick: rts
.831b						xt_buffer_colon:
.831b		20 40 84	jsr $8440	                jsr xt_create
.831e		20 27 82	jsr $8227	                jsr xt_allot
.8321		60		rts		z_buffer_colon: rts
.8322						xt_c_comma:
.8322		20 71 d7	jsr $d771	                jsr underflow_1
.8325		b5 00		lda $00,x	                lda 0,x
.8327		20 71 97	jsr $9771	                jsr cmpl_a
.832a		e8		inx		                inx
.832b		e8		inx		                inx
.832c		60		rts		z_c_comma:      rts
.832d						xt_c_fetch:
.832d		20 71 d7	jsr $d771	                jsr underflow_1
.8330		a1 00		lda ($00,x)	                lda (0,x)
.8332		95 00		sta $00,x	                sta 0,x
.8334		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8336		60		rts		z_c_fetch:      rts
.8337						xt_c_store:
.8337		20 76 d7	jsr $d776	                jsr underflow_2
.833a		b5 02		lda $02,x	                lda 2,x
.833c		81 00		sta ($00,x)	                sta (0,x)
.833e		e8		inx		                inx
.833f		e8		inx		                inx
.8340		e8		inx		                inx
.8341		e8		inx		                inx
.8342		60		rts		z_c_store:      rts
.8343						xt_cell_plus:
.8343		20 71 d7	jsr $d771	                jsr underflow_1
.8346		f6 00		inc $00,x	                inc 0,x
.8348		d0 02		bne $834c	                bne +
.834a		f6 01		inc $01,x	                inc 1,x
.834c						+
.834c		f6 00		inc $00,x	                inc 0,x
.834e		d0 02		bne $8352	                bne _done
.8350		f6 01		inc $01,x	                inc 1,x
.8352						_done:
.8352		60		rts		z_cell_plus:    rts
.8353						xt_char:
.8353		20 4d 8d	jsr $8d4d	                jsr xt_parse_name
.8356		b5 00		lda $00,x	                lda 0,x
.8358		15 01		ora $01,x	                ora 1,x
.835a		d0 05		bne $8361	                bne _not_empty
.835c		a9 05		lda #$05	                lda #err_noname
.835e		4c 87 d7	jmp $d787	                jmp error
.8361						_not_empty:
.8361		e8		inx		                inx             ; drop number of characters, leave addr
.8362		e8		inx		                inx
.8363		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8365		95 00		sta $00,x	                sta 0,x
.8367		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8369		60		rts		z_char:         rts
.836a						xt_chars:
.836a		20 71 d7	jsr $d771	                jsr underflow_1
.836d		60		rts		z_chars:        rts
.836e						xt_colon:
.836e		a5 1a		lda $1a		                lda state
.8370		05 1b		ora $1b		                ora state+1
.8372		f0 05		beq $8379	                beq +
.8374		a9 07		lda #$07	                lda #err_state
.8376		4c 87 d7	jmp $d787	                jmp error
.8379						+
.8379		c6 1a		dec $1a		                dec state
.837b		c6 1b		dec $1b		                dec state+1
.837d		a9 40		lda #$40	                lda #%01000000
.837f		04 1c		tsb $1c		                tsb status
.8381		20 c8 d6	jsr $d6c8	                jsr current_to_dp
.8384		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8386		48		pha		                pha
.8387		a5 02		lda $02		                lda dp
.8389		48		pha		                pha
.838a		a9 80		lda #$80	                lda #%10000000
.838c		04 1c		tsb $1c		                tsb status
.838e		20 40 84	jsr $8440	                jsr xt_create
.8391		20 c8 d6	jsr $d6c8	                jsr current_to_dp   ; This might be able to be omitted
.8394		a5 02		lda $02		                lda dp
.8396		85 06		sta $06		                sta workword
.8398		a5 03		lda $03		                lda dp+1
.839a		85 07		sta $07		                sta workword+1
.839c		68		pla		                pla
.839d		85 02		sta $02		                sta dp
.839f		68		pla		                pla
.83a0		85 03		sta $03		                sta dp+1
.83a2		20 db d6	jsr $d6db	                jsr dp_to_current
.83a5		a5 00		lda $00		                lda cp
.83a7		38		sec		                sec
.83a8		e9 03		sbc #$03	                sbc #3
.83aa		85 00		sta $00		                sta cp
.83ac		b0 02		bcs $83b0	                bcs _done
.83ae		c6 01		dec $01		                dec cp+1
.83b0						_done:
.83b0		60		rts		z_colon:        rts
.83b1						xt_colon_noname:
.83b1		a5 1a		lda $1a		                lda state
.83b3		05 1b		ora $1b		                ora state+1
.83b5		f0 05		beq $83bc	                beq +
.83b7		a9 07		lda #$07	                lda #err_state
.83b9		4c 87 d7	jmp $d787	                jmp error
.83bc						+
.83bc		c6 1a		dec $1a		                dec state
.83be		c6 1b		dec $1b		                dec state+1
.83c0		a9 40		lda #$40	                lda #%01000000
.83c2		14 1c		trb $1c		                trb status
.83c4		a5 00		lda $00		                lda cp
.83c6		85 06		sta $06		                sta workword
.83c8		a5 01		lda $01		                lda cp+1
.83ca		85 07		sta $07		                sta workword+1
.83cc		60		rts		z_colon_noname:        rts
.83cd						xt_comma:
.83cd		20 71 d7	jsr $d771	                jsr underflow_1
.83d0		a0 02		ldy #$02	                ldy #2
.83d2		b5 00		lda $00,x	_twice:         lda 0,x
.83d4		20 71 97	jsr $9771	                jsr cmpl_a
.83d7		e8		inx		                inx
.83d8		88		dey		                dey
.83d9		d0 f7		bne $83d2	                bne _twice
.83db		60		rts		z_comma:        rts
.83dc						xt_compile_only:
.83dc		20 c8 d6	jsr $d6c8	                jsr current_to_dp
.83df		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.83e1		b1 02		lda ($02),y	                lda (dp),y
.83e3		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.83e5		91 02		sta ($02),y	                sta (dp),y
.83e7		60		rts		z_compile_only: rts
.83e8						xt_value:
.83e8						xt_constant:
.83e8		20 71 d7	jsr $d771	                jsr underflow_1
.83eb		20 40 84	jsr $8440	                jsr xt_create
.83ee		38		sec		                sec
.83ef		a5 00		lda $00		                lda cp
.83f1		e9 02		sbc #$02	                sbc #2
.83f3		85 25		sta $25		                sta tmp1
.83f5		a5 01		lda $01		                lda cp+1
.83f7		e9 00		sbc #$00	                sbc #0
.83f9		85 26		sta $26		                sta tmp1+1
.83fb		a9 d9		lda #$d9	                lda #<doconst           ; LSB of DOCONST
.83fd		92 25		sta ($25)	                sta (tmp1)
.83ff		a0 01		ldy #$01	                ldy #1
.8401		a9 d5		lda #$d5	                lda #>doconst           ; MSB of DOCONST
.8403		91 25		sta ($25),y	                sta (tmp1),y
.8405		20 cd 83	jsr $83cd	                jsr xt_comma            ; drop through to adjust_z
.8408						adjust_z:
.8408		20 00 9c	jsr $9c00	                jsr xt_latestnt         ; gives us ( -- nt )
.840b		b5 00		lda $00,x	                lda 0,x
.840d		85 25		sta $25		                sta tmp1
.840f		b5 01		lda $01,x	                lda 1,x
.8411		85 26		sta $26		                sta tmp1+1
.8413		a0 06		ldy #$06	                ldy #6
.8415		b1 25		lda ($25),y	                lda (tmp1),y
.8417		18		clc		                clc
.8418		69 02		adc #$02	                adc #2
.841a		91 25		sta ($25),y	                sta (tmp1),y
.841c		c8		iny		                iny
.841d		b1 25		lda ($25),y	                lda (tmp1),y
.841f		69 00		adc #$00	                adc #0                  ; only need carry
.8421		91 25		sta ($25),y	                sta (tmp1),y
.8423		e8		inx		                inx
.8424		e8		inx		                inx
.8425						z_value:
.8425		60		rts		z_constant:     rts
.8426						xt_count:
.8426		20 71 d7	jsr $d771	                jsr underflow_1
.8429		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.842b		a8		tay		                tay
.842c		f6 00		inc $00,x	                inc 0,x         ; LSB
.842e		d0 02		bne $8432	                bne +
.8430		f6 01		inc $01,x	                inc 1,x         ; MSB
.8432		98		tya		+               tya
.8433		ca		dex		                dex
.8434		ca		dex		                dex
.8435		95 00		sta $00,x	                sta 0,x         ; LSB
.8437		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8439		60		rts		z_count:        rts
.843a						xt_cr:
.843a		a9 0a		lda #$0a	                lda #AscLF
.843c		20 c5 86	jsr $86c5	                jsr emit_a
.843f		60		rts		z_cr:           rts
.8440						xt_create:
.8440		20 4d 8d	jsr $8d4d	                jsr xt_parse_name       ; ( addr u )
.8443		b5 00		lda $00,x	                lda 0,x
.8445		15 01		ora $01,x	                ora 1,x
.8447		d0 05		bne $844e	                bne _got_name
.8449		a9 05		lda #$05	                lda #err_noname
.844b		4c 87 d7	jmp $d787	                jmp error
.844e						_got_name:
.844e		74 01		stz $01,x	                stz 1,x
.8450		20 ab 93	jsr $93ab	                jsr xt_two_dup          ; ( addr u addr u )
.8453		20 d7 9a	jsr $9ad7	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8456		b5 00		lda $00,x	                lda 0,x
.8458		15 01		ora $01,x	                ora 1,x
.845a		f0 1e		beq $847a	                beq _new_name           ; We haven't seen this one before.
.845c		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.845d		e8		inx		                inx
.845e		24 1c		bit $1c		                bit status
.8460		10 08		bpl $846a	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8462		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8464		05 1c		ora $1c		                ora status
.8466		85 1c		sta $1c		                sta status
.8468		80 18		bra $8482	                bra _process_name
.846a						_redefined_name:
.846a		a9 02		lda #$02	                lda #str_redefined
.846c		20 ad d7	jsr $d7ad	                jsr print_string_no_lf
.846f		20 ab 93	jsr $93ab	                jsr xt_two_dup           ; ( addr u addr u )
.8472		20 c0 94	jsr $94c0	                jsr xt_type
.8475		20 c7 91	jsr $91c7	                jsr xt_space
.8478		80 08		bra $8482	                bra _process_name
.847a						_new_name:
.847a		e8		inx		                inx                     ; Drop flag (0) from find-name.
.847b		e8		inx		                inx
.847c		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.847e		25 1c		and $1c		                and status
.8480		85 1c		sta $1c		                sta status
.8482						_process_name:
.8482		b5 00		lda $00,x	                lda 0,x
.8484		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.8486		a5 00		lda $00		                lda cp
.8488		85 25		sta $25		                sta tmp1
.848a		a5 01		lda $01		                lda cp+1
.848c		85 26		sta $26		                sta tmp1+1
.848e		b5 00		lda $00,x	                lda 0,x
.8490		18		clc		                clc
.8491		69 08		adc #$08	                adc #8
.8493		85 29		sta $29		                sta tmp3                ; total header length
.8495		95 00		sta $00,x	                sta 0,x
.8497		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.8499		20 27 82	jsr $8227	                jsr xt_allot    ; ( addr )
.849c		20 c8 d6	jsr $d6c8	                jsr current_to_dp
.849f		a0 00		ldy #$00	                ldy #0
.84a1		a5 27		lda $27		                lda tmp2
.84a3		91 25		sta ($25),y	                sta (tmp1),y
.84a5		a9 08		lda #$08	                lda #NN
.84a7		09 20		ora #$20	                ora #HC
.84a9		c8		iny		                iny
.84aa		91 25		sta ($25),y	                sta (tmp1),y
.84ac		c8		iny		                iny
.84ad		a5 02		lda $02		                lda dp
.84af		91 25		sta ($25),y	                sta (tmp1),y
.84b1		c8		iny		                iny
.84b2		a5 03		lda $03		                lda dp+1
.84b4		91 25		sta ($25),y	                sta (tmp1),y
.84b6		c8		iny		                iny
.84b7		a5 26		lda $26		                lda tmp1+1
.84b9		85 03		sta $03		                sta dp+1
.84bb		a5 25		lda $25		                lda tmp1
.84bd		85 02		sta $02		                sta dp
.84bf		18		clc		                clc
.84c0		65 29		adc $29		                adc tmp3        ; add total header length
.84c2		91 25		sta ($25),y	                sta (tmp1),y
.84c4		48		pha		                pha             ; we need this in the next step
.84c5		c8		iny		                iny
.84c6		a5 26		lda $26		                lda tmp1+1
.84c8		69 00		adc #$00	                adc #0          ; only need the carry
.84ca		91 25		sta ($25),y	                sta (tmp1),y
.84cc		c8		iny		                iny
.84cd		68		pla		                pla             ; LSB of "z_" address
.84ce		18		clc		                clc
.84cf		69 03		adc #$03	                adc #3
.84d1		91 25		sta ($25),y	                sta (tmp1),y
.84d3		88		dey		                dey             ; get the MSB of xt back
.84d4		b1 25		lda ($25),y	                lda (tmp1),y
.84d6		69 00		adc #$00	                adc #0          ; only need the carry
.84d8		c8		iny		                iny
.84d9		c8		iny		                iny
.84da		91 25		sta ($25),y	                sta (tmp1),y
.84dc		c8		iny		                iny
.84dd		b5 00		lda $00,x	                lda 0,x
.84df		38		sec		                sec
.84e0		e9 08		sbc #$08	                sbc #8
.84e2		85 23		sta $23		                sta tmptos
.84e4		b5 01		lda $01,x	                lda 1,x
.84e6		e9 00		sbc #$00	                sbc #0          ; only need carry
.84e8		85 24		sta $24		                sta tmptos+1
.84ea						_name_loop:
.84ea		b1 23		lda ($23),y	                lda (tmptos),y
.84ec		c9 5b		cmp #$5b	                cmp #'Z'+1
.84ee		b0 06		bcs $84f6	                bcs _store_name
.84f0		c9 41		cmp #$41	                cmp #'A'
.84f2		90 02		bcc $84f6	                bcc _store_name
.84f4		09 20		ora #$20	                ora #$20
.84f6						_store_name:
.84f6		91 25		sta ($25),y	                sta (tmp1),y
.84f8		c8		iny		                iny
.84f9		c6 27		dec $27		                dec tmp2
.84fb		d0 ed		bne $84ea	                bne _name_loop
.84fd		a0 d6		ldy #$d6	                ldy #>dovar
.84ff		a9 1f		lda #$1f	                lda #<dovar
.8501		20 61 97	jsr $9761	                jsr cmpl_subroutine
.8504		20 db d6	jsr $d6db	                jsr dp_to_current
.8507		e8		inx		                inx
.8508		e8		inx		                inx
.8509		60		rts		z_create:       rts
.850a						xt_decimal:
.850a		a9 0a		lda #$0a	                lda #10
.850c		85 18		sta $18		                sta base
.850e		64 19		stz $19		                stz base+1              ; paranoid
.8510		60		rts		z_decimal:      rts
.8511						xt_defer:
.8511		20 40 84	jsr $8440	                jsr xt_create
.8514		a5 00		lda $00		                lda cp          ; LSB
.8516		38		sec		                sec
.8517		e9 02		sbc #$02	                sbc #2
.8519		85 25		sta $25		                sta tmp1
.851b		a5 01		lda $01		                lda cp+1        ; MSB
.851d		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.851f		85 26		sta $26		                sta tmp1+1
.8521		a0 00		ldy #$00	                ldy #0
.8523		a9 ed		lda #$ed	                lda #<dodefer   ; LSB
.8525		91 25		sta ($25),y	                sta (tmp1),y
.8527		c8		iny		                iny
.8528		a9 d5		lda #$d5	                lda #>dodefer   ; MSB
.852a		91 25		sta ($25),y	                sta (tmp1),y
.852c		a9 01		lda #$01	                lda #<defer_error
.852e		92 00		sta ($00)	                sta (cp)
.8530		e6 00		inc $00		                inc cp
.8532		d0 02		bne $8536	                bne +
.8534		e6 01		inc $01		                inc cp+1
.8536						+
.8536		a9 d6		lda #$d6	                lda #>defer_error
.8538		92 00		sta ($00)	                sta (cp)
.853a		e6 00		inc $00		                inc cp
.853c		d0 02		bne $8540	                bne +
.853e		e6 01		inc $01		                inc cp+1
.8540						+
.8540		20 08 84	jsr $8408	                jsr adjust_z    ; adjust header to correct length
.8543		60		rts		z_defer:        rts
.8544						xt_defer_fetch:
.8544		20 9a 92	jsr $929a	                jsr xt_to_body
.8547		20 1a 88	jsr $881a	                jsr xt_fetch
.854a		60		rts		z_defer_fetch:  rts
.854b						xt_defer_store:
.854b		20 9a 92	jsr $929a	                jsr xt_to_body
.854e		20 14 92	jsr $9214	                jsr xt_store
.8551		60		rts		z_defer_store:  rts
.8552						xt_depth:
.8552		a9 78		lda #$78	                lda #dsp0
.8554		86 1e		stx $1e		                stx tmpdsp
.8556		38		sec		                sec
.8557		e5 1e		sbc $1e		                sbc tmpdsp
.8559		4a		lsr a		                lsr
.855a		ca		dex		                dex
.855b		ca		dex		                dex
.855c		95 00		sta $00,x	                sta 0,x
.855e		74 01		stz $01,x	                stz 1,x
.8560		60		rts		z_depth:        rts
.8561						xt_question_do:
.8561		ca		dex		                dex
.8562		ca		dex		                dex
.8563		a9 a4		lda #$a4	                lda #<question_do_runtime
.8565		95 00		sta $00,x	                sta 0,x
.8567		a9 85		lda #$85	                lda #>question_do_runtime
.8569		95 01		sta $01,x	                sta 1,x
.856b		20 a0 86	jsr $86a0	                jsr xt_dup              ; xt and xt' are the same
.856e		ca		dex		                dex
.856f		ca		dex		                dex
.8570		a9 10		lda #$10	                lda #question_do_runtime_size
.8572		95 00		sta $00,x	                sta 0,x
.8574		74 01		stz $01,x	                stz 1,x
.8576		20 2f 97	jsr $972f	                jsr cmpl_by_limit
.8579		90 0b		bcc $8586	                bcc _native
.857b		20 1b 89	jsr $891b	                jsr xt_here
.857e		20 d8 9d	jsr $9dd8	                jsr xt_zero
.8581		20 cd 83	jsr $83cd	                jsr xt_comma
.8584		80 08		bra $858e	                bra do_common
.8586						_native:
.8586		20 82 97	jsr $9782	                jsr cmpl_jump_later
.8589		80 03		bra $858e	                bra do_common
.858b						xt_do:
.858b		20 d8 9d	jsr $9dd8	                jsr xt_zero             ; push 0 TOS
.858e						do_common:
.858e		ca		dex		                dex
.858f		ca		dex		                dex
.8590		a5 21		lda $21		                lda loopleave
.8592		95 00		sta $00,x	                sta 0,x
.8594		a5 22		lda $22		                lda loopleave+1
.8596		95 01		sta $01,x	                sta 1,x
.8598		64 22		stz $22		                stz loopleave+1
.859a		a0 85		ldy #$85	                ldy #>do_runtime
.859c		a9 bc		lda #$bc	                lda #<do_runtime
.859e		20 61 97	jsr $9761	                jsr cmpl_subroutine
.85a1		4c 1b 89	jmp $891b	                jmp xt_here
.85a4						z_question_do:
.85a4						z_do:
.85a4						question_do_runtime:
.85a4		b5 00		lda $00,x	                lda 0,x
.85a6		d5 02		cmp $02,x	                cmp 2,x
.85a8		d0 0d		bne $85b7	                bne _begin
.85aa		b5 01		lda $01,x	                lda 1,x
.85ac		d5 03		cmp $03,x	                cmp 3,x
.85ae		d0 07		bne $85b7	                bne _begin
.85b0		e8		inx		                inx                     ; drop loop limits and skip
.85b1		e8		inx		                inx
.85b2		e8		inx		                inx
.85b3		e8		inx		                inx
=16						question_do_runtime_size = * - question_do_runtime
.85b4		a9 00		lda #$00	                lda #0
>85b6		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.85b7		a9 01		lda #$01	_begin:         lda #1
.85b9		4c 1b 98	jmp $981b	                jmp zbranch_runtime
.85bc						do_runtime:
.85bc		a4 1f		ldy $1f		                ldy loopctrl
.85be		30 05		bmi $85c5	                bmi +                   ; is this the first LCB?
.85c0		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.85c2		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.85c5						+
.85c5		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.85c6		c8		iny		                iny
.85c7		c8		iny		                iny
.85c8		c8		iny		                iny
.85c9		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.85cb		38		sec		                sec
.85cc		a9 00		lda #$00	                lda #0
.85ce		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.85d0		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.85d3		a9 80		lda #$80	                lda #$80
.85d5		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.85d7		99 03 01	sta $0103,y	                sta loopfufa+1,y
.85da		18		clc		                clc
.85db		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.85dd		79 02 01	adc $0102,y	                adc loopfufa,y
.85e0		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.85e2		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.85e4		79 03 01	adc $0103,y	                adc loopfufa+1,y
.85e7		99 01 01	sta $0101,y	                sta loopindex+1,y
.85ea		e8		inx		                inx                 ; clean up the stack
.85eb		e8		inx		                inx
.85ec		e8		inx		                inx
.85ed		e8		inx		                inx
.85ee		60		rts		                rts
.85ef						xt_does:
.85ef		a0 85		ldy #$85	                ldy #>does_runtime
.85f1		a9 fe		lda #$fe	                lda #<does_runtime
.85f3		20 61 97	jsr $9761	                jsr cmpl_subroutine
.85f6		a0 d6		ldy #$d6	                ldy #>dodoes
.85f8		a9 06		lda #$06	                lda #<dodoes
.85fa		20 61 97	jsr $9761	                jsr cmpl_subroutine
.85fd		60		rts		z_does:         rts
.85fe						does_runtime:
.85fe		7a		ply		                ply             ; LSB
.85ff		68		pla		                pla             ; MSB
.8600		c8		iny		                iny
.8601		d0 01		bne $8604	                bne +
.8603		1a		inc a		                ina
.8604						+
.8604		84 25		sty $25		                sty tmp1
.8606		85 26		sta $26		                sta tmp1+1
.8608		20 c8 d6	jsr $d6c8	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.860b		a5 02		lda $02		                lda dp
.860d		18		clc		                clc
.860e		69 04		adc #$04	                adc #4
.8610		85 27		sta $27		                sta tmp2
.8612		a5 03		lda $03		                lda dp+1
.8614		69 00		adc #$00	                adc #0          ; we only care about the carry
.8616		85 28		sta $28		                sta tmp2+1
.8618		b2 27		lda ($27)	                lda (tmp2)
.861a		18		clc		                clc
.861b		69 01		adc #$01	                adc #1
.861d		85 29		sta $29		                sta tmp3
.861f		a0 01		ldy #$01	                ldy #1
.8621		b1 27		lda ($27),y	                lda (tmp2),y
.8623		69 00		adc #$00	                adc #0          ; we only care about the carry
.8625		85 2a		sta $2a		                sta tmp3+1
.8627		a5 25		lda $25		                lda tmp1        ; LSB
.8629		92 29		sta ($29)	                sta (tmp3)
.862b		a5 26		lda $26		                lda tmp1+1
.862d		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.862f		60		rts		                rts
.8630						xt_dot:
.8630		20 71 d7	jsr $d771	                jsr underflow_1
.8633						w_dot:
.8633		20 a3 86	jsr $86a3	                jsr w_dup                      ; ( n n )
.8636		20 d2 80	jsr $80d2	                jsr w_abs                      ; ( n u )
.8639		20 d8 9d	jsr $9dd8	                jsr w_zero                     ; ( n u 0 )
.863c		20 cf 89	jsr $89cf	                jsr w_less_number_sign         ; ( n u 0 )
.863f		20 b2 8c	jsr $8cb2	                jsr w_number_sign_s            ; ( n ud )
.8642		20 90 8f	jsr $8f90	                jsr w_rot                      ; ( ud n )
.8645		20 4f 91	jsr $914f	                jsr w_sign                     ; ( ud )
.8648		20 90 8c	jsr $8c90	                jsr w_number_sign_greater      ; ( addr u )
.864b		20 c3 94	jsr $94c3	                jsr w_type
.864e		20 c7 91	jsr $91c7	                jsr w_space
.8651		60		rts		z_dot:          rts
.8652						xt_dot_paren:
.8652		ca		dex		                dex
.8653		ca		dex		                dex
.8654		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8656		95 00		sta $00,x	                sta 0,x
.8658		74 01		stz $01,x	                stz 1,x
.865a		20 a8 8d	jsr $8da8	                jsr xt_parse
.865d		20 c0 94	jsr $94c0	                jsr xt_type
.8660		60		rts		z_dot_paren:    rts
.8661						xt_dot_quote:
.8661		20 d6 8f	jsr $8fd6	                jsr xt_s_quote
.8664		a0 94		ldy #$94	                ldy #>xt_type
.8666		a9 c0		lda #$c0	                lda #<xt_type
.8668		20 61 97	jsr $9761	                jsr cmpl_subroutine
.866b		60		rts		z_dot_quote:    rts
.866c						xt_dot_r:
.866c		20 76 d7	jsr $d776	                jsr underflow_2
.866f		20 68 93	jsr $9368	                jsr xt_to_r
.8672		20 a0 86	jsr $86a0	                jsr xt_dup
.8675		20 cf 80	jsr $80cf	                jsr xt_abs
.8678		20 d8 9d	jsr $9dd8	                jsr xt_zero
.867b		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.867e		20 af 8c	jsr $8caf	                jsr xt_number_sign_s
.8681		20 8d 8f	jsr $8f8d	                jsr xt_rot
.8684		20 4c 91	jsr $914c	                jsr xt_sign
.8687		20 8d 8c	jsr $8c8d	                jsr xt_number_sign_greater
.868a		20 ec 8e	jsr $8eec	                jsr xt_r_from
.868d		20 01 8d	jsr $8d01	                jsr xt_over
.8690		20 e4 8b	jsr $8be4	                jsr xt_minus
.8693		20 cd 91	jsr $91cd	                jsr xt_spaces
.8696		20 c0 94	jsr $94c0	                jsr xt_type
.8699		60		rts		z_dot_r:        rts
.869a						xt_drop:
.869a		20 71 d7	jsr $d771	                jsr underflow_1
.869d		e8		inx		                inx
.869e		e8		inx		                inx
.869f		60		rts		z_drop:         rts
.86a0						xt_dup:
.86a0		20 71 d7	jsr $d771	                jsr underflow_1
.86a3						w_dup:
.86a3		ca		dex		                dex
.86a4		ca		dex		                dex
.86a5		b5 02		lda $02,x	                lda 2,x         ; LSB
.86a7		95 00		sta $00,x	                sta 0,x
.86a9		b5 03		lda $03,x	                lda 3,x         ; MSB
.86ab		95 01		sta $01,x	                sta 1,x
.86ad		60		rts		z_dup:          rts
.86ae						xt_else:
.86ae						xt_endof:
.86ae		20 82 97	jsr $9782	                jsr cmpl_jump_later
.86b1		20 2a 92	jsr $922a	                jsr xt_swap         ; ( target orig )
.86b4						xt_then:
.86b4		20 1b 89	jsr $891b	                jsr xt_here
.86b7		20 2a 92	jsr $922a	                jsr xt_swap
.86ba		20 14 92	jsr $9214	                jsr xt_store
.86bd						z_else:
.86bd						z_endof:
.86bd		60		rts		z_then:         rts
.86be						xt_emit:
.86be		20 71 d7	jsr $d771	                jsr underflow_1
.86c1		b5 00		lda $00,x	                lda 0,x
.86c3		e8		inx		                inx
.86c4		e8		inx		                inx
.86c5						emit_a:
.86c5		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.86c8						z_emit:
.86c8						xt_endcase:
.86c8		a0 86		ldy #$86	                ldy #>xt_drop
.86ca		a9 9a		lda #$9a	                lda #<xt_drop
.86cc		20 61 97	jsr $9761	                jsr cmpl_subroutine
.86cf						_endcase_loop:
.86cf		b5 00		lda $00,x	                lda 0,x
.86d1		15 01		ora $01,x	                ora 1,x
.86d3		f0 05		beq $86da	                beq _done
.86d5		20 b4 86	jsr $86b4	                jsr xt_then
.86d8		80 f5		bra $86cf	                bra _endcase_loop
.86da						_done:
.86da		e8		inx		                inx
.86db		e8		inx		                inx
.86dc		60		rts		z_endcase:      rts
.86dd						xt_environment_q:
.86dd		20 71 d7	jsr $d771	                jsr underflow_1
.86e0		a0 00		ldy #$00	                ldy #00                 ; counter for table
.86e2		5a		phy		                phy
.86e3						_table_loop:
.86e3		20 ab 93	jsr $93ab	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.86e6		ca		dex		                dex
.86e7		ca		dex		                dex                     ; ( addr u addr u ? )
.86e8		b9 5a 87	lda $875a,y	                lda env_table_single,y
.86eb		95 00		sta $00,x	                sta 0,x
.86ed		c8		iny		                iny
.86ee		b9 5a 87	lda $875a,y	                lda env_table_single,y
.86f1		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.86f3		c8		iny		                iny
.86f4		15 00		ora $00,x	                ora 0,x
.86f6		f0 4d		beq $8745	                beq _table_done
.86f8		5a		phy		                phy                     ; save Y, which is used by COUNT
.86f9		20 26 84	jsr $8426	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.86fc		20 9f 9f	jsr $9f9f	                jsr xt_compare          ; ( addr u f )
.86ff		7a		ply		                ply
.8700		b5 00		lda $00,x	                lda 0,x
.8702		15 01		ora $01,x	                ora 1,x
.8704		f0 04		beq $870a	                beq _got_result
.8706		e8		inx		                inx                     ; DROP, now ( addr u )
.8707		e8		inx		                inx
.8708		80 d9		bra $86e3	                bra _table_loop
.870a						_got_result:
.870a		e8		inx		                inx                     ; drop flag, now ( addr u )
.870b		e8		inx		                inx
.870c		88		dey		                dey                     ; go back to index we had
.870d		88		dey		                dey
.870e		68		pla		                pla
.870f		d0 0d		bne $871e	                bne _double_result
.8711		b9 78 87	lda $8778,y	                lda env_results_single,y
.8714		95 02		sta $02,x	                sta 2,x
.8716		c8		iny		                iny
.8717		b9 78 87	lda $8778,y	                lda env_results_single,y
.871a		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.871c		80 1f		bra $873d	                bra _set_flag
.871e						_double_result:
.871e		ca		dex		                dex                     ; ( addr u ? )
.871f		ca		dex		                dex
.8720		98		tya		                tya
.8721		38		sec		                sec
.8722		e9 18		sbc #$18	                sbc #24
.8724		0a		asl a		                asl
.8725		a8		tay		                tay
.8726		b9 8e 87	lda $878e,y	                lda env_results_double,y
.8729		95 02		sta $02,x	                sta 2,x
.872b		c8		iny		                iny
.872c		b9 8e 87	lda $878e,y	                lda env_results_double,y
.872f		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8731		c8		iny		                iny
.8732		b9 8e 87	lda $878e,y	                lda env_results_double,y
.8735		95 04		sta $04,x	                sta 4,x
.8737		c8		iny		                iny
.8738		b9 8e 87	lda $878e,y	                lda env_results_double,y
.873b		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.873d						_set_flag:
.873d		a9 ff		lda #$ff	                lda #$FF
.873f		95 00		sta $00,x	                sta 0,x
.8741		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8743		80 14		bra $8759	                bra _done
.8745						_table_done:
.8745		68		pla		                pla
.8746		d0 09		bne $8751	                bne _no_match
.8748		1a		inc a		                ina
.8749		48		pha		                pha
.874a		8a		txa		                txa
.874b		18		clc		                clc
.874c		69 06		adc #$06	                adc #6                  ; skip six bytes
.874e		aa		tax		                tax                     ; ( addr u )
.874f		80 92		bra $86e3	                bra _table_loop
.8751						_no_match:
.8751		8a		txa		                txa
.8752		18		clc		                clc
.8753		69 0a		adc #$0a	                adc #10
.8755		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8756		20 d8 9d	jsr $9dd8	                jsr xt_false
.8759						_done:
.8759						z_environment_q:
.8759		60		rts		                rts
.875a						env_table_single:
>875a		59 d5 69 d5 6f d5 74 d5		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8762		86 d5
>8764		8e d5 97 d5 9d d5 a3 d5		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>876c		b6 d5 c2 d5 00 00		        .word envs_sc, envs_wl, 0000
.8772						env_table_double:
>8772		cc d5 d2 d5 00 00		        .word envs_max_d, envs_max_ud, 0000
.8778						env_results_single:
>8778		ff 00				        .word $00FF     ; /COUNTED-STRING
>877a		ff 00				        .word $00FF     ; /HOLD
>877c		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>877e		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8780		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8782		ff 00				        .word $00FF     ; MAX-CHAR
>8784		ff 7f				        .word $7FFF     ; MAX-N
>8786		ff ff				        .word $FFFF     ; MAX-U
>8788		80 00				        .word $0080     ; RETURN-STACK-CELLS
>878a		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>878c		09 00				        .word $0009     ; WORDLISTS
.878e						env_results_double:
>878e		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8792		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8796						xt_equal:
.8796		20 76 d7	jsr $d776	                jsr underflow_2
.8799		b5 00		lda $00,x	                lda 0,x                 ; LSB
.879b		d5 02		cmp $02,x	                cmp 2,x
.879d		d0 0a		bne $87a9	                bne _false
.879f		b5 01		lda $01,x	                lda 1,x                 ; MSB
.87a1		d5 03		cmp $03,x	                cmp 3,x
.87a3		d0 04		bne $87a9	                bne _false
.87a5		a9 ff		lda #$ff	                lda #$FF
.87a7		80 02		bra $87ab	                bra _done
.87a9		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.87ab		95 02		sta $02,x	_done:          sta 2,x
.87ad		95 03		sta $03,x	                sta 3,x
.87af		e8		inx		                inx
.87b0		e8		inx		                inx
.87b1		60		rts		z_equal:        rts
.87b2						xt_blank:
.87b2		ca		dex		                dex
.87b3		ca		dex		                dex
.87b4		a9 20		lda #$20	                lda #AscSP
.87b6		95 00		sta $00,x	                sta 0,x
.87b8		74 01		stz $01,x	                stz 1,x
.87ba		80 06		bra $87c2	                bra xt_fill     ; skip over code for ERASE
.87bc						xt_erase:
.87bc		ca		dex		                dex
.87bd		ca		dex		                dex
.87be		74 00		stz $00,x	                stz 0,x
.87c0		74 01		stz $01,x	                stz 1,x
.87c2						xt_fill:
.87c2		20 7b d7	jsr $d77b	                jsr underflow_3
.87c5		b5 04		lda $04,x	                lda 4,x         ; LSB
.87c7		85 25		sta $25		                sta tmp1
.87c9		b5 05		lda $05,x	                lda 5,x
.87cb		85 26		sta $26		                sta tmp1+1
.87cd		b5 02		lda $02,x	                lda 2,x
.87cf		85 27		sta $27		                sta tmp2
.87d1		b5 03		lda $03,x	                lda 3,x
.87d3		85 28		sta $28		                sta tmp2+1
.87d5		b5 00		lda $00,x	                lda 0,x
.87d7		a8		tay		                tay
.87d8						_loop:
.87d8		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.87da		c5 26		cmp $26		                cmp tmp1+1
.87dc		90 21		bcc $87ff	                bcc _done               ; RAM_END < TMP1, so leave
.87de		d0 06		bne $87e6	                bne _check_counter      ; RAM_END is not smaller and not equal
.87e0		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.87e2		c5 25		cmp $25		                cmp tmp1
.87e4		90 19		bcc $87ff	                bcc _done               ; RAM_END < TMP1, so leave
.87e6						_check_counter:
.87e6		a5 27		lda $27		                lda tmp2
.87e8		05 28		ora $28		                ora tmp2+1
.87ea		f0 13		beq $87ff	                beq _done
.87ec		98		tya		                tya
.87ed		92 25		sta ($25)	                sta (tmp1)
.87ef		a5 27		lda $27		                lda tmp2
.87f1		d0 02		bne $87f5	                bne +
.87f3		c6 28		dec $28		                dec tmp2+1
.87f5		c6 27		dec $27		+               dec tmp2
.87f7		e6 25		inc $25		                inc tmp1
.87f9		d0 dd		bne $87d8	                bne _loop
.87fb		e6 26		inc $26		                inc tmp1+1
.87fd		80 d9		bra $87d8	                bra _loop
.87ff						_done:
.87ff		8a		txa		                txa
.8800		18		clc		                clc
.8801		69 06		adc #$06	                adc #6
.8803		aa		tax		                tax
.8804						z_blank:
.8804						z_erase:
.8804		60		rts		z_fill:         rts
.8805						xt_execute:
.8805		20 71 d7	jsr $d771	                jsr underflow_1
.8808		20 0c 88	jsr $880c	                jsr doexecute   ; do not combine to JMP (native coding)
.880b		60		rts		z_execute:      rts
.880c						doexecute:
.880c		b5 00		lda $00,x	                lda 0,x
.880e		85 04		sta $04		                sta ip
.8810		b5 01		lda $01,x	                lda 1,x
.8812		85 05		sta $05		                sta ip+1
.8814		e8		inx		                inx
.8815		e8		inx		                inx
.8816		6c 04 00	jmp ($0004)	                jmp (ip)
.8819						xt_exit:
.8819		60		rts		                rts             ; keep before z_exit
.881a						z_exit:
.881a						xt_fetch:
.881a		20 71 d7	jsr $d771	                jsr underflow_1
.881d						w_fetch:
.881d		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.881f		a8		tay		                tay
.8820		f6 00		inc $00,x	                inc 0,x
.8822		d0 02		bne $8826	                bne +
.8824		f6 01		inc $01,x	                inc 1,x
.8826						+
.8826		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8828		95 01		sta $01,x	                sta 1,x
.882a		94 00		sty $00,x	                sty 0,x
.882c		60		rts		z_fetch:        rts
.882d						xt_find:
.882d		20 71 d7	jsr $d771	                jsr underflow_1
.8830		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8832		48		pha		                pha
.8833		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8835		48		pha		                pha
.8836		20 26 84	jsr $8426	                jsr xt_count            ; ( caddr -- addr u )
.8839		20 d7 9a	jsr $9ad7	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.883c		b5 00		lda $00,x	                lda 0,x
.883e		15 01		ora $01,x	                ora 1,x
.8840		d0 0b		bne $884d	                bne _found_word
.8842		20 d8 9d	jsr $9dd8	                jsr xt_false            ; ( 0 0 )
.8845		68		pla		                pla                     ; LSB of address
.8846		95 02		sta $02,x	                sta 2,x
.8848		68		pla		                pla
.8849		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.884b		80 27		bra $8874	                bra _done               ; ( addr 0 )
.884d						_found_word:
.884d		68		pla		                pla
.884e		68		pla		                pla
.884f		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.8852		20 15 9c	jsr $9c15	                jsr xt_name_to_int      ; ( nt xt )
.8855		20 2a 92	jsr $922a	                jsr xt_swap             ; ( xt nt )
.8858		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.885a		f6 00		inc $00,x	                inc 0,x
.885c		d0 02		bne $8860	                bne +
.885e		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8860						+
.8860		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8862		29 04		and #$04	                and #IM
.8864		d0 08		bne $886e	                bne _immediate          ; bit set, we're immediate
.8866		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8868		95 00		sta $00,x	                sta 0,x
.886a		95 01		sta $01,x	                sta 1,x
.886c		80 06		bra $8874	                bra _done
.886e						_immediate:
.886e		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8870		95 00		sta $00,x	                sta 0,x
.8872		74 01		stz $01,x	                stz 1,x
.8874						_done:
.8874		60		rts		z_find:         rts
.8875						xt_fm_slash_mod:
.8875		20 7b d7	jsr $d77b	                jsr underflow_3
.8878		64 27		stz $27		                stz tmp2        ; default: n is positive
.887a		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.887c		10 0e		bpl $888c	                bpl _check_d
.887e		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.8880		20 1f 8c	jsr $8c1f	                jsr xt_negate   ; NEGATE
.8883		20 68 93	jsr $9368	                jsr xt_to_r     ; >R
.8886		20 46 9e	jsr $9e46	                jsr xt_dnegate  ; DNEGATE
.8889		20 ec 8e	jsr $8eec	                jsr xt_r_from   ; R>
.888c						_check_d:
.888c		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.888e		10 0d		bpl $889d	                bpl _multiply
.8890		18		clc		                clc
.8891		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.8893		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.8895		95 02		sta $02,x	                sta 2,x
.8897		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8899		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.889b		95 03		sta $03,x	                sta 3,x
.889d						_multiply:
.889d		20 45 95	jsr $9545	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.88a0		a5 27		lda $27		                lda tmp2
.88a2		f0 07		beq $88ab	                beq _done
.88a4		e8		inx		                inx             ; pretend that we SWAP
.88a5		e8		inx		                inx
.88a6		20 1f 8c	jsr $8c1f	                jsr xt_negate
.88a9		ca		dex		                dex
.88aa		ca		dex		                dex
.88ab						_done:
.88ab		60		rts		z_fm_slash_mod: rts
.88ac						load_evaluate:
.88ac		a9 ff		lda #$ff	                lda #$FF
.88ae		85 25		sta $25		                sta tmp1
.88b0		80 11		bra $88c3	                bra load_evaluate_start
.88b2						xt_evaluate:
.88b2		20 76 d7	jsr $d776	                jsr underflow_2
.88b5		64 25		stz $25		                stz tmp1
.88b7		b5 00		lda $00,x	                lda 0,x
.88b9		15 01		ora $01,x	                ora 1,x
.88bb		d0 06		bne $88c3	                bne evaluate_got_work
.88bd		e8		inx		                inx
.88be		e8		inx		                inx
.88bf		e8		inx		                inx
.88c0		e8		inx		                inx
.88c1		80 42		bra $8905	                bra evaluate_done
.88c3						load_evaluate_start:
.88c3						evaluate_got_work:
.88c3		a0 05		ldy #$05	                ldy #blk_offset+1
.88c5		b1 08		lda ($08),y	                lda (up),y
.88c7		48		pha		                pha
.88c8		88		dey		                dey
.88c9		b1 08		lda ($08),y	                lda (up),y
.88cb		48		pha		                pha
.88cc		a5 25		lda $25		                lda tmp1
.88ce		d0 05		bne $88d5	                bne _nozero
.88d0		91 08		sta ($08),y	                sta (up),y
.88d2		c8		iny		                iny
.88d3		91 08		sta ($08),y	                sta (up),y
.88d5						_nozero:
.88d5		20 79 9b	jsr $9b79	                jsr xt_input_to_r
.88d8		a9 ff		lda #$ff	                lda #$FF
.88da		85 0a		sta $0a		                sta insrc
.88dc		85 0b		sta $0b		                sta insrc+1
.88de		64 10		stz $10		                stz toin
.88e0		64 11		stz $11		                stz toin+1
.88e2		b5 00		lda $00,x	                lda 0,x
.88e4		85 0e		sta $0e		                sta ciblen
.88e6		b5 01		lda $01,x	                lda 1,x
.88e8		85 0f		sta $0f		                sta ciblen+1
.88ea		b5 02		lda $02,x	                lda 2,x
.88ec		85 0c		sta $0c		                sta cib
.88ee		b5 03		lda $03,x	                lda 3,x
.88f0		85 0d		sta $0d		                sta cib+1
.88f2		e8		inx		                inx             ; A clean stack is a clean mind
.88f3		e8		inx		                inx
.88f4		e8		inx		                inx
.88f5		e8		inx		                inx
.88f6		20 ee d6	jsr $d6ee	                jsr interpret   ; ( -- )
.88f9		20 86 9d	jsr $9d86	                jsr xt_r_to_input
.88fc		a0 04		ldy #$04	                ldy #blk_offset
.88fe		68		pla		                pla
.88ff		91 08		sta ($08),y	                sta (up),y
.8901		c8		iny		                iny
.8902		68		pla		                pla
.8903		91 08		sta ($08),y	                sta (up),y
.8905						evaluate_done:
.8905		60		rts		z_evaluate:     rts
.8906						xt_greater_than:
.8906		20 76 d7	jsr $d776	                jsr underflow_2
.8909		a0 00		ldy #$00	                ldy #0          ; default false
.890b		20 af d6	jsr $d6af	                jsr compare_16bit
.890e		f0 03		beq $8913	                beq _false
.8910		10 01		bpl $8913	                bpl _false
.8912		88		dey		                dey
.8913						_false:
.8913		98		tya		                tya
.8914		e8		inx		                inx
.8915		e8		inx		                inx
.8916		95 00		sta $00,x	                sta 0,x
.8918		95 01		sta $01,x	                sta 1,x
.891a		60		rts		z_greater_than: rts
.891b						xt_here:
.891b						xt_begin:
.891b						xt_asm_arrow:
.891b		ca		dex		                dex
.891c		ca		dex		                dex
.891d		a5 00		lda $00		                lda cp
.891f		95 00		sta $00,x	                sta 0,x
.8921		a5 01		lda $01		                lda cp+1
.8923		95 01		sta $01,x	                sta 1,x
.8925						z_here:
.8925						z_begin:
.8925						z_asm_arrow:
.8925		60		rts		                rts
.8926						xt_hex:
.8926		a9 10		lda #$10	                lda #16
.8928		85 18		sta $18		                sta base
.892a		64 19		stz $19		                stz base+1              ; paranoid
.892c		60		rts		z_hex:          rts
.892d						xt_hold:
.892d		20 71 d7	jsr $d771	                jsr underflow_1
.8930						w_hold:
.8930		a5 2b		lda $2b		                lda tohold
.8932		d0 02		bne $8936	                bne +
.8934		c6 2c		dec $2c		                dec tohold+1
.8936						+
.8936		c6 2b		dec $2b		                dec tohold
.8938		b5 00		lda $00,x	                lda 0,x
.893a		92 2b		sta ($2b)	                sta (tohold)
.893c		e8		inx		                inx
.893d		e8		inx		                inx
.893e		60		rts		z_hold:         rts
.893f						xt_i:
.893f		ca		dex		                dex
.8940		ca		dex		                dex
.8941		a4 1f		ldy $1f		                ldy loopctrl
.8943		38		sec		                sec
.8944		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.8946		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8949		95 00		sta $00,x	                sta 0,x
.894b		b9 01 01	lda $0101,y	                lda loopindex+1,y
.894e		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8951		95 01		sta $01,x	                sta 1,x
.8953		60		rts		z_i:            rts
.8954						xt_if:
.8954		20 9e 97	jsr $979e	                jsr cmpl_0branch_later
.8957		60		rts		z_if:           rts
.8958						xt_immediate:
.8958		20 c8 d6	jsr $d6c8	                jsr current_to_dp
.895b		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.895d		b1 02		lda ($02),y	                lda (dp),y
.895f		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.8961		91 02		sta ($02),y	                sta (dp),y
.8963		60		rts		z_immediate:    rts
.8964						xt_invert:
.8964		20 71 d7	jsr $d771	                jsr underflow_1
.8967		a9 ff		lda #$ff	                lda #$FF
.8969		55 00		eor $00,x	                eor 0,x         ; LSB
.896b		95 00		sta $00,x	                sta 0,x
.896d		a9 ff		lda #$ff	                lda #$FF
.896f		55 01		eor $01,x	                eor 1,x         ; MSB
.8971		95 01		sta $01,x	                sta 1,x
.8973		60		rts		z_invert:       rts
.8974						xt_is:
.8974		a5 1a		lda $1a		                lda state
.8976		05 1b		ora $1b		                ora state+1
.8978		f0 0c		beq $8986	                beq _interpreting
.897a		20 14 83	jsr $8314	                jsr xt_bracket_tick
.897d		a0 85		ldy #$85	                ldy #>xt_defer_store
.897f		a9 4b		lda #$4b	                lda #<xt_defer_store
.8981		20 61 97	jsr $9761	                jsr cmpl_subroutine
.8984		80 06		bra $898c	                bra _done
.8986						_interpreting:
.8986		20 3e 92	jsr $923e	                jsr xt_tick
.8989		20 4b 85	jsr $854b	                jsr xt_defer_store
.898c						_done:
.898c		60		rts		z_is:           rts
.898d						xt_j:
.898d		ca		dex		                dex                 ; make space on the stack
.898e		ca		dex		                dex
.898f		a5 1f		lda $1f		                lda loopctrl
.8991		38		sec		                sec
.8992		e9 04		sbc #$04	                sbc #4
.8994		a8		tay		                tay
.8995		38		sec		                sec
.8996		b9 00 01	lda $0100,y	                lda loopindex,y
.8999		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.899c		95 00		sta $00,x	                sta 0,x
.899e		b9 01 01	lda $0101,y	                lda loopindex+1,y
.89a1		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.89a4		95 01		sta $01,x	                sta 1,x
.89a6		60		rts		z_j:            rts
.89a7						xt_key:
.89a7		20 b1 89	jsr $89b1	                jsr key_a               ; returns char in A
.89aa		ca		dex		                dex
.89ab		ca		dex		                dex
.89ac		95 00		sta $00,x	                sta 0,x
.89ae		74 01		stz $01,x	                stz 1,x
.89b0		60		rts		z_key:          rts
.89b1						key_a:
.89b1		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.89b4						xt_leave:
.89b4		a5 21		lda $21		                lda loopleave
.89b6		a4 22		ldy $22		                ldy loopleave+1
.89b8		20 66 97	jsr $9766	                jsr cmpl_jump   ; emit the JMP chaining prior leave address
.89bb		38		sec		                sec
.89bc		a5 00		lda $00		                lda cp
.89be		e9 02		sbc #$02	                sbc #2
.89c0		85 21		sta $21		                sta loopleave
.89c2		a5 01		lda $01		                lda cp+1
.89c4		b0 01		bcs $89c7	                bcs +
.89c6		3a		dec a		                dea
.89c7		85 22		sta $22		+               sta loopleave+1
.89c9						z_leave:
.89c9		60		rts		                rts
.89ca						xt_left_bracket:
.89ca		64 1a		stz $1a		                stz state
.89cc		64 1b		stz $1b		                stz state+1
.89ce		60		rts		z_left_bracket: rts
.89cf						xt_less_number_sign:
.89cf						w_less_number_sign:
.89cf		20 0f 8d	jsr $8d0f	                jsr w_pad      ; ( addr )
.89d2		b5 00		lda $00,x	                lda 0,x
.89d4		85 2b		sta $2b		                sta tohold
.89d6		b5 01		lda $01,x	                lda 1,x
.89d8		85 2c		sta $2c		                sta tohold+1
.89da		e8		inx		                inx
.89db		e8		inx		                inx
.89dc						z_less_number_sign:
.89dc		60		rts		                rts
.89dd						xt_less_than:
.89dd		20 76 d7	jsr $d776	                jsr underflow_2
.89e0		a0 00		ldy #$00	                ldy #0          ; default false
.89e2		20 af d6	jsr $d6af	                jsr compare_16bit
.89e5		f0 03		beq $89ea	                beq _false
.89e7		30 01		bmi $89ea	                bmi _false
.89e9		88		dey		                dey
.89ea						_false:
.89ea		98		tya		                tya
.89eb		e8		inx		                inx
.89ec		e8		inx		                inx
.89ed		95 00		sta $00,x	                sta 0,x
.89ef		95 01		sta $01,x	                sta 1,x
.89f1		60		rts		z_less_than:    rts
.89f2						xt_literal:
.89f2		20 71 d7	jsr $d771	                jsr underflow_1
.89f5		a9 0a		lda #$0a	                lda #template_push_tos_size
.89f7		20 8c 97	jsr $978c	                jsr check_nc_limit
.89fa		90 0c		bcc $8a08	                bcc _inline
.89fc		a0 8a		ldy #$8a	                ldy #>literal_runtime
.89fe		a9 3a		lda #$3a	                lda #<literal_runtime
.8a00		20 61 97	jsr $9761	                jsr cmpl_subroutine
.8a03		20 cd 83	jsr $83cd	                jsr xt_comma
.8a06		80 27		bra $8a2f	                bra z_literal
.8a08						_inline:
.8a08		a0 94		ldy #$94	                ldy #$94        ; STY opcode
.8a0a		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a0c		d0 02		bne $8a10	                bne +
.8a0e		a0 74		ldy #$74	                ldy #$74        ; STZ opcode
.8a10		5a		phy		+               phy
.8a11		b5 00		lda $00,x	                lda 0,x         ; LSB
.8a13		48		pha		                pha
.8a14		a0 02		ldy #$02	                ldy #2
.8a16		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a18		f0 03		beq $8a1d	                beq _copy
.8a1a		a0 00		ldy #$00	                ldy #0
.8a1c		48		pha		                pha
.8a1d		b9 30 8a	lda $8a30,y	_copy:          lda template_push_tos,y
.8a20		c9 ff		cmp #$ff	                cmp #$ff        ; is it a placeholder?
.8a22		d0 01		bne $8a25	                bne +
.8a24		68		pla		                pla
.8a25		20 71 97	jsr $9771	+               jsr cmpl_a
.8a28		c8		iny		                iny
.8a29		c0 0a		cpy #$0a	                cpy #template_push_tos_size
.8a2b		d0 f0		bne $8a1d	                bne _copy
.8a2d		e8		inx		                inx             ; drop the literal
.8a2e		e8		inx		                inx
.8a2f		60		rts		z_literal:      rts
.8a30						template_push_tos:
.8a30		a0 ff		ldy #$ff	                ldy #$ff        ; we'll omit this if MSB is zero
.8a32		a9 ff		lda #$ff	                lda #$ff
.8a34		ca		dex		                dex
.8a35		ca		dex		                dex
.8a36		95 00		sta $00,x	                sta 0,x
>8a38		ff 01				                .byte $ff, 1    ; this will become either sty 1,x or stz 1,x
=10						template_push_tos_size = * - template_push_tos
.8a3a						literal_runtime:
.8a3a		ca		dex		                dex
.8a3b		ca		dex		                dex
.8a3c		68		pla		                pla             ; LSB
.8a3d		85 25		sta $25		                sta tmp1
.8a3f		68		pla		                pla             ; MSB
.8a40		85 26		sta $26		                sta tmp1+1
.8a42		a0 01		ldy #$01	                ldy #1
.8a44		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.8a46		95 00		sta $00,x	                sta 0,x
.8a48		c8		iny		                iny
.8a49		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.8a4b		95 01		sta $01,x	                sta 1,x
.8a4d		98		tya		                tya
.8a4e		18		clc		                clc
.8a4f		65 25		adc $25		                adc tmp1
.8a51		a8		tay		                tay
.8a52		a5 26		lda $26		                lda tmp1+1
.8a54		69 00		adc #$00	                adc #0
.8a56		48		pha		                pha
.8a57		5a		phy		                phy
.8a58		60		rts		                rts
.8a59						xt_loop:
.8a59		ca		dex		                dex
.8a5a		ca		dex		                dex
.8a5b		ca		dex		                dex
.8a5c		ca		dex		                dex
.8a5d		a9 d2		lda #$d2	                lda #<loop_runtime
.8a5f		95 02		sta $02,x	                sta 2,x
.8a61		a9 8a		lda #$8a	                lda #>loop_runtime
.8a63		95 03		sta $03,x	                sta 3,x
.8a65		a9 11		lda #$11	                lda #loop_runtime_size
.8a67		95 00		sta $00,x	                sta 0,x
.8a69		74 01		stz $01,x	                stz 1,x
.8a6b		80 12		bra $8a7f	                bra xt_loop_common
.8a6d						xt_plus_loop:
.8a6d		ca		dex		                dex
.8a6e		ca		dex		                dex
.8a6f		ca		dex		                dex
.8a70		ca		dex		                dex
.8a71		a9 eb		lda #$eb	                lda #<plus_loop_runtime
.8a73		95 02		sta $02,x	                sta 2,x
.8a75		a9 8a		lda #$8a	                lda #>plus_loop_runtime
.8a77		95 03		sta $03,x	                sta 3,x
.8a79		a9 1a		lda #$1a	                lda #plus_loop_runtime_size
.8a7b		95 00		sta $00,x	                sta 0,x
.8a7d		74 01		stz $01,x	                stz 1,x
.8a7f						xt_loop_common:
.8a7f		20 01 8d	jsr $8d01	                jsr xt_over
.8a82		20 2a 92	jsr $922a	                jsr xt_swap             ; xt and xt' are the same
.8a85		20 2f 97	jsr $972f	                jsr cmpl_by_limit
.8a88		90 05		bcc $8a8f	                bcc _native
.8a8a		20 cd 83	jsr $83cd	                jsr xt_comma
.8a8d		80 03		bra $8a92	                bra +
.8a8f						_native:
.8a8f		20 7a 97	jsr $977a	                jsr cmpl_jump_tos
.8a92						+
.8a92		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.8a94		f0 19		beq $8aaf	                beq _noleave
.8a96						_next:
.8a96		a0 01		ldy #$01	                ldy #1
.8a98		b1 21		lda ($21),y	                lda (loopleave),y
.8a9a		48		pha		                pha
.8a9b		a5 01		lda $01		                lda cp+1
.8a9d		91 21		sta ($21),y	                sta (loopleave),y
.8a9f		88		dey		                dey
.8aa0		b1 21		lda ($21),y	                lda (loopleave),y
.8aa2		48		pha		                pha
.8aa3		a5 00		lda $00		                lda cp
.8aa5		91 21		sta ($21),y	                sta (loopleave),y
.8aa7		68		pla		                pla
.8aa8		85 21		sta $21		                sta loopleave
.8aaa		68		pla		                pla
.8aab		85 22		sta $22		                sta loopleave+1
.8aad		d0 e7		bne $8a96	                bne _next
.8aaf						_noleave:
.8aaf		b5 00		lda $00,x	                lda 0,x
.8ab1		85 21		sta $21		                sta loopleave
.8ab3		b5 01		lda $01,x	                lda 1,x
.8ab5		85 22		sta $22		                sta loopleave+1
.8ab7		a9 cd		lda #$cd	                lda #<xt_unloop
.8ab9		95 00		sta $00,x	                sta 0,x
.8abb		a9 95		lda #$95	                lda #>xt_unloop
.8abd		95 01		sta $01,x	                sta 1,x
.8abf		20 c3 96	jsr $96c3	                jsr xt_compile_comma
.8ac2		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.8ac4		f0 09		beq $8acf	                beq +
.8ac6		20 1b 89	jsr $891b	                jsr xt_here
.8ac9		20 2a 92	jsr $922a	                jsr xt_swap
.8acc		4c 14 92	jmp $9214	                jmp xt_store            ; write here as ?DO jmp target and return
.8acf		e8		inx		+               inx                     ; drop the ignored word for DO
.8ad0		e8		inx		                inx
.8ad1						z_loop:
.8ad1		60		rts		z_plus_loop:    rts
.8ad2						loop_runtime:
.8ad2		e6 20		inc $20		                inc loopidx0            ; increment the LSB of loopindex
.8ad4		d0 0d		bne $8ae3	                bne _repeat             ; avoid expensive test most of the time
.8ad6		a4 1f		ldy $1f		                ldy loopctrl
.8ad8		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8adb		1a		inc a		                ina
.8adc		c9 80		cmp #$80	                cmp #$80
.8ade		f0 06		beq $8ae6	                beq _done
.8ae0		99 01 01	sta $0101,y	                sta loopindex+1,y
=17						loop_runtime_size = * - loop_runtime
.8ae3						_repeat:
.8ae3		a9 00		lda #$00	                lda #0
>8ae5		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8ae6		a9 01		lda #$01	_done:          lda #1
.8ae8		4c 1b 98	jmp $981b	                jmp zbranch_runtime
.8aeb						plus_loop_runtime:
.8aeb		18		clc		                clc
.8aec		b5 00		lda $00,x	                lda 0,x                 ; LSB of step
.8aee		65 20		adc $20		                adc loopidx0
.8af0		85 20		sta $20		                sta loopidx0
.8af2		e8		inx		                inx                     ; dump step from TOS before MSB test
.8af3		e8		inx		                inx                     ; since we might skip it
.8af4		b5 ff		lda $ff,x	                lda $FF,x               ; MSB of step since 1,x == -1,x+2
.8af6		d0 02		bne $8afa	                bne _chkv               ; if it's non-zero we have to check
.8af8		90 0b		bcc $8b05	                bcc _repeat             ; but if 0 and no carry, we're good
.8afa		b8		clv		_chkv:          clv
.8afb		a4 1f		ldy $1f		                ldy loopctrl            ; get LCB offset
.8afd		79 01 01	adc $0101,y	                adc loopindex+1,y       ; MSB of index
.8b00		99 01 01	sta $0101,y	                sta loopindex+1,y       ; put MSB of index back on stack
.8b03		70 03		bvs $8b08	                bvs _done               ; skip over JMP instruction
=26						plus_loop_runtime_size = * - plus_loop_runtime
.8b05						_repeat:
.8b05		a9 00		lda #$00	                lda #0
>8b07		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8b08		a9 01		lda #$01	_done:          lda #1
.8b0a		4c 1b 98	jmp $981b	                jmp zbranch_runtime
.8b0d						xt_lshift:
.8b0d		20 76 d7	jsr $d776	                jsr underflow_2
.8b10		b5 00		lda $00,x	                lda 0,x
.8b12		29 0f		and #$0f	                and #%00001111
.8b14		f0 08		beq $8b1e	                beq _done
.8b16		a8		tay		                tay
.8b17						_loop:
.8b17		16 02		asl $02,x	                asl 2,x
.8b19		36 03		rol $03,x	                rol 3,x
.8b1b		88		dey		                dey
.8b1c		d0 f9		bne $8b17	                bne _loop
.8b1e						_done:
.8b1e		e8		inx		                inx
.8b1f		e8		inx		                inx
.8b20		60		rts		z_lshift:       rts
.8b21						xt_m_star:
.8b21		20 76 d7	jsr $d776	                jsr underflow_2
.8b24		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8b26		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.8b28		48		pha		                pha
.8b29		20 cf 80	jsr $80cf	                jsr xt_abs
.8b2c		20 2a 92	jsr $922a	                jsr xt_swap
.8b2f		20 cf 80	jsr $80cf	                jsr xt_abs
.8b32		20 87 95	jsr $9587	                jsr xt_um_star          ; ( d )
.8b35		68		pla		                pla
.8b36		10 03		bpl $8b3b	                bpl _done
.8b38		20 46 9e	jsr $9e46	                jsr xt_dnegate
.8b3b						_done:
.8b3b		60		rts		z_m_star:       rts
.8b3c						xt_marker:
.8b3c		20 c8 d6	jsr $d6c8	                jsr current_to_dp
.8b3f		a5 02		lda $02		                lda dp
.8b41		48		pha		                pha
.8b42		a5 03		lda $03		                lda dp+1
.8b44		48		pha		                pha
.8b45		a5 00		lda $00		                lda cp
.8b47		48		pha		                pha
.8b48		a5 01		lda $01		                lda cp+1
.8b4a		48		pha		                pha
.8b4b		20 40 84	jsr $8440	                jsr xt_create
.8b4e		a5 00		lda $00		                lda cp          ; LSB
.8b50		38		sec		                sec
.8b51		e9 02		sbc #$02	                sbc #2
.8b53		85 00		sta $00		                sta cp
.8b55		b0 02		bcs $8b59	                bcs +
.8b57		c6 01		dec $01		                dec cp+1        ; we only care about the borrow
.8b59						+
.8b59		a0 8b		ldy #$8b	                ldy #>marker_runtime
.8b5b		a9 77		lda #$77	                lda #<marker_runtime
.8b5d		20 6d 97	jsr $976d	                jsr cmpl_word
.8b60		7a		ply		                ply                     ; MSB
.8b61		68		pla		                pla                     ; LSB
.8b62		20 6d 97	jsr $976d	                jsr cmpl_word
.8b65		7a		ply		                ply                     ; MSB
.8b66		68		pla		                pla                     ; LSB
.8b67		20 6d 97	jsr $976d	                jsr cmpl_word
.8b6a		a0 08		ldy #$08	                ldy #marker_start_offset
.8b6c						-
.8b6c		b1 08		lda ($08),y	                lda (up),y
.8b6e		20 71 97	jsr $9771	                jsr cmpl_a
.8b71		c8		iny		                iny
.8b72		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8b74		d0 f6		bne $8b6c	                bne -
.8b76		60		rts		z_marker:       rts
.8b77						marker_runtime:
.8b77		68		pla		                pla
.8b78		85 25		sta $25		                sta tmp1        ; LSB of address
.8b7a		68		pla		                pla
.8b7b		85 26		sta $26		                sta tmp1+1      ; MSB of address
.8b7d		a0 01		ldy #$01	                ldy #1          ; start at 1 due to RTS mechanics
.8b7f		b1 25		lda ($25),y	                lda (tmp1),y
.8b81		85 00		sta $00		                sta cp
.8b83		c8		iny		                iny
.8b84		b1 25		lda ($25),y	                lda (tmp1),y
.8b86		85 01		sta $01		                sta cp+1
.8b88		c8		iny		                iny
.8b89		b1 25		lda ($25),y	                lda (tmp1),y
.8b8b		85 02		sta $02		                sta dp
.8b8d		c8		iny		                iny
.8b8e		b1 25		lda ($25),y	                lda (tmp1),y
.8b90		85 03		sta $03		                sta dp+1
.8b92		38		sec		                sec
.8b93		a5 25		lda $25		                lda tmp1
.8b95		e9 03		sbc #$03	                sbc #marker_start_offset - 5
.8b97		85 25		sta $25		                sta tmp1
.8b99		b0 02		bcs $8b9d	                bcs +
.8b9b		c6 26		dec $26		                dec tmp1+1
.8b9d						+
.8b9d		a0 08		ldy #$08	                ldy #marker_start_offset
.8b9f						-
.8b9f		b1 25		lda ($25),y	                lda (tmp1),y
.8ba1		91 08		sta ($08),y	                sta (up),y
.8ba3		c8		iny		                iny
.8ba4		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8ba6		d0 f7		bne $8b9f	                bne -
.8ba8		20 db d6	jsr $d6db	                jsr dp_to_current       ; Move the CURRENT DP back.
.8bab		60		rts		                rts
.8bac						xt_max:
.8bac		20 76 d7	jsr $d776	                jsr underflow_2
.8baf		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bb1		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.8bb3		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bb5		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bb7		50 02		bvc $8bbb	                bvc _no_overflow
.8bb9		49 80		eor #$80	                eor #$80        ; complement negative flag
.8bbb						_no_overflow:
.8bbb		30 08		bmi $8bc5	                bmi _keep_nos
.8bbd		b5 00		lda $00,x	                lda 0,x
.8bbf		95 02		sta $02,x	                sta 2,x
.8bc1		b5 01		lda $01,x	                lda 1,x
.8bc3		95 03		sta $03,x	                sta 3,x
.8bc5						_keep_nos:
.8bc5		e8		inx		                inx
.8bc6		e8		inx		                inx
.8bc7		60		rts		z_max:          rts
.8bc8						xt_min:
.8bc8		20 76 d7	jsr $d776	                jsr underflow_2
.8bcb		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bcd		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.8bcf		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bd1		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bd3		50 02		bvc $8bd7	                bvc _no_overflow
.8bd5		49 80		eor #$80	                eor #$80
.8bd7						_no_overflow:
.8bd7		10 08		bpl $8be1	                bpl _keep_nos
.8bd9		b5 00		lda $00,x	                lda 0,x
.8bdb		95 02		sta $02,x	                sta 2,x
.8bdd		b5 01		lda $01,x	                lda 1,x
.8bdf		95 03		sta $03,x	                sta 3,x
.8be1						_keep_nos:
.8be1		e8		inx		                inx
.8be2		e8		inx		                inx
.8be3		60		rts		z_min:          rts
.8be4						xt_minus:
.8be4		20 76 d7	jsr $d776	                jsr underflow_2
.8be7		38		sec		                sec
.8be8		b5 02		lda $02,x	                lda 2,x         ; LSB
.8bea		f5 00		sbc $00,x	                sbc 0,x
.8bec		95 02		sta $02,x	                sta 2,x
.8bee		b5 03		lda $03,x	                lda 3,x         ; MSB
.8bf0		f5 01		sbc $01,x	                sbc 1,x
.8bf2		95 03		sta $03,x	                sta 3,x
.8bf4		e8		inx		                inx
.8bf5		e8		inx		                inx
.8bf6		60		rts		z_minus:        rts
.8bf7						xt_mod:
.8bf7		20 76 d7	jsr $d776	                jsr underflow_2
.8bfa		20 66 91	jsr $9166	                jsr xt_slash_mod
.8bfd		e8		inx		                inx             ; DROP
.8bfe		e8		inx		                inx
.8bff						z_mod:
.8bff		60		rts		                rts
.8c00						xt_move:
.8c00		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.8c02		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.8c04		f0 05		beq $8c0b	                beq _lsb                ; wasn't helpful, move to LSB
.8c06		b0 0e		bcs $8c16	                bcs _to_move_up         ; we want CMOVE>
.8c08		4c 29 9f	jmp $9f29	                jmp xt_cmove            ; JSR/RTS
.8c0b						_lsb:
.8c0b		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.8c0d		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.8c0f		f0 08		beq $8c19	                beq _equal              ; LSB is equal as well
.8c11		b0 03		bcs $8c16	                bcs _to_move_up         ; we want CMOVE>
.8c13		4c 29 9f	jmp $9f29	                jmp xt_cmove            ; JSR/RTS
.8c16						_to_move_up:
.8c16		4c 64 9f	jmp $9f64	                jmp xt_cmove_up         ; JSR/RTS
.8c19						_equal:
.8c19		8a		txa		                txa
.8c1a		18		clc		                clc
.8c1b		69 06		adc #$06	                adc #6
.8c1d		aa		tax		                tax
.8c1e		60		rts		z_move:         rts
.8c1f						xt_negate:
.8c1f		20 71 d7	jsr $d771	                jsr underflow_1
.8c22		a9 00		lda #$00	        	lda #0
.8c24		38		sec		                sec
.8c25		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8c27		95 00		sta $00,x	                sta 0,x
.8c29		a9 00		lda #$00	                lda #0
.8c2b		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.8c2d		95 01		sta $01,x	                sta 1,x
.8c2f		60		rts		z_negate:       rts
.8c30						xt_nip:
.8c30		20 76 d7	jsr $d776	                jsr underflow_2
.8c33		b5 00		lda $00,x	                lda 0,x         ; LSB
.8c35		95 02		sta $02,x	                sta 2,x
.8c37		b5 01		lda $01,x	                lda 1,x         ; MSB
.8c39		95 03		sta $03,x	                sta 3,x
.8c3b		e8		inx		                inx
.8c3c		e8		inx		                inx
.8c3d		60		rts		z_nip:          rts
.8c3e						xt_not_equals:
.8c3e		20 76 d7	jsr $d776	                jsr underflow_2
.8c41		a0 00		ldy #$00	                ldy #0                  ; default is true
.8c43		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8c45		d5 02		cmp $02,x	                cmp 2,x
.8c47		d0 0a		bne $8c53	                bne _not_equal
.8c49		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8c4b		d5 03		cmp $03,x	                cmp 3,x
.8c4d		d0 04		bne $8c53	                bne _not_equal
.8c4f		a9 ff		lda #$ff	                lda #$FF
.8c51		80 01		bra $8c54	                bra _done
.8c53						_not_equal:
.8c53		88		dey		                dey                     ; drop thru to done
.8c54						_done:
.8c54		98		tya		                tya
.8c55		e8		inx		                inx
.8c56		e8		inx		                inx
.8c57		95 00		sta $00,x	                sta 0,x
.8c59		95 01		sta $01,x	                sta 1,x
.8c5b		60		rts		z_not_equals:   rts
.8c5c						xt_number_sign:
.8c5c		20 76 d7	jsr $d776	                jsr underflow_2         ; double number
.8c5f						w_number_sign:
.8c5f		ca		dex		                dex                     ; inline w_zero
.8c60		ca		dex		                dex
.8c61		74 00		stz $00,x	                stz 0,x
.8c63		74 01		stz $01,x	                stz 1,x
.8c65		e6 19		inc $19		                inc base+1
.8c67		b5 02		lda $02,x	                lda 2,x                 ; if msw is 0 we can skip the first pass
.8c69		15 03		ora $03,x	                ora 3,x
.8c6b		f0 0b		beq $8c78	                beq _skip               ; enter with ( v 0 0 -rot -- 0 v 0 )
.8c6d						_loop:
.8c6d		ca		dex		                dex                     ; inline `base @`
.8c6e		ca		dex		                dex
.8c6f		a5 18		lda $18		                lda base                ; base <= 36
.8c71		95 00		sta $00,x	                sta 0,x
.8c73		74 01		stz $01,x	                stz 1,x
.8c75		20 48 95	jsr $9548	                jsr w_um_slash_mod      ; ( v u 0 base -- v ru qu )
.8c78		20 5f 9c	jsr $9c5f	_skip:          jsr w_not_rote          ; ( qu v ru )
.8c7b		46 19		lsr $19		                lsr base+1              ; 1 => 0 + C=1 => 0 + C=0
.8c7d		b0 ee		bcs $8c6d	                bcs _loop               ; run two passes
.8c7f		b5 00		lda $00,x	                lda 0,x
.8c81		a8		tay		                tay
.8c82		b9 f7 d2	lda $d2f7,y	                lda s_abc_upper,y       ; upper case 0-9A-Z
.8c85		95 00		sta $00,x	                sta 0,x
.8c87		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.8c89		20 30 89	jsr $8930	                jsr w_hold
.8c8c						z_number_sign:
.8c8c		60		rts		                rts
.8c8d						xt_number_sign_greater:
.8c8d		20 76 d7	jsr $d776	                jsr underflow_2         ; double number
.8c90						w_number_sign_greater:
.8c90		a5 2b		lda $2b		                lda tohold
.8c92		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.8c94		95 02		sta $02,x	                sta 2,x
.8c96		a5 2c		lda $2c		                lda tohold+1
.8c98		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.8c9a		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.8c9c		20 0f 8d	jsr $8d0f	                jsr w_pad       ; ( addr addr pad )
.8c9f		38		sec		                sec
.8ca0		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.8ca2		f5 02		sbc $02,x	                sbc 2,x
.8ca4		95 02		sta $02,x	                sta 2,x
.8ca6		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.8ca8		f5 03		sbc $03,x	                sbc 3,x
.8caa		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.8cac		e8		inx		                inx
.8cad		e8		inx		                inx
.8cae						z_number_sign_greater:
.8cae		60		rts		                rts
.8caf						xt_number_sign_s:
.8caf		20 76 d7	jsr $d776	                jsr underflow_2
.8cb2						w_number_sign_s:
.8cb2						_loop:
.8cb2		20 5f 8c	jsr $8c5f	                jsr w_number_sign
.8cb5		b5 00		lda $00,x	                lda 0,x
.8cb7		15 01		ora $01,x	                ora 1,x
.8cb9		15 02		ora $02,x	                ora 2,x
.8cbb		15 03		ora $03,x	                ora 3,x
.8cbd		d0 f3		bne $8cb2	                bne _loop
.8cbf						z_number_sign_s:
.8cbf		60		rts		                rts
.8cc0						xt_of:
.8cc0		a0 8d		ldy #$8d	                ldy #>xt_over
.8cc2		a9 01		lda #$01	                lda #<xt_over
.8cc4		20 61 97	jsr $9761	                jsr cmpl_subroutine
.8cc7		a0 87		ldy #$87	                ldy #>xt_equal
.8cc9		a9 96		lda #$96	                lda #<xt_equal
.8ccb		20 61 97	jsr $9761	                jsr cmpl_subroutine
.8cce		20 54 89	jsr $8954	                jsr xt_if
.8cd1		a0 86		ldy #$86	                ldy #>xt_drop
.8cd3		a9 9a		lda #$9a	                lda #<xt_drop
.8cd5		20 61 97	jsr $9761	                jsr cmpl_subroutine
.8cd8		60		rts		z_of:           rts
.8cd9						xt_one_minus:
.8cd9		20 71 d7	jsr $d771	                jsr underflow_1
.8cdc		b5 00		lda $00,x	                lda 0,x
.8cde		d0 02		bne $8ce2	                bne +
.8ce0		d6 01		dec $01,x	                dec 1,x
.8ce2						+
.8ce2		d6 00		dec $00,x	                dec 0,x
.8ce4		60		rts		z_one_minus:    rts
.8ce5						xt_char_plus:
.8ce5						xt_one_plus:
.8ce5		20 71 d7	jsr $d771	                jsr underflow_1
.8ce8		f6 00		inc $00,x	                inc 0,x
.8cea		d0 02		bne $8cee	                bne _done
.8cec		f6 01		inc $01,x	                inc 1,x
.8cee						_done:
.8cee						z_char_plus:
.8cee		60		rts		z_one_plus:     rts
.8cef						xt_or:
.8cef		20 76 d7	jsr $d776	                jsr underflow_2
.8cf2		b5 00		lda $00,x	                lda 0,x
.8cf4		15 02		ora $02,x	                ora 2,x
.8cf6		95 02		sta $02,x	                sta 2,x
.8cf8		b5 01		lda $01,x	                lda 1,x
.8cfa		15 03		ora $03,x	                ora 3,x
.8cfc		95 03		sta $03,x	                sta 3,x
.8cfe		e8		inx		                inx
.8cff		e8		inx		                inx
.8d00		60		rts		z_or:           rts
.8d01						xt_over:
.8d01		20 76 d7	jsr $d776	                jsr underflow_2
.8d04		ca		dex		                dex
.8d05		ca		dex		                dex
.8d06		b5 04		lda $04,x	                lda 4,x         ; LSB
.8d08		95 00		sta $00,x	                sta 0,x
.8d0a		b5 05		lda $05,x	                lda 5,x         ; MSB
.8d0c		95 01		sta $01,x	                sta 1,x
.8d0e		60		rts		z_over:         rts
.8d0f						xt_pad:
.8d0f						w_pad:
.8d0f		ca		dex		                dex
.8d10		ca		dex		                dex
.8d11		a5 00		lda $00		                lda cp
.8d13		18		clc		                clc
.8d14		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.8d16		95 00		sta $00,x	                sta 0,x
.8d18		a5 01		lda $01		                lda cp+1
.8d1a		69 00		adc #$00	                adc #0          ; only need carry
.8d1c		95 01		sta $01,x	                sta 1,x
.8d1e		60		rts		z_pad:          rts
.8d1f						xt_page:
.8d1f		a9 1b		lda #$1b	                lda #AscESC
.8d21		20 c5 86	jsr $86c5	                jsr emit_a
.8d24		a9 5b		lda #$5b	                lda #'['
.8d26		20 c5 86	jsr $86c5	                jsr emit_a
.8d29		a9 32		lda #$32	                lda #'2'
.8d2b		20 c5 86	jsr $86c5	                jsr emit_a
.8d2e		a9 4a		lda #$4a	                lda #'J'
.8d30		20 c5 86	jsr $86c5	                jsr emit_a
.8d33		20 d8 9d	jsr $9dd8	                jsr xt_zero
.8d36		20 d8 9d	jsr $9dd8	                jsr xt_zero
.8d39		20 a2 82	jsr $82a2	                jsr xt_at_xy
.8d3c		60		rts		z_page:         rts
.8d3d						xt_paren:
.8d3d		ca		dex		                dex
.8d3e		ca		dex		                dex
.8d3f		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8d41		95 00		sta $00,x	                sta 0,x
.8d43		74 01		stz $01,x	                stz 1,x
.8d45		20 a8 8d	jsr $8da8	                jsr xt_parse
.8d48		e8		inx		                inx
.8d49		e8		inx		                inx
.8d4a		e8		inx		                inx
.8d4b		e8		inx		                inx
.8d4c		60		rts		z_paren:        rts
.8d4d						xt_parse_name:
.8d4d		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.8d4f		38		sec		                sec
.8d50		e5 10		sbc $10		                sbc toin
.8d52		85 25		sta $25		                sta tmp1
.8d54		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.8d56		e5 11		sbc $11		                sbc toin+1
.8d58		85 26		sta $26		                sta tmp1+1
.8d5a		a5 25		lda $25		                lda tmp1
.8d5c		05 26		ora $26		                ora tmp1+1
.8d5e		f0 28		beq $8d88	                beq _empty_line
.8d60		a5 0c		lda $0c		                lda cib
.8d62		18		clc		                clc
.8d63		65 10		adc $10		                adc toin
.8d65		85 27		sta $27		                sta tmp2                ; LSB of first character
.8d67		a5 0d		lda $0d		                lda cib+1
.8d69		65 11		adc $11		                adc toin+1
.8d6b		85 28		sta $28		                sta tmp2+1              ; MSB
.8d6d						_skip_loop:
.8d6d		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.8d6f		20 64 d7	jsr $d764	                jsr is_whitespace
.8d72		90 1f		bcc $8d93	                bcc _char_found
.8d74		e6 27		inc $27		                inc tmp2
.8d76		d0 02		bne $8d7a	                bne +
.8d78		e6 28		inc $28		                inc tmp2+1
.8d7a						+
.8d7a		a5 25		lda $25		                lda tmp1
.8d7c		d0 02		bne $8d80	                bne +
.8d7e		c6 26		dec $26		                dec tmp1+1
.8d80		c6 25		dec $25		+               dec tmp1
.8d82		a5 25		lda $25		                lda tmp1
.8d84		05 26		ora $26		                ora tmp1+1
.8d86		d0 e5		bne $8d6d	                bne _skip_loop          ; fall through if empty line
.8d88						_empty_line:
.8d88		ca		dex		                dex
.8d89		ca		dex		                dex
.8d8a		ca		dex		                dex
.8d8b		ca		dex		                dex
.8d8c		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.8d8e		74 01		stz $01,x	                stz 1,x
.8d90		4c 3d 8e	jmp $8e3d	                jmp z_parse_name        ; skip over PARSE
.8d93						_char_found:
.8d93		a5 27		lda $27		                lda tmp2
.8d95		38		sec		                sec
.8d96		e5 0c		sbc $0c		                sbc cib
.8d98		85 10		sta $10		                sta toin
.8d9a		a5 28		lda $28		                lda tmp2+1
.8d9c		e5 0d		sbc $0d		                sbc cib+1
.8d9e		85 11		sta $11		                sta toin+1
.8da0		ca		dex		                dex
.8da1		ca		dex		                dex
.8da2		a9 20		lda #$20	                lda #AscSP
.8da4		95 00		sta $00,x	                sta 0,x
.8da6		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.8da8						xt_parse:
.8da8		20 71 d7	jsr $d771	                jsr underflow_1
.8dab		a5 0e		lda $0e		                lda ciblen
.8dad		05 0f		ora $0f		                ora ciblen+1
.8daf		f0 0c		beq $8dbd	                beq _abort_parse
.8db1		a5 11		lda $11		                lda toin+1              ; MSB
.8db3		c5 0f		cmp $0f		                cmp ciblen+1
.8db5		90 0e		bcc $8dc5	                bcc _go_parse           ; unsigned comparison
.8db7		a5 10		lda $10		                lda toin                ; LSB
.8db9		c5 0e		cmp $0e		                cmp ciblen
.8dbb		90 08		bcc $8dc5	                bcc _go_parse
.8dbd						_abort_parse:
.8dbd		ca		dex		                dex
.8dbe		ca		dex		                dex
.8dbf		74 00		stz $00,x	                stz 0,x
.8dc1		74 01		stz $01,x	                stz 1,x
.8dc3		80 78		bra $8e3d	                bra _done
.8dc5						_go_parse:
.8dc5		b5 00		lda $00,x	                lda 0,x
.8dc7		85 23		sta $23		                sta tmptos
.8dc9		ca		dex		                dex
.8dca		ca		dex		                dex
.8dcb		a5 0c		lda $0c		                lda cib
.8dcd		18		clc		                clc
.8dce		65 10		adc $10		                adc toin        ; LSB
.8dd0		85 25		sta $25		                sta tmp1
.8dd2		85 27		sta $27		                sta tmp2
.8dd4		95 02		sta $02,x	                sta 2,x
.8dd6		a5 0d		lda $0d		                lda cib+1
.8dd8		65 11		adc $11		                adc toin+1      ; MSB
.8dda		85 26		sta $26		                sta tmp1+1
.8ddc		85 28		sta $28		                sta tmp2+1
.8dde		95 03		sta $03,x	                sta 3,x
.8de0		a5 0c		lda $0c		                lda cib
.8de2		18		clc		                clc
.8de3		65 0e		adc $0e		                adc ciblen
.8de5		85 29		sta $29		                sta tmp3
.8de7		a5 0d		lda $0d		                lda cib+1
.8de9		65 0f		adc $0f		                adc ciblen+1
.8deb		85 2a		sta $2a		                sta tmp3+1
.8ded		64 24		stz $24		                stz tmptos+1
.8def						_loop:
.8def		a5 27		lda $27		                lda tmp2
.8df1		c5 29		cmp $29		                cmp tmp3
.8df3		d0 06		bne $8dfb	                bne _not_empty
.8df5		a5 28		lda $28		                lda tmp2+1
.8df7		c5 2a		cmp $2a		                cmp tmp3+1
.8df9		f0 1d		beq $8e18	                beq _eol
.8dfb						_not_empty:
.8dfb		b2 27		lda ($27)	                lda (tmp2)
.8dfd		a4 23		ldy $23		                ldy tmptos
.8dff		c0 20		cpy #$20	                cpy #AscSP
.8e01		d0 07		bne $8e0a	                bne _not_whitespace
.8e03		20 64 d7	jsr $d764	                jsr is_whitespace
.8e06		90 02		bcc $8e0a	                bcc _not_whitespace
.8e08		80 0c		bra $8e16	                bra _found_delimiter
.8e0a						_not_whitespace:
.8e0a		c5 23		cmp $23		                cmp tmptos
.8e0c		f0 08		beq $8e16	                beq _found_delimiter
.8e0e		e6 27		inc $27		                inc tmp2
.8e10		d0 dd		bne $8def	                bne _loop
.8e12		e6 28		inc $28		                inc tmp2+1
.8e14		80 d9		bra $8def	                bra _loop
.8e16						_found_delimiter:
.8e16		e6 24		inc $24		                inc tmptos+1
.8e18						_eol:
.8e18		a5 27		lda $27		                lda tmp2
.8e1a		38		sec		                sec
.8e1b		e5 25		sbc $25		                sbc tmp1
.8e1d		95 00		sta $00,x	                sta 0,x
.8e1f		a5 28		lda $28		                lda tmp2+1
.8e21		e5 26		sbc $26		                sbc tmp1+1
.8e23		95 01		sta $01,x	                sta 1,x
.8e25		a5 27		lda $27		                lda tmp2
.8e27		38		sec		                sec
.8e28		e5 0c		sbc $0c		                sbc cib
.8e2a		85 10		sta $10		                sta toin
.8e2c		a5 28		lda $28		                lda tmp2+1
.8e2e		e5 0d		sbc $0d		                sbc cib+1
.8e30		85 11		sta $11		                sta toin+1
.8e32		a5 10		lda $10		                lda toin
.8e34		18		clc		                clc
.8e35		65 24		adc $24		                adc tmptos+1
.8e37		85 10		sta $10		                sta toin
.8e39		90 02		bcc $8e3d	                bcc +
.8e3b		e6 11		inc $11		                inc toin+1
.8e3d						+
.8e3d						_done:
.8e3d						z_parse_name:
.8e3d		60		rts		z_parse:        rts
.8e3e						xt_pick:
.8e3e		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.8e40		8a		txa		                txa
.8e41		75 00		adc $00,x	                adc 0,x
.8e43		a8		tay		                tay
.8e44		b9 02 00	lda $0002,y	                lda 0002,y
.8e47		95 00		sta $00,x	                sta 0,x
.8e49		b9 03 00	lda $0003,y	                lda 0003,y
.8e4c		95 01		sta $01,x	                sta 1,x
.8e4e		60		rts		z_pick:         rts
.8e4f						xt_plus:
.8e4f		20 76 d7	jsr $d776	                jsr underflow_2
.8e52		18		clc		                clc
.8e53		b5 00		lda $00,x	                lda 0,x         ; LSB
.8e55		75 02		adc $02,x	                adc 2,x
.8e57		95 02		sta $02,x	                sta 2,x
.8e59		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.8e5b		75 03		adc $03,x	                adc 3,x
.8e5d		95 03		sta $03,x	                sta 3,x
.8e5f		e8		inx		                inx
.8e60		e8		inx		                inx
.8e61		60		rts		z_plus:         rts
.8e62						xt_plus_store:
.8e62		20 76 d7	jsr $d776	                jsr underflow_2
.8e65		b5 00		lda $00,x	                lda 0,x
.8e67		85 25		sta $25		                sta tmp1
.8e69		b5 01		lda $01,x	                lda 1,x
.8e6b		85 26		sta $26		                sta tmp1+1
.8e6d		a0 00		ldy #$00	                ldy #0          ; LSB
.8e6f		b1 25		lda ($25),y	                lda (tmp1),y
.8e71		18		clc		                clc
.8e72		75 02		adc $02,x	                adc 2,x
.8e74		91 25		sta ($25),y	                sta (tmp1),y
.8e76		c8		iny		                iny             ; MSB
.8e77		b1 25		lda ($25),y	                lda (tmp1),y
.8e79		75 03		adc $03,x	                adc 3,x
.8e7b		91 25		sta ($25),y	                sta (tmp1),y
.8e7d		e8		inx		                inx
.8e7e		e8		inx		                inx
.8e7f		e8		inx		                inx
.8e80		e8		inx		                inx
.8e81		60		rts		z_plus_store:   rts
.8e82						xt_postpone:
.8e82		20 4d 8d	jsr $8d4d	                jsr xt_parse_name               ; ( -- addr n )
.8e85		b5 00		lda $00,x	                lda 0,x
.8e87		15 01		ora $01,x	                ora 1,x
.8e89		d0 05		bne $8e90	                bne +
.8e8b		a9 05		lda #$05	                lda #err_noname
.8e8d		4c 87 d7	jmp $d787	                jmp error
.8e90						+
.8e90		20 d7 9a	jsr $9ad7	                jsr xt_find_name                ; ( -- nt | 0 )
.8e93		d0 05		bne $8e9a	                bne +
.8e95		a9 05		lda #$05	                lda #err_noname
.8e97		4c 87 d7	jmp $d787	                jmp error
.8e9a						+
.8e9a		b5 00		lda $00,x	                lda 0,x
.8e9c		85 25		sta $25		                sta tmp1
.8e9e		b5 01		lda $01,x	                lda 1,x
.8ea0		85 26		sta $26		                sta tmp1+1
.8ea2		20 15 9c	jsr $9c15	                jsr xt_name_to_int              ; ( nt -- xt )
.8ea5		e6 25		inc $25		                inc tmp1
.8ea7		d0 02		bne $8eab	                bne +
.8ea9		e6 26		inc $26		                inc tmp1+1
.8eab						+
.8eab		b2 25		lda ($25)	                lda (tmp1)
.8ead		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.8eaf		f0 05		beq $8eb6	                beq _not_immediate
.8eb1		20 c3 96	jsr $96c3	                jsr xt_compile_comma
.8eb4		80 0a		bra $8ec0	                bra _done
.8eb6						_not_immediate:
.8eb6		20 f2 89	jsr $89f2	                jsr xt_literal
.8eb9		a0 96		ldy #$96	                ldy #>xt_compile_comma
.8ebb		a9 c3		lda #$c3	                lda #<xt_compile_comma
.8ebd		20 61 97	jsr $9761	                jsr cmpl_subroutine
.8ec0						_done:
.8ec0		60		rts		z_postpone:     rts
.8ec1						xt_question_dup:
.8ec1		20 71 d7	jsr $d771	                jsr underflow_1
.8ec4		b5 00		lda $00,x	                lda 0,x
.8ec6		15 01		ora $01,x	                ora 1,x
.8ec8		f0 0a		beq $8ed4	                beq _done
.8eca		ca		dex		                dex
.8ecb		ca		dex		                dex
.8ecc		b5 02		lda $02,x	                lda 2,x
.8ece		95 00		sta $00,x	                sta 0,x
.8ed0		b5 03		lda $03,x	                lda 3,x
.8ed2		95 01		sta $01,x	                sta 1,x
.8ed4						_done:
.8ed4		60		rts		z_question_dup: rts
.8ed5						xt_r_fetch:
.8ed5						w_r_fetch:
.8ed5		68		pla		                pla                     ; LSB
.8ed6		7a		ply		                ply                     ; MSB
.8ed7		1a		inc a		                inc a
.8ed8		85 25		sta $25		                sta tmp1                ; LSB
.8eda		d0 01		bne $8edd	                bne +
.8edc		c8		iny		                iny
.8edd						+
.8edd		84 26		sty $26		                sty tmp1+1              ; MSB
.8edf		ca		dex		                dex
.8ee0		ca		dex		                dex
.8ee1		7a		ply		                ply             ; LSB
.8ee2		94 00		sty $00,x	                sty 0,x
.8ee4		68		pla		                pla             ; MSB
.8ee5		95 01		sta $01,x	                sta 1,x
.8ee7		48		pha		                pha
.8ee8		5a		phy		                phy
.8ee9		6c 25 00	jmp ($0025)	z_r_fetch:      jmp (tmp1)
.8eec						xt_r_from:
.8eec						w_r_from:
.8eec		68		pla		                pla                     ; LSB
.8eed		7a		ply		                ply                     ; MSB
.8eee		1a		inc a		                inc a
.8eef		85 25		sta $25		                sta tmp1                ; LSB
.8ef1		d0 01		bne $8ef4	                bne +
.8ef3		c8		iny		                iny
.8ef4						+
.8ef4		84 26		sty $26		                sty tmp1+1              ; MSB
.8ef6		ca		dex		                dex
.8ef7		ca		dex		                dex
.8ef8		68		pla		                pla             ; LSB
.8ef9		95 00		sta $00,x	                sta 0,x
.8efb		68		pla		                pla             ; MSB
.8efc		95 01		sta $01,x	                sta 1,x
.8efe		6c 25 00	jmp ($0025)	z_r_from:       jmp (tmp1)
.8f01						xt_recurse:
.8f01		a0 00		ldy #$00	                ldy #0
.8f03		a9 20		lda #$20	                lda #OpJSR
.8f05		91 00		sta ($00),y	                sta (cp),y
.8f07		c8		iny		                iny
.8f08		24 1c		bit $1c		                bit status
.8f0a		70 0c		bvs $8f18	                bvs _nt_in_workword
.8f0c		a5 06		lda $06		                lda workword
.8f0e		91 00		sta ($00),y	                sta (cp),y
.8f10		c8		iny		                iny
.8f11		a5 07		lda $07		                lda workword+1
.8f13		91 00		sta ($00),y	                sta (cp),y
.8f15		c8		iny		                iny
.8f16		80 1b		bra $8f33	                bra _update_cp
.8f18						_nt_in_workword:
.8f18		a5 06		lda $06		                lda workword            ; LSB
.8f1a		18		clc		                clc
.8f1b		69 04		adc #$04	                adc #4
.8f1d		85 25		sta $25		                sta tmp1
.8f1f		a5 07		lda $07		                lda workword+1          ; MSB
.8f21		69 00		adc #$00	                adc #0
.8f23		85 26		sta $26		                sta tmp1+1
.8f25		b2 25		lda ($25)	                lda (tmp1)
.8f27		91 00		sta ($00),y	                sta (cp),y
.8f29		5a		phy		                phy
.8f2a		a0 01		ldy #$01	                ldy #1
.8f2c		b1 25		lda ($25),y	                lda (tmp1),y
.8f2e		7a		ply		                ply
.8f2f		c8		iny		                iny
.8f30		91 00		sta ($00),y	                sta (cp),y
.8f32		c8		iny		                iny
.8f33						_update_cp:
.8f33		98		tya		                tya
.8f34		18		clc		                clc
.8f35		65 00		adc $00		                adc cp
.8f37		85 00		sta $00		                sta cp
.8f39		90 02		bcc $8f3d	                bcc _done
.8f3b		e6 01		inc $01		                inc cp+1
.8f3d						_done:
.8f3d		60		rts		z_recurse:      rts
.8f3e						xt_refill:
.8f3e		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.8f40		d0 2d		bne $8f6f	                bne _src_not_kbd
.8f42		ca		dex		                dex
.8f43		ca		dex		                dex
.8f44		ca		dex		                dex
.8f45		ca		dex		                dex
.8f46		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.8f48		95 02		sta $02,x	                sta 2,x
.8f4a		a5 0d		lda $0d		                lda cib+1
.8f4c		95 03		sta $03,x	                sta 3,x
.8f4e		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.8f50		64 0f		stz $0f		                stz ciblen+1
.8f52		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.8f54		95 00		sta $00,x	                sta 0,x
.8f56		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.8f58		20 e4 80	jsr $80e4	                jsr xt_accept           ; ( addr n1 -- n2)
.8f5b		b5 00		lda $00,x	                lda 0,x
.8f5d		85 0e		sta $0e		                sta ciblen
.8f5f		b5 01		lda $01,x	                lda 1,x
.8f61		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.8f63		64 10		stz $10		                stz toin
.8f65		64 11		stz $11		                stz toin+1
.8f67		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.8f69		95 00		sta $00,x	                sta 0,x
.8f6b		95 01		sta $01,x	                sta 1,x
.8f6d		80 10		bra $8f7f	                bra _done
.8f6f						_src_not_kbd:
.8f6f		1a		inc a		                ina
.8f70		d0 08		bne $8f7a	                bne _src_not_string
.8f72		ca		dex		                dex
.8f73		ca		dex		                dex
.8f74		74 00		stz $00,x	                stz 0,x
.8f76		74 01		stz $01,x	                stz 1,x
.8f78		80 05		bra $8f7f	                bra z_refill
.8f7a						_src_not_string:
.8f7a		a9 01		lda #$01	                lda #err_badsource
.8f7c		4c 87 d7	jmp $d787	                jmp error
.8f7f						_done:
.8f7f		60		rts		z_refill:       rts
.8f80						xt_repeat:
.8f80		20 1f 82	jsr $821f	                jsr xt_again
.8f83		4c b4 86	jmp $86b4	                jmp xt_then
.8f86						z_repeat:
.8f86						xt_right_bracket:
.8f86		a9 ff		lda #$ff	                lda #$FF
.8f88		85 1a		sta $1a		                sta state
.8f8a		85 1b		sta $1b		                sta state+1
.8f8c						z_right_bracket:
.8f8c		60		rts		                rts
.8f8d						xt_rot:
.8f8d		20 7b d7	jsr $d77b	                jsr underflow_3
.8f90						w_rot:
.8f90		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.8f92		b5 03		lda $03,x	                lda 3,x
.8f94		95 05		sta $05,x	                sta 5,x
.8f96		b5 01		lda $01,x	                lda 1,x
.8f98		95 03		sta $03,x	                sta 3,x
.8f9a		94 01		sty $01,x	                sty 1,x
.8f9c		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.8f9e		b5 02		lda $02,x	                lda 2,x
.8fa0		95 04		sta $04,x	                sta 4,x
.8fa2		b5 00		lda $00,x	                lda 0,x
.8fa4		95 02		sta $02,x	                sta 2,x
.8fa6		94 00		sty $00,x	                sty 0,x
.8fa8		60		rts		z_rot:          rts
.8fa9						xt_rshift:
.8fa9		20 76 d7	jsr $d776	                jsr underflow_2
.8fac		b5 00		lda $00,x	                lda 0,x
.8fae		29 0f		and #$0f	                and #%00001111
.8fb0		f0 08		beq $8fba	                beq _done               ; if 0 shifts, quit
.8fb2		a8		tay		                tay
.8fb3						_loop:
.8fb3		56 03		lsr $03,x	                lsr 3,x
.8fb5		76 02		ror $02,x	                ror 2,x
.8fb7		88		dey		                dey
.8fb8		d0 f9		bne $8fb3	                bne _loop
.8fba						_done:
.8fba		e8		inx		                inx
.8fbb		e8		inx		                inx
.8fbc		60		rts		z_rshift:       rts
.8fbd						xt_s_backslash_quote:
.8fbd		a9 ff		lda #$ff	                lda #$FF
.8fbf		85 27		sta $27		                sta tmp2
.8fc1		64 28		stz $28		                stz tmp2+1
.8fc3		20 da 8f	jsr $8fda	                jsr s_quote_start
.8fc6						z_s_backslash_quote:
.8fc6		60		rts		                rts
.8fc7						convert_hex_value:
.8fc7		c9 41		cmp #$41	        cmp #'A'
.8fc9		90 07		bcc $8fd2	        bcc _digit
.8fcb		29 df		and #$df	        and #$DF                ; Make it uppercase.
.8fcd		38		sec		        sec
.8fce		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.8fd0		80 03		bra $8fd5	        bra _done
.8fd2						_digit:
.8fd2		38		sec		        sec
.8fd3		e9 30		sbc #$30	        sbc #'0'
.8fd5						_done:
.8fd5		60		rts		        rts
.8fd6						xt_s_quote:
.8fd6		64 27		stz $27		                stz tmp2
.8fd8		64 28		stz $28		                stz tmp2+1
.8fda						s_quote_start:
.8fda		20 82 97	jsr $9782	                jsr cmpl_jump_later
.8fdd		20 1b 89	jsr $891b	                jsr xt_here             ; the start of the string
.8fe0						_savechars_loop:
.8fe0		a5 11		lda $11		                lda toin+1              ; MSB
.8fe2		c5 0f		cmp $0f		                cmp ciblen+1
.8fe4		90 2a		bcc $9010	                bcc _input_fine         ; unsigned comparison
.8fe6		a5 10		lda $10		                lda toin                ; LSB
.8fe8		c5 0e		cmp $0e		                cmp ciblen
.8fea		90 24		bcc $9010	                bcc _input_fine
.8fec		a5 27		lda $27		                lda tmp2
.8fee		48		pha		                pha
.8fef		a5 28		lda $28		                lda tmp2+1
.8ff1		48		pha		                pha
.8ff2		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.8ff4		48		pha		                pha
.8ff5		20 3e 8f	jsr $8f3e	                jsr xt_refill           ; ( -- f )
.8ff8		68		pla		                pla
.8ff9		85 29		sta $29		                sta tmp3
.8ffb		68		pla		                pla
.8ffc		85 28		sta $28		                sta tmp2+1
.8ffe		68		pla		                pla
.8fff		85 27		sta $27		                sta tmp2
.9001		b5 00		lda $00,x	                lda 0,x
.9003		15 01		ora $01,x	                ora 1,x
.9005		d0 05		bne $900c	                bne _refill_ok
.9007		a9 06		lda #$06	                lda #err_refill
.9009		4c 87 d7	jmp $d787	                jmp error
.900c						_refill_ok:
.900c		e8		inx		                inx
.900d		e8		inx		                inx
.900e		80 d0		bra $8fe0	                bra _savechars_loop
.9010						_input_fine:
.9010		a5 0c		lda $0c		                lda cib
.9012		18		clc		                clc
.9013		65 10		adc $10		                adc toin        ; LSB
.9015		85 25		sta $25		                sta tmp1
.9017		a5 0d		lda $0d		                lda cib+1
.9019		65 11		adc $11		                adc toin+1      ; MSB
.901b		85 26		sta $26		                sta tmp1+1
.901d		b2 25		lda ($25)	                lda (tmp1)
.901f		24 27		bit $27		                bit tmp2
.9021		30 03		bmi $9026	                bmi _handle_escapes    ; Only checking bit 7
.9023		4c a9 90	jmp $90a9	                jmp _regular_char
.9026						_handle_escapes:
.9026		24 28		bit $28		                bit tmp2+1
.9028		30 03		bmi $902d	                bmi _escaped
.902a		4c 9f 90	jmp $909f	                jmp _not_escaped
.902d						_escaped:
.902d		70 3c		bvs $906b	                bvs _check_esc_chars
.902f		a9 01		lda #$01	                lda #1
.9031		24 28		bit $28		                bit tmp2+1
.9033		d0 10		bne $9045	                bne _esc_x_second_digit
.9035		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.9037		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.9039		20 c7 8f	jsr $8fc7	                jsr convert_hex_value
.903c		0a		asl a		                asl
.903d		0a		asl a		                asl
.903e		0a		asl a		                asl
.903f		0a		asl a		                asl
.9040		85 29		sta $29		                sta tmp3    ; Save it for later.
.9042		4c b0 90	jmp $90b0	                jmp _next_character
.9045						_esc_x_second_digit:
.9045		64 28		stz $28		                stz tmp2+1
.9047		b2 25		lda ($25)	                lda (tmp1)
.9049		20 c7 8f	jsr $8fc7	                jsr convert_hex_value
.904c		05 29		ora $29		                ora tmp3
.904e		4c ad 90	jmp $90ad	                jmp _save_character
.9051						_esc_tr_table:
>9051		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9052		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9053		00 00				    .byte   0,0             ; c, d no escape
>9055		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9056		0c				    .byte   12              ; f -> FF (ASCII value 12)
>9057		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>905c		0a				    .byte   10              ; l -> LF (ASCII value 10)
>905d		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>905e		0a				    .byte   10              ; n behaves like l --> lf
>905f		00 00				    .byte   0,0             ; o,p
>9061		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9062		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9063		00				    .byte   0               ; s
>9064		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9065		00				    .byte   0               ; u
>9066		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9067		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>906a		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.906b						_check_esc_chars:
.906b		64 28		stz $28		                stz tmp2+1
.906d		c9 61		cmp #$61	                cmp #'a'
.906f		30 1a		bmi $908b	                bmi _check_esc_quote
.9071		c9 7b		cmp #$7b	                cmp #'z'+1
.9073		10 16		bpl $908b	                bpl _check_esc_quote
.9075		a8		tay		                tay
.9076		b9 f0 8f	lda $8ff0,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9079		d0 03		bne $907e	                bne _esc_replace
.907b		98		tya		                tya                     ; revert if no translation
.907c		80 0d		bra $908b	                bra _check_esc_quote
.907e		10 2d		bpl $90ad	_esc_replace:   bpl _save_character     ; simple replacement
.9080		29 7f		and #$7f	                and #$7F                ; clear hi bit
.9082		f0 29		beq $90ad	                beq _save_character     ; NUL we can just output
.9084		20 71 97	jsr $9771	                jsr cmpl_a              ; else output first char (CR)
.9087		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9089		80 22		bra $90ad	                bra _save_character
.908b						_check_esc_quote:
.908b		c9 22		cmp #$22	                cmp #'"'
.908d		f0 1e		beq $90ad	                beq _save_character
.908f		c9 78		cmp #$78	                cmp #'x'
.9091		d0 06		bne $9099	                bne _check_esc_backslash
.9093		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.9095		85 28		sta $28		                sta tmp2+1
.9097		80 17		bra $90b0	                bra _next_character
.9099						_check_esc_backslash:
.9099		c9 5c		cmp #$5c	                cmp #'\'
.909b		d0 0c		bne $90a9	                bne _regular_char
.909d		80 0e		bra $90ad	                bra _save_character
.909f						_not_escaped:
.909f		c9 5c		cmp #$5c	                cmp #'\'
.90a1		d0 06		bne $90a9	                bne _regular_char
.90a3		a9 ff		lda #$ff	                lda #$FF
.90a5		85 28		sta $28		                sta tmp2+1
.90a7		80 07		bra $90b0	                bra _next_character
.90a9						_regular_char:
.90a9		c9 22		cmp #$22	                cmp #'"'
.90ab		f0 0c		beq $90b9	                beq _found_string_end
.90ad						_save_character:
.90ad		20 71 97	jsr $9771	                jsr cmpl_a
.90b0						_next_character:
.90b0		e6 10		inc $10		                inc toin
.90b2		d0 02		bne $90b6	                bne _savechars_loop_longjump
.90b4		e6 11		inc $11		                inc toin+1
.90b6						_savechars_loop_longjump:
.90b6		4c e0 8f	jmp $8fe0	                jmp _savechars_loop
.90b9						_found_string_end:
.90b9		e6 10		inc $10		                inc toin
.90bb		d0 02		bne $90bf	                bne +
.90bd		e6 11		inc $11		                inc toin+1
.90bf						+
.90bf		20 1b 89	jsr $891b	                jsr xt_here
.90c2		20 8d 8f	jsr $8f8d	                jsr xt_rot
.90c5		20 14 92	jsr $9214	                jsr xt_store    ; Update the jmp target
.90c8		20 1b 89	jsr $891b	                jsr xt_here
.90cb		20 01 8d	jsr $8d01	                jsr xt_over
.90ce		20 e4 8b	jsr $8be4	                jsr xt_minus    ; HERE - addr gives string length
.90d1		a5 1a		lda $1a		                lda state
.90d3		05 1b		ora $1b		                ora state+1             ; paranoid
.90d5		f0 03		beq $90da	                beq _done
.90d7		20 43 a1	jsr $a143	                jsr cmpl_sliteral         ; ( addr u -- )
.90da						_done:
.90da		60		rts		z_s_quote:      rts
.90db						xt_s_to_d:
.90db		20 71 d7	jsr $d771	                jsr underflow_1
.90de		ca		dex		                dex
.90df		ca		dex		                dex
.90e0		74 00		stz $00,x	                stz 0,x
.90e2		74 01		stz $01,x	                stz 1,x
.90e4		b5 03		lda $03,x	                lda 3,x
.90e6		10 04		bpl $90ec	                bpl _done
.90e8		d6 00		dec $00,x	                dec 0,x
.90ea		d6 01		dec $01,x	                dec 1,x
.90ec						_done:
.90ec		60		rts		z_s_to_d:       rts
.90ed						xt_semicolon:
.90ed		24 1c		bit $1c		                bit status
.90ef		70 11		bvs $9102	                bvs _colonword
.90f1		a9 60		lda #$60	                lda #OpRTS
.90f3		20 71 97	jsr $9771	                jsr cmpl_a
.90f6		ca		dex		                dex
.90f7		ca		dex		                dex
.90f8		a5 06		lda $06		                lda workword
.90fa		95 00		sta $00,x	                sta 0,x
.90fc		a5 07		lda $07		                lda workword+1
.90fe		95 01		sta $01,x	                sta 1,x
.9100		80 45		bra $9147	                bra _semicolon_done
.9102						_colonword:
.9102		a0 06		ldy #$06	                ldy #6
.9104		a5 00		lda $00		                lda cp
.9106		91 06		sta ($06),y	                sta (workword),y
.9108		c8		iny		                iny
.9109		a5 01		lda $01		                lda cp+1
.910b		91 06		sta ($06),y	                sta (workword),y
.910d		a9 60		lda #$60	                lda #OpRTS
.910f		20 71 97	jsr $9771	                jsr cmpl_a
.9112		24 1c		bit $1c		                bit status
.9114		10 26		bpl $913c	                bpl _new_word   ; Bit 7 is clear = new word
.9116		ca		dex		                dex
.9117		ca		dex		                dex
.9118		ca		dex		                dex
.9119		ca		dex		                dex
.911a		b2 06		lda ($06)	                lda (workword)
.911c		95 00		sta $00,x	                sta 0,x
.911e		74 01		stz $01,x	                stz 1,x
.9120		a5 06		lda $06		                lda workword
.9122		18		clc		                clc
.9123		69 08		adc #$08	                adc #8
.9125		95 02		sta $02,x	                sta 2,x
.9127		a5 07		lda $07		                lda workword+1
.9129		69 00		adc #$00	                adc #0                  ; only want carry
.912b		95 03		sta $03,x	                sta 3,x
.912d		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.912f		20 ad d7	jsr $d7ad	                jsr print_string_no_lf
.9132		20 c0 94	jsr $94c0	                jsr xt_type
.9135		20 c7 91	jsr $91c7	                jsr xt_space
.9138		a9 80		lda #$80	                lda #%10000000
.913a		14 1c		trb $1c		                trb status
.913c						_new_word:
.913c		a5 06		lda $06		                lda workword
.913e		85 02		sta $02		                sta dp
.9140		a5 07		lda $07		                lda workword+1
.9142		85 03		sta $03		                sta dp+1
.9144		20 db d6	jsr $d6db	                jsr dp_to_current       ; Save the updated DP to the
.9147						_semicolon_done:
.9147		64 1a		stz $1a		                stz state
.9149		64 1b		stz $1b		                stz state+1
.914b		60		rts		z_semicolon:    rts
.914c						xt_sign:
.914c		20 71 d7	jsr $d771	                jsr underflow_1
.914f						w_sign:
.914f		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9151		30 04		bmi $9157	                bmi _minus
.9153		e8		inx		                inx
.9154		e8		inx		                inx
.9155		80 09		bra $9160	                bra _done
.9157						_minus:
.9157		a9 2d		lda #$2d	                lda #'-'
.9159		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.915b		74 01		stz $01,x	                stz 1,x         ; paranoid
.915d		20 30 89	jsr $8930	                jsr w_hold
.9160						_done:
.9160		60		rts		z_sign:         rts
.9161						xt_slash:
.9161		a9 00		lda #$00	                lda #0
.9163		48		pha		                pha
.9164		80 03		bra $9169	                bra slashmod_common
.9166						xt_slash_mod:
.9166		a9 ff		lda #$ff	                lda #$FF
.9168		48		pha		                pha             ; falls through to _common
.9169						slashmod_common:
.9169		20 68 93	jsr $9368	                jsr xt_to_r             ; >R
.916c		20 db 90	jsr $90db	                jsr xt_s_to_d           ; S>D
.916f		20 ec 8e	jsr $8eec	                jsr xt_r_from           ; R>
.9172		20 7e 91	jsr $917e	                jsr xt_sm_slash_rem     ; SM/REM
.9175		68		pla		                pla
.9176		d0 05		bne $917d	                bne _done
.9178		20 2a 92	jsr $922a	                jsr xt_swap
.917b		e8		inx		                inx             ; DROP
.917c		e8		inx		                inx
.917d						_done:
.917d						z_slash_mod:
.917d		60		rts		z_slash:        rts
.917e						xt_sm_slash_rem:
.917e		20 7b d7	jsr $d77b	                jsr underflow_3 ; contains double number
.9181		b5 03		lda $03,x	                lda 3,x
.9183		48		pha		                pha
.9184		b5 01		lda $01,x	                lda 1,x
.9186		55 03		eor $03,x	                eor 3,x
.9188		48		pha		                pha
.9189		20 cf 80	jsr $80cf	                jsr xt_abs
.918c		e8		inx		                inx             ; pretend we pushed n1 to R
.918d		e8		inx		                inx
.918e		20 27 9e	jsr $9e27	                jsr xt_dabs
.9191		ca		dex		                dex
.9192		ca		dex		                dex
.9193		20 45 95	jsr $9545	                jsr xt_um_slash_mod     ; UM/MOD
.9196		68		pla		                pla
.9197		10 03		bpl $919c	                bpl +
.9199		20 1f 8c	jsr $8c1f	                jsr xt_negate
.919c						+
.919c		68		pla		                pla
.919d		10 07		bpl $91a6	                bpl _done
.919f		e8		inx		                inx             ; pretend we pushed quotient to R
.91a0		e8		inx		                inx
.91a1		20 1f 8c	jsr $8c1f	                jsr xt_negate
.91a4		ca		dex		                dex
.91a5		ca		dex		                dex
.91a6						_done:
.91a6		60		rts		z_sm_slash_rem: rts
.91a7						xt_source:
.91a7		ca		dex		                dex
.91a8		ca		dex		                dex
.91a9		a5 0c		lda $0c		                lda cib
.91ab		95 00		sta $00,x	                sta 0,x
.91ad		a5 0d		lda $0d		                lda cib+1
.91af		95 01		sta $01,x	                sta 1,x
.91b1		ca		dex		                dex
.91b2		ca		dex		                dex
.91b3		a5 0e		lda $0e		                lda ciblen
.91b5		95 00		sta $00,x	                sta 0,x
.91b7		a5 0f		lda $0f		                lda ciblen+1
.91b9		95 01		sta $01,x	                sta 1,x
.91bb		60		rts		z_source:       rts
.91bc						xt_source_id:
.91bc		ca		dex		                dex
.91bd		ca		dex		                dex
.91be		a5 0a		lda $0a		                lda insrc
.91c0		95 00		sta $00,x	                sta 0,x
.91c2		a5 0b		lda $0b		                lda insrc+1
.91c4		95 01		sta $01,x	                sta 1,x
.91c6		60		rts		z_source_id:    rts
.91c7						xt_space:
.91c7						w_space:
.91c7		a9 20		lda #$20	                lda #AscSP
.91c9		20 c5 86	jsr $86c5	                jsr emit_a
.91cc		60		rts		z_space:        rts
.91cd						xt_spaces:
.91cd		20 71 d7	jsr $d771	                jsr underflow_1
.91d0		b5 01		lda $01,x	                lda 1,x         ; ANS says this word takes a signed value
.91d2		30 10		bmi $91e4	                bmi _done       ; but prints no spaces for negative values.
.91d4		b4 00		ldy $00,x	                ldy 0,x
.91d6		f0 08		beq $91e0	                beq _msb
.91d8						_loop:
.91d8		a9 20		lda #$20	                lda #AscSP
.91da		20 c5 86	jsr $86c5	                jsr emit_a      ; user routine preserves X and Y
.91dd		88		dey		                dey
.91de		d0 f8		bne $91d8	                bne _loop       ; Y is zero on exit so looping again emits 256 more spaces
.91e0						_msb:
.91e0		d6 01		dec $01,x	                dec 1,x         ; when decrementing MSB goes negative, it was zero so we're done
.91e2		10 f4		bpl $91d8	                bpl _loop       ; otherwise emit another 256 spaces
.91e4		e8		inx		_done:          inx
.91e5		e8		inx		                inx
.91e6		60		rts		z_spaces:       rts
.91e7						xt_star:
.91e7		20 76 d7	jsr $d776	                jsr underflow_2
.91ea		20 87 95	jsr $9587	                jsr xt_um_star
.91ed		e8		inx		                inx
.91ee		e8		inx		                inx
.91ef		60		rts		z_star:         rts
.91f0						xt_star_slash:
.91f0		20 f9 91	jsr $91f9	                jsr xt_star_slash_mod
.91f3		20 2a 92	jsr $922a	                jsr xt_swap
.91f6		e8		inx		                inx
.91f7		e8		inx		                inx
.91f8						z_star_slash:
.91f8		60		rts		                rts
.91f9						xt_star_slash_mod:
.91f9		20 7b d7	jsr $d77b	                jsr underflow_3
.91fc		20 68 93	jsr $9368	                jsr xt_to_r
.91ff		20 21 8b	jsr $8b21	                jsr xt_m_star
.9202		20 ec 8e	jsr $8eec	                jsr xt_r_from
.9205		20 7e 91	jsr $917e	                jsr xt_sm_slash_rem
.9208						z_star_slash_mod:
.9208		60		rts		                rts
.9209						xt_state:
.9209		ca		dex		                dex
.920a		ca		dex		                dex
.920b		a9 1a		lda #$1a	                lda #<state
.920d		95 00		sta $00,x	                sta 0,x
.920f		a9 00		lda #$00	                lda #>state
.9211		95 01		sta $01,x	                sta 1,x
.9213		60		rts		z_state:        rts
.9214						xt_store:
.9214		20 76 d7	jsr $d776	                jsr underflow_2
.9217		b5 02		lda $02,x	                lda 2,x         ; LSB
.9219		81 00		sta ($00,x)	                sta (0,x)
.921b		f6 00		inc $00,x	                inc 0,x
.921d		d0 02		bne $9221	                bne +
.921f		f6 01		inc $01,x	                inc 1,x
.9221						+
.9221		b5 03		lda $03,x	                lda 3,x         ; MSB
.9223		81 00		sta ($00,x)	                sta (0,x)
.9225		e8		inx		                inx             ; 2DROP
.9226		e8		inx		                inx
.9227		e8		inx		                inx
.9228		e8		inx		                inx
.9229		60		rts		z_store:        rts
.922a						xt_swap:
.922a		20 76 d7	jsr $d776	                jsr underflow_2
.922d						w_swap:
.922d		b5 00		lda $00,x	                lda 0,x         ; LSB
.922f		b4 02		ldy $02,x	                ldy 2,x
.9231		95 02		sta $02,x	                sta 2,x
.9233		94 00		sty $00,x	                sty 0,x
.9235		b5 01		lda $01,x	                lda 1,x         ; MSB
.9237		b4 03		ldy $03,x	                ldy 3,x
.9239		95 03		sta $03,x	                sta 3,x
.923b		94 01		sty $01,x	                sty 1,x
.923d		60		rts		z_swap:         rts
.923e						xt_tick:
.923e		20 4d 8d	jsr $8d4d	                jsr xt_parse_name       ; ( -- addr u )
.9241		b5 00		lda $00,x	                lda 0,x
.9243		15 01		ora $01,x	                ora 1,x
.9245		d0 05		bne $924c	                bne +
.9247		a9 05		lda #$05	                lda #err_noname
.9249		4c 87 d7	jmp $d787	                jmp error
.924c						+
.924c		20 d7 9a	jsr $9ad7	                jsr xt_find_name        ; ( addr u -- nt )
.924f		b5 00		lda $00,x	                lda 0,x
.9251		15 01		ora $01,x	                ora 1,x
.9253		d0 05		bne $925a	                bne +
.9255		a9 08		lda #$08	                lda #err_syntax
.9257		4c 87 d7	jmp $d787	                jmp error
.925a						+
.925a		20 15 9c	jsr $9c15	                jsr xt_name_to_int      ; ( nt -- xt )
.925d		60		rts		z_tick:         rts
.925e						xt_to:
.925e		20 3e 92	jsr $923e	                jsr xt_tick             ; ( [n] xt )
.9261		b5 00		lda $00,x	                lda 0,x                 ; LSB
.9263		18		clc		                clc
.9264		69 03		adc #$03	                adc #3
.9266		85 25		sta $25		                sta tmp1
.9268		b5 01		lda $01,x	                lda 1,x                 ; MSB
.926a		69 00		adc #$00	                adc #0                  ; we just want the carry
.926c		85 26		sta $26		                sta tmp1+1
.926e		a5 1a		lda $1a		                lda state
.9270		05 1b		ora $1b		                ora state+1
.9272		f0 14		beq $9288	                beq _interpret
.9274		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.9276		95 00		sta $00,x	                sta 0,x
.9278		a5 26		lda $26		                lda tmp1+1
.927a		95 01		sta $01,x	                sta 1,x
.927c		20 f2 89	jsr $89f2	                jsr xt_literal      ; generate the runtime for LITERAL tmp1
.927f		a0 92		ldy #$92	                ldy #>xt_store      ; write the runtime for !
.9281		a9 14		lda #$14	                lda #<xt_store
.9283		20 61 97	jsr $9761	                jsr cmpl_subroutine
.9286		80 11		bra $9299	                bra _done
.9288						_interpret:
.9288		20 76 d7	jsr $d776	                jsr underflow_2
.928b		e8		inx		                inx
.928c		e8		inx		                inx                     ; leaving just ( n )
.928d		b5 00		lda $00,x	                lda 0,x
.928f		92 25		sta ($25)	                sta (tmp1)              ; LSB
.9291		a0 01		ldy #$01	                ldy #1
.9293		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9295		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.9297		e8		inx		                inx                     ; DROP
.9298		e8		inx		                inx
.9299						_done:
.9299		60		rts		z_to:           rts
.929a						xt_to_body:
.929a		20 71 d7	jsr $d771	                jsr underflow_1
.929d		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( xt xt )
.92a0		20 8f 9b	jsr $9b8f	                jsr xt_int_to_name      ; ( xt nt )
.92a3		f6 00		inc $00,x	                inc 0,x
.92a5		d0 02		bne $92a9	                bne +
.92a7		f6 01		inc $01,x	                inc 1,x
.92a9						+
.92a9		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.92ab		29 20		and #$20	                and #HC
.92ad		f0 0b		beq $92ba	                beq _no_cfa
.92af		18		clc		                clc
.92b0		b5 02		lda $02,x	                lda 2,x         ; LSB
.92b2		69 03		adc #$03	                adc #3
.92b4		95 02		sta $02,x	                sta 2,x
.92b6		90 02		bcc $92ba	                bcc _no_cfa
.92b8		f6 03		inc $03,x	                inc 3,x         ; MSB
.92ba						_no_cfa:
.92ba		e8		inx		                inx             ; get rid of the nt
.92bb		e8		inx		                inx
.92bc		60		rts		z_to_body:      rts
.92bd						xt_to_in:
.92bd		ca		dex		                dex
.92be		ca		dex		                dex
.92bf		a9 10		lda #$10	                lda #<toin
.92c1		95 00		sta $00,x	                sta 0,x
.92c3		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.92c5		95 01		sta $01,x	                sta 1,x
.92c7		60		rts		z_to_in:        rts
.92c8						xt_to_number:
.92c8		20 80 d7	jsr $d780	                jsr underflow_4
.92cb		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.92cd		85 2d		sta $2d		                sta scratch
.92cf		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.92d1		85 2e		sta $2e		                sta scratch+1
.92d3		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.92d5		85 2f		sta $2f		                sta scratch+2
.92d7		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.92d9		85 30		sta $30		                sta scratch+3
.92db		ca		dex		                dex
.92dc		ca		dex		                dex
.92dd						_loop:
.92dd		a1 04		lda ($04,x)	                lda (4,x)
.92df		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.92e1		74 01		stz $01,x	                stz 1,x                 ; paranoid
.92e3		20 7b 9a	jsr $9a7b	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.92e6		b5 00		lda $00,x	                lda 0,x
.92e8		d0 04		bne $92ee	                bne _digit_ok
.92ea		e8		inx		                inx
.92eb		e8		inx		                inx
.92ec		80 67		bra $9355	                bra _done       ; ( ud-lo ud-hi addr u char )
.92ee						_digit_ok:
.92ee		b5 02		lda $02,x	                lda 2,x
.92f0		85 31		sta $31		                sta scratch+4
.92f2		b5 03		lda $03,x	                lda 3,x
.92f4		85 32		sta $32		                sta scratch+5
.92f6		a5 2f		lda $2f		                lda scratch+2
.92f8		95 02		sta $02,x	                sta 2,x         ; NOS
.92fa		a5 30		lda $30		                lda scratch+3
.92fc		95 03		sta $03,x	                sta 3,x
.92fe		a5 18		lda $18		                lda base
.9300		95 00		sta $00,x	                sta 0,x         ; TOS
.9302		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.9304		20 87 95	jsr $9587	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.9307		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.9309		85 33		sta $33		                sta scratch+6
.930b		b5 03		lda $03,x	                lda 3,x
.930d		85 34		sta $34		                sta scratch+7
.930f		a5 2d		lda $2d		                lda scratch
.9311		95 02		sta $02,x	                sta 2,x
.9313		a5 2e		lda $2e		                lda scratch+1
.9315		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.9317		a5 18		lda $18		                lda base
.9319		95 00		sta $00,x	                sta 0,x
.931b		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.931d		20 87 95	jsr $9587	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.9320		b5 00		lda $00,x	                lda 0,x
.9322		85 2f		sta $2f		                sta scratch+2
.9324		b5 01		lda $01,x	                lda 1,x
.9326		85 30		sta $30		                sta scratch+3
.9328		b5 02		lda $02,x	                lda 2,x
.932a		85 2d		sta $2d		                sta scratch
.932c		b5 03		lda $03,x	                lda 3,x
.932e		85 2e		sta $2e		                sta scratch+1
.9330		18		clc		                clc
.9331		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.9333		65 31		adc $31		                adc scratch+4   ; n LSB
.9335		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.9337		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.9339		65 32		adc $32		                adc scratch+5   ; n MSB
.933b		85 2e		sta $2e		                sta scratch+1
.933d		a5 2f		lda $2f		                lda scratch+2   ; LSB
.933f		65 33		adc $33		                adc scratch+6
.9341		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.9343		a5 30		lda $30		                lda scratch+3   ; MSB
.9345		65 34		adc $34		                adc scratch+7
.9347		85 30		sta $30		                sta scratch+3
.9349		e8		inx		                inx
.934a		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.934b		f6 04		inc $04,x	                inc 4,x
.934d		d0 02		bne $9351	                bne +
.934f		f6 05		inc $05,x	                inc 5,x
.9351						+
.9351		d6 02		dec $02,x	                dec 2,x
.9353		d0 88		bne $92dd	                bne _loop
.9355						_done:
.9355		e8		inx		                inx
.9356		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.9357		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.9359		95 06		sta $06,x	                sta 6,x
.935b		a5 2e		lda $2e		                lda scratch+1
.935d		95 07		sta $07,x	                sta 7,x
.935f		a5 2f		lda $2f		                lda scratch+2
.9361		95 04		sta $04,x	                sta 4,x
.9363		a5 30		lda $30		                lda scratch+3
.9365		95 05		sta $05,x	                sta 5,x
.9367		60		rts		z_to_number:    rts
.9368						xt_to_r:
.9368						w_to_r:
.9368		68		pla		                pla                     ; LSB
.9369		7a		ply		                ply                     ; MSB
.936a		1a		inc a		                inc a
.936b		85 25		sta $25		                sta tmp1                ; LSB
.936d		d0 01		bne $9370	                bne +
.936f		c8		iny		                iny
.9370						+
.9370		84 26		sty $26		                sty tmp1+1              ; MSB
.9372		20 71 d7	jsr $d771	                jsr underflow_1
.9375		b5 01		lda $01,x	                lda 1,x         ; MSB
.9377		48		pha		                pha
.9378		b5 00		lda $00,x	                lda 0,x         ; LSB
.937a		48		pha		                pha
.937b		e8		inx		                inx
.937c		e8		inx		                inx
.937d		6c 25 00	jmp ($0025)	z_to_r:         jmp (tmp1)
.9380						xt_true:
.9380		ca		dex		                dex
.9381		ca		dex		                dex
.9382		a9 ff		lda #$ff	                lda #$FF
.9384		95 00		sta $00,x	                sta 0,x
.9386		95 01		sta $01,x	                sta 1,x
.9388		60		rts		z_true:         rts
.9389						xt_tuck:
.9389		20 76 d7	jsr $d776	                jsr underflow_2
.938c		ca		dex		                dex
.938d		ca		dex		                dex
.938e		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.9390		b5 02		lda $02,x	                lda 2,x
.9392		95 04		sta $04,x	                sta 4,x
.9394		94 02		sty $02,x	                sty 2,x
.9396		95 00		sta $00,x	                sta 0,x
.9398		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.939a		b5 03		lda $03,x	                lda 3,x
.939c		95 05		sta $05,x	                sta 5,x
.939e		94 03		sty $03,x	                sty 3,x         ; bba
.93a0		95 01		sta $01,x	                sta 1,x         ; baa
.93a2		60		rts		z_tuck:         rts
.93a3						xt_two_drop:
.93a3		20 76 d7	jsr $d776	                jsr underflow_2
.93a6		e8		inx		                inx
.93a7		e8		inx		                inx
.93a8		e8		inx		                inx
.93a9		e8		inx		                inx
.93aa		60		rts		z_two_drop:     rts
.93ab						xt_two_dup:
.93ab		20 76 d7	jsr $d776	                jsr underflow_2
.93ae		ca		dex		                dex
.93af		ca		dex		                dex
.93b0		ca		dex		                dex
.93b1		ca		dex		                dex
.93b2		b5 04		lda $04,x	                lda 4,x         ; TOS
.93b4		95 00		sta $00,x	                sta 0,x
.93b6		b5 05		lda $05,x	                lda 5,x
.93b8		95 01		sta $01,x	                sta 1,x
.93ba		b5 06		lda $06,x	                lda 6,x         ; NOS
.93bc		95 02		sta $02,x	                sta 2,x
.93be		b5 07		lda $07,x	                lda 7,x
.93c0		95 03		sta $03,x	                sta 3,x
.93c2		60		rts		z_two_dup:      rts
.93c3						xt_two_fetch:
.93c3		20 71 d7	jsr $d771	                jsr underflow_1
.93c6		b5 00		lda $00,x	                lda 0,x
.93c8		85 25		sta $25		                sta tmp1
.93ca		b4 01		ldy $01,x	                ldy 1,x
.93cc		84 26		sty $26		                sty tmp1+1
.93ce		ca		dex		                dex             ; reuse one stack element
.93cf		ca		dex		                dex
.93d0		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.93d2		95 00		sta $00,x	                sta 0,x
.93d4		a0 01		ldy #$01	                ldy #1          ; copy next
.93d6		b1 25		lda ($25),y	                lda (tmp1),y
.93d8		95 01		sta $01,x	                sta 1,x
.93da		c8		iny		                iny             ; copy next
.93db		b1 25		lda ($25),y	                lda (tmp1),y
.93dd		95 02		sta $02,x	                sta 2,x
.93df		c8		iny		                iny             ; copy next
.93e0		b1 25		lda ($25),y	                lda (tmp1),y
.93e2		95 03		sta $03,x	                sta 3,x
.93e4		60		rts		z_two_fetch:    rts
.93e5						xt_two_over:
.93e5		20 80 d7	jsr $d780	                jsr underflow_4
.93e8		ca		dex		                dex
.93e9		ca		dex		                dex
.93ea		ca		dex		                dex
.93eb		ca		dex		                dex
.93ec		b5 08		lda $08,x	                lda 8,x
.93ee		95 00		sta $00,x	                sta 0,x
.93f0		b5 09		lda $09,x	                lda 9,x
.93f2		95 01		sta $01,x	                sta 1,x
.93f4		b5 0a		lda $0a,x	                lda 10,x
.93f6		95 02		sta $02,x	                sta 2,x
.93f8		b5 0b		lda $0b,x	                lda 11,x
.93fa		95 03		sta $03,x	                sta 3,x
.93fc		60		rts		z_two_over:     rts
.93fd						xt_two_r_fetch:
.93fd		68		pla		                pla                     ; LSB
.93fe		7a		ply		                ply                     ; MSB
.93ff		1a		inc a		                inc a
.9400		85 25		sta $25		                sta tmp1                ; LSB
.9402		d0 01		bne $9405	                bne +
.9404		c8		iny		                iny
.9405						+
.9405		84 26		sty $26		                sty tmp1+1              ; MSB
.9407		8a		txa		                txa             ; set Y = SP; X -= 4
.9408		ba		tsx		                tsx
.9409		da		phx		                phx
.940a		7a		ply		                ply
.940b		38		sec		                sec
.940c		e9 04		sbc #$04	                sbc #4
.940e		aa		tax		                tax
.940f		b9 01 01	lda $0101,y	                lda $101,y
.9412		95 00		sta $00,x	                sta 0,x
.9414		b9 02 01	lda $0102,y	                lda $102,y
.9417		95 01		sta $01,x	                sta 1,x
.9419		b9 03 01	lda $0103,y	                lda $103,y
.941c		95 02		sta $02,x	                sta 2,x
.941e		b9 04 01	lda $0104,y	                lda $104,y
.9421		95 03		sta $03,x	                sta 3,x
.9423		6c 25 00	jmp ($0025)	z_two_r_fetch:  jmp (tmp1)
.9426						xt_two_r_from:
.9426		68		pla		                pla                     ; LSB
.9427		7a		ply		                ply                     ; MSB
.9428		1a		inc a		                inc a
.9429		85 25		sta $25		                sta tmp1                ; LSB
.942b		d0 01		bne $942e	                bne +
.942d		c8		iny		                iny
.942e						+
.942e		84 26		sty $26		                sty tmp1+1              ; MSB
.9430		ca		dex		                dex
.9431		ca		dex		                dex
.9432		ca		dex		                dex
.9433		ca		dex		                dex
.9434		68		pla		                pla                     ; LSB
.9435		95 00		sta $00,x	                sta 0,x
.9437		68		pla		                pla                     ; MSB
.9438		95 01		sta $01,x	                sta 1,x
.943a		68		pla		                pla                     ; LSB
.943b		95 02		sta $02,x	                sta 2,x
.943d		68		pla		                pla                     ; MSB
.943e		95 03		sta $03,x	                sta 3,x
.9440		6c 25 00	jmp ($0025)	z_two_r_from:   jmp (tmp1)
.9443						xt_two_slash:
.9443		20 71 d7	jsr $d771	                jsr underflow_1
.9446		b5 01		lda $01,x	                lda 1,x
.9448		0a		asl a		                asl                     ; save the sign
.9449		76 01		ror $01,x	                ror 1,x
.944b		76 00		ror $00,x	                ror 0,x
.944d		60		rts		z_two_slash:    rts
.944e						xt_two_star:
.944e						xt_cells:
.944e		20 71 d7	jsr $d771	                jsr underflow_1
.9451		16 00		asl $00,x	                asl 0,x
.9453		36 01		rol $01,x	                rol 1,x
.9455						z_cells:
.9455		60		rts		z_two_star:     rts
.9456						xt_two_store:
.9456		20 7b d7	jsr $d77b	                jsr underflow_3
.9459		b5 00		lda $00,x	                lda 0,x
.945b		85 25		sta $25		                sta tmp1
.945d		b4 01		ldy $01,x	                ldy 1,x
.945f		84 26		sty $26		                sty tmp1+1
.9461		e8		inx		                inx
.9462		e8		inx		                inx
.9463		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.9465		92 25		sta ($25)	                sta (tmp1)
.9467		b5 01		lda $01,x	                lda 1,x         ; copy next
.9469		a0 01		ldy #$01	                ldy #1
.946b		91 25		sta ($25),y	                sta (tmp1),y
.946d		b5 02		lda $02,x	                lda 2,x         ; copy next
.946f		c8		iny		                iny
.9470		91 25		sta ($25),y	                sta (tmp1),y
.9472		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.9474		c8		iny		                iny
.9475		91 25		sta ($25),y	                sta (tmp1),y
.9477		e8		inx		                inx             ; 2DROP
.9478		e8		inx		                inx
.9479		e8		inx		                inx
.947a		e8		inx		                inx
.947b		60		rts		z_two_store:    rts
.947c						xt_two_swap:
.947c		20 80 d7	jsr $d780	                jsr underflow_4
.947f		b5 00		lda $00,x	                lda 0,x
.9481		b4 04		ldy $04,x	                ldy 4,x
.9483		95 04		sta $04,x	                sta 4,x
.9485		94 00		sty $00,x	                sty 0,x
.9487		b5 01		lda $01,x	                lda 1,x
.9489		b4 05		ldy $05,x	                ldy 5,x
.948b		95 05		sta $05,x	                sta 5,x
.948d		94 01		sty $01,x	                sty 1,x
.948f		b5 02		lda $02,x	                lda 2,x
.9491		b4 06		ldy $06,x	                ldy 6,x
.9493		95 06		sta $06,x	                sta 6,x
.9495		94 02		sty $02,x	                sty 2,x
.9497		b5 03		lda $03,x	                lda 3,x
.9499		b4 07		ldy $07,x	                ldy 7,x
.949b		95 07		sta $07,x	                sta 7,x
.949d		94 03		sty $03,x	                sty 3,x
.949f		60		rts		z_two_swap:     rts
.94a0						xt_two_to_r:
.94a0		68		pla		                pla                     ; LSB
.94a1		7a		ply		                ply                     ; MSB
.94a2		1a		inc a		                inc a
.94a3		85 25		sta $25		                sta tmp1                ; LSB
.94a5		d0 01		bne $94a8	                bne +
.94a7		c8		iny		                iny
.94a8						+
.94a8		84 26		sty $26		                sty tmp1+1              ; MSB
.94aa		20 76 d7	jsr $d776	                jsr underflow_2
.94ad		b5 03		lda $03,x	                lda 3,x         ; MSB
.94af		48		pha		                pha
.94b0		b5 02		lda $02,x	                lda 2,x         ; LSB
.94b2		48		pha		                pha
.94b3		b5 01		lda $01,x	                lda 1,x         ; MSB
.94b5		48		pha		                pha
.94b6		b5 00		lda $00,x	                lda 0,x         ; LSB
.94b8		48		pha		                pha
.94b9		e8		inx		                inx
.94ba		e8		inx		                inx
.94bb		e8		inx		                inx
.94bc		e8		inx		                inx
.94bd		6c 25 00	jmp ($0025)	z_two_to_r:     jmp (tmp1)
.94c0						xt_type:
.94c0		20 76 d7	jsr $d776	                jsr underflow_2
.94c3						w_type:
.94c3		b5 02		lda $02,x	                lda 2,x
.94c5		85 25		sta $25		                sta tmp1
.94c7		b5 03		lda $03,x	                lda 3,x
.94c9		85 26		sta $26		                sta tmp1+1
.94cb						_loop:
.94cb		b5 00		lda $00,x	                lda 0,x
.94cd		15 01		ora $01,x	                ora 1,x
.94cf		f0 15		beq $94e6	                beq _done
.94d1		b2 25		lda ($25)	                lda (tmp1)
.94d3		20 c5 86	jsr $86c5	                jsr emit_a      ; avoids stack foolery
.94d6		e6 25		inc $25		                inc tmp1
.94d8		d0 02		bne $94dc	                bne +
.94da		e6 26		inc $26		                inc tmp1+1
.94dc						+
.94dc		b5 00		lda $00,x	                lda 0,x
.94de		d0 02		bne $94e2	                bne +
.94e0		d6 01		dec $01,x	                dec 1,x
.94e2						+
.94e2		d6 00		dec $00,x	                dec 0,x
.94e4		80 e5		bra $94cb	                bra _loop
.94e6						_done:
.94e6		e8		inx		                inx
.94e7		e8		inx		                inx
.94e8		e8		inx		                inx
.94e9		e8		inx		                inx
.94ea		60		rts		z_type:         rts
.94eb						xt_u_dot:
.94eb		20 71 d7	jsr $d771	                jsr underflow_1
.94ee		20 de d7	jsr $d7de	                jsr print_u
.94f1		a9 20		lda #$20	                lda #AscSP
.94f3		20 c5 86	jsr $86c5	                jsr emit_a
.94f6		60		rts		z_u_dot:        rts
.94f7						xt_u_dot_r:
.94f7		20 76 d7	jsr $d776	                jsr underflow_2
.94fa		20 68 93	jsr $9368	                jsr xt_to_r
.94fd		20 d8 9d	jsr $9dd8	                jsr xt_zero
.9500		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9503		20 af 8c	jsr $8caf	                jsr xt_number_sign_s
.9506		20 8d 8c	jsr $8c8d	                jsr xt_number_sign_greater
.9509		20 ec 8e	jsr $8eec	                jsr xt_r_from
.950c		20 01 8d	jsr $8d01	                jsr xt_over
.950f		20 e4 8b	jsr $8be4	                jsr xt_minus
.9512		20 cd 91	jsr $91cd	                jsr xt_spaces
.9515		20 c0 94	jsr $94c0	                jsr xt_type
.9518		60		rts		z_u_dot_r:      rts
.9519						xt_u_greater_than:
.9519		20 76 d7	jsr $d776	                jsr underflow_2
.951c		b5 00		lda $00,x	                lda 0,x
.951e		d5 02		cmp $02,x	                cmp 2,x
.9520		b5 01		lda $01,x	                lda 1,x
.9522		f5 03		sbc $03,x	                sbc 3,x
.9524		e8		inx		                inx
.9525		e8		inx		                inx
.9526		a9 00		lda #$00	                lda #0
.9528		69 ff		adc #$ff	                adc #$FF
.952a		95 00		sta $00,x	                sta 0,x         ; store flag
.952c		95 01		sta $01,x	                sta 1,x
.952e		60		rts		z_u_greater_than:    rts
.952f						xt_u_less_than:
.952f		20 76 d7	jsr $d776	                jsr underflow_2
.9532		b5 02		lda $02,x	                lda 2,x
.9534		d5 00		cmp $00,x	                cmp 0,x
.9536		b5 03		lda $03,x	                lda 3,x
.9538		f5 01		sbc $01,x	                sbc 1,x
.953a		e8		inx		                inx
.953b		e8		inx		                inx
.953c		a9 00		lda #$00	                lda #0
.953e		69 ff		adc #$ff	                adc #$FF
.9540		95 00		sta $00,x	                sta 0,x         ; store flag
.9542		95 01		sta $01,x	                sta 1,x
.9544		60		rts		z_u_less_than:    rts
.9545						xt_um_slash_mod:
.9545		20 7b d7	jsr $d77b	                jsr underflow_3
.9548						w_um_slash_mod:
.9548		b5 00		lda $00,x	                lda 0,x
.954a		15 01		ora $01,x	                ora 1,x
.954c		d0 05		bne $9553	                bne _not_zero
.954e		a9 04		lda #$04	                lda #err_divzero
.9550		4c 87 d7	jmp $d787	                jmp error
.9553						_not_zero:
.9553		a9 11		lda #$11	                lda #17
.9555		85 23		sta $23		                sta tmptos
.9557						_loop:
.9557		36 04		rol $04,x	                rol 4,x
.9559		36 05		rol $05,x	                rol 5,x
.955b		c6 23		dec $23		                dec tmptos
.955d		f0 22		beq $9581	                beq _done
.955f		36 02		rol $02,x	                rol 2,x
.9561		36 03		rol $03,x	                rol 3,x
.9563		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.9565		26 25		rol $25		                rol tmp1
.9567		38		sec		                sec
.9568		b5 02		lda $02,x	                lda 2,x
.956a		f5 00		sbc $00,x	                sbc 0,x
.956c		85 26		sta $26		                sta tmp1+1
.956e		b5 03		lda $03,x	                lda 3,x
.9570		f5 01		sbc $01,x	                sbc 1,x
.9572		a8		tay		                tay
.9573		a5 25		lda $25		                lda tmp1
.9575		e9 00		sbc #$00	                sbc #0
.9577		90 de		bcc $9557	                bcc _loop
.9579		a5 26		lda $26		                lda tmp1+1
.957b		95 02		sta $02,x	                sta 2,x
.957d		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.957f		80 d6		bra $9557	                bra _loop
.9581						_done:
.9581		e8		inx		                inx
.9582		e8		inx		                inx
.9583		20 2d 92	jsr $922d	                jsr w_swap
.9586		60		rts		z_um_slash_mod: rts
.9587						xt_um_star:
.9587		20 76 d7	jsr $d776	                jsr underflow_2
.958a		18		clc		                clc
.958b		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.958d		e9 00		sbc #$00	                sbc #0
.958f		85 27		sta $27		                sta tmp2
.9591		b5 01		lda $01,x	                lda 1,x
.9593		e9 00		sbc #$00	                sbc #0
.9595		90 31		bcc $95c8	                bcc _zero       ; is TOS zero?
.9597		85 28		sta $28		                sta tmp2+1
.9599		a9 00		lda #$00	                lda #0
.959b		85 25		sta $25		                sta tmp1
.959d		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.959f		ca		dex		                dex
.95a0		ca		dex		                dex
.95a1						_outer_loop:
.95a1		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.95a3		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.95a5						_inner_loop:
.95a5		90 0c		bcc $95b3	                bcc _no_add
.95a7		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.95a9		a5 25		lda $25		                lda tmp1
.95ab		65 27		adc $27		                adc tmp2
.95ad		85 25		sta $25		                sta tmp1
.95af		a5 26		lda $26		                lda tmp1+1
.95b1		65 28		adc $28		                adc tmp2+1
.95b3						_no_add:
.95b3		6a		ror a		                ror
.95b4		66 25		ror $25		                ror tmp1
.95b6		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.95b8		88		dey		                dey
.95b9		d0 ea		bne $95a5	                bne _inner_loop ; go back for one more shift?
.95bb		e8		inx		                inx
.95bc		e4 29		cpx $29		                cpx tmp3
.95be		d0 e1		bne $95a1	                bne _outer_loop ; go back for eight more shifts?
.95c0		95 01		sta $01,x	                sta 1,x
.95c2		a5 25		lda $25		                lda tmp1
.95c4		95 00		sta $00,x	                sta 0,x
.95c6		80 04		bra $95cc	                bra _done
.95c8						_zero:
.95c8		74 02		stz $02,x	                stz 2,x
.95ca		74 03		stz $03,x	                stz 3,x
.95cc						_done:
.95cc		60		rts		z_um_star:      rts
.95cd						xt_unloop:
.95cd		a4 1f		ldy $1f		                ldy loopctrl
.95cf		88		dey		                dey
.95d0		88		dey		                dey
.95d1		88		dey		                dey
.95d2		88		dey		                dey
.95d3		84 1f		sty $1f		                sty loopctrl
.95d5		30 05		bmi $95dc	                bmi z_unloop            ; no active loops?
.95d7		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.95da		85 20		sta $20		                sta loopidx0
.95dc		60		rts		z_unloop:       rts
.95dd						xt_until:
.95dd		20 b3 97	jsr $97b3	                jsr cmpl_0branch_tos
.95e0		60		rts		z_until:        rts
.95e1						xt_unused:
.95e1		ca		dex		                dex
.95e2		ca		dex		                dex
.95e3		a9 00		lda #$00	                lda #<cp_end
.95e5		38		sec		                sec
.95e6		e5 00		sbc $00		                sbc cp
.95e8		95 00		sta $00,x	                sta 0,x
.95ea		a9 7c		lda #$7c	                lda #>cp_end
.95ec		e5 01		sbc $01		                sbc cp+1
.95ee		95 01		sta $01,x	                sta 1,x
.95f0		60		rts		z_unused:       rts
.95f1						xt_variable:
.95f1		20 40 84	jsr $8440	                jsr xt_create
.95f4		a9 00		lda #$00	                lda #0
.95f6		92 00		sta ($00)	                sta (cp)
.95f8		e6 00		inc $00		                inc cp
.95fa		d0 02		bne $95fe	                bne +
.95fc		e6 01		inc $01		                inc cp+1
.95fe						+
.95fe		92 00		sta ($00)	                sta (cp)
.9600		e6 00		inc $00		                inc cp
.9602		d0 02		bne $9606	                bne +
.9604		e6 01		inc $01		                inc cp+1
.9606						+
.9606		20 08 84	jsr $8408	                jsr adjust_z
.9609		60		rts		z_variable:     rts
.960a						xt_while:
.960a		20 9e 97	jsr $979e	                jsr cmpl_0branch_later          ; branch to location we'll determine later
.960d		20 2a 92	jsr $922a	                jsr xt_swap
.9610		60		rts		z_while:        rts
.9611						xt_within:
.9611		20 7b d7	jsr $d77b	                jsr underflow_3
.9614		20 01 8d	jsr $8d01	                jsr xt_over
.9617		20 e4 8b	jsr $8be4	                jsr xt_minus
.961a		20 68 93	jsr $9368	                jsr xt_to_r
.961d		20 e4 8b	jsr $8be4	                jsr xt_minus
.9620		20 ec 8e	jsr $8eec	                jsr xt_r_from
.9623		20 2f 95	jsr $952f	                jsr xt_u_less_than
.9626		60		rts		z_within:       rts
.9627						xt_word:
.9627		20 71 d7	jsr $d771	                jsr underflow_1
.962a		a4 10		ldy $10		                ldy toin                ; >IN
.962c						_loop:
.962c		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.962e		f0 09		beq $9639	                beq _found_char
.9630		b1 0c		lda ($0c),y	                lda (cib),y
.9632		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.9634		d0 03		bne $9639	                bne _found_char
.9636		c8		iny		                iny
.9637		80 f3		bra $962c	                bra _loop
.9639						_found_char:
.9639		84 10		sty $10		                sty toin
.963b		20 a8 8d	jsr $8da8	                jsr xt_parse            ; Returns ( addr u )
.963e		b5 00		lda $00,x	                lda 0,x
.9640		92 00		sta ($00)	                sta (cp)                ; Save length of string
.9642		48		pha		                pha                     ; Keep copy of length for later
.9643		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr u u )
.9646		a5 00		lda $00		                lda cp
.9648		18		clc		                clc
.9649		69 01		adc #$01	                adc #1
.964b		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.964d		a5 01		lda $01		                lda cp+1
.964f		69 00		adc #$00	                adc #0
.9651		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.9653		20 00 8c	jsr $8c00	                jsr xt_move
.9656		ca		dex		                dex
.9657		ca		dex		                dex
.9658		a5 00		lda $00		                lda cp
.965a		95 00		sta $00,x	                sta 0,x
.965c		a5 01		lda $01		                lda cp+1
.965e		95 01		sta $01,x	                sta 1,x
.9660		68		pla		                pla                     ; length of string
.9661		18		clc		                clc
.9662		65 00		adc $00		                adc cp
.9664		85 00		sta $00		                sta cp
.9666		90 02		bcc $966a	                bcc z_word
.9668		e6 01		inc $01		                inc cp+1
.966a		60		rts		z_word:         rts
.966b						xt_xor:
.966b		20 76 d7	jsr $d776	                jsr underflow_2
.966e		b5 00		lda $00,x	                lda 0,x
.9670		55 02		eor $02,x	                eor 2,x
.9672		95 02		sta $02,x	                sta 2,x
.9674		b5 01		lda $01,x	                lda 1,x
.9676		55 03		eor $03,x	                eor 3,x
.9678		95 03		sta $03,x	                sta 3,x
.967a		e8		inx		                inx
.967b		e8		inx		                inx
.967c		60		rts		z_xor:          rts
.967d						xt_zero_equal:
.967d		20 71 d7	jsr $d771	                jsr underflow_1
.9680		b5 00		lda $00,x	                lda 0,x
.9682		15 01		ora $01,x	                ora 1,x
.9684		f0 02		beq $9688	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.9686		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.9688						_zero:
.9688		49 ff		eor #$ff	                eor #$FF        ; now just invert:
.968a		95 00		sta $00,x	                sta 0,x
.968c		95 01		sta $01,x	                sta 1,x
.968e		60		rts		z_zero_equal:   rts
.968f						xt_zero_greater:
.968f		20 71 d7	jsr $d771	                jsr underflow_1
.9692		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.9694		b5 01		lda $01,x	                lda 1,x         ; MSB
.9696		30 05		bmi $969d	                bmi _done       ; TOS is negative, keep FLASE
.9698		15 00		ora $00,x	                ora 0,x
.969a		f0 01		beq $969d	                beq _done       ; TOS is zero, keep FALSE
.969c		88		dey		                dey             ; TOS is postive, make true
.969d						_done:
.969d		98		tya		                tya
.969e		95 00		sta $00,x	                sta 0,x
.96a0		95 01		sta $01,x	                sta 1,x
.96a2		60		rts		z_zero_greater: rts
.96a3						xt_zero_less:
.96a3		20 71 d7	jsr $d771	                jsr underflow_1
.96a6		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.96a8		b5 01		lda $01,x	                lda 1,x         ; MSB
.96aa		10 01		bpl $96ad	                bpl _done       ; TOS is positive, so keep FALSE
.96ac		88		dey		                dey             ; TOS is negative, make TRUE
.96ad						_done:
.96ad		98		tya		                tya
.96ae		95 00		sta $00,x	                sta 0,x
.96b0		95 01		sta $01,x	                sta 1,x
.96b2		60		rts		z_zero_less:    rts
.96b3						xt_zero_unequal:
.96b3		20 71 d7	jsr $d771	                jsr underflow_1
.96b6		b5 00		lda $00,x	                lda 0,x
.96b8		15 01		ora $01,x	                ora 1,x
.96ba		f0 02		beq $96be	                beq _zero
.96bc		a9 ff		lda #$ff	                lda #$FF
.96be						_zero:
.96be		95 00		sta $00,x	                sta 0,x
.96c0		95 01		sta $01,x	                sta 1,x
.96c2		60		rts		z_zero_unequal: rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/compile.asm

.96c3						xt_compile_comma:
.96c3		20 71 d7	jsr $d771	                jsr underflow_1
.96c6		20 a0 86	jsr $86a0	                jsr xt_dup              ; keep an unadjusted copy of xt
.96c9		20 a0 86	jsr $86a0	                jsr xt_dup              ; plus one to convert to nt
.96cc		20 8f 9b	jsr $9b8f	                jsr xt_int_to_name
.96cf		b5 00		lda $00,x	                lda 0,x
.96d1		15 01		ora $01,x	                ora 1,x
.96d3		f0 6b		beq $9740	                beq cmpl_as_call        ; No nt so unknown size; must compile as a JSR
.96d5		20 a0 86	jsr $86a0	                jsr xt_dup
.96d8		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; status is at nt+1
.96db		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.96dd		e8		inx		                inx                     ; drop pointer
.96de		e8		inx		                inx
.96df		85 29		sta $29		                sta tmp3                ; keep copy of status byte
.96e1		29 08		and #$08	                and #NN
.96e3		d0 5b		bne $9740	                bne cmpl_as_call        ; never native
.96e5		20 b7 9d	jsr $9db7	                jsr xt_wordsize
.96e8		a5 29		lda $29		                lda tmp3
.96ea		29 40		and #$40	                and #ST
.96ec		f0 16		beq $9704	                beq _check_uf
=10						_strip_sz = 10  ; skip the standard 10 byte header which saves return address + 1 to tmp1
.96ee		18		clc		                clc
.96ef		b5 02		lda $02,x	                lda 2,x
.96f1		69 0a		adc #$0a	                adc #_strip_sz
.96f3		95 02		sta $02,x	                sta 2,x
.96f5		90 02		bcc $96f9	                bcc +
.96f7		f6 03		inc $03,x	                inc 3,x                 ; we just care about the carry
.96f9						+
.96f9		38		sec		                sec
.96fa		b5 00		lda $00,x	                lda 0,x
.96fc		e9 0a		sbc #$0a	                sbc #_strip_sz
.96fe		95 00		sta $00,x	                sta 0,x
.9700		b0 02		bcs $9704	                bcs +
.9702		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.9704						+
.9704						_check_uf:
.9704		a5 29		lda $29		                lda tmp3
.9706		29 10		and #$10	                and #UF
.9708		f0 1f		beq $9729	                beq _check_limit
.970a		a0 02		ldy #$02	                ldy #uf_strip_offset
.970c		b1 08		lda ($08),y	                lda (up),y
.970e		c8		iny		                iny
.970f		11 08		ora ($08),y	                ora (up),y
.9711		f0 16		beq $9729	                beq _check_limit
.9713		18		clc		                clc
.9714		b5 02		lda $02,x	                lda 2,x
.9716		69 03		adc #$03	                adc #3
.9718		95 02		sta $02,x	                sta 2,x
.971a		90 02		bcc $971e	                bcc +
.971c		f6 03		inc $03,x	                inc 3,x                  ; we just care about the carry
.971e						+
.971e		38		sec		                sec
.971f		b5 00		lda $00,x	                lda 0,x
.9721		e9 03		sbc #$03	                sbc #3
.9723		95 00		sta $00,x	                sta 0,x
.9725		b0 02		bcs $9729	                bcs +
.9727		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.9729						+
.9729						_check_limit:
.9729		a5 29		lda $29		                lda tmp3
.972b		29 02		and #$02	                and #AN                 ; check Always Native (AN) bit
.972d		d0 1e		bne $974d	                bne cmpl_inline         ; always natively compile
.972f						cmpl_by_limit:
.972f		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.9731		b5 01		lda $01,x	                lda 1,x                 ; MSB of word size
.9733		d1 08		cmp ($08),y	                cmp (up),y              ; user-defined limit MSB
.9735		90 16		bcc $974d	                bcc cmpl_inline         ; borrow (C=0) means size < limit
.9737		d0 07		bne $9740	                bne cmpl_as_call        ; else non-zero means size > limit
.9739		88		dey		                dey
.973a		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.973c		d5 00		cmp $00,x	                cmp 0,x
.973e		b0 0d		bcs $974d	                bcs cmpl_inline         ; not bigger, so good to go
.9740						cmpl_as_call:
.9740		20 a3 93	jsr $93a3	                jsr xt_two_drop         ; either way 2drop leaves original xt
.9743		a9 20		lda #$20	                lda #OpJSR
.9745		20 71 97	jsr $9771	                jsr cmpl_a
.9748		20 cd 83	jsr $83cd	                jsr xt_comma
.974b		38		sec		                sec
.974c		60		rts		                rts
.974d						cmpl_inline:
.974d		20 1b 89	jsr $891b	                jsr xt_here
.9750		20 2a 92	jsr $922a	                jsr xt_swap
.9753		20 a0 86	jsr $86a0	                jsr xt_dup
.9756		20 27 82	jsr $8227	                jsr xt_allot            ; allocate space for the word
.9759		20 00 8c	jsr $8c00	                jsr xt_move
.975c		20 9a 86	jsr $869a	                jsr xt_drop             ; drop original xt
.975f		18		clc		                clc
.9760		60		rts		                rts
.9761						z_compile_comma:
.9761						cmpl_subroutine:
.9761		48		pha		                pha             ; save LSB of address
.9762		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR
.9764		80 03		bra $9769	                bra +
.9766						cmpl_jump:
.9766		48		pha		                pha             ; save LSB of address
.9767		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP, fall thru
.9769						+
.9769		20 71 97	jsr $9771	                jsr cmpl_a      ; compile opcode
.976c		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.976d						cmpl_word:
.976d		20 71 97	jsr $9771	                jsr cmpl_a      ; compile LSB of address
.9770		98		tya		                tya             ; fall thru for MSB
.9771						cmpl_a:
.9771		92 00		sta ($00)	                sta (cp)
.9773		e6 00		inc $00		                inc cp
.9775		d0 02		bne $9779	                bne _done
.9777		e6 01		inc $01		                inc cp+1
.9779						_done:
.9779		60		rts		                rts
.977a						cmpl_jump_tos:
.977a		a9 4c		lda #$4c	                lda #OpJMP
.977c		20 71 97	jsr $9771	                jsr cmpl_a
.977f		4c cd 83	jmp $83cd	                jmp xt_comma
.9782						cmpl_jump_later:
.9782		a9 4c		lda #$4c	                lda #OpJMP
.9784		20 71 97	jsr $9771	                jsr cmpl_a
.9787		20 1b 89	jsr $891b	                jsr xt_here
.978a		80 e1		bra $976d	                bra cmpl_word
.978c						check_nc_limit:
.978c		48		pha		                pha
.978d		38		sec		                sec
.978e		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.9790		b1 08		lda ($08),y	                lda (up),y              ; if MSB non zero we're good, leave with C=0
.9792		f0 01		beq $9795	                beq +
.9794		18		clc		                clc
.9795						+
.9795		68		pla		                pla
.9796		90 05		bcc $979d	                bcc _done
.9798		3a		dec a		                dea                     ; simplify test to A-1 < nc-limit
.9799		88		dey		                dey
.979a		d1 08		cmp ($08),y	                cmp (up),y              ; A-1 < LSB leaves C=0, else C=1
.979c		1a		inc a		                ina                     ; restore A, preserves carry
.979d						_done:
.979d		60		rts		                rts
.979e						cmpl_0branch_later:
.979e		20 d8 9d	jsr $9dd8	                jsr xt_zero             ; dummy placeholder, which forces long jmp in native version
.97a1		20 b3 97	jsr $97b3	                jsr cmpl_0branch_tos    ; generate native or subroutine branch code
.97a4		20 1b 89	jsr $891b	                jsr xt_here             ; either way the target address is two bytes before here
.97a7		38		sec		                sec
.97a8		b5 00		lda $00,x	                lda 0,x
.97aa		e9 02		sbc #$02	                sbc #2
.97ac		95 00		sta $00,x	                sta 0,x
.97ae		b0 02		bcs $97b2	                bcs +
.97b0		d6 01		dec $01,x	                dec 1,x
.97b2						+
.97b2		60		rts		                rts
.97b3						cmpl_0branch_tos:
.97b3		a9 0b		lda #$0b	                lda #ztest_runtime_size+5       ; typical size of inline form
.97b5		20 8c 97	jsr $978c	                jsr check_nc_limit              ; returns C=0 if we should native compile
.97b8		90 0a		bcc $97c4	                bcc _inline
.97ba		a0 98		ldy #$98	                ldy #>zero_branch_runtime
.97bc		a9 15		lda #$15	                lda #<zero_branch_runtime
.97be		20 61 97	jsr $9761	                jsr cmpl_subroutine             ; call the 0branch runtime
.97c1		4c cd 83	jmp $83cd	                jmp xt_comma                    ; add the payload and return
.97c4						_inline:
.97c4		a0 00		ldy #$00	                ldy #0
.97c6						-
.97c6		b9 15 98	lda $9815,y	                lda ztest_runtime,y
.97c9		20 71 97	jsr $9771	                jsr cmpl_a
.97cc		c8		iny		                iny
.97cd		c0 06		cpy #$06	                cpy #ztest_runtime_size
.97cf		d0 f5		bne $97c6	                bne -
.97d1		b5 00		lda $00,x	                lda 0,x
.97d3		15 01		ora $01,x	                ora 1,x
.97d5		f0 31		beq $9808	                beq _long               ; always use the long form if target is 0
.97d7		20 a0 86	jsr $86a0	                jsr xt_dup
.97da		20 1b 89	jsr $891b	                jsr xt_here
.97dd		18		clc		                clc
.97de		a9 02		lda #$02	                lda #2
.97e0		75 00		adc $00,x	                adc 0,x
.97e2		95 00		sta $00,x	                sta 0,x
.97e4		90 02		bcc $97e8	                bcc +
.97e6		f6 01		inc $01,x	                inc 1,x
.97e8						+
.97e8		20 e4 8b	jsr $8be4	                jsr xt_minus
.97eb		e8		inx		                inx             ; pre-drop offset and use wraparound indexing to preserve flags
.97ec		e8		inx		                inx
.97ed		b5 ff		lda $ff,x	                lda $ff,x
.97ef		a8		tay		                tay             ; Y=MSB of offset
.97f0		b5 fe		lda $fe,x	                lda $fe,x       ; A=LSB, setting N flag to bit 7
.97f2		30 04		bmi $97f8	                bmi _minus
.97f4		c0 00		cpy #$00	                cpy #0          ; if LSB is positive we need MSB = 0
.97f6		80 02		bra $97fa	                bra +
.97f8		c0 ff		cpy #$ff	_minus:         cpy #$ff        ; if LSB is negative we need MSB = ff
.97fa		d0 0c		bne $9808	+               bne _long
.97fc		a9 f0		lda #$f0	                lda #OpBEQ
.97fe		20 71 97	jsr $9771	                jsr cmpl_a
.9801		b5 fe		lda $fe,x	                lda $fe,x
.9803		e8		inx		                inx             ; drop the original address we used to calc offset
.9804		e8		inx		                inx
.9805		4c 71 97	jmp $9771	                jmp cmpl_a
.9808						_long:
.9808		a9 d0		lda #$d0	                lda #OpBNE
.980a		20 71 97	jsr $9771	                jsr cmpl_a
.980d		a9 03		lda #$03	                lda #3
.980f		20 71 97	jsr $9771	                jsr cmpl_a
.9812		4c 7a 97	jmp $977a	                jmp cmpl_jump_tos
.9815						zero_branch_runtime:
.9815						ztest_runtime:
.9815		e8		inx		                inx
.9816		e8		inx		                inx
.9817		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.9819		15 ff		ora $ff,x	                ora $FF,x
=6						ztest_runtime_size = * - ztest_runtime
.981b						zbranch_runtime:
.981b		7a		ply		                ply
.981c		84 25		sty $25		                sty tmp1
.981e		7a		ply		                ply
.981f		84 26		sty $26		                sty tmp1+1
.9821		a8		tay		                tay             ; test if A = 0 which tells us whether to branch
.9822		f0 0d		beq $9831	                beq _branch
.9824		18		clc		                clc
.9825		a5 25		lda $25		                lda tmp1        ; LSB
.9827		69 03		adc #$03	                adc #3          ; skip two bytes plus the extra for jsr/rts behavior
.9829		85 25		sta $25		                sta tmp1
.982b		90 11		bcc $983e	                bcc _jmp
.982d		e6 26		inc $26		                inc tmp1+1
.982f		80 0d		bra $983e	                bra _jmp
.9831						_branch:
.9831		a0 01		ldy #$01	                ldy #1
.9833		b1 25		lda ($25),y	                lda (tmp1),y
.9835		48		pha		                pha                     ; stash the LSB until we've read the MSB too
.9836		c8		iny		                iny
.9837		b1 25		lda ($25),y	                lda (tmp1),y
.9839		85 26		sta $26		                sta tmp1+1              ; update tmp1 with our branch target
.983b		68		pla		                pla
.983c		85 25		sta $25		                sta tmp1
.983e						_jmp:
.983e		6c 25 00	jmp ($0025)	                jmp (tmp1)

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tools.asm

.9841						xt_bye:
.9841		4c 31 f0	jmp $f031	                jmp kernel_bye
.9844						z_bye:
.9844						xt_dot_s:
.9844		20 52 85	jsr $8552	                jsr xt_depth    ; ( -- u )
.9847		a9 3c		lda #$3c	                lda #'<'
.9849		20 c5 86	jsr $86c5	                jsr emit_a
.984c		b5 00		lda $00,x	                lda 0,x
.984e		48		pha		                pha
.984f		ca		dex		                dex             ; DUP
.9850		ca		dex		                dex
.9851		95 00		sta $00,x	                sta 0,x
.9853		74 01		stz $01,x	                stz 1,x
.9855		20 de d7	jsr $d7de	                jsr print_u
.9858		a9 3e		lda #$3e	                lda #'>'
.985a		20 c5 86	jsr $86c5	                jsr emit_a
.985d		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.985f		20 c5 86	jsr $86c5	                jsr emit_a
.9862		e8		inx		                inx
.9863		e8		inx		                inx
.9864		e0 78		cpx #$78	                cpx #dsp0
.9866		f0 1e		beq $9886	                beq _done
.9868		7a		ply		                ply
.9869		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.986b		85 29		sta $29		                sta tmp3
.986d		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.986f						_loop:
.986f		ca		dex		                dex
.9870		ca		dex		                dex
.9871		b2 29		lda ($29)	                lda (tmp3)
.9873		95 01		sta $01,x	                sta 1,x
.9875		c6 29		dec $29		                dec tmp3
.9877		b2 29		lda ($29)	                lda (tmp3)
.9879		95 00		sta $00,x	                sta 0,x
.987b		c6 29		dec $29		                dec tmp3
.987d		5a		phy		                phy
.987e		20 30 86	jsr $8630	                jsr xt_dot
.9881		7a		ply		                ply
.9882		88		dey		                dey
.9883		d0 ea		bne $986f	                bne _loop
.9885		48		pha		                pha             ; dummy to balance stack
.9886						_done:
.9886		68		pla		                pla
.9887		60		rts		z_dot_s:        rts
.9888						xt_dump:
.9888		20 76 d7	jsr $d776	                jsr underflow_2
.988b						_row:
.988b		a0 10		ldy #$10	                ldy #16
.988d		64 27		stz $27		                stz tmp2
.988f		20 3a 84	jsr $843a	                jsr xt_cr
.9892		b5 03		lda $03,x	                lda 3,x
.9894		20 3c d6	jsr $d63c	                jsr byte_to_ascii
.9897		b5 02		lda $02,x	                lda 2,x
.9899		20 3c d6	jsr $d63c	                jsr byte_to_ascii
.989c		20 c7 91	jsr $91c7	                jsr xt_space
.989f		20 c7 91	jsr $91c7	                jsr xt_space
.98a2						_loop:
.98a2		b5 00		lda $00,x	                lda 0,x
.98a4		15 01		ora $01,x	                ora 1,x
.98a6		f0 39		beq $98e1	                beq _all_printed
.98a8		a1 02		lda ($02,x)	                lda (2,x)
.98aa		48		pha		                pha                     ; byte_to_ascii destroys A
.98ab		20 3c d6	jsr $d63c	                jsr byte_to_ascii
.98ae		20 c7 91	jsr $91c7	                jsr xt_space
.98b1		68		pla		                pla
.98b2		20 57 d7	jsr $d757	                jsr is_printable
.98b5		b0 02		bcs $98b9	                bcs _printable
.98b7		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.98b9						_printable:
.98b9		5a		phy		                phy                     ; save counter
.98ba		a4 27		ldy $27		                ldy tmp2
.98bc		91 00		sta ($00),y	                sta (cp),y
.98be		e6 27		inc $27		                inc tmp2
.98c0		7a		ply		                ply
.98c1		c0 09		cpy #$09	                cpy #9
.98c3		d0 03		bne $98c8	                bne _next_char
.98c5		20 c7 91	jsr $91c7	                jsr xt_space
.98c8						_next_char:
.98c8		f6 02		inc $02,x	                inc 2,x
.98ca		d0 02		bne $98ce	                bne _counter
.98cc		f6 03		inc $03,x	                inc 3,x
.98ce						_counter:
.98ce		b5 00		lda $00,x	                lda 0,x
.98d0		d0 02		bne $98d4	                bne +
.98d2		d6 01		dec $01,x	                dec 1,x
.98d4						+
.98d4		d6 00		dec $00,x	                dec 0,x
.98d6		88		dey		                dey
.98d7		d0 c9		bne $98a2	                bne _loop               ; next byte
.98d9		20 c7 91	jsr $91c7	                jsr xt_space
.98dc		20 ef 98	jsr $98ef	                jsr dump_print_ascii
.98df		80 aa		bra $988b	                bra _row                ; new row
.98e1						_all_printed:
.98e1		a5 27		lda $27		                lda tmp2
.98e3		f0 06		beq $98eb	                beq _done
.98e5		20 c7 91	jsr $91c7	                jsr xt_space
.98e8		20 ef 98	jsr $98ef	                jsr dump_print_ascii
.98eb						_done:
.98eb		20 a3 93	jsr $93a3	                jsr xt_two_drop         ; one byte less than 4x INX
.98ee		60		rts		z_dump:         rts
.98ef						dump_print_ascii:
.98ef		a0 00		ldy #$00	                ldy #0
.98f1						_ascii_loop:
.98f1		b1 00		lda ($00),y	                lda (cp),y
.98f3		20 c5 86	jsr $86c5	                jsr emit_a
.98f6		c8		iny		                iny
.98f7		c0 08		cpy #$08	                cpy #8
.98f9		d0 03		bne $98fe	                bne +
.98fb		20 c7 91	jsr $91c7	                jsr xt_space
.98fe						+
.98fe		c6 27		dec $27		                dec tmp2
.9900		d0 ef		bne $98f1	                bne _ascii_loop
.9902		60		rts		                rts
.9903						xt_question:
.9903		20 1a 88	jsr $881a	                jsr xt_fetch
.9906		20 30 86	jsr $8630	                jsr xt_dot
.9909		60		rts		z_question:     rts
.990a						xt_see:
.990a		20 4d 8d	jsr $8d4d	                jsr xt_parse_name       ; ( addr u )
.990d		20 d7 9a	jsr $9ad7	                jsr xt_find_name        ; ( nt | 0 )
.9910		b5 00		lda $00,x	                lda 0,x
.9912		15 01		ora $01,x	                ora 1,x
.9914		d0 05		bne $991b	                bne +
.9916		a9 05		lda #$05	                lda #err_noname
.9918		4c 87 d7	jmp $d787	                jmp error
.991b						+
.991b		20 3a 84	jsr $843a	                jsr xt_cr
.991e		a5 18		lda $18		                lda base
.9920		48		pha		                pha
.9921		20 26 89	jsr $8926	                jsr xt_hex
.9924		a9 09		lda #$09	                lda #str_see_nt
.9926		20 ad d7	jsr $d7ad	                jsr print_string_no_lf
.9929		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.992c		20 eb 94	jsr $94eb	                jsr xt_u_dot
.992f		20 c7 91	jsr $91c7	                jsr xt_space            ; ( nt )
.9932		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.9935		20 15 9c	jsr $9c15	                jsr xt_name_to_int      ; ( nt xt )
.9938		a9 0a		lda #$0a	                lda #str_see_xt
.993a		20 ad d7	jsr $d7ad	                jsr print_string_no_lf
.993d		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt xt xt )
.9940		20 eb 94	jsr $94eb	                jsr xt_u_dot
.9943		20 3a 84	jsr $843a	                jsr xt_cr               ; ( nt xt )
.9946		a9 08		lda #$08	                lda #str_see_flags
.9948		20 ad d7	jsr $d7ad	                jsr print_string_no_lf
.994b		20 01 8d	jsr $8d01	                jsr xt_over             ; ( nt xt nt )
.994e		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9951		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( nt xt flags )
.9954		b5 00		lda $00,x	                lda 0,x
.9956		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9958						_flag_loop:
.9958		48		pha		                pha
.9959		29 01		and #$01	                and #%00000001
.995b		18		clc		                clc
.995c		69 30		adc #$30	                adc #'0'
.995e		20 c5 86	jsr $86c5	                jsr emit_a
.9961		20 c7 91	jsr $91c7	                jsr xt_space
.9964		68		pla		                pla
.9965		6a		ror a		                ror                     ; Next flag
.9966		88		dey		                dey
.9967		d0 ef		bne $9958	                bne _flag_loop
.9969		20 3a 84	jsr $843a	                jsr xt_cr
.996c		e8		inx		                inx
.996d		e8		inx		                inx                     ; ( nt xt )
.996e		a9 0b		lda #$0b	                lda #str_see_size
.9970		20 ad d7	jsr $d7ad	                jsr print_string_no_lf
.9973		20 2a 92	jsr $922a	                jsr xt_swap             ; ( xt nt )
.9976		20 b7 9d	jsr $9db7	                jsr xt_wordsize         ; ( xt u )
.9979		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.997c		20 0a 85	jsr $850a	                jsr xt_decimal
.997f		20 eb 94	jsr $94eb	                jsr xt_u_dot            ; ( xt u )
.9982		20 26 89	jsr $8926	                jsr xt_hex
.9985		20 3a 84	jsr $843a	                jsr xt_cr
.9988		20 ab 93	jsr $93ab	                jsr xt_two_dup          ; ( xt u xt u )
.998b		20 88 98	jsr $9888	                jsr xt_dump
.998e		20 3a 84	jsr $843a	                jsr xt_cr
.9991		20 85 a1	jsr $a185	                jsr xt_disasm
.9994		68		pla		                pla
.9995		85 18		sta $18		                sta base
.9997		60		rts		z_see:          rts
.9998						xt_words:
.9998		20 3a 84	jsr $843a	                jsr xt_cr
.999b		a9 00		lda #$00	                lda #0
.999d		48		pha		                pha
.999e		ca		dex		                dex                     ; Make room on the stack for
.999f		ca		dex		                dex                     ; a dictionary pointer.
.99a0		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.99a2						_wordlist_loop:
.99a2		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.99a4		a5 29		lda $29		                lda tmp3
.99a6		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.99a8		d0 02		bne $99ac	                bne _have_wordlist
.99aa		80 45		bra $99f1	                bra _words_done
.99ac						_have_wordlist:
.99ac		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.99ad		69 23		adc #$23	                adc #search_order_offset
.99af		a8		tay		                tay
.99b0		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.99b2		0a		asl a		                asl                     ; Turn offset into cells offset.
.99b3		18		clc		                clc
.99b4		69 0a		adc #$0a	                adc #wordlists_offset
.99b6		a8		tay		                tay
.99b7		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.99b9		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.99bb		c8		iny		                iny
.99bc		b1 08		lda ($08),y	                lda (up),y
.99be		95 01		sta $01,x	                sta 1,x
.99c0						_loop:
.99c0		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.99c3		20 32 9c	jsr $9c32	                jsr xt_name_to_string   ; ( nt addr u )
.99c6		68		pla		                pla
.99c7		18		clc		                clc
.99c8		75 00		adc $00,x	                adc 0,x
.99ca		1a		inc a		                ina                     ; don't forget the space between words
.99cb		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.99cd		90 06		bcc $99d5	                bcc +
.99cf		20 3a 84	jsr $843a	                jsr xt_cr
.99d2		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.99d4		1a		inc a		                ina                     ; with length of this word.
.99d5						+
.99d5		48		pha		                pha
.99d6		20 c0 94	jsr $94c0	                jsr xt_type             ; ( nt )
.99d9		a9 20		lda #$20	                lda #AscSP
.99db		20 c5 86	jsr $86c5	                jsr emit_a
.99de		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; 1+
.99e1		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; 1+
.99e4		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( nt+1 )
.99e7		b5 00		lda $00,x	                lda 0,x
.99e9		15 01		ora $01,x	                ora 1,x
.99eb		d0 d3		bne $99c0	                bne _loop
.99ed		e6 29		inc $29		                inc tmp3
.99ef		80 b1		bra $99a2	                bra _wordlist_loop
.99f1						_words_done:
.99f1		68		pla		                pla                     ; dump counter
.99f2		e8		inx		                inx
.99f3		e8		inx		                inx
.99f4		60		rts		z_words:        rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tali.asm

.99f5						xt_allow_native:
.99f5		20 c8 d6	jsr $d6c8	                jsr current_to_dp
.99f8		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.99fa		b1 02		lda ($02),y	                lda (dp),y
.99fc		29 f5		and #$f5	                and #$FF-NN-AN  ; AN and NN flag is clear.
.99fe		91 02		sta ($02),y	                sta (dp),y
.9a00						z_allow_native:
.9a00		60		rts		                rts
.9a01						xt_always_native:
.9a01		20 c8 d6	jsr $d6c8	                jsr current_to_dp
.9a04		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9a06		b1 02		lda ($02),y	                lda (dp),y
.9a08		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.9a0a		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.9a0c		91 02		sta ($02),y	                sta (dp),y
.9a0e						z_always_native:
.9a0e		60		rts		                rts
.9a0f						xt_bell:
.9a0f		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.9a11		20 c5 86	jsr $86c5	                jsr emit_a
.9a14		60		rts		z_bell:         rts
.9a15						xt_bounds:
.9a15		20 76 d7	jsr $d776	                jsr underflow_2
.9a18		18		clc		                clc
.9a19		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.9a1b		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.9a1d		75 02		adc $02,x	                adc 2,x
.9a1f		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.9a21		94 00		sty $00,x	                sty 0,x
.9a23		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.9a25		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.9a27		75 03		adc $03,x	                adc 3,x
.9a29		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.9a2b		94 01		sty $01,x	                sty 1,x
.9a2d		60		rts		z_bounds:       rts
.9a2e						xt_cleave:
.9a2e		20 76 d7	jsr $d776	                jsr underflow_2
.9a31		20 04 a0	jsr $a004	                jsr xt_minus_leading    ; -LEADING ( addr u )
.9a34		20 79 9b	jsr $9b79	                jsr xt_input_to_r       ; save old imput state
.9a37		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.9a39		85 0e		sta $0e		                sta ciblen
.9a3b		b5 01		lda $01,x	                lda 1,x
.9a3d		85 0f		sta $0f		                sta ciblen+1
.9a3f		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.9a41		85 0c		sta $0c		                sta cib
.9a43		b5 03		lda $03,x	                lda 3,x
.9a45		85 0d		sta $0d		                sta cib+1
.9a47		64 10		stz $10		                stz toin        ; >IN pointer is zero
.9a49		64 11		stz $11		                stz toin+1
.9a4b		20 4d 8d	jsr $8d4d	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.9a4e		b5 00		lda $00,x	                lda 0,x
.9a50		15 01		ora $01,x	                ora 1,x
.9a52		f0 23		beq $9a77	                beq _done
.9a54		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.9a56		38		sec		                sec
.9a57		f5 00		sbc $00,x	                sbc 0,x
.9a59		95 04		sta $04,x	                sta 4,x
.9a5b		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.9a5d		f5 01		sbc $01,x	                sbc 1,x
.9a5f		95 05		sta $05,x	                sta 5,x
.9a61		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.9a63		18		clc		                clc
.9a64		75 00		adc $00,x	                adc 0,x
.9a66		95 06		sta $06,x	                sta 6,x
.9a68		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.9a6a		75 01		adc $01,x	                adc 1,x
.9a6c		95 07		sta $07,x	                sta 7,x
.9a6e		20 7c 94	jsr $947c	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.9a71		20 04 a0	jsr $a004	                jsr xt_minus_leading
.9a74		20 7c 94	jsr $947c	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.9a77						_done:
.9a77		20 86 9d	jsr $9d86	                jsr xt_r_to_input
.9a7a		60		rts		z_cleave:       rts
.9a7b						xt_digit_question:
.9a7b		20 71 d7	jsr $d771	                jsr underflow_1
.9a7e		ca		dex		                dex
.9a7f		ca		dex		                dex
.9a80		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.9a82		74 01		stz $01,x	                stz 1,x
.9a84		74 03		stz $03,x	                stz 3,x                 ; paranoid
.9a86		b5 02		lda $02,x	                lda 2,x
.9a88		c9 30		cmp #$30	                cmp #'0'
.9a8a		90 23		bcc $9aaf	                bcc _done               ; failure flag already set
.9a8c		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.9a8e		90 12		bcc $9aa2	                bcc _checkbase
.9a90		c9 41		cmp #$41	                cmp #'A'
.9a92		90 1b		bcc $9aaf	                bcc _done               ; failure flag is already set
.9a94		c9 61		cmp #$61	                cmp #'a'
.9a96		90 07		bcc $9a9f	                bcc _case_done          ; not lower case, too low
.9a98		c9 7b		cmp #$7b	                cmp #'z'+1
.9a9a		b0 03		bcs $9a9f	                bcs _case_done          ; not lower case, too high
.9a9c		18		clc		                clc                     ; just right
.9a9d		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.9a9f						_case_done:
.9a9f		38		sec		                sec
.9aa0		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.9aa2						_checkbase:
.9aa2		38		sec		                sec
.9aa3		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.9aa5		c5 18		cmp $18		                cmp base
.9aa7		b0 06		bcs $9aaf	                bcs _done               ; already have false flag
.9aa9		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.9aab		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.9aad		d6 01		dec $01,x	                dec 1,x
.9aaf						_done:
.9aaf						z_digit_question:
.9aaf		60		rts		                rts
.9ab0						xt_execute_parsing:
.9ab0		20 7b d7	jsr $d77b	                jsr underflow_3
.9ab3		20 79 9b	jsr $9b79	                jsr xt_input_to_r       ; save normal input for later
.9ab6		20 5c 9c	jsr $9c5c	                jsr xt_not_rote         ; -ROT ( xt addr u )
.9ab9		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.9abb		85 0e		sta $0e		                sta ciblen
.9abd		b5 01		lda $01,x	                lda 1,x
.9abf		85 0f		sta $0f		                sta ciblen+1
.9ac1		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.9ac3		85 0c		sta $0c		                sta cib
.9ac5		b5 03		lda $03,x	                lda 3,x
.9ac7		85 0d		sta $0d		                sta cib+1
.9ac9		64 10		stz $10		                stz toin                ; Set >IN to zero
.9acb		64 11		stz $11		                stz toin+1
.9acd		20 a3 93	jsr $93a3	                jsr xt_two_drop         ; 2DROP ( xt )
.9ad0		20 05 88	jsr $8805	                jsr xt_execute
.9ad3		20 86 9d	jsr $9d86	                jsr xt_r_to_input
.9ad6						z_execute_parsing:
.9ad6		60		rts		                rts
.9ad7						xt_find_name:
.9ad7		20 76 d7	jsr $d776	                jsr underflow_2
.9ada		b5 00		lda $00,x	                lda 0,x
.9adc		15 01		ora $01,x	                ora 1,x
.9ade		d0 03		bne $9ae3	                bne _nonempty
.9ae0		4c 14 9b	jmp $9b14	                jmp _fail_done
.9ae3						_nonempty:
.9ae3		64 29		stz $29		                stz tmp3                ; Start at the beginning
.9ae5						_wordlist_loop:
.9ae5		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9ae7		a5 29		lda $29		                lda tmp3
.9ae9		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.9aeb		f0 27		beq $9b14	                beq _fail_done
.9aed		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9aee		69 23		adc #$23	                adc #search_order_offset
.9af0		a8		tay		                tay
.9af1		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.9af3		0a		asl a		                asl                     ; Turn offset into cells offset.
.9af4		18		clc		                clc
.9af5		69 0a		adc #$0a	                adc #wordlists_offset
.9af7		a8		tay		                tay
.9af8		b1 08		lda ($08),y	                lda (up),y
.9afa		85 25		sta $25		                sta tmp1
.9afc		c8		iny		                iny
.9afd		b1 08		lda ($08),y	                lda (up),y
.9aff		85 26		sta $26		                sta tmp1+1
.9b01		20 53 d6	jsr $d653	                jsr find_header_name
.9b04		d0 04		bne $9b0a	                bne _success
.9b06		e6 29		inc $29		                inc tmp3
.9b08		80 db		bra $9ae5	                bra _wordlist_loop
.9b0a						_success:
.9b0a		a5 25		lda $25		                lda tmp1
.9b0c		95 02		sta $02,x	                sta 2,x
.9b0e		a5 26		lda $26		                lda tmp1+1
.9b10		95 03		sta $03,x	                sta 3,x
.9b12		80 04		bra $9b18	                bra _done
.9b14						_fail_done:
.9b14		74 02		stz $02,x	                stz 2,x         ; failure flag
.9b16		74 03		stz $03,x	                stz 3,x
.9b18						_done:
.9b18		e8		inx		                inx
.9b19		e8		inx		                inx
.9b1a		60		rts		z_find_name:    rts
.9b1b						xt_hexstore:
.9b1b		20 7b d7	jsr $d77b	                jsr underflow_3
.9b1e		20 a0 86	jsr $86a0	                jsr xt_dup              ; Save copy of original address
.9b21		20 a0 94	jsr $94a0	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b24						_loop:
.9b24		b5 00		lda $00,x	                lda 0,x
.9b26		15 01		ora $01,x	                ora 1,x
.9b28		f0 36		beq $9b60	                beq _done
.9b2a		20 2e 9a	jsr $9a2e	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9b2d		20 a0 94	jsr $94a0	                jsr xt_two_to_r
.9b30		20 d8 9d	jsr $9dd8	                jsr xt_zero
.9b33		20 d8 9d	jsr $9dd8	                jsr xt_zero
.9b36		20 26 94	jsr $9426	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9b39		20 c8 92	jsr $92c8	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9b3c		b5 00		lda $00,x	                lda 0,x
.9b3e		15 01		ora $01,x	                ora 1,x
.9b40		d0 17		bne $9b59	                bne _have_chars_left
.9b42		20 a3 93	jsr $93a3	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9b45		20 21 9e	jsr $9e21	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9b48		20 d5 8e	jsr $8ed5	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9b4b		20 37 83	jsr $8337	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b4e		20 ec 8e	jsr $8eec	                jsr xt_r_from           ; R>
.9b51		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; 1+
.9b54		20 68 93	jsr $9368	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9b57		80 cb		bra $9b24	                bra _loop
.9b59						_have_chars_left:
.9b59		8a		txa		                txa
.9b5a		18		clc		                clc
.9b5b		69 08		adc #$08	                adc #8
.9b5d		aa		tax		                tax
.9b5e		80 c4		bra $9b24	                bra _loop
.9b60						_done:
.9b60		e8		inx		                inx
.9b61		e8		inx		                inx
.9b62		e8		inx		                inx
.9b63		e8		inx		                inx                     ; 2DROP
.9b64		20 26 94	jsr $9426	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.9b67		20 2a 92	jsr $922a	                jsr xt_swap
.9b6a		20 e4 8b	jsr $8be4	                jsr xt_minus            ; ( n )
.9b6d		60		rts		z_hexstore:     rts
.9b6e						xt_input:
.9b6e		ca		dex		                dex
.9b6f		ca		dex		                dex
.9b70		a9 14		lda #$14	                lda #<input
.9b72		95 00		sta $00,x	                sta 0,x
.9b74		a9 00		lda #$00	                lda #>input
.9b76		95 01		sta $01,x	                sta 1,x
.9b78		60		rts		z_input:        rts
.9b79						xt_input_to_r:
.9b79		68		pla		                pla
.9b7a		85 25		sta $25		                sta tmp1
.9b7c		68		pla		                pla
.9b7d		85 26		sta $26		                sta tmp1+1
.9b7f		a0 07		ldy #$07	                ldy #7
.9b81						_loop:
.9b81		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9b84		48		pha		                pha
.9b85		88		dey		                dey
.9b86		10 f9		bpl $9b81	                bpl _loop
.9b88		a5 26		lda $26		                lda tmp1+1
.9b8a		48		pha		                pha
.9b8b		a5 25		lda $25		                lda tmp1
.9b8d		48		pha		                pha
.9b8e		60		rts		z_input_to_r: 	rts
.9b8f						xt_int_to_name:
.9b8f		20 71 d7	jsr $d771	                jsr underflow_1
.9b92		ca		dex		                dex
.9b93		ca		dex		                dex
.9b94		74 00		stz $00,x	                stz 0,x
.9b96		74 01		stz $01,x	                stz 1,x
.9b98						_wordlist_loop:
.9b98		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9b9a		0a		asl a		                asl                     ; Turn offset into cells offset.
.9b9b		18		clc		                clc
.9b9c		69 0a		adc #$0a	                adc #wordlists_offset
.9b9e		a8		tay		                tay
.9b9f		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9ba1		85 27		sta $27		                sta tmp2                ; into tmp2
.9ba3		c8		iny		                iny
.9ba4		b1 08		lda ($08),y	                lda (up),y
.9ba6		85 28		sta $28		                sta tmp2+1
.9ba8		a5 27		lda $27		                lda tmp2
.9baa		05 28		ora $28		                ora tmp2+1
.9bac		f0 36		beq $9be4	                beq _next_wordlist
.9bae		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9bb0		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9bb2		b5 03		lda $03,x	                lda 3,x
.9bb4		85 2a		sta $2a		                sta tmp3+1
.9bb6						_loop:
.9bb6		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9bb8		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.9bba		c5 29		cmp $29		                cmp tmp3
.9bbc		d0 07		bne $9bc5	                bne _no_match
.9bbe		c8		iny		                iny
.9bbf		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9bc1		c5 2a		cmp $2a		                cmp tmp3+1
.9bc3		f0 30		beq $9bf5	                beq _match
.9bc5						_no_match:
.9bc5		18		clc		                clc
.9bc6		a5 27		lda $27		                lda tmp2
.9bc8		69 02		adc #$02	                adc #2
.9bca		85 27		sta $27		                sta tmp2
.9bcc		90 02		bcc $9bd0	                bcc +
.9bce		e6 28		inc $28		                inc tmp2+1
.9bd0						+
.9bd0		a0 00		ldy #$00	                ldy #0
.9bd2		b1 27		lda ($27),y	                lda (tmp2),y
.9bd4		48		pha		                pha
.9bd5		c8		iny		                iny
.9bd6		11 27		ora ($27),y	                ora (tmp2),y
.9bd8		f0 09		beq $9be3	                beq _zero
.9bda		b1 27		lda ($27),y	                lda (tmp2),y
.9bdc		85 28		sta $28		                sta tmp2+1
.9bde		68		pla		                pla
.9bdf		85 27		sta $27		                sta tmp2
.9be1		80 d3		bra $9bb6	                bra _loop
.9be3						_zero:
.9be3		68		pla		                pla             ; Leftover from above loop
.9be4						_next_wordlist:
.9be4		b5 00		lda $00,x	                lda 0,x
.9be6		1a		inc a		                ina
.9be7		95 00		sta $00,x	                sta 0,x
.9be9		c9 0c		cmp #$0c	                cmp #max_wordlists
.9beb		d0 ab		bne $9b98	                bne _wordlist_loop
.9bed		e8		inx		                inx
.9bee		e8		inx		                inx
.9bef		74 00		stz $00,x	                stz 0,x
.9bf1		74 01		stz $01,x	                stz 1,x
.9bf3		80 0a		bra $9bff	                bra z_int_to_name
.9bf5						_match:
.9bf5		e8		inx		                inx
.9bf6		e8		inx		                inx
.9bf7		a5 27		lda $27		                lda tmp2
.9bf9		95 00		sta $00,x	                sta 0,x
.9bfb		a5 28		lda $28		                lda tmp2+1
.9bfd		95 01		sta $01,x	                sta 1,x
.9bff		60		rts		z_int_to_name:  rts
.9c00						xt_latestnt:
.9c00		ca		dex		                dex
.9c01		ca		dex		                dex
.9c02		20 c8 d6	jsr $d6c8	                jsr current_to_dp
.9c05		a5 02		lda $02		                lda dp
.9c07		95 00		sta $00,x	                sta 0,x
.9c09		a5 03		lda $03		                lda dp+1
.9c0b		95 01		sta $01,x	                sta 1,x
.9c0d		60		rts		z_latestnt:     rts
.9c0e						xt_latestxt:
.9c0e		20 00 9c	jsr $9c00	                jsr xt_latestnt         ; ( nt )
.9c11		20 15 9c	jsr $9c15	                jsr xt_name_to_int      ; ( xt )
.9c14		60		rts		z_latestxt:     rts
.9c15						xt_name_to_int:
.9c15		20 71 d7	jsr $d771	                jsr underflow_1
.9c18		b5 00		lda $00,x	                lda 0,x
.9c1a		18		clc		                clc
.9c1b		69 04		adc #$04	                adc #4
.9c1d		85 29		sta $29		                sta tmp3
.9c1f		b5 01		lda $01,x	                lda 1,x
.9c21		90 01		bcc $9c24	                bcc _done
.9c23		1a		inc a		                ina
.9c24						_done:
.9c24		85 2a		sta $2a		                sta tmp3+1
.9c26		a0 00		ldy #$00	                ldy #0
.9c28		b1 29		lda ($29),y	                lda (tmp3),y
.9c2a		95 00		sta $00,x	                sta 0,x
.9c2c		c8		iny		                iny
.9c2d		b1 29		lda ($29),y	                lda (tmp3),y
.9c2f		95 01		sta $01,x	                sta 1,x
.9c31		60		rts		z_name_to_int:  rts
.9c32						xt_name_to_string:
.9c32		20 71 d7	jsr $d771	                jsr underflow_1
.9c35		ca		dex		                dex
.9c36		ca		dex		                dex
.9c37		a1 02		lda ($02,x)	                lda (2,x)
.9c39		95 00		sta $00,x	                sta 0,x
.9c3b		74 01		stz $01,x	                stz 1,x
.9c3d		b5 02		lda $02,x	                lda 2,x         ; LSB
.9c3f		18		clc		                clc
.9c40		69 08		adc #$08	                adc #8
.9c42		95 02		sta $02,x	                sta 2,x
.9c44		90 02		bcc $9c48	                bcc z_name_to_string
.9c46		f6 03		inc $03,x	                inc 3,x         ; MSB
.9c48						z_name_to_string:
.9c48		60		rts		                rts
.9c49						xt_nc_limit:
.9c49		a9 00		lda #$00	                lda #nc_limit_offset
.9c4b		4c 2d d6	jmp $d62d	                jmp push_upvar_tos
.9c4e						z_nc_limit:
.9c4e						xt_never_native:
.9c4e		20 c8 d6	jsr $d6c8	                jsr current_to_dp
.9c51		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9c53		b1 02		lda ($02),y	                lda (dp),y
.9c55		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9c57		29 fd		and #$fd	                and #$FF-AN     ; and AN flag is clear.
.9c59		91 02		sta ($02),y	                sta (dp),y
.9c5b						z_never_native:
.9c5b		60		rts		                rts
.9c5c						xt_not_rote:
.9c5c		20 7b d7	jsr $d77b	                jsr underflow_3
.9c5f						w_not_rote:
.9c5f		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9c61		b5 03		lda $03,x	                lda 3,x
.9c63		95 01		sta $01,x	                sta 1,x
.9c65		b5 05		lda $05,x	                lda 5,x
.9c67		95 03		sta $03,x	                sta 3,x
.9c69		94 05		sty $05,x	                sty 5,x
.9c6b		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9c6d		b5 02		lda $02,x	                lda 2,x
.9c6f		95 00		sta $00,x	                sta 0,x
.9c71		b5 04		lda $04,x	                lda 4,x
.9c73		95 02		sta $02,x	                sta 2,x
.9c75		94 04		sty $04,x	                sty 4,x
.9c77		60		rts		z_not_rote:     rts
.9c78						xt_number:
.9c78		20 76 d7	jsr $d776	                jsr underflow_2
.9c7b		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.9c7d		a5 18		lda $18		                lda base
.9c7f		48		pha		                pha
.9c80		20 ab 93	jsr $93ab	                jsr xt_two_dup
.9c83		a1 02		lda ($02,x)	                lda (2,x)
.9c85		c9 23		cmp #$23	                cmp #'#'                ; decimal?
.9c87		d0 04		bne $9c8d	                bne _check_hex
.9c89		a9 0a		lda #$0a	                lda #10
.9c8b		80 42		bra $9ccf	                bra _base_changed
.9c8d						_check_hex:
.9c8d		c9 24		cmp #$24	                cmp #'$'
.9c8f		d0 04		bne $9c95	                bne _check_binary
.9c91		a9 10		lda #$10	                lda #16
.9c93		80 3a		bra $9ccf	                bra _base_changed
.9c95						_check_binary:
.9c95		c9 25		cmp #$25	                cmp #'%'
.9c97		d0 04		bne $9c9d	                bne _check_char
.9c99		a9 02		lda #$02	                lda #2
.9c9b		80 32		bra $9ccf	                bra _base_changed
.9c9d						_check_char:
.9c9d		c9 27		cmp #$27	                cmp #"'"
.9c9f		d0 3a		bne $9cdb	                bne _check_minus
.9ca1		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9ca3		c9 03		cmp #$03	                cmp #3
.9ca5		d0 26		bne $9ccd	                bne _not_a_char
.9ca7		b5 01		lda $01,x	                lda 1,x
.9ca9		d0 22		bne $9ccd	                bne _not_a_char ; No compare needed to check for non-zero.
.9cab		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9cad		18		clc		                clc
.9cae		69 02		adc #$02	                adc #2          ; length of string
.9cb0		85 23		sta $23		                sta tmptos
.9cb2		b5 03		lda $03,x	                lda 3,x
.9cb4		69 00		adc #$00	                adc #0          ; only need carry
.9cb6		85 24		sta $24		                sta tmptos+1
.9cb8		b2 23		lda ($23)	                lda (tmptos)
.9cba		c9 27		cmp #$27	                cmp #"'"
.9cbc		d0 0f		bne $9ccd	                bne _not_a_char
.9cbe		f6 02		inc $02,x	                inc 2,x
.9cc0		d0 02		bne $9cc4	                bne +
.9cc2		f6 03		inc $03,x	                inc 3,x
.9cc4						+
.9cc4		a1 02		lda ($02,x)	                lda (2,x)
.9cc6		95 02		sta $02,x	                sta 2,x
.9cc8		74 03		stz $03,x	                stz 3,x
.9cca		4c 4d 9d	jmp $9d4d	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9ccd						_not_a_char:
.9ccd		80 5c		bra $9d2b	                bra _number_error
.9ccf						_base_changed:
.9ccf		85 18		sta $18		                sta base        ; Switch to the new base
.9cd1		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9cd3		d0 02		bne $9cd7	                bne +
.9cd5		f6 03		inc $03,x	                inc 3,x
.9cd7						+
.9cd7		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9cd9		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9cdb						_check_minus:
.9cdb		c9 2d		cmp #$2d	                cmp #'-'
.9cdd		d0 0c		bne $9ceb	                bne _check_dot
.9cdf		a9 80		lda #$80	                lda #$80
.9ce1		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.9ce3		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9ce5		d0 02		bne $9ce9	                bne +
.9ce7		f6 03		inc $03,x	                inc 3,x
.9ce9						+
.9ce9		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9ceb						_check_dot:
.9ceb		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9ced		18		clc		                clc
.9cee		75 00		adc $00,x	                adc 0,x         ; length of string
.9cf0		85 23		sta $23		                sta tmptos
.9cf2		b5 03		lda $03,x	                lda 3,x
.9cf4		69 00		adc #$00	                adc #0          ; only need carry
.9cf6		85 24		sta $24		                sta tmptos+1
.9cf8		a5 23		lda $23		                lda tmptos
.9cfa		d0 02		bne $9cfe	                bne +
.9cfc		c6 24		dec $24		                dec tmptos+1
.9cfe						+
.9cfe		c6 23		dec $23		                dec tmptos
.9d00		b2 23		lda ($23)	                lda (tmptos)
.9d02		c9 2e		cmp #$2e	                cmp #'.'
.9d04		d0 04		bne $9d0a	                bne _main
.9d06		e6 1e		inc $1e		                inc tmpdsp
.9d08		d6 00		dec $00,x	                dec 0,x
.9d0a						_main:
.9d0a		ca		dex		                dex
.9d0b		ca		dex		                dex
.9d0c		ca		dex		                dex
.9d0d		ca		dex		                dex
.9d0e		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9d10		95 00		sta $00,x	                sta 0,x
.9d12		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9d14		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9d16		95 02		sta $02,x	                sta 2,x
.9d18		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9d1a		95 03		sta $03,x	                sta 3,x
.9d1c		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9d1e		74 05		stz $05,x	                stz 5,x
.9d20		74 06		stz $06,x	                stz 6,x
.9d22		74 07		stz $07,x	                stz 7,x
.9d24		20 c8 92	jsr $92c8	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9d27		b5 00		lda $00,x	                lda 0,x
.9d29		f0 1e		beq $9d49	                beq _all_converted
.9d2b						_number_error:
.9d2b		20 a3 93	jsr $93a3	                jsr xt_two_drop ; >NUMBER modified addr u
.9d2e		20 a3 93	jsr $93a3	                jsr xt_two_drop ; ud   (partially converted number)
.9d31		a9 3e		lda #$3e	                lda #'>'
.9d33		20 c5 86	jsr $86c5	                jsr emit_a
.9d36		20 c0 94	jsr $94c0	                jsr xt_type
.9d39		a9 3c		lda #$3c	                lda #'<'
.9d3b		20 c5 86	jsr $86c5	                jsr emit_a
.9d3e		20 c7 91	jsr $91c7	                jsr xt_space
.9d41		68		pla		                pla
.9d42		85 18		sta $18		                sta base
.9d44		a9 08		lda #$08	                lda #err_syntax
.9d46		4c 87 d7	jmp $d787	                jmp error
.9d49						_all_converted:
.9d49		e8		inx		                inx ; Drop the current addr u
.9d4a		e8		inx		                inx
.9d4b		e8		inx		                inx
.9d4c		e8		inx		                inx
.9d4d						_drop_original_string:
.9d4d		20 7c 94	jsr $947c	                jsr xt_two_swap  ; Drop the original addr u
.9d50		20 a3 93	jsr $93a3	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9d53		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9d55		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9d57		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9d58		f0 0a		beq $9d64	                beq _single
.9d5a		98		tya		                tya
.9d5b		04 1c		tsb $1c		                tsb status
.9d5d		90 0f		bcc $9d6e	                bcc _done       ; no minus, all done
.9d5f		20 46 9e	jsr $9e46	                jsr xt_dnegate
.9d62		80 0a		bra $9d6e	                bra _done
.9d64						_single:
.9d64		e8		inx		                inx
.9d65		e8		inx		                inx
.9d66		98		tya		                tya
.9d67		14 1c		trb $1c		                trb status
.9d69		90 03		bcc $9d6e	                bcc _done       ; no minus, all done
.9d6b		20 1f 8c	jsr $8c1f	                jsr xt_negate
.9d6e						_done:
.9d6e		68		pla		                pla
.9d6f		85 18		sta $18		                sta base
.9d71		60		rts		z_number:       rts
.9d72						xt_editor_wordlist:
.9d72						xt_one:
.9d72		ca		dex		                dex
.9d73		ca		dex		                dex
.9d74		a9 01		lda #$01	                lda #1
.9d76		95 00		sta $00,x	                sta 0,x
.9d78		74 01		stz $01,x	                stz 1,x
.9d7a						z_editor_wordlist:
.9d7a						z_one:
.9d7a		60		rts		                rts
.9d7b						xt_output:
.9d7b		ca		dex		                dex
.9d7c		ca		dex		                dex
.9d7d		a9 12		lda #$12	                lda #<output
.9d7f		95 00		sta $00,x	                sta 0,x
.9d81		a9 00		lda #$00	                lda #>output
.9d83		95 01		sta $01,x	                sta 1,x
.9d85		60		rts		z_output:       rts
.9d86						xt_r_to_input:
.9d86		68		pla		                pla
.9d87		85 25		sta $25		                sta tmp1
.9d89		68		pla		                pla
.9d8a		85 26		sta $26		                sta tmp1+1
.9d8c		a0 00		ldy #$00	                ldy #0
.9d8e						_loop:
.9d8e		68		pla		                pla
.9d8f		99 0a 00	sta $000a,y	                sta insrc,y
.9d92		c8		iny		                iny
.9d93		c0 08		cpy #$08	                cpy #8
.9d95		d0 f7		bne $9d8e	                bne _loop
.9d97		a5 26		lda $26		                lda tmp1+1
.9d99		48		pha		                pha
.9d9a		a5 25		lda $25		                lda tmp1
.9d9c		48		pha		                pha
.9d9d		60		rts		z_r_to_input: 	rts
.9d9e						xt_strip_underflow:
.9d9e		a9 02		lda #$02	                lda #uf_strip_offset
.9da0		4c 2d d6	jmp $d62d	                jmp push_upvar_tos
.9da3						z_strip_underflow:
.9da3						xt_assembler_wordlist:
.9da3						xt_two:
.9da3		ca		dex		                dex
.9da4		ca		dex		                dex
.9da5		a9 02		lda #$02	                lda #2
.9da7		95 00		sta $00,x	                sta 0,x
.9da9		74 01		stz $01,x	                stz 1,x
.9dab						z_assembler_wordlist:
.9dab		60		rts		z_two:          rts
.9dac						xt_useraddr:
.9dac		ca		dex		                dex
.9dad		ca		dex		                dex
.9dae		a9 08		lda #$08	                lda #<up
.9db0		95 00		sta $00,x	                sta 0,x
.9db2		a9 00		lda #$00	                lda #>up
.9db4		95 01		sta $01,x	                sta 1,x
.9db6		60		rts		z_useraddr:     rts
.9db7						xt_wordsize:
.9db7		20 71 d7	jsr $d771	                jsr underflow_1
.9dba		b5 00		lda $00,x	                lda 0,x
.9dbc		85 25		sta $25		                sta tmp1
.9dbe		b5 01		lda $01,x	                lda 1,x
.9dc0		85 26		sta $26		                sta tmp1+1
.9dc2		a0 06		ldy #$06	                ldy #6
.9dc4		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.9dc6		88		dey		                dey
.9dc7		88		dey		                dey
.9dc8		38		sec		                sec
.9dc9		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.9dcb		95 00		sta $00,x	                sta 0,x
.9dcd		a0 07		ldy #$07	                ldy #7
.9dcf		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.9dd1		88		dey		                dey
.9dd2		88		dey		                dey
.9dd3		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.9dd5		95 01		sta $01,x	                sta 1,x
.9dd7		60		rts		z_wordsize:     rts
.9dd8						xt_case:
.9dd8						xt_false:
.9dd8						xt_forth_wordlist:
.9dd8						xt_zero:
.9dd8						w_zero:
.9dd8		ca		dex		                dex             ; push
.9dd9		ca		dex		                dex
.9dda		74 00		stz $00,x	                stz 0,x
.9ddc		74 01		stz $01,x	                stz 1,x
.9dde						z_case:
.9dde						z_false:
.9dde						z_forth_wordlist:
.9dde						z_zero:
.9dde		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/double.asm

.9ddf						xt_d_minus:
.9ddf		20 80 d7	jsr $d780	                jsr underflow_4 ; two double numbers
.9de2		38		sec		                sec
.9de3		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.9de5		f5 02		sbc $02,x	                sbc 2,x
.9de7		95 06		sta $06,x	                sta 6,x
.9de9		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.9deb		f5 03		sbc $03,x	                sbc 3,x
.9ded		95 07		sta $07,x	                sta 7,x
.9def		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.9df1		f5 00		sbc $00,x	                sbc 0,x
.9df3		95 04		sta $04,x	                sta 4,x
.9df5		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.9df7		f5 01		sbc $01,x	                sbc 1,x
.9df9		95 05		sta $05,x	                sta 5,x
.9dfb		e8		inx		                inx
.9dfc		e8		inx		                inx
.9dfd		e8		inx		                inx
.9dfe		e8		inx		                inx
.9dff		60		rts		z_d_minus:      rts
.9e00						xt_d_plus:
.9e00		20 80 d7	jsr $d780	                jsr underflow_4 ; two double numbers
.9e03		18		clc		                clc
.9e04		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.9e06		75 06		adc $06,x	                adc 6,x
.9e08		95 06		sta $06,x	                sta 6,x
.9e0a		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.9e0c		75 07		adc $07,x	                adc 7,x
.9e0e		95 07		sta $07,x	                sta 7,x
.9e10		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.9e12		75 04		adc $04,x	                adc 4,x
.9e14		95 04		sta $04,x	                sta 4,x
.9e16		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.9e18		75 05		adc $05,x	                adc 5,x
.9e1a		95 05		sta $05,x	                sta 5,x
.9e1c		e8		inx		                inx
.9e1d		e8		inx		                inx
.9e1e		e8		inx		                inx
.9e1f		e8		inx		                inx
.9e20		60		rts		z_d_plus:       rts
.9e21						xt_d_to_s:
.9e21		20 76 d7	jsr $d776	                jsr underflow_2
.9e24		e8		inx		                inx
.9e25		e8		inx		                inx
.9e26		60		rts		z_d_to_s:       rts
.9e27						xt_dabs:
.9e27		20 76 d7	jsr $d776	                jsr underflow_2 ; double number
.9e2a		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.9e2c		10 17		bpl $9e45	                bpl _done       ; positive, we get off light
.9e2e		a0 00		ldy #$00	                ldy #0
.9e30		38		sec		                sec
.9e31		98		tya		                tya
.9e32		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e34		95 02		sta $02,x	                sta 2,x
.9e36		98		tya		                tya
.9e37		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e39		95 03		sta $03,x	                sta 3,x
.9e3b		98		tya		                tya
.9e3c		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e3e		95 00		sta $00,x	                sta 0,x
.9e40		98		tya		                tya
.9e41		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9e43		95 01		sta $01,x	                sta 1,x
.9e45						_done:
.9e45		60		rts		z_dabs:         rts
.9e46						xt_dnegate:
.9e46		20 76 d7	jsr $d776	                jsr underflow_2 ; double number
.9e49		a0 00		ldy #$00	     		ldy #0
.9e4b		38		sec		                sec
.9e4c		98		tya		                tya
.9e4d		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e4f		95 02		sta $02,x	                sta 2,x
.9e51		98		tya		                tya
.9e52		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e54		95 03		sta $03,x	                sta 3,x
.9e56		98		tya		                tya
.9e57		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e59		95 00		sta $00,x	                sta 0,x
.9e5b		98		tya		                tya
.9e5c		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9e5e		95 01		sta $01,x	                sta 1,x
.9e60		60		rts		z_dnegate:      rts
.9e61						xt_d_dot:
.9e61		20 76 d7	jsr $d776	                jsr underflow_2
.9e64		20 89 93	jsr $9389	                jsr xt_tuck
.9e67		20 27 9e	jsr $9e27	                jsr xt_dabs
.9e6a		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9e6d		20 af 8c	jsr $8caf	                jsr xt_number_sign_s
.9e70		20 8d 8f	jsr $8f8d	                jsr xt_rot
.9e73		20 4c 91	jsr $914c	                jsr xt_sign
.9e76		20 8d 8c	jsr $8c8d	                jsr xt_number_sign_greater
.9e79		20 c0 94	jsr $94c0	                jsr xt_type
.9e7c		20 c7 91	jsr $91c7	                jsr xt_space
.9e7f		60		rts		z_d_dot:        rts
.9e80						xt_d_dot_r:
.9e80		20 7b d7	jsr $d77b	                jsr underflow_3
.9e83		20 68 93	jsr $9368	                jsr xt_to_r
.9e86		20 89 93	jsr $9389	                jsr xt_tuck
.9e89		20 27 9e	jsr $9e27	                jsr xt_dabs
.9e8c		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9e8f		20 af 8c	jsr $8caf	                jsr xt_number_sign_s
.9e92		20 8d 8f	jsr $8f8d	                jsr xt_rot
.9e95		20 4c 91	jsr $914c	                jsr xt_sign
.9e98		20 8d 8c	jsr $8c8d	                jsr xt_number_sign_greater
.9e9b		20 ec 8e	jsr $8eec	                jsr xt_r_from
.9e9e		20 01 8d	jsr $8d01	                jsr xt_over
.9ea1		20 e4 8b	jsr $8be4	                jsr xt_minus
.9ea4		20 cd 91	jsr $91cd	                jsr xt_spaces
.9ea7		20 c0 94	jsr $94c0	                jsr xt_type
.9eaa		60		rts		z_d_dot_r:      rts
.9eab						xt_two_constant:
.9eab		20 76 d7	jsr $d776	                jsr underflow_2
.9eae		20 40 84	jsr $8440	                jsr xt_create
.9eb1		20 2a 92	jsr $922a	                jsr xt_swap
.9eb4		20 cd 83	jsr $83cd	                jsr xt_comma
.9eb7		20 cd 83	jsr $83cd	                jsr xt_comma
.9eba		20 fe 85	jsr $85fe	                jsr does_runtime    ; does> turns into these two routines.
.9ebd		20 06 d6	jsr $d606	                jsr dodoes
.9ec0		20 a0 86	jsr $86a0	                jsr xt_dup
.9ec3		20 1a 88	jsr $881a	                jsr xt_fetch
.9ec6		20 2a 92	jsr $922a	                jsr xt_swap
.9ec9		20 43 83	jsr $8343	                jsr xt_cell_plus
.9ecc		20 1a 88	jsr $881a	                jsr xt_fetch
.9ecf		60		rts		z_two_constant: rts
.9ed0						xt_two_literal:
.9ed0		20 76 d7	jsr $d776	                jsr underflow_2 ; double number
.9ed3		a9 0a		lda #$0a	                lda #template_push_tos_size
.9ed5		0a		asl a		                asl
.9ed6		20 8c 97	jsr $978c	                jsr check_nc_limit
.9ed9		b0 09		bcs $9ee4	                bcs _no_inline
.9edb		20 2a 92	jsr $922a	                jsr xt_swap
.9ede		20 f2 89	jsr $89f2	                jsr xt_literal
.9ee1		4c f2 89	jmp $89f2	                jmp xt_literal
.9ee4						_no_inline:
.9ee4		20 43 a1	jsr $a143	                jsr cmpl_two_literal
.9ee7		60		rts		z_two_literal:  rts
.9ee8						xt_two_variable:
.9ee8		20 40 84	jsr $8440	                jsr xt_create
.9eeb		ca		dex		                dex
.9eec		ca		dex		                dex
.9eed		a9 04		lda #$04	                lda #4
.9eef		95 00		sta $00,x	                sta 0,x
.9ef1		74 01		stz $01,x	                stz 1,x
.9ef3		20 27 82	jsr $8227	                jsr xt_allot
.9ef6		60		rts		z_two_variable: rts
.9ef7						xt_ud_dot:
.9ef7		20 76 d7	jsr $d776	                jsr underflow_2 ; double number
.9efa		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9efd		20 af 8c	jsr $8caf	                jsr xt_number_sign_s
.9f00		20 8d 8c	jsr $8c8d	                jsr xt_number_sign_greater
.9f03		20 c0 94	jsr $94c0	                jsr xt_type
.9f06		20 c7 91	jsr $91c7	                jsr xt_space
.9f09		60		rts		z_ud_dot:        rts
.9f0a						xt_ud_dot_r:
.9f0a		20 7b d7	jsr $d77b	                jsr underflow_3
.9f0d		20 68 93	jsr $9368	                jsr xt_to_r
.9f10		20 cf 89	jsr $89cf	                jsr xt_less_number_sign
.9f13		20 af 8c	jsr $8caf	                jsr xt_number_sign_s
.9f16		20 8d 8c	jsr $8c8d	                jsr xt_number_sign_greater
.9f19		20 ec 8e	jsr $8eec	                jsr xt_r_from
.9f1c		20 01 8d	jsr $8d01	                jsr xt_over
.9f1f		20 e4 8b	jsr $8be4	                jsr xt_minus
.9f22		20 cd 91	jsr $91cd	                jsr xt_spaces
.9f25		20 c0 94	jsr $94c0	                jsr xt_type
.9f28		60		rts		z_ud_dot_r:      rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/string.asm

.9f29						xt_cmove:
.9f29		20 7b d7	jsr $d77b	                jsr underflow_3
.9f2c		b5 02		lda $02,x	                lda 2,x
.9f2e		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9f30		b5 03		lda $03,x	                lda 3,x
.9f32		85 28		sta $28		                sta tmp2+1
.9f34		b5 04		lda $04,x	                lda 4,x
.9f36		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9f38		b5 05		lda $05,x	                lda 5,x
.9f3a		85 26		sta $26		                sta tmp1+1
.9f3c		a0 00		ldy #$00	                ldy #0
.9f3e		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.9f40		f0 0f		beq $9f51	                beq _dopartial
.9f42						_page:
.9f42		b1 25		lda ($25),y	                lda (tmp1),y
.9f44		91 27		sta ($27),y	                sta (tmp2),y
.9f46		c8		iny		                iny
.9f47		d0 f9		bne $9f42	                bne _page
.9f49		e6 26		inc $26		                inc tmp1+1
.9f4b		e6 28		inc $28		                inc tmp2+1
.9f4d		d6 01		dec $01,x	                dec 1,x
.9f4f		d0 f1		bne $9f42	                bne _page
.9f51						_dopartial:
.9f51		b5 00		lda $00,x	                lda 0,x         ; length of last page
.9f53		f0 09		beq $9f5e	                beq _done
.9f55						_partial:
.9f55		b1 25		lda ($25),y	                lda (tmp1),y
.9f57		91 27		sta ($27),y	                sta (tmp2),y
.9f59		c8		iny		                iny
.9f5a		d6 00		dec $00,x	                dec 0,x
.9f5c		d0 f7		bne $9f55	                bne _partial
.9f5e						_done:
.9f5e		8a		txa		                txa
.9f5f		18		clc		                clc
.9f60		69 06		adc #$06	                adc #6
.9f62		aa		tax		                tax
.9f63		60		rts		z_cmove:        rts
.9f64						xt_cmove_up:
.9f64		20 7b d7	jsr $d77b	                jsr underflow_3
.9f67		b5 02		lda $02,x	                lda 2,x
.9f69		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9f6b		b5 03		lda $03,x	                lda 3,x
.9f6d		18		clc		                clc
.9f6e		75 01		adc $01,x	                adc 1,x
.9f70		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.9f72		b5 04		lda $04,x	                lda 4,x
.9f74		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9f76		b5 05		lda $05,x	                lda 5,x
.9f78		18		clc		                clc
.9f79		75 01		adc $01,x	                adc 1,x
.9f7b		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.9f7d		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.9f7f		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.9f81		f0 0e		beq $9f91	                beq _nopartial
.9f83						_outerloop:
.9f83		88		dey		                dey
.9f84		f0 07		beq $9f8d	                beq _finishpage
.9f86						_innerloop:
.9f86		b1 25		lda ($25),y	                lda (tmp1),y
.9f88		91 27		sta ($27),y	                sta (tmp2),y
.9f8a		88		dey		                dey
.9f8b		d0 f9		bne $9f86	                bne _innerloop
.9f8d						_finishpage:
.9f8d		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.9f8f		92 27		sta ($27)	                sta (tmp2)
.9f91						_nopartial:
.9f91		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.9f93		c6 28		dec $28		                dec tmp2+1
.9f95		d6 01		dec $01,x	                dec 1,x
.9f97		d0 ea		bne $9f83	                bne _outerloop
.9f99		8a		txa		                txa
.9f9a		18		clc		                clc
.9f9b		69 06		adc #$06	                adc #6
.9f9d		aa		tax		                tax
.9f9e		60		rts		z_cmove_up:     rts
.9f9f						xt_compare:
.9f9f		20 80 d7	jsr $d780	                jsr underflow_4
.9fa2		b5 02		lda $02,x	                lda 2,x
.9fa4		85 27		sta $27		                sta tmp2
.9fa6		b5 03		lda $03,x	                lda 3,x
.9fa8		85 28		sta $28		                sta tmp2+1
.9faa		b5 06		lda $06,x	                lda 6,x
.9fac		85 25		sta $25		                sta tmp1
.9fae		b5 07		lda $07,x	                lda 7,x
.9fb0		85 26		sta $26		                sta tmp1+1
.9fb2						_compare_loop:
.9fb2		b5 04		lda $04,x	                lda 4,x
.9fb4		15 05		ora $05,x	                ora 5,x
.9fb6		f0 2c		beq $9fe4	                beq _str1_done
.9fb8		b5 00		lda $00,x	                lda 0,x
.9fba		15 01		ora $01,x	                ora 1,x
.9fbc		f0 3a		beq $9ff8	                beq _greater    ; Str2 empty first
.9fbe		b2 25		lda ($25)	                lda (tmp1)
.9fc0		d2 27		cmp ($27)	                cmp (tmp2)
.9fc2		90 26		bcc $9fea	                bcc _less
.9fc4		d0 32		bne $9ff8	                bne _greater
.9fc6		e6 25		inc $25		                inc tmp1
.9fc8		d0 02		bne $9fcc	                bne +
.9fca		e6 26		inc $26		                inc tmp1+1
.9fcc						+
.9fcc		e6 27		inc $27		                inc tmp2
.9fce		d0 02		bne $9fd2	                bne +
.9fd0		e6 28		inc $28		                inc tmp2+1
.9fd2						+
.9fd2		b5 04		lda $04,x	                lda 4,x
.9fd4		d0 02		bne $9fd8	                bne +
.9fd6		d6 05		dec $05,x	                dec 5,x
.9fd8						+
.9fd8		d6 04		dec $04,x	                dec 4,x
.9fda		b5 00		lda $00,x	                lda 0,x
.9fdc		d0 02		bne $9fe0	                bne +
.9fde		d6 01		dec $01,x	                dec 1,x
.9fe0						+
.9fe0		d6 00		dec $00,x	                dec 0,x
.9fe2		80 ce		bra $9fb2	                bra _compare_loop
.9fe4						_str1_done:
.9fe4		b5 00		lda $00,x	                lda 0,x
.9fe6		15 01		ora $01,x	                ora 1,x
.9fe8		f0 08		beq $9ff2	                beq _equal      ; Both out of letters
.9fea						_less:
.9fea		a9 ff		lda #$ff	                lda #$FF
.9fec		95 06		sta $06,x	                sta 6,x
.9fee		95 07		sta $07,x	                sta 7,x
.9ff0		80 0c		bra $9ffe	                bra _done
.9ff2						_equal:
.9ff2		74 06		stz $06,x	                stz 6,x
.9ff4		74 07		stz $07,x	                stz 7,x
.9ff6		80 06		bra $9ffe	                bra _done
.9ff8						_greater:
.9ff8		a9 01		lda #$01	                lda #1
.9ffa		95 06		sta $06,x	                sta 6,x
.9ffc		74 07		stz $07,x	                stz 7,x
.9ffe						_done:
.9ffe		8a		txa		                txa
.9fff		18		clc		                clc
.a000		69 06		adc #$06	                adc #6
.a002		aa		tax		                tax
.a003		60		rts		z_compare:      rts
.a004						xt_minus_leading:
.a004		20 76 d7	jsr $d776	                jsr underflow_2
.a007						_loop:
.a007		b5 00		lda $00,x	                lda 0,x
.a009		15 01		ora $01,x	                ora 1,x
.a00b		f0 0f		beq $a01c	                beq _done
.a00d		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.a00f		20 64 d7	jsr $d764	                jsr is_whitespace
.a012		90 08		bcc $a01c	                bcc _done
.a014		20 72 9d	jsr $9d72	                jsr xt_one              ; ( addr u 1 )
.a017		20 f9 a0	jsr $a0f9	                jsr xt_slash_string     ; ( addr+ u-1 )
.a01a		80 eb		bra $a007	                bra _loop
.a01c						_done:
.a01c						z_minus_leading:
.a01c		60		rts		                rts
.a01d						xt_minus_trailing:
.a01d		20 76 d7	jsr $d776	                jsr underflow_2
.a020		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.a022		15 01		ora $01,x	                ora 1,x         ; MSB of n
.a024		f0 33		beq $a059	                beq _done
.a026		18		clc		                clc
.a027		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.a029		75 00		adc $00,x	                adc 0,x
.a02b		85 25		sta $25		                sta tmp1
.a02d		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.a02f		75 01		adc $01,x	                adc 1,x
.a031		85 26		sta $26		                sta tmp1+1
.a033		a5 25		lda $25		                lda tmp1
.a035		d0 02		bne $a039	                bne +
.a037		c6 26		dec $26		                dec tmp1+1
.a039						+
.a039		c6 25		dec $25		                dec tmp1
.a03b						_loop:
.a03b		b2 25		lda ($25)	                lda (tmp1)
.a03d		c9 20		cmp #$20	                cmp #AscSP
.a03f		d0 18		bne $a059	                bne _done
.a041		a5 25		lda $25		                lda tmp1
.a043		d0 02		bne $a047	                bne +
.a045		c6 26		dec $26		                dec tmp1+1
.a047						+
.a047		c6 25		dec $25		                dec tmp1
.a049		b5 00		lda $00,x	                lda 0,x
.a04b		d0 02		bne $a04f	                bne +
.a04d		d6 01		dec $01,x	                dec 1,x
.a04f						+
.a04f		d6 00		dec $00,x	                dec 0,x
.a051		b5 00		lda $00,x	                lda 0,x
.a053		15 01		ora $01,x	                ora 1,x
.a055		f0 02		beq $a059	                beq _done       ; Count has reached zero - we're done!
.a057		80 e2		bra $a03b	                bra _loop
.a059						_done:
.a059						z_minus_trailing:
.a059		60		rts		                rts
.a05a						xt_search:
.a05a		20 80 d7	jsr $d780	                jsr underflow_4
.a05d		b5 00		lda $00,x	                lda 0,x
.a05f		15 01		ora $01,x	                ora 1,x
.a061		d0 0b		bne $a06e	                bne _start_search
.a063		e8		inx		                inx             ; Remove u2
.a064		e8		inx		                inx
.a065		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.a067		95 00		sta $00,x	                sta 0,x
.a069		95 01		sta $01,x	                sta 1,x
.a06b		4c f8 a0	jmp $a0f8	                jmp z_search
.a06e						_start_search:
.a06e		20 d8 9d	jsr $9dd8	                jsr xt_zero
.a071						_search_loop:
.a071		18		clc		                clc
.a072		b5 00		lda $00,x	                lda 0,x
.a074		75 02		adc $02,x	                adc 2,x
.a076		85 25		sta $25		                sta tmp1
.a078		b5 01		lda $01,x	                lda 1,x
.a07a		75 03		adc $03,x	                adc 3,x
.a07c		d5 07		cmp $07,x	                cmp 7,x
.a07e		90 12		bcc $a092	                bcc _init_comparison ; Obviously less
.a080		d0 06		bne $a088	                bne _not_found
.a082		b5 06		lda $06,x	                lda 6,x
.a084		c5 25		cmp $25		                cmp tmp1
.a086		b0 0a		bcs $a092	                bcs _init_comparison
.a088						_not_found:
.a088		e8		inx		                inx             ; Remove offset
.a089		e8		inx		                inx
.a08a		e8		inx		                inx             ; Remove u2
.a08b		e8		inx		                inx
.a08c		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.a08e		74 01		stz $01,x	                stz 1,x
.a090		80 66		bra $a0f8	                bra z_search
.a092						_init_comparison:
.a092		18		clc		                clc
.a093		b5 08		lda $08,x	                lda 8,x
.a095		75 00		adc $00,x	                adc 0,x
.a097		85 25		sta $25		                sta tmp1
.a099		b5 09		lda $09,x	                lda 9,x
.a09b		75 01		adc $01,x	                adc 1,x
.a09d		85 26		sta $26		                sta tmp1+1
.a09f		b5 04		lda $04,x	                lda 4,x
.a0a1		85 27		sta $27		                sta tmp2
.a0a3		b5 05		lda $05,x	                lda 5,x
.a0a5		85 28		sta $28		                sta tmp2+1
.a0a7		b5 02		lda $02,x	                lda 2,x
.a0a9		85 29		sta $29		                sta tmp3
.a0ab		b5 03		lda $03,x	                lda 3,x
.a0ad		85 2a		sta $2a		                sta tmp3+1
.a0af						_comparison_loop:
.a0af		b2 25		lda ($25)	                lda (tmp1)
.a0b1		d2 27		cmp ($27)	                cmp (tmp2)
.a0b3		f0 05		beq $a0ba	                beq _letters_match
.a0b5		20 e5 8c	jsr $8ce5	                jsr xt_one_plus
.a0b8		80 b7		bra $a071	                bra _search_loop
.a0ba						_letters_match:
.a0ba		e6 25		inc $25		                inc tmp1
.a0bc		d0 02		bne $a0c0	                bne +
.a0be		e6 26		inc $26		                inc tmp1+1
.a0c0						+
.a0c0		e6 27		inc $27		                inc tmp2
.a0c2		d0 02		bne $a0c6	                bne +
.a0c4		e6 28		inc $28		                inc tmp2+1
.a0c6						+
.a0c6		a5 29		lda $29		                lda tmp3
.a0c8		d0 02		bne $a0cc	                bne +
.a0ca		c6 2a		dec $2a		                dec tmp3+1
.a0cc						+
.a0cc		c6 29		dec $29		                dec tmp3
.a0ce		a5 29		lda $29		                lda tmp3
.a0d0		05 2a		ora $2a		                ora tmp3+1
.a0d2		d0 db		bne $a0af	                bne _comparison_loop ; Check the next letter
.a0d4		18		clc		                clc
.a0d5		b5 00		lda $00,x	                lda 0,x
.a0d7		75 08		adc $08,x	                adc 8,x
.a0d9		95 08		sta $08,x	                sta 8,x
.a0db		b5 01		lda $01,x	                lda 1,x
.a0dd		75 09		adc $09,x	                adc 9,x
.a0df		95 09		sta $09,x	                sta 9,x
.a0e1		38		sec		                sec
.a0e2		b5 06		lda $06,x	                lda 6,x
.a0e4		f5 00		sbc $00,x	                sbc 0,x
.a0e6		95 06		sta $06,x	                sta 6,x
.a0e8		b5 07		lda $07,x	                lda 7,x
.a0ea		f5 01		sbc $01,x	                sbc 1,x
.a0ec		95 07		sta $07,x	                sta 7,x
.a0ee		e8		inx		                inx             ; drop offset
.a0ef		e8		inx		                inx
.a0f0		e8		inx		                inx             ; drop u2
.a0f1		e8		inx		                inx
.a0f2		a9 ff		lda #$ff	                lda #$FF
.a0f4		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.a0f6		95 01		sta $01,x	                sta 1,x
.a0f8		60		rts		z_search:       rts
.a0f9						xt_slash_string:
.a0f9		20 7b d7	jsr $d77b	                jsr underflow_3
.a0fc		18		clc		                clc             ; 3OS+TOS
.a0fd		b5 00		lda $00,x	                lda 0,x
.a0ff		75 04		adc $04,x	                adc 4,x
.a101		95 04		sta $04,x	                sta 4,x
.a103		b5 01		lda $01,x	                lda 1,x
.a105		75 05		adc $05,x	                adc 5,x
.a107		95 05		sta $05,x	                sta 5,x
.a109		38		sec		                sec             ; NOS-TOS
.a10a		b5 02		lda $02,x	                lda 2,x
.a10c		f5 00		sbc $00,x	                sbc 0,x
.a10e		95 02		sta $02,x	                sta 2,x
.a110		b5 03		lda $03,x	                lda 3,x
.a112		f5 01		sbc $01,x	                sbc 1,x
.a114		95 03		sta $03,x	                sta 3,x
.a116		e8		inx		                inx
.a117		e8		inx		                inx
.a118		60		rts		z_slash_string: rts
.a119						xt_sliteral:
.a119		20 76 d7	jsr $d776	                jsr underflow_2
.a11c		20 82 97	jsr $9782	                jsr cmpl_jump_later
.a11f		20 68 93	jsr $9368	                jsr xt_to_r
.a122		20 1b 89	jsr $891b	                jsr xt_here
.a125		20 2a 92	jsr $922a	                jsr xt_swap
.a128		20 a0 86	jsr $86a0	                jsr xt_dup
.a12b		20 27 82	jsr $8227	                jsr xt_allot            ; reserve u bytes for string
.a12e		20 1b 89	jsr $891b	                jsr xt_here
.a131		20 ec 8e	jsr $8eec	                jsr xt_r_from
.a134		20 14 92	jsr $9214	                jsr xt_store            ; point jmp past string
.a137		20 ab 93	jsr $93ab	                jsr xt_two_dup
.a13a		20 a0 94	jsr $94a0	                jsr xt_two_to_r
.a13d		20 00 8c	jsr $8c00	                jsr xt_move             ; copy u bytes from addr -> addr'
.a140		20 26 94	jsr $9426	                jsr xt_two_r_from
.a143						cmpl_sliteral:
.a143						cmpl_two_literal:
.a143		a0 a1		ldy #$a1	                ldy #>sliteral_runtime
.a145		a9 5d		lda #$5d	                lda #<sliteral_runtime
.a147		20 61 97	jsr $9761	                jsr cmpl_subroutine
.a14a		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a14c		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a14e		20 6d 97	jsr $976d	                jsr cmpl_word
.a151		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a153		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a155		20 6d 97	jsr $976d	                jsr cmpl_word
.a158		e8		inx		                inx
.a159		e8		inx		                inx
.a15a		e8		inx		                inx
.a15b		e8		inx		                inx
.a15c		60		rts		z_sliteral:     rts
.a15d						sliteral_runtime:
.a15d		ca		dex		                dex
.a15e		ca		dex		                dex
.a15f		ca		dex		                dex
.a160		ca		dex		                dex
.a161		68		pla		                pla
.a162		85 25		sta $25		                sta tmp1        ; LSB of address
.a164		7a		ply		                ply
.a165		84 26		sty $26		                sty tmp1+1      ; MSB of address
.a167		18		clc		                clc
.a168		69 04		adc #$04	                adc #4
.a16a		90 01		bcc $a16d	                bcc +
.a16c		c8		iny		                iny
.a16d						+
.a16d		5a		phy		                phy
.a16e		48		pha		                pha
.a16f		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a171		b1 25		lda ($25),y	                lda (tmp1),y
.a173		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a175		c8		iny		                iny
.a176		b1 25		lda ($25),y	                lda (tmp1),y
.a178		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a17a		c8		iny		                iny
.a17b		b1 25		lda ($25),y	                lda (tmp1),y
.a17d		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a17f		c8		iny		                iny
.a180		b1 25		lda ($25),y	                lda (tmp1),y
.a182		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a184		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/disasm.asm

.a185						xt_disasm:
.a185		20 76 d7	jsr $d776	                jsr underflow_2
.a188		20 8c a1	jsr $a18c	                jsr disassembler
.a18b		60		rts		z_disasm:       rts
.a18c						disassembler:
.a18c		64 32		stz $32		                stz scratch+5   ; flag indicating whether we're arriving at sliteral (vs 2literal)
.a18e		20 3a 84	jsr $843a	                jsr xt_cr       ; ( addr u )
.a191						_byte_loop:
.a191		20 01 8d	jsr $8d01	                jsr xt_over     ; ( addr u addr )
.a194		20 eb 94	jsr $94eb	                jsr xt_u_dot    ; ( addr u )
.a197		20 c7 91	jsr $91c7	                jsr xt_space
.a19a		a9 94		lda #$94	                lda #<oc_index_table
.a19c		85 27		sta $27		                sta tmp2
.a19e		a9 b3		lda #$b3	                lda #>oc_index_table
.a1a0		85 28		sta $28		                sta tmp2+1
.a1a2		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.a1a4		85 2d		sta $2d		                sta scratch     ; Save opcode
.a1a6		0a		asl a		                asl             ; multiply by two for offset
.a1a7		90 02		bcc $a1ab	                bcc +
.a1a9		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.a1ab						+
.a1ab		a8		tay		                tay             ; use Y as the index
.a1ac		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a1ae		85 29		sta $29		                sta tmp3
.a1b0		48		pha		                pha
.a1b1		c8		iny		                iny
.a1b2		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a1b4		85 2a		sta $2a		                sta tmp3+1
.a1b6		48		pha		                pha
.a1b7		b2 29		lda ($29)	                lda (tmp3)
.a1b9		a8		tay		                tay                     ; save copy of lengths byte
.a1ba		10 3c		bpl $a1f8	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.a1bc		20 d8 9d	jsr $9dd8	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.a1bf		f6 04		inc $04,x	                inc 4,x
.a1c1		d0 02		bne $a1c5	                bne +
.a1c3		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.a1c5						+
.a1c5		b5 02		lda $02,x	                lda 2,x
.a1c7		d0 02		bne $a1cb	                bne +
.a1c9		d6 03		dec $03,x	                dec 3,x
.a1cb						+
.a1cb		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.a1cd		a1 04		lda ($04,x)	                lda (4,x)
.a1cf		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.a1d1		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.a1d3		98		tya		                tya                     ; retrieve copy of lengths byte
.a1d4		2a		rol a		                rol                     ; shift bit 6 to bit 7
.a1d5		10 14		bpl $a1eb	                bpl _print_operand
.a1d7		f6 04		inc $04,x	                inc 4,x
.a1d9		d0 02		bne $a1dd	                bne +
.a1db		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.a1dd						+
.a1dd		b5 02		lda $02,x	                lda 2,x
.a1df		d0 02		bne $a1e3	                bne +
.a1e1		d6 03		dec $03,x	                dec 3,x
.a1e3						+
.a1e3		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.a1e5		a1 04		lda ($04,x)	                lda (4,x)
.a1e7		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.a1e9		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.a1eb						_print_operand:
.a1eb		ca		dex		                dex
.a1ec		ca		dex		                dex
.a1ed		a9 05		lda #$05	                lda #5
.a1ef		95 00		sta $00,x	                sta 0,x
.a1f1		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.a1f3		20 f7 94	jsr $94f7	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.a1f6		80 0b		bra $a203	                bra _print_mnemonic
.a1f8						_no_operand:
.a1f8		ca		dex		                dex
.a1f9		ca		dex		                dex
.a1fa		a9 05		lda #$05	                lda #5
.a1fc		95 00		sta $00,x	                sta 0,x
.a1fe		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.a200		20 cd 91	jsr $91cd	                jsr xt_spaces           ; ( addr u )
.a203						_print_mnemonic:
.a203		20 c7 91	jsr $91c7	                jsr xt_space
.a206		ca		dex		                dex
.a207		ca		dex		                dex                     ; ( addr u ? )
.a208		68		pla		                pla                     ; MSB
.a209		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.a20b		68		pla		                pla                     ; LSB
.a20c		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.a20e		20 26 84	jsr $8426	                jsr xt_count            ; ( addr u addr-o u-o )
.a211		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a213		b5 00		lda $00,x	                lda 0,x
.a215		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.a217		95 00		sta $00,x	                sta 0,x
.a219		20 c0 94	jsr $94c0	                jsr xt_type             ; ( addr u )
.a21c		a5 2d		lda $2d		                lda scratch
.a21e		c9 20		cmp #$20	                cmp #OpJSR
.a220		d0 15		bne $a237	                bne _not_jsr
.a222		ca		dex		                dex
.a223		ca		dex		                dex
.a224		a9 05		lda #$05	                lda #5
.a226		95 00		sta $00,x	                sta 0,x
.a228		74 01		stz $01,x	                stz 1,x
.a22a		20 cd 91	jsr $91cd	                jsr xt_spaces
.a22d		20 08 a3	jsr $a308	                jsr disasm_special
.a230		b0 70		bcs $a2a2	                bcs _printing_done
.a232		20 e8 a2	jsr $a2e8	                jsr disasm_jsr
.a235		b0 6b		bcs $a2a2	                bcs _printing_done
.a237						_not_jsr:
.a237		c9 4c		cmp #$4c	                cmp #OpJMP
.a239		d0 2d		bne $a268	                bne _not_jmp
.a23b		a5 2e		lda $2e		                lda scratch+1   ; Copy the pointer.
.a23d		85 30		sta $30		                sta scratch+3
.a23f		a5 2f		lda $2f		                lda scratch+2
.a241		85 31		sta $31		                sta scratch+4
.a243		b2 30		lda ($30)	                lda (scratch+3)
.a245		c9 20		cmp #$20	                cmp #OpJSR          ; check for JSR
.a247		d0 59		bne $a2a2	                bne _printing_done
.a249		e6 30		inc $30		                inc scratch+3
.a24b		d0 02		bne $a24f	                bne +
.a24d		e6 31		inc $31		                inc scratch+4
.a24f						+
.a24f		b2 30		lda ($30)	                lda (scratch+3)
.a251		c9 5d		cmp #$5d	                cmp #<sliteral_runtime
.a253		d0 4d		bne $a2a2	                bne _printing_done
.a255		e6 30		inc $30		                inc scratch+3
.a257		d0 02		bne $a25b	                bne +
.a259		e6 31		inc $31		                inc scratch+4
.a25b						+
.a25b		b2 30		lda ($30)	                lda (scratch+3)
.a25d		c9 a1		cmp #$a1	                cmp #>sliteral_runtime
.a25f		d0 41		bne $a2a2	                bne _printing_done
.a261		c6 32		dec $32		                dec scratch+5                   ; flag for next go round
.a263		20 be a2	jsr $a2be	                jsr disasm_sliteral_jump
.a266		80 3a		bra $a2a2	                bra _printing_done
.a268						_not_jmp:
.a268		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.a26a		f0 06		beq $a272	                beq _is_rel
.a26c		29 1f		and #$1f	                and #$1F
.a26e		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.a270		d0 30		bne $a2a2	                bne _printing_done
.a272						_is_rel:
.a272		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.a274		ca		dex		                dex
.a275		ca		dex		                dex
.a276		74 01		stz $01,x	                stz 1,x
.a278		a5 2e		lda $2e		                lda scratch+1
.a27a		95 00		sta $00,x	                sta 0,x
.a27c		10 04		bpl $a282	                bpl +
.a27e		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.a280		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.a282		38		sec		+               sec                 ; start counting from address after opcode
.a283		75 04		adc $04,x	                adc 4,x
.a285		95 00		sta $00,x	                sta 0,x
.a287		b5 01		lda $01,x	                lda 1,x
.a289		75 05		adc $05,x	                adc 5,x
.a28b		95 01		sta $01,x	                sta 1,x
.a28d		5a		phy		                phy                 ; save the direction indicator
.a28e		ca		dex		                dex
.a28f		ca		dex		                dex
.a290		a9 09		lda #$09	                lda #9
.a292		95 00		sta $00,x	                sta 0,x
.a294		74 01		stz $01,x	                stz 1,x
.a296		20 f7 94	jsr $94f7	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.a299		a9 20		lda #$20	                lda #AscSP          ; print space and branch direction indicator
.a29b		20 c5 86	jsr $86c5	                jsr emit_a
.a29e		68		pla		                pla
.a29f		20 c5 86	jsr $86c5	                jsr emit_a
.a2a2						_printing_done:
.a2a2		20 3a 84	jsr $843a	                jsr xt_cr
.a2a5		f6 02		inc $02,x	                inc 2,x
.a2a7		d0 02		bne $a2ab	                bne +
.a2a9		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.a2ab						+
.a2ab		20 d9 8c	jsr $8cd9	                jsr xt_one_minus        ; ( addr+1 u-1 )
.a2ae		b5 00		lda $00,x	                lda 0,x                 ; All done?
.a2b0		15 01		ora $01,x	                ora 1,x
.a2b2		f0 07		beq $a2bb	                beq _done
.a2b4		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.a2b6		30 03		bmi $a2bb	                bmi _done
.a2b8		4c 91 a1	jmp $a191	                jmp _byte_loop          ; out of range for BRA
.a2bb						_done:
.a2bb		4c a3 93	jmp $93a3	                jmp xt_two_drop         ; JSR/RTS
.a2be						disasm_sliteral_jump:
.a2be		20 2a 92	jsr $922a	                jsr xt_swap
.a2c1		ca		dex		                dex
.a2c2		ca		dex		                dex
.a2c3		a5 2e		lda $2e		                lda scratch+1
.a2c5		95 00		sta $00,x	                sta 0,x
.a2c7		a5 2f		lda $2f		                lda scratch+2
.a2c9		95 01		sta $01,x	                sta 1,x
.a2cb		20 2a 92	jsr $922a	                jsr xt_swap
.a2ce		20 e4 8b	jsr $8be4	                jsr xt_minus
.a2d1		20 d9 8c	jsr $8cd9	                jsr xt_one_minus
.a2d4		20 e4 8b	jsr $8be4	                jsr xt_minus
.a2d7		ca		dex		                dex
.a2d8		ca		dex		                dex
.a2d9		a5 2e		lda $2e		                lda scratch+1
.a2db		95 00		sta $00,x	                sta 0,x
.a2dd		a5 2f		lda $2f		                lda scratch+2
.a2df		95 01		sta $01,x	                sta 1,x
.a2e1		20 d9 8c	jsr $8cd9	                jsr xt_one_minus
.a2e4		20 2a 92	jsr $922a	                jsr xt_swap ; ( new_addr new_n )
.a2e7		60		rts		                rts
.a2e8						disasm_jsr:
.a2e8		ca		dex		                dex
.a2e9		ca		dex		                dex
.a2ea		a5 2e		lda $2e		                lda scratch+1
.a2ec		95 00		sta $00,x	                sta 0,x
.a2ee		a5 2f		lda $2f		                lda scratch+2
.a2f0		95 01		sta $01,x	                sta 1,x
.a2f2		20 8f 9b	jsr $9b8f	                jsr xt_int_to_name
.a2f5		b5 00		lda $00,x	                lda 0,x
.a2f7		15 01		ora $01,x	                ora 1,x
.a2f9		f0 08		beq $a303	                beq _no_nt
.a2fb		20 32 9c	jsr $9c32	                jsr xt_name_to_string
.a2fe		20 c0 94	jsr $94c0	                jsr xt_type
.a301		38		sec		                sec
.a302		60		rts		                rts
.a303						_no_nt:
.a303		20 a3 93	jsr $93a3	                jsr xt_two_drop
.a306		18		clc		                clc
.a307		60		rts		                rts
.a308						disasm_special:
.a308		a0 2c		ldy #$2c	                ldy #(_end_handlers - _special_handlers - 4)
.a30a		b9 96 a3	lda $a396,y	_check:         lda _special_handlers,y
.a30d		c5 2e		cmp $2e		                cmp scratch+1
.a30f		d0 07		bne $a318	                bne _next
.a311		b9 97 a3	lda $a397,y	                lda _special_handlers+1,y
.a314		c5 2f		cmp $2f		                cmp scratch+2
.a316		f0 08		beq $a320	                beq _found_handler
.a318		88		dey		_next:          dey
.a319		88		dey		                dey
.a31a		88		dey		                dey
.a31b		88		dey		                dey
.a31c		10 ec		bpl $a30a	                bpl _check
.a31e		18		clc		                clc
.a31f		60		rts		                rts
.a320						_found_handler:
.a320		a5 32		lda $32		                lda scratch+5               ; are we expecting sliteral?
.a322		f0 04		beq $a328	                beq +
.a324		64 32		stz $32		                stz scratch+5               ; yes, skip 2literal and match again
.a326		80 f0		bra $a318	                bra _next
.a328						+
.a328		b9 99 a3	lda $a399,y	                lda _special_handlers+3,y   ; payload + prefix
.a32b		48		pha		                pha                         ; stash a copy for payload later
.a32c		4a		lsr a		                lsr
.a32d		4a		lsr a		                lsr
.a32e		f0 06		beq $a336	                beq _no_prefix
.a330		18		clc		                clc
.a331		69 20		adc #$20	                adc #32
.a333		20 c5 86	jsr $86c5	                jsr emit_a
.a336						_no_prefix:
.a336		b9 98 a3	lda $a398,y	                lda _special_handlers+2,y   ; string index
.a339		20 ad d7	jsr $d7ad	                jsr print_string_no_lf
.a33c		68		pla		                pla
.a33d		29 03		and #$03	                and #3                      ; payload is 0, 1 or 2 words
.a33f		f0 0f		beq $a350	                beq _done
.a341		c9 03		cmp #$03	                cmp #3                      ; but 3 means a double-word
.a343		d0 03		bne $a348	                bne _show_payload
.a345		4c 6a a3	jmp $a36a	                jmp _print_2literal
.a348						_show_payload:
.a348		48		pha		                pha
.a349		20 52 a3	jsr $a352	                jsr _print_literal
.a34c		68		pla		                pla
.a34d		3a		dec a		                dea
.a34e		d0 f8		bne $a348	                bne _show_payload
.a350		38		sec		_done:          sec
.a351		60		rts		                rts
.a352						_print_literal:
.a352		20 2a 92	jsr $922a	                jsr xt_swap ; switch to (u addr)
.a355		20 e5 8c	jsr $8ce5	                jsr xt_one_plus
.a358		20 a0 86	jsr $86a0	                jsr xt_dup
.a35b		20 03 99	jsr $9903	                jsr xt_question ; Print the value at the address
.a35e		20 e5 8c	jsr $8ce5	                jsr xt_one_plus
.a361		20 2a 92	jsr $922a	                jsr xt_swap ; (addr+2 u)
.a364		20 d9 8c	jsr $8cd9	                jsr xt_one_minus
.a367		4c d9 8c	jmp $8cd9	                jmp xt_one_minus ; (addr+2 u-2)
.a36a						_print_2literal:
.a36a		20 2a 92	jsr $922a	                jsr xt_swap
.a36d		20 e5 8c	jsr $8ce5	                jsr xt_one_plus
.a370		20 a0 86	jsr $86a0	                jsr xt_dup
.a373		20 c3 93	jsr $93c3	                jsr xt_two_fetch
.a376		20 2a 92	jsr $922a	                jsr xt_swap             ; 2! / 2@ put MSW first; but 2literal writes LSW first
.a379		20 61 9e	jsr $9e61	                jsr xt_d_dot
.a37c		18		clc		                clc
.a37d		b5 00		lda $00,x	                lda 0,x
.a37f		69 03		adc #$03	                adc #3
.a381		95 00		sta $00,x	                sta 0,x
.a383		90 02		bcc $a387	                bcc +
.a385		f6 01		inc $01,x	                inc 1,x
.a387						+
.a387		20 2a 92	jsr $922a	                jsr xt_swap ; ( addr+4 u )
.a38a		38		sec		                sec
.a38b		b5 00		lda $00,x	                lda 0,x
.a38d		e9 04		sbc #$04	                sbc #4
.a38f		95 00		sta $00,x	                sta 0,x
.a391		b0 02		bcs $a395	                bcs +
.a393		d6 01		dec $01,x	                dec 1,x
.a395						+
.a395		60		rts		                rts
.a396						_special_handlers:
>a396		71 d7				    .word underflow_1
>a398		0c 44				        .byte str_disasm_sdc, 0 + ('1'-32)*4
>a39a		76 d7				    .word underflow_2
>a39c		0c 48				        .byte str_disasm_sdc, 0 + ('2'-32)*4
>a39e		7b d7				    .word underflow_3
>a3a0		0c 4c				        .byte str_disasm_sdc, 0 + ('3'-32)*4
>a3a2		80 d7				    .word underflow_4
>a3a4		0c 50				        .byte str_disasm_sdc, 0 + ('4'-32)*4
>a3a6		3a 8a				    .word literal_runtime
>a3a8		0d 01				        .byte str_disasm_lit, 1
>a3aa		5d a1				    .word sliteral_runtime
>a3ac		0d ce				        .byte str_disasm_lit, 2 + ('S'-32)*4
>a3ae		5d a1				    .word sliteral_runtime                      ; 2literal and sliteral use the same runtime
>a3b0		0d 4b				        .byte str_disasm_lit, 3 + ('2'-32)*4    ; list is searched in reverse, put 2literal first
>a3b2		15 98				    .word zero_branch_runtime
>a3b4		0e 01				        .byte str_disasm_0bra, 1
>a3b6		d2 8a				    .word loop_runtime
>a3b8		0f 01				        .byte str_disasm_loop, 1
>a3ba		eb 8a				    .word plus_loop_runtime
>a3bc		0f 2d				        .byte str_disasm_loop, 1 + ('+'-32)*4
>a3be		bc 85				    .word do_runtime
>a3c0		10 00				        .byte str_disasm_do, 0
>a3c2		a4 85				    .word question_do_runtime
>a3c4		10 7d				        .byte str_disasm_do, 1 + ('?'-32)*4
.a3c6						_end_handlers:
.a3c6						disassembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/assembler.asm

.a3c6						assembler:
.a3c6						xt_asm_adc_h:
.a3c6		a9 69		lda #$69	                lda #$69
.a3c8		4c 21 a7	jmp $a721	                jmp asm_common
.a3cb						z_asm_adc_h:
.a3cb						xt_asm_adc_x:
.a3cb		a9 7d		lda #$7d	                lda #$7D
.a3cd		4c 21 a7	jmp $a721	                jmp asm_common
.a3d0						z_asm_adc_x:
.a3d0						xt_asm_adc_y:
.a3d0		a9 79		lda #$79	                lda #$79
.a3d2		4c 21 a7	jmp $a721	                jmp asm_common
.a3d5						z_asm_adc_y:
.a3d5						xt_asm_adc_z:
.a3d5		a9 65		lda #$65	                lda #$65
.a3d7		4c 21 a7	jmp $a721	                jmp asm_common
.a3da						z_asm_adc_z:
.a3da						xt_asm_adc_zi:
.a3da		a9 72		lda #$72	                lda #$72
.a3dc		4c 21 a7	jmp $a721	                jmp asm_common
.a3df						z_asm_adc_zi:
.a3df						xt_asm_adc_ziy:
.a3df		a9 71		lda #$71	                lda #$71
.a3e1		4c 21 a7	jmp $a721	                jmp asm_common
.a3e4						z_asm_adc_ziy:
.a3e4						xt_asm_adc_zx:
.a3e4		a9 75		lda #$75	                lda #$75
.a3e6		4c 21 a7	jmp $a721	                jmp asm_common
.a3e9						z_asm_adc_zx:
.a3e9						xt_asm_adc_zxi:
.a3e9		a9 61		lda #$61	                lda #$61
.a3eb		4c 21 a7	jmp $a721	                jmp asm_common
.a3ee						z_asm_adc_zxi:
.a3ee						xt_asm_and:
.a3ee		a9 2d		lda #$2d	                lda #$2D
.a3f0		4c 21 a7	jmp $a721	                jmp asm_common
.a3f3						z_asm_and:
.a3f3						xt_asm_and_h:
.a3f3		a9 29		lda #$29	                lda #$29
.a3f5		4c 21 a7	jmp $a721	                jmp asm_common
.a3f8						z_asm_and_h:
.a3f8						xt_asm_and_x:
.a3f8		a9 3d		lda #$3d	                lda #$3D
.a3fa		4c 21 a7	jmp $a721	                jmp asm_common
.a3fd						z_asm_and_x:
.a3fd						xt_asm_and_y:
.a3fd		a9 39		lda #$39	                lda #$39
.a3ff		4c 21 a7	jmp $a721	                jmp asm_common
.a402						z_asm_and_y:
.a402						xt_asm_and_z:
.a402		a9 25		lda #$25	                lda #$25
.a404		4c 21 a7	jmp $a721	                jmp asm_common
.a407						z_asm_and_z:
.a407						xt_asm_and_zi:
.a407		a9 32		lda #$32	                lda #$32
.a409		4c 21 a7	jmp $a721	                jmp asm_common
.a40c						z_asm_and_zi:
.a40c						xt_asm_and_ziy:
.a40c		a9 31		lda #$31	                lda #$31
.a40e		4c 21 a7	jmp $a721	                jmp asm_common
.a411						z_asm_and_ziy:
.a411						xt_asm_and_zx:
.a411		a9 35		lda #$35	                lda #$35
.a413		4c 21 a7	jmp $a721	                jmp asm_common
.a416						z_asm_and_zx:
.a416						xt_asm_and_zxi:
.a416		a9 21		lda #$21	                lda #$21
.a418		4c 21 a7	jmp $a721	                jmp asm_common
.a41b						z_asm_and_zxi:
.a41b						xt_asm_asl:
.a41b		a9 0e		lda #$0e	                lda #$0E
.a41d		4c 21 a7	jmp $a721	                jmp asm_common
.a420						z_asm_asl:
.a420						xt_asm_asl_a:
.a420		a9 0a		lda #$0a	                lda #$0A
.a422		4c 21 a7	jmp $a721	                jmp asm_common
.a425						z_asm_asl_a:
.a425						xt_asm_asl_x:
.a425		a9 1e		lda #$1e	                lda #$1E
.a427		4c 21 a7	jmp $a721	                jmp asm_common
.a42a						z_asm_asl_x:
.a42a						xt_asm_asl_z:
.a42a		a9 06		lda #$06	                lda #$06
.a42c		4c 21 a7	jmp $a721	                jmp asm_common
.a42f						z_asm_asl_z:
.a42f						xt_asm_asl_zx:
.a42f		a9 16		lda #$16	                lda #$16
.a431		4c 21 a7	jmp $a721	                jmp asm_common
.a434						z_asm_asl_zx:
.a434						xt_asm_bcc:
.a434		a9 90		lda #$90	                lda #$90
.a436		4c 21 a7	jmp $a721	                jmp asm_common
.a439						z_asm_bcc:
.a439						xt_asm_bcs:
.a439		a9 b0		lda #$b0	                lda #$B0
.a43b		a0 02		ldy #$02	                ldy #2
.a43d		4c 21 a7	jmp $a721	                jmp asm_common
.a440						z_asm_bcs:
.a440						xt_asm_beq:
.a440		a9 f0		lda #$f0	                lda #$F0
.a442		4c 21 a7	jmp $a721	                jmp asm_common
.a445						z_asm_beq:
.a445						xt_asm_bit:
.a445		a9 2c		lda #$2c	                lda #$2C
.a447		4c 21 a7	jmp $a721	                jmp asm_common
.a44a						z_asm_bit:
.a44a						xt_asm_bit_h:
.a44a		a9 89		lda #$89	                lda #$89
.a44c		4c 21 a7	jmp $a721	                jmp asm_common
.a44f						z_asm_bit_h:
.a44f						xt_asm_bit_x:
.a44f		a9 3c		lda #$3c	                lda #$3C
.a451		4c 21 a7	jmp $a721	                jmp asm_common
.a454						z_asm_bit_x:
.a454						xt_asm_bit_z:
.a454		a9 24		lda #$24	                lda #$24
.a456		4c 21 a7	jmp $a721	                jmp asm_common
.a459						z_asm_bit_z:
.a459						xt_asm_bit_zx:
.a459		a9 34		lda #$34	                lda #$34
.a45b		4c 21 a7	jmp $a721	                jmp asm_common
.a45e						z_asm_bit_zx:
.a45e						xt_asm_bmi:
.a45e		a9 30		lda #$30	                lda #$30
.a460		4c 21 a7	jmp $a721	                jmp asm_common
.a463						z_asm_bmi:
.a463						xt_asm_bne:
.a463		a9 d0		lda #$d0	                lda #$D0
.a465		4c 21 a7	jmp $a721	                jmp asm_common
.a468						z_asm_bne:
.a468						xt_asm_bpl:
.a468		a9 10		lda #$10	                lda #$10
.a46a		4c 21 a7	jmp $a721	                jmp asm_common
.a46d						z_asm_bpl:
.a46d						xt_asm_bra:
.a46d		a9 80		lda #$80	                lda #$80
.a46f		4c 21 a7	jmp $a721	                jmp asm_common
.a472						z_asm_bra:
.a472						xt_asm_brk:
.a472		a9 00		lda #$00	                lda #$00
.a474		4c 21 a7	jmp $a721	                jmp asm_common
.a477						z_asm_brk:
.a477						xt_asm_bvc:
.a477		a9 50		lda #$50	                lda #$50
.a479		4c 21 a7	jmp $a721	                jmp asm_common
.a47c						z_asm_bvc:
.a47c						xt_asm_bvs:
.a47c		a9 70		lda #$70	                lda #$70
.a47e		4c 21 a7	jmp $a721	                jmp asm_common
.a481						z_asm_bvs:
.a481						xt_asm_clc:
.a481		a9 18		lda #$18	                lda #$18
.a483		4c 21 a7	jmp $a721	                jmp asm_common
.a486						z_asm_clc:
.a486						xt_asm_cld:
.a486		a9 d8		lda #$d8	                lda #$D8
.a488		4c 21 a7	jmp $a721	                jmp asm_common
.a48b						z_asm_cld:
.a48b						xt_asm_cli:
.a48b		a9 58		lda #$58	                lda #$58
.a48d		4c 21 a7	jmp $a721	                jmp asm_common
.a490						z_asm_cli:
.a490						xt_asm_clv:
.a490		a9 b8		lda #$b8	                lda #$B8
.a492		4c 21 a7	jmp $a721	                jmp asm_common
.a495						z_asm_clv:
.a495						xt_asm_cmp:
.a495		a9 cd		lda #$cd	                lda #$CD
.a497		4c 21 a7	jmp $a721	                jmp asm_common
.a49a						z_asm_cmp:
.a49a						xt_asm_cmp_h:
.a49a		a9 c9		lda #$c9	                lda #$C9
.a49c		4c 21 a7	jmp $a721	                jmp asm_common
.a49f						z_asm_cmp_h:
.a49f						xt_asm_cmp_x:
.a49f		a9 dd		lda #$dd	                lda #$DD
.a4a1		4c 21 a7	jmp $a721	                jmp asm_common
.a4a4						z_asm_cmp_x:
.a4a4						xt_asm_cmp_y:
.a4a4		a9 d9		lda #$d9	                lda #$D9
.a4a6		4c 21 a7	jmp $a721	                jmp asm_common
.a4a9						z_asm_cmp_y:
.a4a9						xt_asm_cmp_z:
.a4a9		a9 c5		lda #$c5	                lda #$C5
.a4ab		4c 21 a7	jmp $a721	                jmp asm_common
.a4ae						z_asm_cmp_z:
.a4ae						xt_asm_cmp_zi:
.a4ae		a9 d2		lda #$d2	                lda #$D2
.a4b0		4c 21 a7	jmp $a721	                jmp asm_common
.a4b3						z_asm_cmp_zi:
.a4b3						xt_asm_cmp_ziy:
.a4b3		a9 d1		lda #$d1	                lda #$D1
.a4b5		4c 21 a7	jmp $a721	                jmp asm_common
.a4b8						z_asm_cmp_ziy:
.a4b8						xt_asm_cmp_zx:
.a4b8		a9 d5		lda #$d5	                lda #$D5
.a4ba		4c 21 a7	jmp $a721	                jmp asm_common
.a4bd						z_asm_cmp_zx:
.a4bd						xt_asm_cmp_zxi:
.a4bd		a9 c1		lda #$c1	                lda #$C1
.a4bf		4c 21 a7	jmp $a721	                jmp asm_common
.a4c2						z_asm_cmp_zxi:
.a4c2						xt_asm_cpx:
.a4c2		a9 ec		lda #$ec	                lda #$EC
.a4c4		4c 21 a7	jmp $a721	                jmp asm_common
.a4c7						z_asm_cpx:
.a4c7						xt_asm_cpx_h:
.a4c7		a9 e0		lda #$e0	                lda #$E0
.a4c9		4c 21 a7	jmp $a721	                jmp asm_common
.a4cc						z_asm_cpx_h:
.a4cc						xt_asm_cpx_z:
.a4cc		a9 e4		lda #$e4	                lda #$E4
.a4ce		4c 21 a7	jmp $a721	                jmp asm_common
.a4d1						z_asm_cpx_z:
.a4d1						xt_asm_cpy:
.a4d1		a9 cc		lda #$cc	                lda #$CC
.a4d3		a0 03		ldy #$03	                ldy #3
.a4d5		4c 21 a7	jmp $a721	                jmp asm_common
.a4d8						z_asm_cpy:
.a4d8						xt_asm_cpy_h:
.a4d8		a9 c0		lda #$c0	                lda #$C0
.a4da		4c 21 a7	jmp $a721	                jmp asm_common
.a4dd						z_asm_cpy_h:
.a4dd						xt_asm_cpy_z:
.a4dd		a9 c4		lda #$c4	                lda #$C4
.a4df		4c 21 a7	jmp $a721	                jmp asm_common
.a4e2						z_asm_cpy_z:
.a4e2						xt_asm_dec:
.a4e2		a9 ce		lda #$ce	                lda #$CE
.a4e4		4c 21 a7	jmp $a721	                jmp asm_common
.a4e7						z_asm_dec:
.a4e7						xt_asm_dec_a:
.a4e7		a9 3a		lda #$3a	                lda #$3A
.a4e9		4c 21 a7	jmp $a721	                jmp asm_common
.a4ec						z_asm_dec_a:
.a4ec						xt_asm_dec_x:
.a4ec		a9 de		lda #$de	                lda #$DE
.a4ee		4c 21 a7	jmp $a721	                jmp asm_common
.a4f1						z_asm_dec_x:
.a4f1						xt_asm_dec_z:
.a4f1		a9 c6		lda #$c6	                lda #$C6
.a4f3		4c 21 a7	jmp $a721	                jmp asm_common
.a4f6						z_asm_dec_z:
.a4f6						xt_asm_dec_zx:
.a4f6		a9 d6		lda #$d6	                lda #$D6
.a4f8		4c 21 a7	jmp $a721	                jmp asm_common
.a4fb						z_asm_dec_zx:
.a4fb						xt_asm_dex:
.a4fb		a9 ca		lda #$ca	                lda #$CA
.a4fd		4c 21 a7	jmp $a721	                jmp asm_common
.a500						z_asm_dex:
.a500						xt_asm_dey:
.a500		a9 88		lda #$88	                lda #$88
.a502		4c 21 a7	jmp $a721	                jmp asm_common
.a505						z_asm_dey:
.a505						xt_asm_eor:
.a505		a9 4d		lda #$4d	                lda #$4D
.a507		4c 21 a7	jmp $a721	                jmp asm_common
.a50a						z_asm_eor:
.a50a						xt_asm_eor_h:
.a50a		a9 49		lda #$49	                lda #$49
.a50c		4c 21 a7	jmp $a721	                jmp asm_common
.a50f						z_asm_eor_h:
.a50f						xt_asm_eor_x:
.a50f		a9 5d		lda #$5d	                lda #$5D
.a511		4c 21 a7	jmp $a721	                jmp asm_common
.a514						z_asm_eor_x:
.a514						xt_asm_eor_y:
.a514		a9 59		lda #$59	                lda #$59
.a516		4c 21 a7	jmp $a721	                jmp asm_common
.a519						z_asm_eor_y:
.a519						xt_asm_eor_z:
.a519		a9 45		lda #$45	                lda #$45
.a51b		4c 21 a7	jmp $a721	                jmp asm_common
.a51e						z_asm_eor_z:
.a51e						xt_asm_eor_zi:
.a51e		a9 52		lda #$52	                lda #$52
.a520		4c 21 a7	jmp $a721	                jmp asm_common
.a523						z_asm_eor_zi:
.a523						xt_asm_eor_ziy:
.a523		a9 51		lda #$51	                lda #$51
.a525		4c 21 a7	jmp $a721	                jmp asm_common
.a528						z_asm_eor_ziy:
.a528						xt_asm_eor_zx:
.a528		a9 55		lda #$55	                lda #$55
.a52a		4c 21 a7	jmp $a721	                jmp asm_common
.a52d						z_asm_eor_zx:
.a52d						xt_asm_eor_zxi:
.a52d		a9 41		lda #$41	                lda #$41
.a52f		4c 21 a7	jmp $a721	                jmp asm_common
.a532						z_asm_eor_zxi:
.a532						xt_asm_inc:
.a532		a9 ee		lda #$ee	                lda #$EE
.a534		4c 21 a7	jmp $a721	                jmp asm_common
.a537						z_asm_inc:
.a537						xt_asm_inc_a:
.a537		a9 1a		lda #$1a	                lda #$1A
.a539		4c 21 a7	jmp $a721	                jmp asm_common
.a53c						z_asm_inc_a:
.a53c						xt_asm_inc_x:
.a53c		a9 fe		lda #$fe	                lda #$FE
.a53e		4c 21 a7	jmp $a721	                jmp asm_common
.a541						z_asm_inc_x:
.a541						xt_asm_inc_z:
.a541		a9 e6		lda #$e6	                lda #$E6
.a543		4c 21 a7	jmp $a721	                jmp asm_common
.a546						z_asm_inc_z:
.a546						xt_asm_inc_zx:
.a546		a9 f6		lda #$f6	                lda #$F6
.a548		4c 21 a7	jmp $a721	                jmp asm_common
.a54b						z_asm_inc_zx:
.a54b						xt_asm_inx:
.a54b		a9 e8		lda #$e8	                lda #$E8
.a54d		4c 21 a7	jmp $a721	                jmp asm_common
.a550						z_asm_inx:
.a550						xt_asm_iny:
.a550		a9 c8		lda #$c8	                lda #$C8
.a552		4c 21 a7	jmp $a721	                jmp asm_common
.a555						z_asm_iny:
.a555						xt_asm_jmp:
.a555		a9 4c		lda #$4c	                lda #$4C
.a557		4c 21 a7	jmp $a721	                jmp asm_common
.a55a						z_asm_jmp:
.a55a						xt_asm_jmp_i:
.a55a		a9 6c		lda #$6c	                lda #$6C
.a55c		4c 21 a7	jmp $a721	                jmp asm_common
.a55f						z_asm_jmp_i:
.a55f						xt_asm_jmp_xi:
.a55f		a9 7c		lda #$7c	                lda #$7C
.a561		4c 21 a7	jmp $a721	                jmp asm_common
.a564						z_asm_jmp_xi:
.a564						xt_asm_jsr:
.a564		a9 20		lda #$20	                lda #$20
.a566		4c 21 a7	jmp $a721	                jmp asm_common
.a569						z_asm_jsr:
.a569						xt_asm_lda:
.a569		a9 ad		lda #$ad	                lda #$AD
.a56b		4c 21 a7	jmp $a721	                jmp asm_common
.a56e						z_asm_lda:
.a56e						xt_asm_lda_h:
.a56e		a9 a9		lda #$a9	                lda #$A9
.a570		4c 21 a7	jmp $a721	                jmp asm_common
.a573						z_asm_lda_h:
.a573						xt_asm_lda_x:
.a573		a9 bd		lda #$bd	                lda #$BD
.a575		4c 21 a7	jmp $a721	                jmp asm_common
.a578						z_asm_lda_x:
.a578						xt_asm_lda_y:
.a578		a9 b9		lda #$b9	                lda #$B9
.a57a		4c 21 a7	jmp $a721	                jmp asm_common
.a57d						z_asm_lda_y:
.a57d						xt_asm_lda_z:
.a57d		a9 a5		lda #$a5	                lda #$A5
.a57f		4c 21 a7	jmp $a721	                jmp asm_common
.a582						z_asm_lda_z:
.a582						xt_asm_lda_zi:
.a582		a9 b2		lda #$b2	                lda #$B2
.a584		4c 21 a7	jmp $a721	                jmp asm_common
.a587						z_asm_lda_zi:
.a587						xt_asm_lda_ziy:
.a587		a9 b1		lda #$b1	                lda #$B1
.a589		4c 21 a7	jmp $a721	                jmp asm_common
.a58c						z_asm_lda_ziy:
.a58c						xt_asm_lda_zx:
.a58c		a9 b5		lda #$b5	                lda #$B5
.a58e		4c 21 a7	jmp $a721	                jmp asm_common
.a591						z_asm_lda_zx:
.a591						xt_asm_lda_zxi:
.a591		a9 a1		lda #$a1	                lda #$A1
.a593		4c 21 a7	jmp $a721	                jmp asm_common
.a596						z_asm_lda_zxi:
.a596						xt_asm_ldx:
.a596		a9 ae		lda #$ae	                lda #$AE
.a598		4c 21 a7	jmp $a721	                jmp asm_common
.a59b						z_asm_ldx:
.a59b						xt_asm_ldx_h:
.a59b		a9 a2		lda #$a2	                lda #$A2
.a59d		4c 21 a7	jmp $a721	                jmp asm_common
.a5a0						z_asm_ldx_h:
.a5a0						xt_asm_ldx_y:
.a5a0		a9 be		lda #$be	                lda #$BE
.a5a2		4c 21 a7	jmp $a721	                jmp asm_common
.a5a5						z_asm_ldx_y:
.a5a5						xt_asm_ldx_z:
.a5a5		a9 a6		lda #$a6	                lda #$A6
.a5a7		4c 21 a7	jmp $a721	                jmp asm_common
.a5aa						z_asm_ldx_z:
.a5aa						xt_asm_ldx_zy:
.a5aa		a9 b6		lda #$b6	                lda #$B6
.a5ac		4c 21 a7	jmp $a721	                jmp asm_common
.a5af						z_asm_ldx_zy:
.a5af						xt_asm_ldy:
.a5af		a9 ac		lda #$ac	                lda #$AC
.a5b1		4c 21 a7	jmp $a721	                jmp asm_common
.a5b4						z_asm_ldy:
.a5b4						xt_asm_ldy_h:
.a5b4		a9 a0		lda #$a0	                lda #$A0
.a5b6		4c 21 a7	jmp $a721	                jmp asm_common
.a5b9						z_asm_ldy_h:
.a5b9						xt_asm_ldy_x:
.a5b9		a9 bc		lda #$bc	                lda #$BC
.a5bb		4c 21 a7	jmp $a721	                jmp asm_common
.a5be						z_asm_ldy_x:
.a5be						xt_asm_ldy_z:
.a5be		a9 a4		lda #$a4	                lda #$A4
.a5c0		4c 21 a7	jmp $a721	                jmp asm_common
.a5c3						z_asm_ldy_z:
.a5c3						xt_asm_ldy_zx:
.a5c3		a9 b4		lda #$b4	                lda #$B4
.a5c5		4c 21 a7	jmp $a721	                jmp asm_common
.a5c8						z_asm_ldy_zx:
.a5c8						xt_asm_lsr:
.a5c8		a9 4e		lda #$4e	                lda #$4E
.a5ca		4c 21 a7	jmp $a721	                jmp asm_common
.a5cd						z_asm_lsr:
.a5cd						xt_asm_lsr_a:
.a5cd		a9 4a		lda #$4a	                lda #$4A
.a5cf		4c 21 a7	jmp $a721	                jmp asm_common
.a5d2						z_asm_lsr_a:
.a5d2						xt_asm_lsr_x:
.a5d2		a9 5e		lda #$5e	                lda #$5E
.a5d4		4c 21 a7	jmp $a721	                jmp asm_common
.a5d7						z_asm_lsr_x:
.a5d7						xt_asm_lsr_z:
.a5d7		a9 46		lda #$46	                lda #$46
.a5d9		4c 21 a7	jmp $a721	                jmp asm_common
.a5dc						z_asm_lsr_z:
.a5dc						xt_asm_lsr_zx:
.a5dc		a9 56		lda #$56	                lda #$56
.a5de		4c 21 a7	jmp $a721	                jmp asm_common
.a5e1						z_asm_lsr_zx:
.a5e1						xt_asm_nop:
.a5e1		a9 ea		lda #$ea	                lda #$EA
.a5e3		4c 21 a7	jmp $a721	                jmp asm_common
.a5e6						z_asm_nop:
.a5e6						xt_asm_ora:
.a5e6		a9 0d		lda #$0d	                lda #$0D
.a5e8		4c 21 a7	jmp $a721	                jmp asm_common
.a5eb						z_asm_ora:
.a5eb						xt_asm_ora_h:
.a5eb		a9 09		lda #$09	                lda #$09
.a5ed		4c 21 a7	jmp $a721	                jmp asm_common
.a5f0						z_asm_ora_h:
.a5f0						xt_asm_ora_x:
.a5f0		a9 1d		lda #$1d	                lda #$1D
.a5f2		4c 21 a7	jmp $a721	                jmp asm_common
.a5f5						z_asm_ora_x:
.a5f5						xt_asm_ora_y:
.a5f5		a9 19		lda #$19	                lda #$19
.a5f7		4c 21 a7	jmp $a721	                jmp asm_common
.a5fa						z_asm_ora_y:
.a5fa						xt_asm_ora_z:
.a5fa		a9 05		lda #$05	                lda #$05
.a5fc		4c 21 a7	jmp $a721	                jmp asm_common
.a5ff						z_asm_ora_z:
.a5ff						xt_asm_ora_zi:
.a5ff		a9 12		lda #$12	                lda #$12
.a601		a0 02		ldy #$02	                ldy #2
.a603		4c 21 a7	jmp $a721	                jmp asm_common
.a606						z_asm_ora_zi:
.a606						xt_asm_ora_ziy:
.a606		a9 11		lda #$11	                lda #$11
.a608		4c 21 a7	jmp $a721	                jmp asm_common
.a60b						z_asm_ora_ziy:
.a60b						xt_asm_ora_zx:
.a60b		a9 15		lda #$15	                lda #$15
.a60d		4c 21 a7	jmp $a721	                jmp asm_common
.a610						z_asm_ora_zx:
.a610						xt_asm_ora_zxi:
.a610		a9 01		lda #$01	                lda #$01
.a612		4c 21 a7	jmp $a721	                jmp asm_common
.a615						z_asm_ora_zxi:
.a615						xt_asm_pha:
.a615		a9 48		lda #$48	                lda #$48
.a617		4c 21 a7	jmp $a721	                jmp asm_common
.a61a						z_asm_pha:
.a61a						xt_asm_php:
.a61a		a9 08		lda #$08	                lda #$08
.a61c		4c 21 a7	jmp $a721	                jmp asm_common
.a61f						z_asm_php:
.a61f						xt_asm_phx:
.a61f		a9 da		lda #$da	                lda #$DA
.a621		4c 21 a7	jmp $a721	                jmp asm_common
.a624						z_asm_phx:
.a624						xt_asm_phy:
.a624		a9 5a		lda #$5a	                lda #$5A
.a626		4c 21 a7	jmp $a721	                jmp asm_common
.a629						z_asm_phy:
.a629						xt_asm_pla:
.a629		a9 68		lda #$68	                lda #$68
.a62b		4c 21 a7	jmp $a721	                jmp asm_common
.a62e						z_asm_pla:
.a62e						xt_asm_plp:
.a62e		a9 28		lda #$28	                lda #$28
.a630		4c 21 a7	jmp $a721	                jmp asm_common
.a633						z_asm_plp:
.a633						xt_asm_plx:
.a633		a9 fa		lda #$fa	                lda #$FA
.a635		4c 21 a7	jmp $a721	                jmp asm_common
.a638						z_asm_plx:
.a638						xt_asm_ply:
.a638		a9 7a		lda #$7a	                lda #$7A
.a63a		4c 21 a7	jmp $a721	                jmp asm_common
.a63d						z_asm_ply:
.a63d						xt_asm_rol:
.a63d		a9 2e		lda #$2e	                lda #$2E
.a63f		4c 21 a7	jmp $a721	                jmp asm_common
.a642						z_asm_rol:
.a642						xt_asm_rol_a:
.a642		a9 2a		lda #$2a	                lda #$2A
.a644		4c 21 a7	jmp $a721	                jmp asm_common
.a647						z_asm_rol_a:
.a647						xt_asm_rol_x:
.a647		a9 3e		lda #$3e	                lda #$3E
.a649		4c 21 a7	jmp $a721	                jmp asm_common
.a64c						z_asm_rol_x:
.a64c						xt_asm_rol_z:
.a64c		a9 26		lda #$26	                lda #$26
.a64e		4c 21 a7	jmp $a721	                jmp asm_common
.a651						z_asm_rol_z:
.a651						xt_asm_rol_zx:
.a651		a9 36		lda #$36	                lda #$36
.a653		4c 21 a7	jmp $a721	                jmp asm_common
.a656						z_asm_rol_zx:
.a656						xt_asm_ror:
.a656		a9 6e		lda #$6e	                lda #$6E
.a658		4c 21 a7	jmp $a721	                jmp asm_common
.a65b						z_asm_ror:
.a65b						xt_asm_ror_a:
.a65b		a9 6a		lda #$6a	                lda #$6A
.a65d		4c 21 a7	jmp $a721	                jmp asm_common
.a660						z_asm_ror_a:
.a660						xt_asm_ror_x:
.a660		a9 7e		lda #$7e	                lda #$7E
.a662		4c 21 a7	jmp $a721	                jmp asm_common
.a665						z_asm_ror_x:
.a665						xt_asm_ror_z:
.a665		a9 66		lda #$66	                lda #$66
.a667		4c 21 a7	jmp $a721	                jmp asm_common
.a66a						z_asm_ror_z:
.a66a						xt_asm_ror_zx:
.a66a		a9 76		lda #$76	                lda #$76
.a66c		4c 21 a7	jmp $a721	                jmp asm_common
.a66f						z_asm_ror_zx:
.a66f						xt_asm_rti:
.a66f		a9 40		lda #$40	                lda #$40
.a671		4c 21 a7	jmp $a721	                jmp asm_common
.a674						z_asm_rti:
.a674						xt_asm_rts:
.a674		a9 60		lda #$60	                lda #$60
.a676		4c 21 a7	jmp $a721	                jmp asm_common
.a679						z_asm_rts:
.a679						xt_asm_sbc:
.a679		a9 ed		lda #$ed	                lda #$ED
.a67b		4c 21 a7	jmp $a721	                jmp asm_common
.a67e						z_asm_sbc:
.a67e						xt_asm_sbc_h:
.a67e		a9 e9		lda #$e9	                lda #$E9
.a680		4c 21 a7	jmp $a721	                jmp asm_common
.a683						z_asm_sbc_h:
.a683						xt_asm_sbc_x:
.a683		a9 fd		lda #$fd	                lda #$FD
.a685		4c 21 a7	jmp $a721	                jmp asm_common
.a688						z_asm_sbc_x:
.a688						xt_asm_sbc_y:
.a688		a9 f9		lda #$f9	                lda #$F9
.a68a		4c 21 a7	jmp $a721	                jmp asm_common
.a68d						z_asm_sbc_y:
.a68d						xt_asm_sbc_z:
.a68d		a9 e5		lda #$e5	                lda #$E5
.a68f		4c 21 a7	jmp $a721	                jmp asm_common
.a692						z_asm_sbc_z:
.a692						xt_asm_sbc_zi:
.a692		a9 f2		lda #$f2	                lda #$F2
.a694		4c 21 a7	jmp $a721	                jmp asm_common
.a697						z_asm_sbc_zi:
.a697						xt_asm_sbc_ziy:
.a697		a9 f1		lda #$f1	                lda #$F1
.a699		4c 21 a7	jmp $a721	                jmp asm_common
.a69c						z_asm_sbc_ziy:
.a69c						xt_asm_sbc_zx:
.a69c		a9 f5		lda #$f5	                lda #$F5
.a69e		4c 21 a7	jmp $a721	                jmp asm_common
.a6a1						z_asm_sbc_zx:
.a6a1						xt_asm_sbc_zxi:
.a6a1		a9 e1		lda #$e1	                lda #$E1
.a6a3		80 7c		bra $a721	                bra asm_common  ; <-- limit for BRA instead of JMP
.a6a5						z_asm_sbc_zxi:
.a6a5						xt_asm_sec:
.a6a5		a9 38		lda #$38	                lda #$38
.a6a7		80 78		bra $a721	                bra asm_common
.a6a9						z_asm_sec:
.a6a9						xt_asm_sed:
.a6a9		a9 f8		lda #$f8	                lda #$F8
.a6ab		80 74		bra $a721	                bra asm_common
.a6ad						z_asm_sed:
.a6ad						xt_asm_sei:
.a6ad		a9 78		lda #$78	                lda #$78
.a6af		80 70		bra $a721	                bra asm_common
.a6b1						z_asm_sei:
.a6b1						xt_asm_sta:
.a6b1		a9 8d		lda #$8d	                lda #$8D
.a6b3		80 6c		bra $a721	                bra asm_common
.a6b5						z_asm_sta:
.a6b5						xt_asm_sta_x:
.a6b5		a9 9d		lda #$9d	                lda #$9D
.a6b7		80 68		bra $a721	                bra asm_common
.a6b9						z_asm_sta_x:
.a6b9						xt_asm_sta_y:
.a6b9		a9 99		lda #$99	                lda #$99
.a6bb		80 64		bra $a721	                bra asm_common
.a6bd						z_asm_sta_y:
.a6bd						xt_asm_sta_z:
.a6bd		a9 85		lda #$85	                lda #$85
.a6bf		80 60		bra $a721	                bra asm_common
.a6c1						z_asm_sta_z:
.a6c1						xt_asm_sta_zi:
.a6c1		a9 92		lda #$92	                lda #$92
.a6c3		80 5c		bra $a721	                bra asm_common
.a6c5						z_asm_sta_zi:
.a6c5						xt_asm_sta_ziy:
.a6c5		a9 91		lda #$91	                lda #$91
.a6c7		80 58		bra $a721	                bra asm_common
.a6c9						z_asm_sta_ziy:
.a6c9						xt_asm_sta_zx:
.a6c9		a9 95		lda #$95	                lda #$95
.a6cb		80 54		bra $a721	                bra asm_common
.a6cd						z_asm_sta_zx:
.a6cd						xt_asm_sta_zxi:
.a6cd		a9 81		lda #$81	                lda #$81
.a6cf		80 50		bra $a721	                bra asm_common
.a6d1						z_asm_sta_zxi:
.a6d1						xt_asm_stx:
.a6d1		a9 8e		lda #$8e	                lda #$8E
.a6d3		80 4c		bra $a721	                bra asm_common
.a6d5						z_asm_stx:
.a6d5						xt_asm_stx_z:
.a6d5		a9 86		lda #$86	                lda #$86
.a6d7		80 48		bra $a721	                bra asm_common
.a6d9						z_asm_stx_z:
.a6d9						xt_asm_stx_zy:
.a6d9		a9 96		lda #$96	                lda #$96
.a6db		80 44		bra $a721	                bra asm_common
.a6dd						z_asm_stx_zy:
.a6dd						xt_asm_sty:
.a6dd		a9 8c		lda #$8c	                lda #$8C
.a6df		80 40		bra $a721	                bra asm_common
.a6e1						z_asm_sty:
.a6e1						xt_asm_sty_z:
.a6e1		a9 84		lda #$84	                lda #$84
.a6e3		80 3c		bra $a721	                bra asm_common
.a6e5						z_asm_sty_z:
.a6e5						xt_asm_sty_zx:
.a6e5		a9 94		lda #$94	                lda #$94
.a6e7		80 38		bra $a721	                bra asm_common
.a6e9						z_asm_sty_zx:
.a6e9						xt_asm_stz:
.a6e9		a9 9c		lda #$9c	                lda #$9C
.a6eb		80 34		bra $a721	                bra asm_common
.a6ed						z_asm_stz:
.a6ed						xt_asm_stz_x:
.a6ed		a9 9e		lda #$9e	                lda #$9E
.a6ef		80 30		bra $a721	                bra asm_common
.a6f1						z_asm_stz_x:
.a6f1						xt_asm_stz_z:
.a6f1		a9 64		lda #$64	                lda #$64
.a6f3		80 2c		bra $a721	                bra asm_common
.a6f5						z_asm_stz_z:
.a6f5						xt_asm_stz_zx:
.a6f5		a9 74		lda #$74	                lda #$74
.a6f7		80 28		bra $a721	                bra asm_common
.a6f9						z_asm_stz_zx:
.a6f9						xt_asm_tax:
.a6f9		a9 aa		lda #$aa	                lda #$AA
.a6fb		80 24		bra $a721	                bra asm_common
.a6fd						z_asm_tax:
.a6fd						xt_asm_tay:
.a6fd		a9 a8		lda #$a8	                lda #$A8
.a6ff		80 20		bra $a721	                bra asm_common
.a701						z_asm_tay:
.a701						xt_asm_trb:
.a701		a9 1c		lda #$1c	                lda #$1C
.a703		80 1c		bra $a721	                bra asm_common
.a705						z_asm_trb:
.a705						xt_asm_trb_z:
.a705		a9 14		lda #$14	                lda #$14
.a707		80 18		bra $a721	                bra asm_common
.a709						z_asm_trb_z:
.a709						xt_asm_tsb:
.a709		a9 0c		lda #$0c	                lda #$0C
.a70b		80 14		bra $a721	                bra asm_common
.a70d						z_asm_tsb:
.a70d						xt_asm_tsb_z:
.a70d		a9 04		lda #$04	                lda #$04
.a70f		80 10		bra $a721	                bra asm_common
.a711						z_asm_tsb_z:
.a711						xt_asm_tsx:
.a711		a9 ba		lda #$ba	                lda #$BA
.a713		80 0c		bra $a721	                bra asm_common
.a715						z_asm_tsx:
.a715						xt_asm_txa:
.a715		a9 8a		lda #$8a	                lda #$8A
.a717		80 08		bra $a721	                bra asm_common
.a719						z_asm_txa:
.a719						xt_asm_txs:
.a719		a9 9a		lda #$9a	                lda #$9A
.a71b		80 04		bra $a721	                bra asm_common
.a71d						z_asm_txs:
.a71d						xt_asm_tya:
.a71d		a9 98		lda #$98	                lda #$98
.a71f		80 00		bra $a721	                bra asm_common
.a721						z_asm_tya:
.a721						asm_common:
.a721		a8		tay		                tay
.a722		20 71 97	jsr $9771	                jsr cmpl_a
.a725		a9 94		lda #$94	                lda #<oc_index_table
.a727		85 27		sta $27		                sta tmp2
.a729		a9 b3		lda #$b3	                lda #>oc_index_table
.a72b		85 28		sta $28		                sta tmp2+1
.a72d		98		tya		                tya             ; retrieve opcode
.a72e		0a		asl a		                asl             ; times two for offset
.a72f		90 02		bcc $a733	                bcc +
.a731		e6 28		inc $28		                inc tmp2+1
.a733						+
.a733		a8		tay		                tay             ; use Y as the index
.a734		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a736		85 29		sta $29		                sta tmp3
.a738		c8		iny		                iny
.a739		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a73b		85 2a		sta $2a		                sta tmp3+1
.a73d		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.a73f		2a		rol a		                rol
.a740		2a		rol a		                rol
.a741		2a		rol a		                rol             ; Three times because we go through Carry
.a742		29 03		and #$03	                and #%00000011
.a744		a8		tay		                tay
.a745		88		dey		                dey
.a746		f0 12		beq $a75a	                beq _done
.a748		20 71 d7	jsr $d771	                jsr underflow_1
.a74b		b5 00		lda $00,x	                lda 0,x
.a74d		20 71 97	jsr $9771	                jsr cmpl_a      ; does not use Y
.a750		88		dey		                dey
.a751		f0 05		beq $a758	                beq _done_drop
.a753		b5 01		lda $01,x	                lda 1,x
.a755		20 71 97	jsr $9771	                jsr cmpl_a      ; Fall through to _done_drop
.a758						_done_drop:
.a758		e8		inx		                inx
.a759		e8		inx		                inx             ; Fall through to _done
.a75a						_done:
.a75a		60		rts		                rts             ; Returns to original caller
.a75b						xt_asm_push_a:
.a75b		a0 00		ldy #$00	                ldy #0
.a75d						_loop:
.a75d		b9 6b a7	lda $a76b,y	                lda asm_push_a_data,y
.a760		c9 ff		cmp #$ff	                cmp #$FF
.a762		f0 06		beq $a76a	                beq _done
.a764		20 71 97	jsr $9771	                jsr cmpl_a      ; does not change Y
.a767		c8		iny		                iny
.a768		80 f3		bra $a75d	                bra _loop
.a76a						_done:
.a76a						z_asm_push_a:
.a76a		60		rts		                rts
.a76b						asm_push_a_data:
>a76b		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>a771		ff				        .byte $FF               ; terminator
.a772						xt_asm_back_jump:
.a772						z_asm_back_jump:
.a772		60		rts		                rts
.a773						xt_asm_back_branch:
.a773		20 1b 89	jsr $891b	                jsr xt_here             ; ( addr-l addr-h )
.a776		20 e4 8b	jsr $8be4	                jsr xt_minus            ; ( offset )
.a779		3a		dec a		                dea
.a77a		3a		dec a		                dea
.a77b						z_asm_back_branch:
.a77b		60		rts		                rts
.a77c						assembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/ed.asm

.a77c						xt_ed:
.a77c		20 80 a7	jsr $a780	                jsr ed6502      ; kept in separate file
.a77f		60		rts		z_ed:           rts
=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.a780						ed6502:
.a780		a5 18		lda $18		                lda base
.a782		85 3a		sta $3a		                sta ed_base
.a784		a9 0a		lda #$0a	                lda #10
.a786		85 18		sta $18		                sta base
.a788		64 35		stz $35		                stz ed_head
.a78a		64 36		stz $36		                stz ed_head+1
.a78c		64 37		stz $37		                stz ed_cur
.a78e		64 38		stz $38		                stz ed_cur+1
.a790		64 39		stz $39		                stz ed_flags
.a792		20 d8 9d	jsr $9dd8	                jsr xt_zero
.a795		20 d8 9d	jsr $9dd8	                jsr xt_zero             ; ( addr-t u-t )
.a798		20 3a 84	jsr $843a	                jsr xt_cr
.a79b						ed_input_loop:
.a79b		a9 81		lda #$81	                lda #%10000001
.a79d		14 39		trb $39		                trb ed_flags
.a79f		20 7a ac	jsr $ac7a	                jsr ed_get_input
.a7a2		a5 0e		lda $0e		                lda ciblen
.a7a4		d0 1f		bne $a7c5	                bne _command_mode
.a7a6		ca		dex		                dex
.a7a7		ca		dex		                dex                     ; ( addr-t u-t ? )
.a7a8		a5 37		lda $37		                lda ed_cur
.a7aa		95 00		sta $00,x	                sta 0,x
.a7ac		a5 38		lda $38		                lda ed_cur+1
.a7ae		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.a7b0		a9 80		lda #$80	                lda #%10000000
.a7b2		04 39		tsb $39		                tsb ed_flags
.a7b4		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.a7b7		20 96 ac	jsr $ac96	                jsr ed_is_valid_line
.a7ba		b0 03		bcs $a7bf	                bcs +
.a7bc		4c 6a ac	jmp $ac6a	                jmp ed_error_1drop
.a7bf						+
.a7bf		20 d8 9d	jsr $9dd8	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.a7c2		4c 90 a8	jmp $a890	                jmp _line_number_only_from_external
.a7c5						_command_mode:
.a7c5		20 d8 9d	jsr $9dd8	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.a7c8		20 d8 9d	jsr $9dd8	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.a7cb		b2 0c		lda ($0c)	                lda (cib)
.a7cd		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.a7cf		d0 3a		bne $a80b	                bne _prefix_dollar
.a7d1		20 8b ac	jsr $ac8b	                jsr ed_have_text
.a7d4		a5 37		lda $37		                lda ed_cur
.a7d6		95 02		sta $02,x	                sta 2,x
.a7d8		a5 38		lda $38		                lda ed_cur+1
.a7da		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a7dc		a9 80		lda #$80	                lda #%10000000
.a7de		04 39		tsb $39		                tsb ed_flags
.a7e0		a5 0e		lda $0e		                lda ciblen
.a7e2		3a		dec a		                dea                     ; sets Z if A was 1
.a7e3		d0 03		bne $a7e8	                bne +
.a7e5		4c 90 a8	jmp $a890	                jmp _line_number_only_from_external
.a7e8						+
.a7e8		ca		dex		                dex
.a7e9		ca		dex		                dex
.a7ea		ca		dex		                dex
.a7eb		ca		dex		                dex
.a7ec		a5 0c		lda $0c		                lda cib
.a7ee		95 02		sta $02,x	                sta 2,x
.a7f0		a5 0d		lda $0d		                lda cib+1
.a7f2		95 03		sta $03,x	                sta 3,x
.a7f4		a5 0e		lda $0e		                lda ciblen
.a7f6		95 00		sta $00,x	                sta 0,x
.a7f8		a5 0f		lda $0f		                lda ciblen+1
.a7fa		95 01		sta $01,x	                sta 1,x
.a7fc		20 d9 8c	jsr $8cd9	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.a7ff		20 2a 92	jsr $922a	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.a802		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.a805		20 2a 92	jsr $922a	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.a808		4c e8 a8	jmp $a8e8	                jmp _check_for_para2
.a80b						_prefix_dollar:
.a80b		b2 0c		lda ($0c)	                lda (cib)
.a80d		c9 24		cmp #$24	                cmp #'$'
.a80f		d0 1c		bne $a82d	                bne _prefix_percent
.a811		20 8b ac	jsr $ac8b	                jsr ed_have_text
.a814		e8		inx		                inx
.a815		e8		inx		                inx                     ; ( addr-t u-t 0 )
.a816		20 b8 ac	jsr $acb8	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.a819		20 2a 92	jsr $922a	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.a81c		a9 80		lda #$80	                lda #%10000000
.a81e		04 39		tsb $39		                tsb ed_flags
.a820		a5 0e		lda $0e		                lda ciblen
.a822		3a		dec a		                dea                     ; sets Z if A was 1
.a823		d0 03		bne $a828	                bne +
.a825		4c 90 a8	jmp $a890	                jmp _line_number_only_from_external
.a828						+
.a828		a0 01		ldy #$01	                ldy #01
.a82a		4c 64 a9	jmp $a964	                jmp _check_command
.a82d						_prefix_percent:
.a82d		b2 0c		lda ($0c)	                lda (cib)
.a82f		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.a831		f0 04		beq $a837	                beq _whole_text
.a833		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.a835		d0 17		bne $a84e	                bne _prefix_semicolon
.a837						_whole_text:
.a837		20 8b ac	jsr $ac8b	                jsr ed_have_text
.a83a		a9 01		lda #$01	                lda #01
.a83c		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.a83e		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.a840						_semicolon_entry:
.a840		e8		inx		                inx
.a841		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.a842		20 b8 ac	jsr $acb8	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a845		a9 80		lda #$80	                lda #%10000000
.a847		04 39		tsb $39		                tsb ed_flags
.a849		a0 01		ldy #$01	                ldy #01
.a84b		4c 64 a9	jmp $a964	                jmp _check_command
.a84e						_prefix_semicolon:
.a84e		b2 0c		lda ($0c)	                lda (cib)
.a850		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.a852		d0 0d		bne $a861	                bne _prefix_number
.a854		20 8b ac	jsr $ac8b	                jsr ed_have_text
.a857		a5 37		lda $37		                lda ed_cur
.a859		95 02		sta $02,x	                sta 2,x
.a85b		a5 38		lda $38		                lda ed_cur+1
.a85d		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a85f		80 df		bra $a840	                bra _semicolon_entry
.a861						_prefix_number:
.a861		20 d8 9d	jsr $9dd8	                jsr xt_zero
.a864		20 d8 9d	jsr $9dd8	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.a867		ca		dex		                dex
.a868		ca		dex		                dex
.a869		ca		dex		                dex
.a86a		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.a86b		a5 0c		lda $0c		                lda cib
.a86d		95 02		sta $02,x	                sta 2,x
.a86f		a5 0d		lda $0d		                lda cib+1
.a871		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.a873		a5 0e		lda $0e		                lda ciblen
.a875		95 00		sta $00,x	                sta 0,x
.a877		a5 0f		lda $0f		                lda ciblen+1
.a879		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.a87b		20 c8 92	jsr $92c8	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.a87e		b5 00		lda $00,x	                lda 0,x
.a880		15 01		ora $01,x	                ora 1,x
.a882		d0 24		bne $a8a8	                bne _have_unconverted_chars
.a884		e8		inx		                inx
.a885		e8		inx		                inx
.a886		e8		inx		                inx
.a887		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.a888		20 21 9e	jsr $9e21	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.a88b		20 5c 9c	jsr $9c5c	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.a88e		e8		inx		                inx
.a88f		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.a890						_line_number_only_from_external:
.a890		20 2a 92	jsr $922a	                jsr xt_swap             ; ( addr-t u-t 0 u )
.a893		20 96 ac	jsr $ac96	                jsr ed_is_valid_line
.a896		b0 03		bcs $a89b	                bcs +
.a898		4c 68 ac	jmp $ac68	                jmp ed_error_2drop
.a89b						+
.a89b		20 2a 92	jsr $922a	                jsr xt_swap             ; ( addr-t u-t u 0 )
.a89e		20 25 ad	jsr $ad25	                jsr ed_para1_to_cur
.a8a1		a9 80		lda #$80	                lda #%10000000
.a8a3		04 39		tsb $39		                tsb ed_flags
.a8a5		4c 43 ab	jmp $ab43	                jmp ed_cmd_p_from_external
.a8a8						_have_unconverted_chars:
.a8a8		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.a8ab		ca		dex		                dex
.a8ac		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.a8ad		a5 0e		lda $0e		                lda ciblen
.a8af		95 00		sta $00,x	                sta 0,x
.a8b1		a5 0f		lda $0f		                lda ciblen+1
.a8b3		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.a8b5		20 96 87	jsr $8796	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.a8b8		b5 00		lda $00,x	                lda 0,x
.a8ba		15 01		ora $01,x	                ora 1,x
.a8bc		f0 0e		beq $a8cc	                beq _no_command_yet
.a8be		8a		txa		                txa
.a8bf		18		clc		                clc
.a8c0		69 0a		adc #$0a	                adc #10
.a8c2		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.a8c3		a9 80		lda #$80	                lda #%10000000
.a8c5		14 39		trb $39		                trb ed_flags
.a8c7		a0 00		ldy #$00	                ldy #00
.a8c9		4c 64 a9	jmp $a964	                jmp _check_command
.a8cc						_no_command_yet:
.a8cc		e8		inx		                inx
.a8cd		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.a8ce		20 68 93	jsr $9368	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.a8d1		20 5c 9c	jsr $9c5c	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.a8d4		20 21 9e	jsr $9e21	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.a8d7		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a8d9		95 06		sta $06,x	                sta 6,x
.a8db		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a8dd		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.a8df		e8		inx		                inx
.a8e0		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.a8e1		20 ec 8e	jsr $8eec	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.a8e4		a9 80		lda #$80	                lda #%10000000
.a8e6		04 39		tsb $39		                tsb ed_flags
.a8e8						_check_for_para2:
.a8e8		a1 02		lda ($02,x)	                lda (2,x)
.a8ea		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.a8ec		f0 0d		beq $a8fb	                beq _got_comma
.a8ee		38		sec		                sec
.a8ef		a5 0e		lda $0e		                lda ciblen
.a8f1		f5 00		sbc $00,x	                sbc 0,x
.a8f3		a8		tay		                tay
.a8f4		e8		inx		                inx
.a8f5		e8		inx		                inx
.a8f6		e8		inx		                inx
.a8f7		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.a8f8		4c 64 a9	jmp $a964	                jmp _check_command
.a8fb						_got_comma:
.a8fb		f6 02		inc $02,x	                inc 2,x
.a8fd		d0 02		bne $a901	                bne +
.a8ff		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.a901						+
.a901		b5 01		lda $01,x	                lda 1,x
.a903		f0 02		beq $a907	                beq +
.a905		d6 01		dec $01,x	                dec 1,x
.a907						+
.a907		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.a909		a1 02		lda ($02,x)	                lda (2,x)
.a90b		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.a90d		d0 14		bne $a923	                bne _para2_not_dollar
.a90f		38		sec		                sec
.a910		a5 0e		lda $0e		                lda ciblen
.a912		f5 02		sbc $02,x	                sbc 2,x
.a914		a8		tay		                tay
.a915		c8		iny		                iny
.a916		5a		phy		                phy
.a917		8a		txa		                txa
.a918		18		clc		                clc
.a919		69 06		adc #$06	                adc #06
.a91b		aa		tax		                tax                     ; ( addr-t u-t para1 )
.a91c		20 b8 ac	jsr $acb8	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a91f		7a		ply		                ply
.a920		4c 64 a9	jmp $a964	                jmp _check_command
.a923						_para2_not_dollar:
.a923		20 68 93	jsr $9368	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.a926		20 d8 9d	jsr $9dd8	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.a929		20 d8 9d	jsr $9dd8	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.a92c		20 8d 8f	jsr $8f8d	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.a92f		20 ec 8e	jsr $8eec	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.a932		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.a935		20 68 93	jsr $9368	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.a938		20 c8 92	jsr $92c8	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.a93b		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.a93e		20 ec 8e	jsr $8eec	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.a941		20 96 87	jsr $8796	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.a944		b5 00		lda $00,x	                lda 0,x
.a946		15 01		ora $01,x	                ora 1,x
.a948		f0 08		beq $a952	                beq _second_number
.a94a		8a		txa		                txa
.a94b		18		clc		                clc
.a94c		69 0c		adc #$0c	                adc #12
.a94e		aa		tax		                tax                     ; back to ( addr-t u-t )
.a94f		4c 6c ac	jmp $ac6c	                jmp ed_error
.a952						_second_number:
.a952		e8		inx		                inx
.a953		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.a954		38		sec		                sec
.a955		a5 0e		lda $0e		                lda ciblen
.a957		f5 00		sbc $00,x	                sbc 0,x
.a959		48		pha		                pha
.a95a		20 a3 93	jsr $93a3	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.a95d		20 21 9e	jsr $9e21	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.a960		20 30 8c	jsr $8c30	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.a963		7a		ply		                ply
.a964						_check_command:
.a964		24 39		bit $39		                bit ed_flags
.a966		30 08		bmi $a970	                bmi _check_command_have_arg
.a968		a5 37		lda $37		                lda ed_cur
.a96a		95 02		sta $02,x	                sta 2,x
.a96c		a5 38		lda $38		                lda ed_cur+1
.a96e		95 03		sta $03,x	                sta 3,x
.a970						_check_command_have_arg:
.a970		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.a972		85 25		sta $25		                sta tmp1
.a974		da		phx		                phx
.a975		a2 00		ldx #$00	                ldx #00
.a977						_cmd_loop:
.a977		bd 50 ad	lda $ad50,x	                lda ed_cmd_list,x
.a97a		f0 07		beq $a983	                beq _illegal_command    ; zero marks end of list
.a97c		c5 25		cmp $25		                cmp tmp1
.a97e		f0 07		beq $a987	                beq _found_cmd
.a980		e8		inx		                inx
.a981		80 f4		bra $a977	                bra _cmd_loop
.a983						_illegal_command:
.a983		fa		plx		                plx
.a984		4c 68 ac	jmp $ac68	                jmp ed_error_2drop
.a987						_found_cmd:
.a987		8a		txa		                txa
.a988		0a		asl a		                asl
.a989		aa		tax		                tax                     ; X * 2 for table
.a98a		7c 5b ad	jmp ($ad5b,x)	                jmp (ed_cmd_table,x)
.a98d						ed_next_command:
.a98d		e8		inx		                inx
.a98e		e8		inx		                inx
.a98f		e8		inx		                inx
.a990		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.a991		4c 9b a7	jmp $a79b	                jmp ed_input_loop
.a994						ed_all_done:
.a994		64 0e		stz $0e		                stz ciblen
.a996		64 0f		stz $0f		                stz ciblen+1
.a998		20 a3 93	jsr $93a3	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.a99b		a5 3a		lda $3a		                lda ed_base
.a99d		85 18		sta $18		                sta base
.a99f		60		rts		                rts
.a9a0						ed_cmd_a:
.a9a0		fa		plx		                plx
.a9a1		e8		inx		                inx
.a9a2		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.a9a3						ed_entry_cmd_i:
.a9a3		20 ee ac	jsr $acee	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.a9a6		20 3a 84	jsr $843a	                jsr xt_cr
.a9a9						_next_string_loop:
.a9a9		20 7a ac	jsr $ac7a	                jsr ed_get_input
.a9ac		b2 0c		lda ($0c)	                lda (cib)
.a9ae		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.a9b0		d0 16		bne $a9c8	                bne _add_line
.a9b2		a4 0e		ldy $0e		                ldy ciblen
.a9b4		c0 01		cpy #$01	                cpy #01
.a9b6		d0 10		bne $a9c8	                bne _add_line
.a9b8		a4 0f		ldy $0f		                ldy ciblen+1
.a9ba		d0 0c		bne $a9c8	                bne _add_line
.a9bc		e8		inx		                inx
.a9bd		e8		inx		                inx
.a9be		a9 40		lda #$40	                lda #%01000000
.a9c0		04 39		tsb $39		                tsb ed_flags
.a9c2		20 3a 84	jsr $843a	                jsr xt_cr
.a9c5		4c 9b a7	jmp $a79b	                jmp ed_input_loop
.a9c8						_add_line:
.a9c8		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.a9cb		20 1b 89	jsr $891b	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.a9ce		20 2a 92	jsr $922a	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.a9d1		20 1a 88	jsr $881a	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.a9d4		20 cd 83	jsr $83cd	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.a9d7		20 89 93	jsr $9389	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.a9da		20 2a 92	jsr $922a	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.a9dd		20 14 92	jsr $9214	                jsr xt_store            ; ! ( addr-t u-t here )
.a9e0		20 1b 89	jsr $891b	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.a9e3		a5 00		lda $00		                lda cp
.a9e5		18		clc		                clc
.a9e6		69 04		adc #$04	                adc #04
.a9e8		85 00		sta $00		                sta cp
.a9ea		90 02		bcc $a9ee	                bcc +
.a9ec		e6 01		inc $01		                inc cp+1
.a9ee						+
.a9ee		e6 37		inc $37		                inc ed_cur
.a9f0		d0 02		bne $a9f4	                bne +
.a9f2		e6 38		inc $38		                inc ed_cur+1
.a9f4						+
.a9f4		20 1b 89	jsr $891b	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.a9f7		20 a0 86	jsr $86a0	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.a9fa		ca		dex		                dex
.a9fb		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.a9fc		a5 0c		lda $0c		                lda cib
.a9fe		95 00		sta $00,x	                sta 0,x
.aa00		a5 0d		lda $0d		                lda cib+1
.aa02		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.aa04		20 2a 92	jsr $922a	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.aa07		ca		dex		                dex
.aa08		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.aa09		a5 0e		lda $0e		                lda ciblen
.aa0b		95 00		sta $00,x	                sta 0,x
.aa0d		a5 0f		lda $0f		                lda ciblen+1
.aa0f		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.aa11		20 00 8c	jsr $8c00	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.aa14		18		clc		                clc
.aa15		a5 00		lda $00		                lda cp
.aa17		65 0e		adc $0e		                adc ciblen
.aa19		85 00		sta $00		                sta cp
.aa1b		90 06		bcc $aa23	                bcc +
.aa1d		a5 01		lda $01		                lda cp+1
.aa1f		65 0f		adc $0f		                adc ciblen+1
.aa21		85 01		sta $01		                sta cp+1
.aa23						+
.aa23		20 01 8d	jsr $8d01	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.aa26		20 14 92	jsr $9214	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.aa29		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; 1+
.aa2c		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.aa2f		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.aa32		a5 0e		lda $0e		                lda ciblen
.aa34		95 02		sta $02,x	                sta 2,x
.aa36		a5 0f		lda $0f		                lda ciblen+1
.aa38		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.aa3a		20 14 92	jsr $9214	                jsr xt_store            ; ! ( addr-t u-t here )
.aa3d		20 3a 84	jsr $843a	                jsr xt_cr
.aa40		4c a9 a9	jmp $a9a9	                jmp _next_string_loop
.aa43						ed_cmd_d:
.aa43		fa		plx		                plx
.aa44		20 8b ac	jsr $ac8b	                jsr ed_have_text
.aa47		20 e0 ac	jsr $ace0	                jsr ed_no_line_zero
.aa4a		b5 00		lda $00,x	                lda 0,x
.aa4c		15 01		ora $01,x	                ora 1,x
.aa4e		d0 08		bne $aa58	                bne +
.aa50		20 01 8d	jsr $8d01	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.aa53		20 95 aa	jsr $aa95	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.aa56		80 33		bra $aa8b	                bra _cmd_d_done
.aa58						+
.aa58		20 96 ac	jsr $ac96	                jsr ed_is_valid_line      ; result is in C flag
.aa5b		b0 03		bcs $aa60	                bcs _cmd_d_loop
.aa5d		4c 68 ac	jmp $ac68	                jmp ed_error_2drop
.aa60						_cmd_d_loop:
.aa60		20 ab 93	jsr $93ab	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.aa63		20 06 89	jsr $8906	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.aa66		b5 00		lda $00,x	                lda 0,x
.aa68		15 01		ora $01,x	                ora 1,x
.aa6a		d0 0d		bne $aa79	                bne _cmd_d_done_with_flag
.aa6c		e8		inx		                inx
.aa6d		e8		inx		                inx                     ; Get rid of the flag from >
.aa6e		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.aa71		20 95 aa	jsr $aa95	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.aa74		20 d9 8c	jsr $8cd9	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.aa77		80 e7		bra $aa60	                bra _cmd_d_loop
.aa79						_cmd_d_done_with_flag:
.aa79		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.aa7a		e8		inx		                inx
.aa7b		b5 02		lda $02,x	                lda 2,x
.aa7d		d0 02		bne $aa81	                bne +
.aa7f		d6 03		dec $03,x	                dec 3,x
.aa81						+
.aa81		d6 02		dec $02,x	                dec 2,x
.aa83		b5 02		lda $02,x	                lda 2,x
.aa85		85 37		sta $37		                sta ed_cur
.aa87		b5 03		lda $03,x	                lda 3,x
.aa89		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.aa8b						_cmd_d_done:
.aa8b		a9 40		lda #$40	                lda #%01000000
.aa8d		04 39		tsb $39		                tsb ed_flags
.aa8f		20 3a 84	jsr $843a	                jsr xt_cr
.aa92		4c 8d a9	jmp $a98d	                jmp ed_next_command
.aa95						_cmd_d_common:
.aa95		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.aa98		20 ee ac	jsr $acee	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.aa9b		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.aa9e		20 2a 92	jsr $922a	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.aaa1		20 d9 8c	jsr $8cd9	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.aaa4		20 ee ac	jsr $acee	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.aaa7		20 14 92	jsr $9214	                jsr xt_store            ; ! ( addr-t u-t )
.aaaa		60		rts		                rts
.aaab						ed_cmd_equ:
.aaab		fa		plx		                plx
.aaac		a5 35		lda $35		                lda ed_head
.aaae		05 36		ora $36		                ora ed_head+1
.aab0		d0 08		bne $aaba	                bne _cmd_equ_have_text
.aab2		ca		dex		                dex
.aab3		ca		dex		                dex
.aab4		74 00		stz $00,x	                stz 0,x
.aab6		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.aab8		80 21		bra $aadb	                bra _cmd_equ_done
.aaba						_cmd_equ_have_text:
.aaba		20 e0 ac	jsr $ace0	                jsr ed_no_line_zero
.aabd		24 39		bit $39		                bit ed_flags
.aabf		30 0c		bmi $aacd	                bmi _cmd_equ_have_para
.aac1		ca		dex		                dex
.aac2		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.aac3		a5 37		lda $37		                lda ed_cur
.aac5		95 00		sta $00,x	                sta 0,x
.aac7		a5 38		lda $38		                lda ed_cur+1
.aac9		95 01		sta $01,x	                sta 1,x
.aacb		80 0e		bra $aadb	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.aacd						_cmd_equ_have_para:
.aacd		b5 00		lda $00,x	                lda 0,x
.aacf		15 01		ora $01,x	                ora 1,x
.aad1		d0 05		bne $aad8	                bne _cmd_equ_two_paras
.aad3		20 01 8d	jsr $8d01	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.aad6		80 03		bra $aadb	                bra _cmd_equ_done
.aad8						_cmd_equ_two_paras:
.aad8		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.aadb						_cmd_equ_done:
.aadb		20 3a 84	jsr $843a	                jsr xt_cr               ; number goes on new line
.aade		20 eb 94	jsr $94eb	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.aae1		20 3a 84	jsr $843a	                jsr xt_cr
.aae4		4c 8d a9	jmp $a98d	                jmp ed_next_command
.aae7						ed_cmd_f:
.aae7		fa		plx		                plx
.aae8		24 39		bit $39		                bit ed_flags
.aaea		30 17		bmi $ab03	                bmi _cmd_f_have_para
.aaec		20 3a 84	jsr $843a	                jsr xt_cr
.aaef		20 68 93	jsr $9368	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.aaf2		20 8d 8f	jsr $8f8d	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.aaf5		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.aaf8		20 eb 94	jsr $94eb	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.aafb		20 5c 9c	jsr $9c5c	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.aafe		20 ec 8e	jsr $8eec	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.ab01		80 11		bra $ab14	                bra _cmd_f_done
.ab03						_cmd_f_have_para:
.ab03		20 01 8d	jsr $8d01	                jsr xt_over
.ab06		20 3a 84	jsr $843a	                jsr xt_cr
.ab09		20 eb 94	jsr $94eb	                jsr xt_u_dot
.ab0c		b5 02		lda $02,x	                lda 2,x
.ab0e		95 06		sta $06,x	                sta 6,x
.ab10		b5 03		lda $03,x	                lda 3,x
.ab12		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.ab14						_cmd_f_done:
.ab14		20 3a 84	jsr $843a	                jsr xt_cr
.ab17		4c 8d a9	jmp $a98d	                jmp ed_next_command
.ab1a						ed_cmd_i:
.ab1a		fa		plx		                plx
.ab1b		e8		inx		                inx
.ab1c		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.ab1d		24 39		bit $39		                bit ed_flags
.ab1f		30 08		bmi $ab29	                bmi _cmd_i_have_para
.ab21		a5 37		lda $37		                lda ed_cur
.ab23		95 00		sta $00,x	                sta 0,x
.ab25		a5 38		lda $38		                lda ed_cur+1
.ab27		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.ab29						_cmd_i_have_para:
.ab29		b5 00		lda $00,x	                lda 0,x
.ab2b		15 01		ora $01,x	                ora 1,x
.ab2d		f0 09		beq $ab38	                beq _cmd_i_done
.ab2f		20 d9 8c	jsr $8cd9	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.ab32		20 d8 9d	jsr $9dd8	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.ab35		20 ac 8b	jsr $8bac	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.ab38						_cmd_i_done:
.ab38		4c a3 a9	jmp $a9a3	                jmp ed_entry_cmd_i
.ab3b						ed_cmd_n:
.ab3b		fa		plx		                plx
.ab3c		a9 01		lda #$01	                lda #%00000001
.ab3e		04 39		tsb $39		                tsb ed_flags
.ab40		80 05		bra $ab47	                bra ed_cmd_p_entry_for_cmd_n
.ab42						ed_cmd_p:
.ab42		fa		plx		                plx
.ab43						ed_cmd_p_from_external:
.ab43		a9 01		lda #$01	                lda #%00000001
.ab45		14 39		trb $39		                trb ed_flags
.ab47						ed_cmd_p_entry_for_cmd_n:
.ab47		20 8b ac	jsr $ac8b	                jsr ed_have_text
.ab4a		20 e0 ac	jsr $ace0	                jsr ed_no_line_zero
.ab4d		20 3a 84	jsr $843a	                jsr xt_cr
.ab50		b5 00		lda $00,x	                lda 0,x
.ab52		15 01		ora $01,x	                ora 1,x
.ab54		d0 10		bne $ab66	                bne _cmd_p_loop
.ab56		b5 02		lda $02,x	                lda 2,x
.ab58		85 37		sta $37		                sta ed_cur
.ab5a		b5 03		lda $03,x	                lda 3,x
.ab5c		85 38		sta $38		                sta ed_cur+1
.ab5e		20 01 8d	jsr $8d01	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.ab61		20 8f ab	jsr $ab8f	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ab64		80 26		bra $ab8c	                bra _cmd_p_all_done
.ab66						_cmd_p_loop:
.ab66		20 ab 93	jsr $93ab	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ab69		20 06 89	jsr $8906	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.ab6c		b5 00		lda $00,x	                lda 0,x
.ab6e		15 01		ora $01,x	                ora 1,x
.ab70		d0 10		bne $ab82	                bne _cmd_p_done
.ab72		e8		inx		                inx
.ab73		e8		inx		                inx                     ; Get rid of the flag from >
.ab74		20 01 8d	jsr $8d01	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.ab77		20 8f ab	jsr $ab8f	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ab7a		f6 02		inc $02,x	                inc 2,x
.ab7c		d0 02		bne $ab80	                bne +
.ab7e		f6 03		inc $03,x	                inc 3,x
.ab80						+
.ab80		80 e4		bra $ab66	                bra _cmd_p_loop
.ab82						_cmd_p_done:
.ab82		e8		inx		                inx
.ab83		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.ab84		b5 00		lda $00,x	                lda 0,x
.ab86		85 37		sta $37		                sta ed_cur
.ab88		b5 01		lda $01,x	                lda 1,x
.ab8a		85 38		sta $38		                sta ed_cur+1
.ab8c						_cmd_p_all_done:
.ab8c		4c 8d a9	jmp $a98d	                jmp ed_next_command
.ab8f						_cmd_p_common:
.ab8f		a5 39		lda $39		                lda ed_flags
.ab91		4a		lsr a		                lsr                     ; bit 0 now in carry
.ab92		90 0b		bcc $ab9f	                bcc _cmd_p_common_no_num
.ab94		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.ab97		20 eb 94	jsr $94eb	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.ab9a		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.ab9c		20 c5 86	jsr $86c5	                jsr emit_a
.ab9f						_cmd_p_common_no_num:
.ab9f		20 ee ac	jsr $acee	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.aba2		20 2e ad	jsr $ad2e	                jsr ed_print_addr
.aba5		60		rts		                rts
.aba6						ed_cmd_q:
.aba6		fa		plx		                plx
.aba7		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.aba9		50 03		bvc $abae	                bvc +
.abab		4c 68 ac	jmp $ac68	                jmp ed_error_2drop
.abae						+
.abae		4c 94 a9	jmp $a994	                jmp ed_all_done            ; can't fall thru because of PLX
.abb1						ed_cmd_qq:
.abb1		fa		plx		                plx
.abb2		4c 94 a9	jmp $a994	                jmp ed_all_done
.abb5						ed_cmd_w:
.abb5		fa		plx		                plx
.abb6		20 8b ac	jsr $ac8b	                jsr ed_have_text
.abb9		24 39		bit $39		                bit ed_flags
.abbb		30 13		bmi $abd0	                bmi _cmd_w_have_para
.abbd		b5 06		lda $06,x	                lda 6,x
.abbf		15 07		ora $07,x	                ora 7,x
.abc1		d0 03		bne $abc6	                bne +
.abc3		4c 68 ac	jmp $ac68	                jmp ed_error_2drop
.abc6						+
.abc6		b5 06		lda $06,x	                lda 6,x
.abc8		95 02		sta $02,x	                sta 2,x
.abca		b5 07		lda $07,x	                lda 7,x
.abcc		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.abce		80 08		bra $abd8	                bra _cmd_w_para_ready
.abd0						_cmd_w_have_para:
.abd0		b5 02		lda $02,x	                lda 2,x
.abd2		95 06		sta $06,x	                sta 6,x
.abd4		b5 03		lda $03,x	                lda 3,x
.abd6		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.abd8						_cmd_w_para_ready:
.abd8		a9 35		lda #$35	                lda #<ed_head
.abda		95 00		sta $00,x	                sta 0,x
.abdc		a9 00		lda #$00	                lda #>ed_head
.abde		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.abe0		20 01 8d	jsr $8d01	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.abe3		20 68 93	jsr $9368	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.abe6						_cmd_w_loop:
.abe6		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.abe9		b5 00		lda $00,x	                lda 0,x
.abeb		15 01		ora $01,x	                ora 1,x
.abed		f0 55		beq $ac44	                beq _cmd_w_eol
.abef		20 ab 93	jsr $93ab	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.abf2		20 a0 94	jsr $94a0	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.abf5		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.abf8		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.abfb		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.abfe		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ac01		20 2a 92	jsr $922a	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ac04		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ac07		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ac0a		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ac0d		20 5c 9c	jsr $9c5c	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ac10		20 2a 92	jsr $922a	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ac13		20 8d 8f	jsr $8f8d	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ac16		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ac19		20 68 93	jsr $9368	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ac1c		20 00 8c	jsr $8c00	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ac1f		20 ec 8e	jsr $8eec	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ac22		20 26 94	jsr $9426	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ac25		20 5c 9c	jsr $9c5c	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ac28		20 4f 8e	jsr $8e4f	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ac2b		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ac2e		ca		dex		                dex
.ac2f		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ac30		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ac32		95 00		sta $00,x	                sta 0,x
.ac34		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ac36		20 2a 92	jsr $922a	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ac39		20 14 92	jsr $9214	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ac3c		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ac3f		20 2a 92	jsr $922a	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ac42		80 a2		bra $abe6	                bra _cmd_w_loop
.ac44						_cmd_w_eol:
.ac44		20 2a 92	jsr $922a	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ac47		20 ec 8e	jsr $8eec	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ac4a		20 e4 8b	jsr $8be4	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ac4d		b5 00		lda $00,x	                lda 0,x
.ac4f		95 04		sta $04,x	                sta 4,x
.ac51		b5 01		lda $01,x	                lda 1,x
.ac53		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ac55		20 3a 84	jsr $843a	                jsr xt_cr
.ac58		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ac5b		20 eb 94	jsr $94eb	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ac5e		20 3a 84	jsr $843a	                jsr xt_cr
.ac61		a9 40		lda #$40	                lda #%01000000
.ac63		14 39		trb $39		                trb ed_flags
.ac65		4c 8d a9	jmp $a98d	                jmp ed_next_command
.ac68						ed_error_2drop:
.ac68		e8		inx		                inx
.ac69		e8		inx		                inx                     ; drop through to _error_1drop
.ac6a						ed_error_1drop:
.ac6a		e8		inx		                inx
.ac6b		e8		inx		                inx                     ; drop through to _error
.ac6c						ed_error:
.ac6c		20 3a 84	jsr $843a	                jsr xt_cr
.ac6f		a9 3f		lda #$3f	                lda #'?'
.ac71		20 c5 86	jsr $86c5	                jsr emit_a
.ac74		20 3a 84	jsr $843a	                jsr xt_cr
.ac77		4c 9b a7	jmp $a79b	                jmp ed_input_loop
.ac7a						ed_get_input:
.ac7a		20 3e 8f	jsr $8f3e	                jsr xt_refill           ;  ( addr-t u-t f )
.ac7d		b5 00		lda $00,x	                lda 0,x
.ac7f		15 01		ora $01,x	                ora 1,x
.ac81		d0 05		bne $ac88	                bne +
.ac83		7a		ply		                ply
.ac84		7a		ply		                ply
.ac85		4c 6a ac	jmp $ac6a	                jmp ed_error_1drop
.ac88						+
.ac88		e8		inx		                inx
.ac89		e8		inx		                inx
.ac8a		60		rts		                rts
.ac8b						ed_have_text:
.ac8b		a5 35		lda $35		                lda ed_head
.ac8d		05 36		ora $36		                ora ed_head+1
.ac8f		d0 04		bne $ac95	                bne +
.ac91		7a		ply		                ply
.ac92		7a		ply		                ply
.ac93		80 d7		bra $ac6c	                bra ed_error
.ac95						+
.ac95		60		rts		                rts
.ac96						ed_is_valid_line:
.ac96		38		sec		                sec                             ; default is legal line number
.ac97		b5 00		lda $00,x	                lda 0,x
.ac99		15 01		ora $01,x	                ora 1,x
.ac9b		f0 19		beq $acb6	                beq _is_valid_line_nope_zero    ; ( n )
.ac9d		20 a0 86	jsr $86a0	                jsr xt_dup                      ; DUP ( n n )
.aca0		20 b8 ac	jsr $acb8	                jsr ed_last_line                  ; ( n n last )
.aca3		20 2a 92	jsr $922a	                jsr xt_swap                     ; SWAP ( n last n )
.aca6		20 dd 89	jsr $89dd	                jsr xt_less_than                ; < ( n f )
.aca9		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.acab		15 01		ora $01,x	                ora 1,x
.acad		d0 05		bne $acb4	                bne _is_valid_line_too_small
.acaf		e8		inx		                inx
.acb0		e8		inx		                inx                     ; DROP flag ( n )
.acb1		38		sec		                sec                     ; Who knows what's happened to C by now
.acb2		80 03		bra $acb7	                bra _is_valid_line_done ; only one exit from this routine
.acb4						_is_valid_line_too_small:
.acb4		e8		inx		                inx
.acb5		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.acb6						_is_valid_line_nope_zero:
.acb6		18		clc		                clc                     ; drop through to _is_valid_line_done
.acb7						_is_valid_line_done:
.acb7		60		rts		                rts
.acb8						ed_last_line:
.acb8		64 25		stz $25		                stz tmp1
.acba		64 26		stz $26		                stz tmp1+1
.acbc		ca		dex		                dex
.acbd		ca		dex		                dex                     ; ( ? )
.acbe		a9 35		lda #$35	                lda #<ed_head
.acc0		95 00		sta $00,x	                sta 0,x
.acc2		a9 00		lda #$00	                lda #>ed_head
.acc4		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.acc6						_last_line_loop:
.acc6		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( addr | 0 )
.acc9		b5 00		lda $00,x	                lda 0,x
.accb		15 01		ora $01,x	                ora 1,x
.accd		f0 08		beq $acd7	                beq _last_line_done
.accf		e6 25		inc $25		                inc tmp1
.acd1		d0 02		bne $acd5	                bne +
.acd3		e6 26		inc $26		                inc tmp1+1
.acd5						+
.acd5		80 ef		bra $acc6	                bra _last_line_loop
.acd7						_last_line_done:
.acd7		a5 25		lda $25		                lda tmp1
.acd9		95 00		sta $00,x	                sta 0,x
.acdb		a5 26		lda $26		                lda tmp1+1
.acdd		95 01		sta $01,x	                sta 1,x                 ; ( u )
.acdf		60		rts		                rts
.ace0						ed_no_line_zero:
.ace0		b5 02		lda $02,x	                lda 2,x
.ace2		15 03		ora $03,x	                ora 3,x
.ace4		d0 07		bne $aced	                bne _no_line_zero_done
.ace6		24 39		bit $39		                bit ed_flags
.ace8		10 03		bpl $aced	                bpl _no_line_zero_done
.acea		4c 68 ac	jmp $ac68	                jmp ed_error_2drop
.aced						_no_line_zero_done:
.aced		60		rts		                rts
.acee						ed_num_to_addr:
.acee		ca		dex		                dex
.acef		ca		dex		                dex                     ; ( u ? )
.acf0		a9 35		lda #$35	                lda #<ed_head
.acf2		95 00		sta $00,x	                sta 0,x
.acf4		a9 00		lda #$00	                lda #>ed_head
.acf6		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.acf8		b5 02		lda $02,x	                lda 2,x
.acfa		15 03		ora $03,x	                ora 3,x
.acfc		d0 05		bne $ad03	                bne _num_to_addr_loop
.acfe		20 30 8c	jsr $8c30	                jsr xt_nip              ; ( addr-h )
.ad01		80 21		bra $ad24	                bra _num_to_addr_done
.ad03						_num_to_addr_loop:
.ad03		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( u addr1 )
.ad06		b5 00		lda $00,x	                lda 0,x
.ad08		15 01		ora $01,x	                ora 1,x
.ad0a		d0 05		bne $ad11	                bne +
.ad0c		20 30 8c	jsr $8c30	                jsr xt_nip              ; NIP ( addr1 )
.ad0f		80 13		bra $ad24	                bra _num_to_addr_done
.ad11						+
.ad11		20 2a 92	jsr $922a	                jsr xt_swap             ; SWAP ( addr1 u )
.ad14		20 d9 8c	jsr $8cd9	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.ad17		b5 00		lda $00,x	                lda 0,x
.ad19		15 01		ora $01,x	                ora 1,x
.ad1b		f0 05		beq $ad22	                beq _num_to_addr_finished
.ad1d		20 2a 92	jsr $922a	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.ad20		80 e1		bra $ad03	                bra _num_to_addr_loop
.ad22						_num_to_addr_finished:
.ad22		e8		inx		                inx
.ad23		e8		inx		                inx                     ; ( addr )
.ad24						_num_to_addr_done:
.ad24		60		rts		                rts
.ad25						ed_para1_to_cur:
.ad25		b5 02		lda $02,x	                lda 2,x
.ad27		85 37		sta $37		                sta ed_cur
.ad29		b5 03		lda $03,x	                lda 3,x
.ad2b		85 38		sta $38		                sta ed_cur+1
.ad2d		60		rts		                rts
.ad2e						ed_print_addr:
.ad2e		20 e5 8c	jsr $8ce5	                jsr xt_one_plus
.ad31		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; ( addr+2 )
.ad34		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr+2 addr+2 )
.ad37		20 e5 8c	jsr $8ce5	                jsr xt_one_plus
.ad3a		20 e5 8c	jsr $8ce5	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.ad3d		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( addr+2 u-s )
.ad40		20 2a 92	jsr $922a	                jsr xt_swap             ; ( u-s addr+2 )
.ad43		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( u-s addr-s )
.ad46		20 2a 92	jsr $922a	                jsr xt_swap             ; ( addr-s u-s )
.ad49		20 c0 94	jsr $94c0	                jsr xt_type
.ad4c		20 3a 84	jsr $843a	                jsr xt_cr
.ad4f		60		rts		                rts
>ad50		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>ad58		71 51 00
.ad5b						ed_cmd_table:
>ad5b		a0 a9 e7 aa 1a ab 43 aa		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>ad63		42 ab 3b ab
>ad67		ab aa b5 ab a6 ab b1 ab		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ad6f						ed6502_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/block.asm

.ad6f						xt_blk:
.ad6f		a9 04		lda #$04	                lda #blk_offset
.ad71		4c 2d d6	jmp $d62d	                jmp push_upvar_tos
.ad74						z_blk:
.ad74						xt_blkbuffer:
.ad74		ca		dex		                dex
.ad75		ca		dex		                dex
.ad76		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ad78		b1 08		lda ($08),y	                lda (up),y
.ad7a		95 00		sta $00,x	                sta 0,x
.ad7c		c8		iny		                iny             ; Move along to the next byte
.ad7d		b1 08		lda ($08),y	                lda (up),y
.ad7f		95 01		sta $01,x	                sta 1,x
.ad81		60		rts		z_blkbuffer:    rts
.ad82						xt_block:
.ad82		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ad84		b1 08		lda ($08),y	                lda (up),y
.ad86		d5 00		cmp $00,x	                cmp 0,x
.ad88		d0 0f		bne $ad99	                bne _not_in_buffer
.ad8a		c8		iny		                iny
.ad8b		b1 08		lda ($08),y	                lda (up),y
.ad8d		d5 01		cmp $01,x	                cmp 1,x
.ad8f		d0 08		bne $ad99	                bne _not_in_buffer
.ad91		a0 30		ldy #$30	                ldy #buffstatus_offset
.ad93		b1 08		lda ($08),y	                lda (up),y
.ad95		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.ad97		d0 30		bne $adc9	                bne _done       ; It's already in the buffer and in use.
.ad99						_not_in_buffer:
.ad99		a0 30		ldy #$30	                ldy #buffstatus_offset
.ad9b		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.ad9d		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.ad9f		d0 0c		bne $adad	                bne _buffer_available ; Unused or not dirty = available
.ada1		20 74 ad	jsr $ad74	                jsr xt_blkbuffer
.ada4		20 7e af	jsr $af7e	                jsr xt_buffblocknum
.ada7		20 1a 88	jsr $881a	                jsr xt_fetch
.adaa		20 6b af	jsr $af6b	                jsr xt_block_write
.adad						_buffer_available:
.adad		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.adaf		b5 00		lda $00,x	                lda 0,x
.adb1		91 08		sta ($08),y	                sta (up),y
.adb3		c8		iny		                iny
.adb4		b5 01		lda $01,x	                lda 1,x
.adb6		91 08		sta ($08),y	                sta (up),y
.adb8		20 74 ad	jsr $ad74	                jsr xt_blkbuffer
.adbb		20 2a 92	jsr $922a	                jsr xt_swap
.adbe		20 53 af	jsr $af53	                jsr xt_block_read
.adc1		a9 01		lda #$01	                lda #1
.adc3		a0 30		ldy #$30	                ldy #buffstatus_offset
.adc5		91 08		sta ($08),y	                sta (up),y
.adc7		ca		dex		                dex
.adc8		ca		dex		                dex
.adc9						_done:
.adc9		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.adcb		b1 08		lda ($08),y	                lda (up),y
.adcd		95 00		sta $00,x	                sta 0,x
.adcf		c8		iny		                iny
.add0		b1 08		lda ($08),y	                lda (up),y
.add2		95 01		sta $01,x	                sta 1,x
.add4		60		rts		z_block:        rts
.add5						xt_block_c65_init:
=0						io_blk_status = 0
=0						io_blk_action = 0
=0						io_blk_number = 0
=0						io_blk_buffer = 0
.add5		a9 ff		lda #$ff	                lda #$ff
.add7		8d 11 f0	sta $f011	                sta io_blk_status
.adda		a9 00		lda #$00	                lda #$0
.addc		8d 10 f0	sta $f010	                sta io_blk_action
.addf		ad 11 f0	lda $f011	                lda io_blk_status      ; $0 if OK, $ff otherwise
.ade2		49 ff		eor #$ff	                eor #$ff            ; invert to forth true/false
.ade4		ca		dex		                dex
.ade5		ca		dex		                dex
.ade6		95 00		sta $00,x	                sta 0,x             ; true ($ff) if OK, false (0) otherwise
.ade8		95 01		sta $01,x	                sta 1,x
.adea		ca		dex		                dex
.adeb		ca		dex		                dex
.adec		a9 0f		lda #$0f	                lda #<c65_blk_read
.adee		95 00		sta $00,x	                sta 0,x
.adf0		a9 ae		lda #$ae	                lda #>c65_blk_read
.adf2		95 01		sta $01,x	                sta 1,x
.adf4		20 61 af	jsr $af61	                jsr xt_block_read_vector
.adf7		20 14 92	jsr $9214	                jsr xt_store
.adfa		ca		dex		                dex
.adfb		ca		dex		                dex
.adfc		a9 0b		lda #$0b	                lda #<c65_blk_write
.adfe		95 00		sta $00,x	                sta 0,x
.ae00		a9 ae		lda #$ae	                lda #>c65_blk_write
.ae02		95 01		sta $01,x	                sta 1,x
.ae04		20 79 af	jsr $af79	                jsr xt_block_write_vector
.ae07		20 14 92	jsr $9214	                jsr xt_store
.ae0a						z_block_c65_init:
.ae0a		60		rts		                rts
.ae0b		a0 02		ldy #$02	c65_blk_write:  ldy #2
.ae0d		80 02		bra $ae11	                bra c65_blk_rw
.ae0f		a0 01		ldy #$01	c65_blk_read:   ldy #1
.ae11		b5 00		lda $00,x	c65_blk_rw:     lda 0,x                 ; ( addr blk# )
.ae13		8d 12 f0	sta $f012	                sta io_blk_number
.ae16		b5 01		lda $01,x	                lda 1,x
.ae18		8d 13 f0	sta $f013	                sta io_blk_number+1
.ae1b		b5 02		lda $02,x	                lda 2,x
.ae1d		8d 14 f0	sta $f014	                sta io_blk_buffer
.ae20		b5 03		lda $03,x	                lda 3,x
.ae22		8d 15 f0	sta $f015	                sta io_blk_buffer+1
.ae25		8c 10 f0	sty $f010	                sty io_blk_action       ; trigger the r/w
.ae28		e8		inx		                inx                     ; clean up stack
.ae29		e8		inx		                inx
.ae2a		e8		inx		                inx
.ae2b		e8		inx		                inx
.ae2c		60		rts		                rts
.ae2d						xt_block_ramdrive_init:
.ae2d		20 71 d7	jsr $d771	                jsr underflow_1
.ae30		20 5d a1	jsr $a15d	                jsr sliteral_runtime
>ae33		3b ae 18 01			                .word ramdrive_code, ramdrive_code_end-ramdrive_code
.ae37		20 b2 88	jsr $88b2	                jsr xt_evaluate
.ae3a						z_block_ramdrive_init:
.ae3a		60		rts		                rts
.ae3b						ramdrive_code:
>ae3b		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>ae43		77 61 70 20 64 65 63 69 6d 61 6c
>ae4e		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>ae55		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>ae59		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>ae61		20 72 61 6d 64 72 69 76 65
>ae6a		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>ae72		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>ae80		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>ae88		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>ae98		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>aea8		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>aeb0		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>aebf		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>aec7		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>aed7		31 30 32 34 20 6d 6f 76 65 20 3b
>aee2		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>aeea		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>aefa		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>af0a		20 21
>af0c		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>af14		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>af24		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>af34		6f 72 20 21
>af38		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>af40		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>af50		65 20 21
.af53						ramdrive_code_end:
.af53						xt_block_read:
.af53		a0 32		ldy #$32	                ldy #blockread_offset
.af55		b1 08		lda ($08),y	                lda (up),y
.af57		85 25		sta $25		                sta tmp1
.af59		c8		iny		                iny
.af5a		b1 08		lda ($08),y	                lda (up),y
.af5c		85 26		sta $26		                sta tmp1+1
.af5e		6c 25 00	jmp ($0025)	                jmp (tmp1)
.af61						z_block_read:
.af61						xt_block_read_vector:
.af61		a9 32		lda #$32	                lda #blockread_offset
.af63		4c 2d d6	jmp $d62d	                jmp push_upvar_tos
.af66						z_block_read_vector:
.af66						xt_block_word_error:
.af66		a9 0c		lda #$0c	                lda #err_blockwords
.af68		4c 87 d7	jmp $d787	                jmp error       ; no RTS needed
.af6b						xt_block_write:
.af6b		a0 34		ldy #$34	                ldy #blockwrite_offset
.af6d		b1 08		lda ($08),y	                lda (up),y
.af6f		85 25		sta $25		                sta tmp1
.af71		c8		iny		                iny
.af72		b1 08		lda ($08),y	                lda (up),y
.af74		85 26		sta $26		                sta tmp1+1
.af76		6c 25 00	jmp ($0025)	                jmp (tmp1)
.af79						z_block_write:
.af79						xt_block_write_vector:
.af79		a9 34		lda #$34	                lda #blockwrite_offset
.af7b		4c 2d d6	jmp $d62d	                jmp push_upvar_tos
.af7e						z_block_write_vector:
.af7e						xt_buffblocknum:
.af7e		a9 2e		lda #$2e	                lda #buffblocknum_offset
.af80		4c 2d d6	jmp $d62d	                jmp push_upvar_tos
.af83						z_buffblocknum:
.af83						xt_buffer:
.af83		a0 30		ldy #$30	                ldy #buffstatus_offset
.af85		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.af87		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.af89		d0 0c		bne $af97	                bne _buffer_available ; Unused or not dirty = available
.af8b		20 74 ad	jsr $ad74	                jsr xt_blkbuffer
.af8e		20 7e af	jsr $af7e	                jsr xt_buffblocknum
.af91		20 1a 88	jsr $881a	                jsr xt_fetch
.af94		20 6b af	jsr $af6b	                jsr xt_block_write
.af97						_buffer_available:
.af97		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.af99		b5 00		lda $00,x	                lda 0,x
.af9b		91 08		sta ($08),y	                sta (up),y
.af9d		c8		iny		                iny
.af9e		b5 01		lda $01,x	                lda 1,x
.afa0		91 08		sta ($08),y	                sta (up),y
.afa2		a9 01		lda #$01	                lda #1
.afa4		a0 30		ldy #$30	                ldy #buffstatus_offset
.afa6		91 08		sta ($08),y	                sta (up),y
.afa8		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.afaa		b1 08		lda ($08),y	                lda (up),y
.afac		95 00		sta $00,x	                sta 0,x
.afae		c8		iny		                iny
.afaf		b1 08		lda ($08),y	                lda (up),y
.afb1		95 01		sta $01,x	                sta 1,x
.afb3		60		rts		z_buffer:       rts
.afb4						xt_buffstatus:
.afb4		a9 30		lda #$30	                lda #buffstatus_offset
.afb6		4c 2d d6	jmp $d62d	                jmp push_upvar_tos
.afb9						z_buffstatus:
.afb9						xt_empty_buffers:
.afb9		a0 30		ldy #$30	                ldy #buffstatus_offset
.afbb		a9 00		lda #$00	                lda #0
.afbd		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.afbf						z_empty_buffers:
.afbf		60		rts		                rts
.afc0						xt_flush:
.afc0		20 1b b0	jsr $b01b	                jsr xt_save_buffers
.afc3		a0 30		ldy #$30	                ldy #buffstatus_offset
.afc5		a9 00		lda #$00	                lda #0
.afc7		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.afc9						z_flush:
.afc9		60		rts		                rts
.afca						xt_list:
.afca		20 71 d7	jsr $d771	                jsr underflow_1
.afcd		20 36 b0	jsr $b036	                jsr xt_scr
.afd0		20 14 92	jsr $9214	                jsr xt_store
.afd3		20 d5 b0	jsr $b0d5	                jsr xt_editor_l
.afd6		60		rts		z_list:         rts
.afd7						xt_load:
.afd7		20 71 d7	jsr $d771	                jsr underflow_1
.afda		a0 05		ldy #$05	                ldy #blk_offset+1
.afdc		b1 08		lda ($08),y	                lda (up),y
.afde		48		pha		                pha
.afdf		88		dey		                dey
.afe0		b1 08		lda ($08),y	                lda (up),y
.afe2		48		pha		                pha
.afe3		b5 00		lda $00,x	                lda 0,x
.afe5		91 08		sta ($08),y	                sta (up),y
.afe7		c8		iny		                iny
.afe8		b5 01		lda $01,x	                lda 1,x
.afea		91 08		sta ($08),y	                sta (up),y
.afec		20 82 ad	jsr $ad82	                jsr xt_block
.afef		ca		dex		                dex
.aff0		ca		dex		                dex
.aff1		a9 04		lda #$04	                lda #4
.aff3		95 01		sta $01,x	                sta 1,x
.aff5		74 00		stz $00,x	                stz 0,x
.aff7		20 ac 88	jsr $88ac	                jsr load_evaluate
.affa		a0 04		ldy #$04	                ldy #blk_offset
.affc		68		pla		                pla
.affd		91 08		sta ($08),y	                sta (up),y
.afff		c8		iny		                iny
.b000		68		pla		                pla
.b001		91 08		sta ($08),y	                sta (up),y
.b003		88		dey		                dey
.b004		11 08		ora ($08),y	                ora (up),y
.b006		f0 12		beq $b01a	                beq _done
.b008		ca		dex		                dex
.b009		ca		dex		                dex
.b00a		a0 04		ldy #$04	                ldy #blk_offset
.b00c		b1 08		lda ($08),y	                lda (up),y
.b00e		95 00		sta $00,x	                sta 0,x
.b010		c8		iny		                iny
.b011		b1 08		lda ($08),y	                lda (up),y
.b013		95 01		sta $01,x	                sta 1,x
.b015		20 82 ad	jsr $ad82	                jsr xt_block
.b018		e8		inx		                inx
.b019		e8		inx		                inx
.b01a						_done:
.b01a		60		rts		z_load:         rts
.b01b						xt_save_buffers:
.b01b		a0 30		ldy #$30	                ldy #buffstatus_offset
.b01d		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b01f		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b021		d0 12		bne $b035	                bne _done       ; Either not used or not dirty = done!
.b023		20 74 ad	jsr $ad74	                jsr xt_blkbuffer
.b026		20 7e af	jsr $af7e	                jsr xt_buffblocknum
.b029		20 1a 88	jsr $881a	                jsr xt_fetch
.b02c		20 6b af	jsr $af6b	                jsr xt_block_write
.b02f		a9 01		lda #$01	                lda #1
.b031		a0 30		ldy #$30	                ldy #buffstatus_offset
.b033		91 08		sta ($08),y	                sta (up),y
.b035						_done:
.b035		60		rts		z_save_buffers: rts
.b036						xt_scr:
.b036		a9 06		lda #$06	                lda #scr_offset
.b038		4c 2d d6	jmp $d62d	                jmp push_upvar_tos
.b03b						z_scr:
.b03b						xt_thru:
.b03b		20 76 d7	jsr $d776	                jsr underflow_2
.b03e		b5 01		lda $01,x	                lda 1,x
.b040		48		pha		                pha
.b041		b5 00		lda $00,x	                lda 0,x
.b043		48		pha		                pha
.b044		e8		inx		                inx
.b045		e8		inx		                inx
.b046						_thru_loop:
.b046		b5 01		lda $01,x	                lda 1,x
.b048		48		pha		                pha
.b049		b5 00		lda $00,x	                lda 0,x
.b04b		48		pha		                pha
.b04c		20 d7 af	jsr $afd7	                jsr xt_load
.b04f		68		pla		                pla
.b050		85 25		sta $25		                sta tmp1
.b052		68		pla		                pla
.b053		85 26		sta $26		                sta tmp1+1
.b055		68		pla		                pla
.b056		85 27		sta $27		                sta tmp2
.b058		68		pla		                pla
.b059		85 28		sta $28		                sta tmp2+1
.b05b		c5 26		cmp $26		                cmp tmp1+1
.b05d		d0 08		bne $b067	                bne _next_screen
.b05f		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.b061		c5 25		cmp $25		                cmp tmp1
.b063		d0 02		bne $b067	                bne _next_screen
.b065		80 18		bra $b07f	                bra _done       ; We just did the last screen.
.b067						_next_screen:
.b067		a5 28		lda $28		                lda tmp2+1
.b069		48		pha		                pha
.b06a		a5 27		lda $27		                lda tmp2
.b06c		48		pha		                pha
.b06d		e6 25		inc $25		                inc tmp1
.b06f		d0 02		bne $b073	                bne +
.b071		e6 26		inc $26		                inc tmp1+1
.b073						+
.b073		ca		dex		                dex
.b074		ca		dex		                dex
.b075		a5 25		lda $25		                lda tmp1
.b077		95 00		sta $00,x	                sta 0,x
.b079		a5 26		lda $26		                lda tmp1+1
.b07b		95 01		sta $01,x	                sta 1,x
.b07d		80 c7		bra $b046	                bra _thru_loop
.b07f						_done:
.b07f		60		rts		z_thru:         rts
.b080						xt_update:
.b080		a0 30		ldy #$30	                ldy #buffstatus_offset
.b082		b1 08		lda ($08),y	                lda (up),y
.b084		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.b086		91 08		sta ($08),y	                sta (up),y
.b088		60		rts		z_update:       rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/editor.asm

.b089						xt_editor_screen_helper:
.b089		20 a0 86	jsr $86a0	                jsr xt_dup
.b08c		20 36 b0	jsr $b036	                jsr xt_scr
.b08f		20 14 92	jsr $9214	                jsr xt_store
.b092		4c 83 af	jmp $af83	                jmp xt_buffer
.b095						xt_editor_enter_screen:
.b095		20 89 b0	jsr $b089	                jsr xt_editor_screen_helper
.b098		20 9a 86	jsr $869a	                jsr xt_drop
.b09b		64 35		stz $35		                stz ed_head
.b09d						_prompt_loop:
.b09d		ca		dex		                dex
.b09e		ca		dex		                dex
.b09f		a5 35		lda $35		                lda ed_head
.b0a1		95 00		sta $00,x	                sta 0,x
.b0a3		74 01		stz $01,x	                stz 1,x
.b0a5		20 68 b1	jsr $b168	                jsr xt_editor_o
.b0a8		e6 35		inc $35		                inc ed_head
.b0aa		a9 10		lda #$10	                lda #16
.b0ac		c5 35		cmp $35		                cmp ed_head
.b0ae		d0 ed		bne $b09d	                bne _prompt_loop
.b0b0						z_editor_enter_screen:
.b0b0		60		rts		                rts
.b0b1						xt_editor_erase_screen:
.b0b1		20 89 b0	jsr $b089	                jsr xt_editor_screen_helper
.b0b4		ca		dex		                dex
.b0b5		ca		dex		                dex
.b0b6		74 00		stz $00,x	                stz 0,x
.b0b8		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.b0ba		95 01		sta $01,x	                sta 1,x
.b0bc		20 b2 87	jsr $87b2	                jsr xt_blank
.b0bf		20 80 b0	jsr $b080	                jsr xt_update
.b0c2						z_editor_erase_screen:
.b0c2		60		rts		                rts
.b0c3						xt_editor_el:
.b0c3		20 4f b1	jsr $b14f	                jsr xt_editor_line
.b0c6		ca		dex		                dex
.b0c7		ca		dex		                dex
.b0c8		a9 40		lda #$40	                lda #64
.b0ca		95 00		sta $00,x	                sta 0,x
.b0cc		74 01		stz $01,x	                stz 1,x
.b0ce		20 b2 87	jsr $87b2	                jsr xt_blank
.b0d1		20 80 b0	jsr $b080	                jsr xt_update
.b0d4		60		rts		z_editor_el:    rts
.b0d5						xt_editor_l:
.b0d5		ca		dex		                dex             ; Put SCR on the stack.
.b0d6		ca		dex		                dex
.b0d7		a0 06		ldy #$06	                ldy #scr_offset
.b0d9		b1 08		lda ($08),y	                lda (up),y
.b0db		95 00		sta $00,x	                sta 0,x
.b0dd		c8		iny		                iny
.b0de		b1 08		lda ($08),y	                lda (up),y
.b0e0		95 01		sta $01,x	                sta 1,x
.b0e2		20 82 ad	jsr $ad82	                jsr xt_block    ; Get the current screen.
.b0e5		20 3a 84	jsr $843a	                jsr xt_cr
.b0e8		80 08		bra $b0f2	                bra _after_screen_msg
.b0ea						_screen_msg:
>b0ea		53 63 72 65 65 6e 20 23		                .text "Screen #"
.b0f2						_after_screen_msg:
.b0f2		20 5d a1	jsr $a15d	                jsr sliteral_runtime
>b0f5		ea b0 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.b0f9		20 c0 94	jsr $94c0	                jsr xt_type
.b0fc		20 36 b0	jsr $b036	                jsr xt_scr
.b0ff		20 1a 88	jsr $881a	                jsr xt_fetch
.b102		ca		dex		                dex
.b103		ca		dex		                dex
.b104		a9 04		lda #$04	                lda #4          ; four spaces
.b106		95 00		sta $00,x	                sta 0,x
.b108		74 01		stz $01,x	                stz 1,x
.b10a		20 f7 94	jsr $94f7	                jsr xt_u_dot_r
.b10d		64 29		stz $29		                stz tmp3
.b10f						_line_loop:
.b10f		20 3a 84	jsr $843a	                jsr xt_cr
.b112		ca		dex		                dex
.b113		ca		dex		                dex
.b114		ca		dex		                dex
.b115		ca		dex		                dex
.b116		74 03		stz $03,x	                stz 3,x
.b118		a5 29		lda $29		                lda tmp3
.b11a		95 02		sta $02,x	                sta 2,x
.b11c		74 01		stz $01,x	                stz 1,x
.b11e		a9 02		lda #$02	                lda #2
.b120		95 00		sta $00,x	                sta 0,x
.b122		20 f7 94	jsr $94f7	                jsr xt_u_dot_r
.b125		20 c7 91	jsr $91c7	                jsr xt_space
.b128		20 a0 86	jsr $86a0	                jsr xt_dup
.b12b		ca		dex		                dex
.b12c		ca		dex		                dex
.b12d		a9 40		lda #$40	                lda #64
.b12f		95 00		sta $00,x	                sta 0,x
.b131		74 01		stz $01,x	                stz 1,x
.b133		20 c0 94	jsr $94c0	                jsr xt_type
.b136		18		clc		                clc
.b137		a9 40		lda #$40	                lda #64
.b139		75 00		adc $00,x	                adc 0,x
.b13b		95 00		sta $00,x	                sta 0,x
.b13d		90 02		bcc $b141	                bcc +
.b13f		f6 01		inc $01,x	                inc 1,x
.b141						+
.b141		e6 29		inc $29		                inc tmp3
.b143		a5 29		lda $29		                lda tmp3
.b145		c9 10		cmp #$10	                cmp #16
.b147		d0 c6		bne $b10f	                bne _line_loop
.b149		20 3a 84	jsr $843a	                jsr xt_cr
.b14c		e8		inx		                inx
.b14d		e8		inx		                inx
.b14e		60		rts		z_editor_l:            rts
.b14f						xt_editor_line:
.b14f		20 71 d7	jsr $d771	                jsr underflow_1
.b152		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.b154						_shift_tos_left:
.b154		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.b156		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.b158		88		dey		                dey
.b159		d0 f9		bne $b154	                bne _shift_tos_left
.b15b		20 36 b0	jsr $b036	                jsr xt_scr
.b15e		20 1a 88	jsr $881a	                jsr xt_fetch
.b161		20 82 ad	jsr $ad82	                jsr xt_block
.b164		20 4f 8e	jsr $8e4f	                jsr xt_plus
.b167		60		rts		z_editor_line:  rts
.b168						xt_editor_o:
.b168		20 3a 84	jsr $843a	                jsr xt_cr
.b16b		20 a0 86	jsr $86a0	                jsr xt_dup
.b16e		20 a3 9d	jsr $9da3	                jsr xt_two
.b171		20 f7 94	jsr $94f7	                jsr xt_u_dot_r
.b174		20 c7 91	jsr $91c7	                jsr xt_space
.b177		a9 2a		lda #$2a	                lda #'*'
.b179		20 c5 86	jsr $86c5	                jsr emit_a
.b17c		20 c7 91	jsr $91c7	                jsr xt_space
.b17f		20 4f b1	jsr $b14f	                jsr xt_editor_line
.b182		20 a0 86	jsr $86a0	                jsr xt_dup      ; Save a copy of the line address for later.
.b185		ca		dex		                dex
.b186		ca		dex		                dex
.b187		a9 40		lda #$40	                lda #64         ; chars/line
.b189		95 00		sta $00,x	                sta 0,x
.b18b		74 01		stz $01,x	                stz 1,x
.b18d		20 e4 80	jsr $80e4	                jsr xt_accept
.b190		20 a0 86	jsr $86a0	                jsr xt_dup
.b193		20 5c 9c	jsr $9c5c	                jsr xt_not_rote ; -rot
.b196		20 4f 8e	jsr $8e4f	                jsr xt_plus
.b199		ca		dex		                dex
.b19a		ca		dex		                dex
.b19b		a9 40		lda #$40	                lda #64         ; chars/line
.b19d		95 00		sta $00,x	                sta 0,x
.b19f		74 01		stz $01,x	                stz 1,x
.b1a1		20 8d 8f	jsr $8f8d	                jsr xt_rot
.b1a4		20 e4 8b	jsr $8be4	                jsr xt_minus
.b1a7		20 b2 87	jsr $87b2	                jsr xt_blank
.b1aa		20 80 b0	jsr $b080	                jsr xt_update
.b1ad		60		rts		z_editor_o:     rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/wordlist.asm

.b1ae						xt_also:
.b1ae		20 d9 b1	jsr $b1d9	                jsr xt_get_order
.b1b1		20 01 8d	jsr $8d01	                jsr xt_over
.b1b4		20 2a 92	jsr $922a	                jsr xt_swap
.b1b7		20 e5 8c	jsr $8ce5	                jsr xt_one_plus
.b1ba		20 e2 b2	jsr $b2e2	                jsr xt_set_order
.b1bd		60		rts		z_also:         rts
.b1be						xt_definitions:
.b1be		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.b1c0		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.b1c2		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.b1c4		91 08		sta ($08),y	                sta (up),y
.b1c6		60		rts		z_definitions:  rts
.b1c7						xt_forth:
.b1c7		a0 23		ldy #$23	                ldy #search_order_offset
.b1c9		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.b1cb		91 08		sta ($08),y	                sta (up),y
.b1cd						z_forth:
.b1cd		60		rts		                rts
.b1ce						xt_get_current:
.b1ce		ca		dex		                dex
.b1cf		ca		dex		                dex
.b1d0		a0 08		ldy #$08	                ldy #current_offset
.b1d2		b1 08		lda ($08),y	                lda (up),y
.b1d4		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.b1d6		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.b1d8		60		rts		z_get_current:  rts
.b1d9						xt_get_order:
.b1d9		a0 22		ldy #$22	                ldy #num_order_offset
.b1db		b1 08		lda ($08),y	                lda (up),y
.b1dd		85 25		sta $25		                sta tmp1
.b1df		f0 16		beq $b1f7	                beq _done       ; If zero, there are no wordlists.
.b1e1						_loop:
.b1e1		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.b1e3		a9 23		lda #$23	                lda #search_order_offset
.b1e5		18		clc		                clc
.b1e6		65 25		adc $25		                adc tmp1
.b1e8		a8		tay		                tay
.b1e9		ca		dex		                dex
.b1ea		ca		dex		                dex
.b1eb		b1 08		lda ($08),y	                lda (up),y
.b1ed		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.b1ef		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.b1f1		a9 00		lda #$00	                lda #0
.b1f3		c5 25		cmp $25		                cmp tmp1
.b1f5		d0 ea		bne $b1e1	                bne _loop
.b1f7						_done:
.b1f7		ca		dex		                dex
.b1f8		ca		dex		                dex
.b1f9		a0 22		ldy #$22	                ldy #num_order_offset
.b1fb		b1 08		lda ($08),y	                lda (up),y
.b1fd		95 00		sta $00,x	                sta 0,x
.b1ff		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.b201		60		rts		z_get_order:    rts
.b202						xt_only:
.b202		20 80 93	jsr $9380	                jsr xt_true
.b205		20 e2 b2	jsr $b2e2	                jsr xt_set_order
.b208		60		rts		z_only:         rts
.b209						xt_order:
.b209		20 3a 84	jsr $843a	                jsr xt_cr
.b20c		20 d9 b1	jsr $b1d9	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.b20f		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.b211		f0 1e		beq $b231	                beq _drop_done
.b213		a8		tay		                tay
.b214						_loop:
.b214		e8		inx		                inx
.b215		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.b216		b5 00		lda $00,x	                lda 0,x
.b218		5a		phy		                phy
.b219		20 34 b2	jsr $b234	                jsr order_print_wid_string   ; internal helper function
.b21c		7a		ply		                ply
.b21d		88		dey		                dey
.b21e		d0 f4		bne $b214	                bne _loop
.b220		20 c7 91	jsr $91c7	                jsr xt_space
.b223		20 c7 91	jsr $91c7	                jsr xt_space
.b226		20 ce b1	jsr $b1ce	                jsr xt_get_current      ; ( wid )
.b229		b5 00		lda $00,x	                lda 0,x
.b22b		20 34 b2	jsr $b234	                jsr order_print_wid_string
.b22e		20 3a 84	jsr $843a	                jsr xt_cr
.b231						_drop_done:
.b231		e8		inx		                inx
.b232		e8		inx		                inx
.b233						z_order:
.b233		60		rts		                rts
.b234						order_print_wid_string:
.b234		c9 04		cmp #$04	                cmp #4
.b236		90 09		bcc $b241	                bcc _output_string      ; less than 4, print a real string
.b238		ca		dex		                dex
.b239		ca		dex		                dex
.b23a		95 00		sta $00,x	                sta 0,x
.b23c		74 01		stz $01,x	                stz 1,x
.b23e		4c eb 94	jmp $94eb	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.b241						_output_string:
.b241		a8		tay		                tay
.b242		b9 48 b2	lda $b248,y	                lda _wid_data,y
.b245		4c ad d7	jmp $d7ad	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.b248						_wid_data:
>b248		04				        .byte str_wid_forth            ; WID 0: "Forth"
>b249		05				        .byte str_wid_editor           ; WID 1: "Editor"
>b24a		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>b24b		07				        .byte str_wid_root             ; WID 3: "Root"
.b24c						xt_previous:
.b24c		20 d9 b1	jsr $b1d9	                jsr xt_get_order
.b24f		20 30 8c	jsr $8c30	                jsr xt_nip
.b252		20 d9 8c	jsr $8cd9	                jsr xt_one_minus
.b255		20 e2 b2	jsr $b2e2	                jsr xt_set_order
.b258		60		rts		z_previous:     rts
.b259						xt_root_wordlist:
.b259		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.b25a		ca		dex		                dex
.b25b		a9 03		lda #$03	                lda #3
.b25d		95 00		sta $00,x	                sta 0,x
.b25f		74 01		stz $01,x	                stz 1,x
.b261						z_root_wordlist:
.b261		60		rts		                rts
.b262						xt_search_wordlist:
.b262		20 7b d7	jsr $d77b	                jsr underflow_3
.b265		a5 08		lda $08		                lda up
.b267		18		clc		                clc
.b268		69 0a		adc #$0a	                adc #wordlists_offset
.b26a		85 27		sta $27		                sta tmp2
.b26c		a5 09		lda $09		                lda up+1
.b26e		69 00		adc #$00	                adc #0          ; Adding carry
.b270		85 28		sta $28		                sta tmp2+1
.b272		b5 00		lda $00,x	                lda 0,x
.b274		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.b275		65 27		adc $27		                adc tmp2
.b277		85 27		sta $27		                sta tmp2
.b279		90 02		bcc $b27d	                bcc +
.b27b		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.b27d						+
.b27d		e8		inx		                inx
.b27e		e8		inx		                inx
.b27f		b5 00		lda $00,x	                lda 0,x
.b281		15 01		ora $01,x	                ora 1,x
.b283		f0 4e		beq $b2d3	                beq _done
.b285		a5 27		lda $27		                lda tmp2
.b287		05 28		ora $28		                ora tmp2+1
.b289		f0 48		beq $b2d3	                beq _done
.b28b		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.b28d		85 25		sta $25		                sta tmp1
.b28f		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.b291		d0 02		bne $b295	                bne +
.b293		e6 28		inc $28		                inc tmp2+1
.b295						+
.b295		b2 27		lda ($27)	                lda (tmp2)
.b297		85 26		sta $26		                sta tmp1+1
.b299		20 53 d6	jsr $d653	                jsr find_header_name
.b29c		f0 31		beq $b2cf	                beq _fail_done
.b29e		e8		inx		                inx
.b29f		e8		inx		                inx
.b2a0		a5 25		lda $25		                lda tmp1
.b2a2		95 00		sta $00,x	                sta 0,x
.b2a4		a5 26		lda $26		                lda tmp1+1
.b2a6		95 01		sta $01,x	                sta 1,x
.b2a8		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.b2ab		20 15 9c	jsr $9c15	                jsr xt_name_to_int      ; ( nt xt )
.b2ae		20 2a 92	jsr $922a	                jsr xt_swap             ; ( xt nt )
.b2b1		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.b2b3		f6 00		inc $00,x	                inc 0,x
.b2b5		d0 02		bne $b2b9	                bne +
.b2b7		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.b2b9						+
.b2b9		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.b2bb		29 04		and #$04	                and #IM
.b2bd		d0 08		bne $b2c7	                bne _immediate          ; bit set, we're immediate
.b2bf		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.b2c1		95 00		sta $00,x	                sta 0,x
.b2c3		95 01		sta $01,x	                sta 1,x
.b2c5		80 0e		bra $b2d5	                bra _done_nodrop
.b2c7						_immediate:
.b2c7		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.b2c9		95 00		sta $00,x	                sta 0,x
.b2cb		74 01		stz $01,x	                stz 1,x
.b2cd		80 06		bra $b2d5	                bra _done_nodrop
.b2cf						_fail_done:
.b2cf		74 02		stz $02,x	                stz 2,x         ; failure flag
.b2d1		74 03		stz $03,x	                stz 3,x
.b2d3						_done:
.b2d3		e8		inx		                inx
.b2d4		e8		inx		                inx
.b2d5						_done_nodrop:
.b2d5						z_search_wordlist:
.b2d5		60		rts		                rts
.b2d6						xt_set_current:
.b2d6		20 71 d7	jsr $d771	                jsr underflow_1
.b2d9		a0 08		ldy #$08	                ldy #current_offset
.b2db		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.b2dd		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.b2df		e8		inx		                inx
.b2e0		e8		inx		                inx
.b2e1		60		rts		z_set_current:  rts
.b2e2						xt_set_order:
.b2e2		a9 ff		lda #$ff	                lda #$FF
.b2e4		d5 01		cmp $01,x	                cmp 1,x
.b2e6		d0 12		bne $b2fa	                bne _start
.b2e8		d5 00		cmp $00,x	                cmp 0,x
.b2ea		d0 0e		bne $b2fa	                bne _start
.b2ec		ca		dex		                dex             ; Make room for the count.
.b2ed		ca		dex		                dex
.b2ee		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.b2f0		a9 03		lda #$03	                lda #3
.b2f2		95 02		sta $02,x	                sta 2,x
.b2f4		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.b2f6		a9 01		lda #$01	                lda #1
.b2f8		95 00		sta $00,x	                sta 0,x
.b2fa						_start:
.b2fa		a0 22		ldy #$22	                ldy #num_order_offset
.b2fc		b5 00		lda $00,x	                lda 0,x
.b2fe		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.b300		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.b302		e8		inx		                inx             ; Drop the count off the data stack.
.b303		e8		inx		                inx
.b304		a5 25		lda $25		                lda tmp1
.b306		f0 0d		beq $b315	                beq _done       ; If zero, there are no wordlists.
.b308		a0 23		ldy #$23	                ldy #search_order_offset
.b30a						_loop:
.b30a		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.b30c		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.b30e		c8		iny		                iny
.b30f		e8		inx		                inx
.b310		e8		inx		                inx
.b311		c6 25		dec $25		                dec tmp1
.b313		d0 f5		bne $b30a	                bne _loop
.b315						_done:
.b315		60		rts		z_set_order:    rts
.b316						xt_to_order:
.b316		20 68 93	jsr $9368	                jsr xt_to_r
.b319		20 d9 b1	jsr $b1d9	                jsr xt_get_order
.b31c		20 ec 8e	jsr $8eec	                jsr xt_r_from
.b31f		20 2a 92	jsr $922a	                jsr xt_swap
.b322		20 e5 8c	jsr $8ce5	                jsr xt_one_plus
.b325		20 e2 b2	jsr $b2e2	                jsr xt_set_order
.b328		60		rts		z_to_order:     rts
.b329						xt_wordlist:
.b329		a0 09		ldy #$09	                ldy #num_wordlists_offset
.b32b		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.b32d		c9 0c		cmp #$0c	                cmp #max_wordlists
.b32f		d0 05		bne $b336	                bne _ok
.b331		a9 0b		lda #$0b	                lda #err_wordlist
.b333		4c 87 d7	jmp $d787	                jmp error
.b336						_ok:
.b336		1a		inc a		                ina             ; Increment the wordlist#
.b337		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.b339		ca		dex		                dex             ; and put it on the stack.
.b33a		ca		dex		                dex
.b33b		95 00		sta $00,x	                sta 0,x
.b33d		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.b33f		60		rts		z_wordlist:     rts

;******  Return to file: platform/../words/all.asm


;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.b340						cold_zp_table:
>b340	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>b342	0002	23 bb				dp:         .word dictionary_start  ; Dictionary Pointer
>b344	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>b346	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>b348	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>b34a	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>b34c	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>b34e	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>b350	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>b352	0012	2d f0				output:     .word kernel_putc       ; vector for EMIT
>b354	0014	27 f0				input:      .word kernel_getc       ; vector for KEY
>b356	0016	00 00				havekey:    .word 0                 ; vector for KEY?  (unused see https://github.com/SamCoVT/TaliForth2/issues/62)
>b358	0018	0a 00				base:       .word 10                ; number radix, default decimal
>b35a	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>b35c	001c	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>b35e	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>b35f	001f					loopctrl:   .byte ?         ; Offset and flags for DO/LOOP/+LOOP control.
>b360	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$100						lcbstack = $100
=256						loopindex = lcbstack+0      ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack+2      ; loop control block offset for limit fudge factor
>b361	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>b363	0023					tmptos:     .word ?         ; temporary TOS storage
>b365	0025					tmp1:       .word ?         ; temporary storage
>b367	0027					tmp2:       .word ?         ; temporary storage
>b369	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>b36b	002b					tohold:     .word ?         ; pointer for formatted output
>b36d	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>b375	0035					tmped:      .word ?,?,?     ; temporary for editors
.b35e						cold_zp_table_end:
.b35e						cold_user_table:
>b35e	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>b360	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>b362	0004	00 00				blk_offset:             .word 0         ; BLK
>b364	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
.b366	0008					marker_start_offset:
>b366	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>b367	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.b368	000a					wordlists_offset:
>b368	000a	23 bb				    .word dictionary_start              ; FORTH-WORDLIST
>b36a	000c	82 c9				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>b36c	000e	d2 c9				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>b36e	0010	41 c9				    .word root_dictionary_start         ; ROOT-WORDLIST
>b370	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>b378	001a	00 00 00 00 00 00 00 00
>b380	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.b381	0023					search_order_offset:
>b381	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>b389	002b	00
.b38a	002c					marker_end_offset:
>b38a	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>b38c	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>b38e	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>b390	0032	66 af				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>b392	0034	66 af				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.b394						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$d0						OpBNE   = $D0
=$f0						OpBEQ   = $F0
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=64						ST = 64 ; Includes stack juggling stripped for native compile
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../opcodes.asm

.b394						oc_index_table:
>b394		94 b5 98 b5 3f ba 3f ba		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc07
>b39c		a0 b5 a6 b5 ac b5 b2 b5
>b3a4		b9 b5 bd b5 c3 b5 3f ba		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>b3ac		c9 b5 cd b5 d1 b5 d5 b5
>b3b4		da b5 de b5 e6 b5 3f ba		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>b3bc		ed b5 f3 b5 fa b5 01 b6
>b3c4		08 b6 0c b6 12 b6 3f ba		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc1E, oc1F
>b3cc		18 b6 1c b6 22 b6 28 b6
>b3d4		2d b6 31 b6 3f ba 3f ba		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>b3dc		39 b6 3f b6 45 b6 4b b6
>b3e4		52 b6 56 b6 5c b6 3f ba		        .word oc28, oc29, oc2A, oc__, oc2C, oc2D, oc2E, oc2F
>b3ec		62 b6 66 b6 6b b6 6f b6
>b3f4		74 b6 78 b6 80 b6 3f ba		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>b3fc		87 b6 8f b6 96 b6 9d b6
>b404		a4 b6 a8 b6 ae b6 3f ba		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc3F
>b40c		b4 b6 ba b6 c0 b6 c6 b6
>b414		cb b6 cf b6 3f ba 3f ba		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>b41c		3f ba d7 b6 dd b6 e3 b6
>b424		ea b6 ee b6 f4 b6 3f ba		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>b42c		fa b6 fe b6 02 b7 06 b7
>b434		0b b7 0f b7 17 b7 3f ba		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>b43c		3f ba 1e b7 25 b7 2c b7
>b444		33 b7 37 b7 3d b7 3f ba		        .word oc58, oc59, oc5A, oc__, oc__, oc5D, oc5E, oc5F
>b44c		3f ba 41 b7 47 b7 4d b7
>b454		52 b7 56 b7 3f ba 3f ba		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b45c		5e b7 64 b7 6a b7 70 b7
>b464		77 b7 7b b7 81 b7 3f ba		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>b46c		87 b7 8d b7 91 b7 95 b7
>b474		9a b7 9e b7 a6 b7 3f ba		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b47c		ad b7 b4 b7 bb b7 c2 b7
>b484		c9 b7 cd b7 d3 b7 3f ba		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>b48c		d7 b7 de b7 e4 b7 ea b7
>b494		ef b7 f3 b7 3f ba 3f ba		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc87
>b49c		fb b7 01 b8 07 b8 0d b8
>b4a4		14 b8 18 b8 1e b8 3f ba		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>b4ac		22 b8 26 b8 2a b8 2e b8
>b4b4		33 b8 37 b8 3f b8 3f ba		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b4bc		46 b8 4d b8 54 b8 5b b8
>b4c4		62 b8 66 b8 6c b8 3f ba		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>b4cc		70 b8 74 b8 7a b8 80 b8
>b4d4		85 b8 8b b8 93 b8 3f ba		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>b4dc		99 b8 9f b8 a5 b8 ab b8
>b4e4		b2 b8 b6 b8 bc b8 3f ba		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>b4ec		c0 b8 c4 b8 c8 b8 cc b8
>b4f4		d1 b8 d5 b8 dd b8 3f ba		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>b4fc		e4 b8 eb b8 f2 b8 f9 b8
>b504		00 b9 04 b9 0a b9 3f ba		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>b50c		0e b9 14 b9 1a b9 20 b9
>b514		25 b9 2b b9 3f ba 3f ba		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>b51c		33 b9 39 b9 3f b9 45 b9
>b524		4c b9 50 b9 56 b9 3f ba		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>b52c		5a b9 5e b9 62 b9 66 b9
>b534		6b b9 6f b9 77 b9 3f ba		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>b53c		3f ba 7e b9 85 b9 8c b9
>b544		93 b9 97 b9 9d b9 3f ba		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>b54c		3f ba a1 b9 a7 b9 ad b9
>b554		b2 b9 b8 b9 3f ba 3f ba		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>b55c		c0 b9 c6 b9 cc b9 d2 b9
>b564		d9 b9 dd b9 e3 b9 3f ba		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>b56c		e7 b9 eb b9 ef b9 f3 b9
>b574		f8 b9 fc b9 04 ba 3f ba		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>b57c		3f ba 0b ba 12 ba 19 ba
>b584		20 ba 24 ba 2a ba 3f ba		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>b58c		3f ba 2e ba 34 ba 3a ba
>b594		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b598		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b5a0		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b5a6		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b5ac		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b5b2		86 72 6d 62 30 2e 7a			oc07:	.text 2*64+6, "rmb0.z"
>b5b9		43 70 68 70				oc08:	.text 1*64+3, "php"
>b5bd		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b5c3		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>b5c9		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>b5cd		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>b5d1		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>b5d5		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>b5da		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b5de		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b5e6		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b5ed		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b5f3		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b5fa		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b601		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b608		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b60c		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b612		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b618		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b61c		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b622		c5 61 73 6c 2e 78			oc1E:	.text 3*64+5, "asl.x"
>b628		c4 62 62 72 31				oc1F:	.text 3*64+4, "bbr1"
>b62d		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b631		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b639		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b63f		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b645		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b64b		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b652		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b656		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b65c		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b662		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b666		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b66b		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b66f		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b674		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b678		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b680		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b687		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b68f		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b696		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b69d		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b6a4		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b6a8		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b6ae		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b6b4		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b6ba		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b6c0		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b6c6		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b6cb		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b6cf		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b6d7		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b6dd		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b6e3		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b6ea		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b6ee		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b6f4		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b6fa		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b6fe		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b702		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b706		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b70b		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b70f		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b717		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b71e		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b725		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b72c		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b733		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b737		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b73d		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b741		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b747		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b74d		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b752		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b756		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b75e		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b764		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b76a		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b770		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b777		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b77b		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b781		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b787		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b78d		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b791		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b795		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b79a		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b79e		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b7a6		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b7ad		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b7b4		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b7bb		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b7c2		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b7c9		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b7cd		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b7d3		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b7d7		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b7de		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b7e4		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b7ea		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b7ef		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b7f3		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b7fb		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b801		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b807		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b80d		86 73 6d 62 30 2e 7a			oc87:	.text 2*64+6, "smb0.z"
>b814		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b818		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b81e		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b822		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b826		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b82a		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b82e		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b833		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b837		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b83f		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b846		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b84d		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b854		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b85b		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b862		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b866		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b86c		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b870		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b874		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b87a		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b880		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b885		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b88b		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b893		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b899		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b89f		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b8a5		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b8ab		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b8b2		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b8b6		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b8bc		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b8c0		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b8c4		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b8c8		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b8cc		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b8d1		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b8d5		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b8dd		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b8e4		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b8eb		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b8f2		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b8f9		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b900		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b904		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b90a		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>b90e		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>b914		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>b91a		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>b920		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>b925		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>b92b		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>b933		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>b939		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>b93f		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>b945		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>b94c		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>b950		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>b956		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>b95a		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>b95e		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>b962		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>b966		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>b96b		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>b96f		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>b977		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>b97e		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>b985		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>b98c		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>b993		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>b997		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>b99d		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>b9a1		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>b9a7		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>b9ad		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>b9b2		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>b9b8		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>b9c0		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>b9c6		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>b9cc		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>b9d2		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>b9d9		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>b9dd		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>b9e3		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>b9e7		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>b9eb		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>b9ef		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>b9f3		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>b9f8		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>b9fc		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>ba04		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>ba0b		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>ba12		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>ba19		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>ba20		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>ba24		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>ba2a		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>ba2e		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>ba34		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>ba3a		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>ba3f		01 3f					oc__:	.text 1, "?"

;******  Return to file: platform/../taliforth.asm

.ba41						forth_words_start:
>ba41		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>ba49		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>ba59		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>ba69		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>ba79		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>ba89		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>ba99		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>baa9		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bab9		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>bac9		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>bad9		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>bae9		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>baf9		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bb09		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bb19		78 69 74 29 20 63 72 20
.bb21						forth_words_end:
.bb21						user_words_start:
>bb21		20 20				.binary "user_words.asc"
.bb23						user_words_end:

;******  Processing file: platform/../words/headers.asm

.bb23						dictionary_start:
="drop"						    _s := "" ? "" : str(.drop)
>bb23		04 10				    .byte len(_s), UF
>bb25		2f bb 9a 86 9f 86		    .word false ? 0 : +, xt_drop, z_drop
>bb2b		64 72 6f 70			    .text _s
.bb2f						+
="dup"						    _s := "" ? "" : str(.dup)
>bb2f		03 10				    .byte len(_s), UF
>bb31		3a bb a0 86 ad 86		    .word false ? 0 : +, xt_dup, z_dup
>bb37		64 75 70			    .text _s
.bb3a						+
="swap"						    _s := "" ? "" : str(.swap)
>bb3a		04 10				    .byte len(_s), UF
>bb3c		46 bb 2a 92 3d 92		    .word false ? 0 : +, xt_swap, z_swap
>bb42		73 77 61 70			    .text _s
.bb46						+
="!"						    _s := "!" ? "!" : str(.store)
>bb46		01 10				    .byte len(_s), UF
>bb48		4f bb 14 92 29 92		    .word false ? 0 : +, xt_store, z_store
>bb4e		21				    .text _s
.bb4f						+
="@"						    _s := "@" ? "@" : str(.fetch)
>bb4f		01 10				    .byte len(_s), UF
>bb51		58 bb 1a 88 2c 88		    .word false ? 0 : +, xt_fetch, z_fetch
>bb57		40				    .text _s
.bb58						+
="over"						    _s := "" ? "" : str(.over)
>bb58		04 10				    .byte len(_s), UF
>bb5a		64 bb 01 8d 0e 8d		    .word false ? 0 : +, xt_over, z_over
>bb60		6f 76 65 72			    .text _s
.bb64						+
=">r"						    _s := ">r" ? ">r" : str(.to_r)
>bb64		02 51				    .byte len(_s), CO+UF+ST
>bb66		6e bb 68 93 7d 93		    .word false ? 0 : +, xt_to_r, z_to_r
>bb6c		3e 72				    .text _s
.bb6e						+
="r>"						    _s := "r>" ? "r>" : str(.r_from)
>bb6e		02 41				    .byte len(_s), CO+ST
>bb70		78 bb ec 8e fe 8e		    .word false ? 0 : +, xt_r_from, z_r_from
>bb76		72 3e				    .text _s
.bb78						+
="r@"						    _s := "r@" ? "r@" : str(.r_fetch)
>bb78		02 41				    .byte len(_s), CO+ST
>bb7a		82 bb d5 8e e9 8e		    .word false ? 0 : +, xt_r_fetch, z_r_fetch
>bb80		72 40				    .text _s
.bb82						+
="nip"						    _s := "" ? "" : str(.nip)
>bb82		03 10				    .byte len(_s), UF
>bb84		8d bb 30 8c 3d 8c		    .word false ? 0 : +, xt_nip, z_nip
>bb8a		6e 69 70			    .text _s
.bb8d						+
="rot"						    _s := "" ? "" : str(.rot)
>bb8d		03 10				    .byte len(_s), UF
>bb8f		98 bb 8d 8f a8 8f		    .word false ? 0 : +, xt_rot, z_rot
>bb95		72 6f 74			    .text _s
.bb98						+
="-rot"						    _s := "-rot" ? "-rot" : str(.not_rote)
>bb98		04 10				    .byte len(_s), UF
>bb9a		a4 bb 5c 9c 77 9c		    .word false ? 0 : +, xt_not_rote, z_not_rote
>bba0		2d 72 6f 74			    .text _s
.bba4						+
="tuck"						    _s := "" ? "" : str(.tuck)
>bba4		04 10				    .byte len(_s), UF
>bba6		b0 bb 89 93 a2 93		    .word false ? 0 : +, xt_tuck, z_tuck
>bbac		74 75 63 6b			    .text _s
.bbb0						+
=","						    _s := "," ? "," : str(.comma)
>bbb0		01 10				    .byte len(_s), UF
>bbb2		b9 bb cd 83 db 83		    .word false ? 0 : +, xt_comma, z_comma
>bbb8		2c				    .text _s
.bbb9						+
="c@"						    _s := "c@" ? "c@" : str(.c_fetch)
>bbb9		02 10				    .byte len(_s), UF
>bbbb		c3 bb 2d 83 36 83		    .word false ? 0 : +, xt_c_fetch, z_c_fetch
>bbc1		63 40				    .text _s
.bbc3						+
="c!"						    _s := "c!" ? "c!" : str(.c_store)
>bbc3		02 10				    .byte len(_s), UF
>bbc5		cd bb 37 83 42 83		    .word false ? 0 : +, xt_c_store, z_c_store
>bbcb		63 21				    .text _s
.bbcd						+
="+!"						    _s := "+!" ? "+!" : str(.plus_store)
>bbcd		02 10				    .byte len(_s), UF
>bbcf		d7 bb 62 8e 81 8e		    .word false ? 0 : +, xt_plus_store, z_plus_store
>bbd5		2b 21				    .text _s
.bbd7						+
="0"						    _s := "0" ? "0" : str(.zero)
>bbd7		01 00				    .byte len(_s), 0
>bbd9		e0 bb d8 9d de 9d		    .word false ? 0 : +, xt_zero, z_zero
>bbdf		30				    .text _s
.bbe0						+
="1"						    _s := "1" ? "1" : str(.one)
>bbe0		01 00				    .byte len(_s), 0
>bbe2		e9 bb 72 9d 7a 9d		    .word false ? 0 : +, xt_one, z_one
>bbe8		31				    .text _s
.bbe9						+
="2"						    _s := "2" ? "2" : str(.two)
>bbe9		01 00				    .byte len(_s), 0
>bbeb		f2 bb a3 9d ab 9d		    .word false ? 0 : +, xt_two, z_two
>bbf1		32				    .text _s
.bbf2						+
="execute"					    _s := "" ? "" : str(.execute)
>bbf2		07 10				    .byte len(_s), UF
>bbf4		01 bc 05 88 0b 88		    .word false ? 0 : +, xt_execute, z_execute
>bbfa		65 78 65 63 75 74 65		    .text _s
.bc01						+
="emit"						    _s := "" ? "" : str(.emit)
>bc01		04 18				    .byte len(_s), NN+UF
>bc03		0d bc be 86 c8 86		    .word false ? 0 : +, xt_emit, z_emit
>bc09		65 6d 69 74			    .text _s
.bc0d						+
="type"						    _s := "" ? "" : str(.type)
>bc0d		04 10				    .byte len(_s), UF
>bc0f		19 bc c0 94 ea 94		    .word false ? 0 : +, xt_type, z_type
>bc15		74 79 70 65			    .text _s
.bc19						+
="."						    _s := "." ? "." : str(.dot)
>bc19		01 10				    .byte len(_s), UF
>bc1b		22 bc 30 86 51 86		    .word false ? 0 : +, xt_dot, z_dot
>bc21		2e				    .text _s
.bc22						+
="u."						    _s := "u." ? "u." : str(.u_dot)
>bc22		02 10				    .byte len(_s), UF
>bc24		2c bc eb 94 f6 94		    .word false ? 0 : +, xt_u_dot, z_u_dot
>bc2a		75 2e				    .text _s
.bc2c						+
="u.r"						    _s := "u.r" ? "u.r" : str(.u_dot_r)
>bc2c		03 10				    .byte len(_s), UF
>bc2e		37 bc f7 94 18 95		    .word false ? 0 : +, xt_u_dot_r, z_u_dot_r
>bc34		75 2e 72			    .text _s
.bc37						+
=".r"						    _s := ".r" ? ".r" : str(.dot_r)
>bc37		02 10				    .byte len(_s), UF
>bc39		41 bc 6c 86 99 86		    .word false ? 0 : +, xt_dot_r, z_dot_r
>bc3f		2e 72				    .text _s
.bc41						+
="d."						    _s := "d." ? "d." : str(.d_dot)
>bc41		02 10				    .byte len(_s), UF
>bc43		4b bc 61 9e 7f 9e		    .word false ? 0 : +, xt_d_dot, z_d_dot
>bc49		64 2e				    .text _s
.bc4b						+
="d.r"						    _s := "d.r" ? "d.r" : str(.d_dot_r)
>bc4b		03 10				    .byte len(_s), UF
>bc4d		56 bc 80 9e aa 9e		    .word false ? 0 : +, xt_d_dot_r, z_d_dot_r
>bc53		64 2e 72			    .text _s
.bc56						+
="ud."						    _s := "ud." ? "ud." : str(.ud_dot)
>bc56		03 10				    .byte len(_s), UF
>bc58		61 bc f7 9e 09 9f		    .word false ? 0 : +, xt_ud_dot, z_ud_dot
>bc5e		75 64 2e			    .text _s
.bc61						+
="ud.r"						    _s := "ud.r" ? "ud.r" : str(.ud_dot_r)
>bc61		04 10				    .byte len(_s), UF
>bc63		6d bc 0a 9f 28 9f		    .word false ? 0 : +, xt_ud_dot_r, z_ud_dot_r
>bc69		75 64 2e 72			    .text _s
.bc6d						+
="?"						    _s := "?" ? "?" : str(.question)
>bc6d		01 00				    .byte len(_s), 0
>bc6f		76 bc 03 99 09 99		    .word false ? 0 : +, xt_question, z_question
>bc75		3f				    .text _s
.bc76						+
="false"					    _s := "false" ? "false" : str(.false)
>bc76		05 00				    .byte len(_s), 0
>bc78		83 bc d8 9d de 9d		    .word false ? 0 : +, xt_false, z_false
>bc7e		66 61 6c 73 65			    .text _s
.bc83						+
="true"						    _s := "true" ? "true" : str(.true)
>bc83		04 00				    .byte len(_s), 0
>bc85		8f bc 80 93 88 93		    .word false ? 0 : +, xt_true, z_true
>bc8b		74 72 75 65			    .text _s
.bc8f						+
="space"					    _s := "" ? "" : str(.space)
>bc8f		05 00				    .byte len(_s), 0
>bc91		9c bc c7 91 cc 91		    .word false ? 0 : +, xt_space, z_space
>bc97		73 70 61 63 65			    .text _s
.bc9c						+
="2dup"						    _s := "2dup" ? "2dup" : str(.two_dup)
>bc9c		04 10				    .byte len(_s), UF
>bc9e		a8 bc ab 93 c2 93		    .word false ? 0 : +, xt_two_dup, z_two_dup
>bca4		32 64 75 70			    .text _s
.bca8						+
="?dup"						    _s := "?dup" ? "?dup" : str(.question_dup)
>bca8		04 10				    .byte len(_s), UF
>bcaa		b4 bc c1 8e d4 8e		    .word false ? 0 : +, xt_question_dup, z_question_dup
>bcb0		3f 64 75 70			    .text _s
.bcb4						+
="+"						    _s := "+" ? "+" : str(.plus)
>bcb4		01 10				    .byte len(_s), UF
>bcb6		bd bc 4f 8e 61 8e		    .word false ? 0 : +, xt_plus, z_plus
>bcbc		2b				    .text _s
.bcbd						+
="-"						    _s := "-" ? "-" : str(.minus)
>bcbd		01 10				    .byte len(_s), UF
>bcbf		c6 bc e4 8b f6 8b		    .word false ? 0 : +, xt_minus, z_minus
>bcc5		2d				    .text _s
.bcc6						+
="1-"						    _s := "1-" ? "1-" : str(.one_minus)
>bcc6		02 10				    .byte len(_s), UF
>bcc8		d0 bc d9 8c e4 8c		    .word false ? 0 : +, xt_one_minus, z_one_minus
>bcce		31 2d				    .text _s
.bcd0						+
="1+"						    _s := "1+" ? "1+" : str(.one_plus)
>bcd0		02 10				    .byte len(_s), UF
>bcd2		da bc e5 8c ee 8c		    .word false ? 0 : +, xt_one_plus, z_one_plus
>bcd8		31 2b				    .text _s
.bcda						+
="2*"						    _s := "2*" ? "2*" : str(.two_star)
>bcda		02 10				    .byte len(_s), UF
>bcdc		e4 bc 4e 94 55 94		    .word false ? 0 : +, xt_two_star, z_two_star
>bce2		32 2a				    .text _s
.bce4						+
="2/"						    _s := "2/" ? "2/" : str(.two_slash)
>bce4		02 10				    .byte len(_s), UF
>bce6		ee bc 43 94 4d 94		    .word false ? 0 : +, xt_two_slash, z_two_slash
>bcec		32 2f				    .text _s
.bcee						+
="abs"						    _s := "" ? "" : str(.abs)
>bcee		03 10				    .byte len(_s), UF
>bcf0		f9 bc cf 80 e3 80		    .word false ? 0 : +, xt_abs, z_abs
>bcf6		61 62 73			    .text _s
.bcf9						+
="dabs"						    _s := "" ? "" : str(.dabs)
>bcf9		04 10				    .byte len(_s), UF
>bcfb		05 bd 27 9e 45 9e		    .word false ? 0 : +, xt_dabs, z_dabs
>bd01		64 61 62 73			    .text _s
.bd05						+
="and"						    _s := "" ? "" : str(.and)
>bd05		03 10				    .byte len(_s), UF
>bd07		10 bd 90 82 a1 82		    .word false ? 0 : +, xt_and, z_and
>bd0d		61 6e 64			    .text _s
.bd10						+
="or"						    _s := "" ? "" : str(.or)
>bd10		02 10				    .byte len(_s), UF
>bd12		1a bd ef 8c 00 8d		    .word false ? 0 : +, xt_or, z_or
>bd18		6f 72				    .text _s
.bd1a						+
="xor"						    _s := "" ? "" : str(.xor)
>bd1a		03 10				    .byte len(_s), UF
>bd1c		25 bd 6b 96 7c 96		    .word false ? 0 : +, xt_xor, z_xor
>bd22		78 6f 72			    .text _s
.bd25						+
="rshift"					    _s := "" ? "" : str(.rshift)
>bd25		06 10				    .byte len(_s), UF
>bd27		33 bd a9 8f bc 8f		    .word false ? 0 : +, xt_rshift, z_rshift
>bd2d		72 73 68 69 66 74		    .text _s
.bd33						+
="lshift"					    _s := "" ? "" : str(.lshift)
>bd33		06 10				    .byte len(_s), UF
>bd35		41 bd 0d 8b 20 8b		    .word false ? 0 : +, xt_lshift, z_lshift
>bd3b		6c 73 68 69 66 74		    .text _s
.bd41						+
="pick"						    _s := "" ? "" : str(.pick)
>bd41		04 00				    .byte len(_s), 0
>bd43		4d bd 3e 8e 4e 8e		    .word false ? 0 : +, xt_pick, z_pick
>bd49		70 69 63 6b			    .text _s
.bd4d						+
="char"						    _s := "" ? "" : str(.char)
>bd4d		04 00				    .byte len(_s), 0
>bd4f		59 bd 53 83 69 83		    .word false ? 0 : +, xt_char, z_char
>bd55		63 68 61 72			    .text _s
.bd59						+
="[char]"					    _s := "[char]" ? "[char]" : str(.bracket_char)
>bd59		06 05				    .byte len(_s), CO+IM
>bd5b		67 bd 0d 83 13 83		    .word false ? 0 : +, xt_bracket_char, z_bracket_char
>bd61		5b 63 68 61 72 5d		    .text _s
.bd67						+
="char+"					    _s := "char+" ? "char+" : str(.char_plus)
>bd67		05 00				    .byte len(_s), 0
>bd69		74 bd e5 8c ee 8c		    .word false ? 0 : +, xt_char_plus, z_char_plus
>bd6f		63 68 61 72 2b			    .text _s
.bd74						+
="chars"					    _s := "" ? "" : str(.chars)
>bd74		05 10				    .byte len(_s), UF
>bd76		81 bd 6a 83 6d 83		    .word false ? 0 : +, xt_chars, z_chars
>bd7c		63 68 61 72 73			    .text _s
.bd81						+
="cells"					    _s := "" ? "" : str(.cells)
>bd81		05 00				    .byte len(_s), 0
>bd83		8e bd 4e 94 55 94		    .word false ? 0 : +, xt_cells, z_cells
>bd89		63 65 6c 6c 73			    .text _s
.bd8e						+
="cell+"					    _s := "cell+" ? "cell+" : str(.cell_plus)
>bd8e		05 10				    .byte len(_s), UF
>bd90		9b bd 43 83 52 83		    .word false ? 0 : +, xt_cell_plus, z_cell_plus
>bd96		63 65 6c 6c 2b			    .text _s
.bd9b						+
="here"						    _s := "" ? "" : str(.here)
>bd9b		04 00				    .byte len(_s), 0
>bd9d		a7 bd 1b 89 25 89		    .word false ? 0 : +, xt_here, z_here
>bda3		68 65 72 65			    .text _s
.bda7						+
="="						    _s := "=" ? "=" : str(.equal)
>bda7		01 10				    .byte len(_s), UF
>bda9		b0 bd 96 87 b1 87		    .word false ? 0 : +, xt_equal, z_equal
>bdaf		3d				    .text _s
.bdb0						+
="<>"						    _s := "<>" ? "<>" : str(.not_equals)
>bdb0		02 10				    .byte len(_s), UF
>bdb2		ba bd 3e 8c 5b 8c		    .word false ? 0 : +, xt_not_equals, z_not_equals
>bdb8		3c 3e				    .text _s
.bdba						+
="<"						    _s := "<" ? "<" : str(.less_than)
>bdba		01 10				    .byte len(_s), UF
>bdbc		c3 bd dd 89 f1 89		    .word false ? 0 : +, xt_less_than, z_less_than
>bdc2		3c				    .text _s
.bdc3						+
="u<"						    _s := "u<" ? "u<" : str(.u_less_than)
>bdc3		02 10				    .byte len(_s), UF
>bdc5		cd bd 2f 95 44 95		    .word false ? 0 : +, xt_u_less_than, z_u_less_than
>bdcb		75 3c				    .text _s
.bdcd						+
="u>"						    _s := "u>" ? "u>" : str(.u_greater_than)
>bdcd		02 10				    .byte len(_s), UF
>bdcf		d7 bd 19 95 2e 95		    .word false ? 0 : +, xt_u_greater_than, z_u_greater_than
>bdd5		75 3e				    .text _s
.bdd7						+
=">"						    _s := ">" ? ">" : str(.greater_than)
>bdd7		01 10				    .byte len(_s), UF
>bdd9		e0 bd 06 89 1a 89		    .word false ? 0 : +, xt_greater_than, z_greater_than
>bddf		3e				    .text _s
.bde0						+
="0="						    _s := "0=" ? "0=" : str(.zero_equal)
>bde0		02 10				    .byte len(_s), UF
>bde2		ea bd 7d 96 8e 96		    .word false ? 0 : +, xt_zero_equal, z_zero_equal
>bde8		30 3d				    .text _s
.bdea						+
="0<>"						    _s := "0<>" ? "0<>" : str(.zero_unequal)
>bdea		03 10				    .byte len(_s), UF
>bdec		f5 bd b3 96 c2 96		    .word false ? 0 : +, xt_zero_unequal, z_zero_unequal
>bdf2		30 3c 3e			    .text _s
.bdf5						+
="0>"						    _s := "0>" ? "0>" : str(.zero_greater)
>bdf5		02 10				    .byte len(_s), UF
>bdf7		ff bd 8f 96 a2 96		    .word false ? 0 : +, xt_zero_greater, z_zero_greater
>bdfd		30 3e				    .text _s
.bdff						+
="0<"						    _s := "0<" ? "0<" : str(.zero_less)
>bdff		02 10				    .byte len(_s), UF
>be01		09 be a3 96 b2 96		    .word false ? 0 : +, xt_zero_less, z_zero_less
>be07		30 3c				    .text _s
.be09						+
="min"						    _s := "" ? "" : str(.min)
>be09		03 10				    .byte len(_s), UF
>be0b		14 be c8 8b e3 8b		    .word false ? 0 : +, xt_min, z_min
>be11		6d 69 6e			    .text _s
.be14						+
="max"						    _s := "" ? "" : str(.max)
>be14		03 10				    .byte len(_s), UF
>be16		1f be ac 8b c7 8b		    .word false ? 0 : +, xt_max, z_max
>be1c		6d 61 78			    .text _s
.be1f						+
="2drop"					    _s := "2drop" ? "2drop" : str(.two_drop)
>be1f		05 10				    .byte len(_s), UF
>be21		2c be a3 93 aa 93		    .word false ? 0 : +, xt_two_drop, z_two_drop
>be27		32 64 72 6f 70			    .text _s
.be2c						+
="2swap"					    _s := "2swap" ? "2swap" : str(.two_swap)
>be2c		05 10				    .byte len(_s), UF
>be2e		39 be 7c 94 9f 94		    .word false ? 0 : +, xt_two_swap, z_two_swap
>be34		32 73 77 61 70			    .text _s
.be39						+
="2over"					    _s := "2over" ? "2over" : str(.two_over)
>be39		05 10				    .byte len(_s), UF
>be3b		46 be e5 93 fc 93		    .word false ? 0 : +, xt_two_over, z_two_over
>be41		32 6f 76 65 72			    .text _s
.be46						+
="2!"						    _s := "2!" ? "2!" : str(.two_store)
>be46		02 10				    .byte len(_s), UF
>be48		50 be 56 94 7b 94		    .word false ? 0 : +, xt_two_store, z_two_store
>be4e		32 21				    .text _s
.be50						+
="2@"						    _s := "2@" ? "2@" : str(.two_fetch)
>be50		02 10				    .byte len(_s), UF
>be52		5a be c3 93 e4 93		    .word false ? 0 : +, xt_two_fetch, z_two_fetch
>be58		32 40				    .text _s
.be5a						+
="2variable"					    _s := "2variable" ? "2variable" : str(.two_variable)
>be5a		09 00				    .byte len(_s), 0
>be5c		6b be e8 9e f6 9e		    .word false ? 0 : +, xt_two_variable, z_two_variable
>be62		32 76 61 72 69 61 62 6c		    .text _s
>be6a		65
.be6b						+
="2constant"					    _s := "2constant" ? "2constant" : str(.two_constant)
>be6b		09 10				    .byte len(_s), UF
>be6d		7c be ab 9e cf 9e		    .word false ? 0 : +, xt_two_constant, z_two_constant
>be73		32 63 6f 6e 73 74 61 6e		    .text _s
>be7b		74
.be7c						+
="2literal"					    _s := "2literal" ? "2literal" : str(.two_literal)
>be7c		08 14				    .byte len(_s), UF+IM
>be7e		8c be d0 9e e7 9e		    .word false ? 0 : +, xt_two_literal, z_two_literal
>be84		32 6c 69 74 65 72 61 6c		    .text _s
.be8c						+
="2r@"						    _s := "2r@" ? "2r@" : str(.two_r_fetch)
>be8c		03 49				    .byte len(_s), CO+NN+ST
>be8e		97 be fd 93 23 94		    .word false ? 0 : +, xt_two_r_fetch, z_two_r_fetch
>be94		32 72 40			    .text _s
.be97						+
="2r>"						    _s := "2r>" ? "2r>" : str(.two_r_from)
>be97		03 41				    .byte len(_s), CO+ST
>be99		a2 be 26 94 40 94		    .word false ? 0 : +, xt_two_r_from, z_two_r_from
>be9f		32 72 3e			    .text _s
.bea2						+
="2>r"						    _s := "2>r" ? "2>r" : str(.two_to_r)
>bea2		03 51				    .byte len(_s), CO+UF+ST
>bea4		ad be a0 94 bd 94		    .word false ? 0 : +, xt_two_to_r, z_two_to_r
>beaa		32 3e 72			    .text _s
.bead						+
="invert"					    _s := "" ? "" : str(.invert)
>bead		06 10				    .byte len(_s), UF
>beaf		bb be 64 89 73 89		    .word false ? 0 : +, xt_invert, z_invert
>beb5		69 6e 76 65 72 74		    .text _s
.bebb						+
="negate"					    _s := "" ? "" : str(.negate)
>bebb		06 10				    .byte len(_s), UF
>bebd		c9 be 1f 8c 2f 8c		    .word false ? 0 : +, xt_negate, z_negate
>bec3		6e 65 67 61 74 65		    .text _s
.bec9						+
="dnegate"					    _s := "" ? "" : str(.dnegate)
>bec9		07 10				    .byte len(_s), UF
>becb		d8 be 46 9e 60 9e		    .word false ? 0 : +, xt_dnegate, z_dnegate
>bed1		64 6e 65 67 61 74 65		    .text _s
.bed8						+
="c,"						    _s := "c," ? "c," : str(.c_comma)
>bed8		02 10				    .byte len(_s), UF
>beda		e2 be 22 83 2c 83		    .word false ? 0 : +, xt_c_comma, z_c_comma
>bee0		63 2c				    .text _s
.bee2						+
="bounds"					    _s := "" ? "" : str(.bounds)
>bee2		06 10				    .byte len(_s), UF
>bee4		f0 be 15 9a 2d 9a		    .word false ? 0 : +, xt_bounds, z_bounds
>beea		62 6f 75 6e 64 73		    .text _s
.bef0						+
="spaces"					    _s := "" ? "" : str(.spaces)
>bef0		06 10				    .byte len(_s), UF
>bef2		fe be cd 91 e6 91		    .word false ? 0 : +, xt_spaces, z_spaces
>bef8		73 70 61 63 65 73		    .text _s
.befe						+
="bl"						    _s := "" ? "" : str(.bl)
>befe		02 00				    .byte len(_s), 0
>bf00		08 bf 04 83 0c 83		    .word false ? 0 : +, xt_bl, z_bl
>bf06		62 6c				    .text _s
.bf08						+
="-trailing"					    _s := "-trailing" ? "-trailing" : str(.minus_trailing)
>bf08		09 10				    .byte len(_s), UF
>bf0a		19 bf 1d a0 59 a0		    .word false ? 0 : +, xt_minus_trailing, z_minus_trailing
>bf10		2d 74 72 61 69 6c 69 6e		    .text _s
>bf18		67
.bf19						+
="-leading"					    _s := "-leading" ? "-leading" : str(.minus_leading)
>bf19		08 10				    .byte len(_s), UF
>bf1b		29 bf 04 a0 1c a0		    .word false ? 0 : +, xt_minus_leading, z_minus_leading
>bf21		2d 6c 65 61 64 69 6e 67		    .text _s
.bf29						+
="/string"					    _s := "/string" ? "/string" : str(.slash_string)
>bf29		07 10				    .byte len(_s), UF
>bf2b		38 bf f9 a0 18 a1		    .word false ? 0 : +, xt_slash_string, z_slash_string
>bf31		2f 73 74 72 69 6e 67		    .text _s
.bf38						+
="refill"					    _s := "" ? "" : str(.refill)
>bf38		06 00				    .byte len(_s), 0
>bf3a		46 bf 3e 8f 7f 8f		    .word false ? 0 : +, xt_refill, z_refill
>bf40		72 65 66 69 6c 6c		    .text _s
.bf46						+
="accept"					    _s := "" ? "" : str(.accept)
>bf46		06 18				    .byte len(_s), UF+NN
>bf48		54 bf e4 80 dc 81		    .word false ? 0 : +, xt_accept, z_accept
>bf4e		61 63 63 65 70 74		    .text _s
.bf54						+
="input>r"					    _s := "input>r" ? "input>r" : str(.input_to_r)
>bf54		07 08				    .byte len(_s), NN
>bf56		63 bf 79 9b 8e 9b		    .word false ? 0 : +, xt_input_to_r, z_input_to_r
>bf5c		69 6e 70 75 74 3e 72		    .text _s
.bf63						+
="r>input"					    _s := "r>input" ? "r>input" : str(.r_to_input)
>bf63		07 08				    .byte len(_s), NN
>bf65		72 bf 86 9d 9d 9d		    .word false ? 0 : +, xt_r_to_input, z_r_to_input
>bf6b		72 3e 69 6e 70 75 74		    .text _s
.bf72						+
="unused"					    _s := "" ? "" : str(.unused)
>bf72		06 00				    .byte len(_s), 0
>bf74		80 bf e1 95 f0 95		    .word false ? 0 : +, xt_unused, z_unused
>bf7a		75 6e 75 73 65 64		    .text _s
.bf80						+
="depth"					    _s := "" ? "" : str(.depth)
>bf80		05 00				    .byte len(_s), 0
>bf82		8d bf 52 85 60 85		    .word false ? 0 : +, xt_depth, z_depth
>bf88		64 65 70 74 68			    .text _s
.bf8d						+
="key"						    _s := "" ? "" : str(.key)
>bf8d		03 00				    .byte len(_s), 0
>bf8f		98 bf a7 89 b0 89		    .word false ? 0 : +, xt_key, z_key
>bf95		6b 65 79			    .text _s
.bf98						+
="allot"					    _s := "" ? "" : str(.allot)
>bf98		05 10				    .byte len(_s), UF
>bf9a		a5 bf 27 82 8f 82		    .word false ? 0 : +, xt_allot, z_allot
>bfa0		61 6c 6c 6f 74			    .text _s
.bfa5						+
="create"					    _s := "" ? "" : str(.create)
>bfa5		06 00				    .byte len(_s), 0
>bfa7		b3 bf 40 84 09 85		    .word false ? 0 : +, xt_create, z_create
>bfad		63 72 65 61 74 65		    .text _s
.bfb3						+
="does>"					    _s := "does>" ? "does>" : str(.does)
>bfb3		05 05				    .byte len(_s), CO+IM
>bfb5		c0 bf ef 85 fd 85		    .word false ? 0 : +, xt_does, z_does
>bfbb		64 6f 65 73 3e			    .text _s
.bfc0						+
="variable"					    _s := "" ? "" : str(.variable)
>bfc0		08 00				    .byte len(_s), 0
>bfc2		d0 bf f1 95 09 96		    .word false ? 0 : +, xt_variable, z_variable
>bfc8		76 61 72 69 61 62 6c 65		    .text _s
.bfd0						+
="constant"					    _s := "" ? "" : str(.constant)
>bfd0		08 10				    .byte len(_s), UF
>bfd2		e0 bf e8 83 25 84		    .word false ? 0 : +, xt_constant, z_constant
>bfd8		63 6f 6e 73 74 61 6e 74		    .text _s
.bfe0						+
="value"					    _s := "" ? "" : str(.value)
>bfe0		05 10				    .byte len(_s), UF
>bfe2		ed bf e8 83 25 84		    .word false ? 0 : +, xt_value, z_value
>bfe8		76 61 6c 75 65			    .text _s
.bfed						+
="to"						    _s := "" ? "" : str(.to)
>bfed		02 0c				    .byte len(_s), NN+IM
>bfef		f7 bf 5e 92 99 92		    .word false ? 0 : +, xt_to, z_to
>bff5		74 6f				    .text _s
.bff7						+
="s>d"						    _s := "s>d" ? "s>d" : str(.s_to_d)
>bff7		03 10				    .byte len(_s), UF
>bff9		02 c0 db 90 ec 90		    .word false ? 0 : +, xt_s_to_d, z_s_to_d
>bfff		73 3e 64			    .text _s
.c002						+
="d>s"						    _s := "d>s" ? "d>s" : str(.d_to_s)
>c002		03 10				    .byte len(_s), UF
>c004		0d c0 21 9e 26 9e		    .word false ? 0 : +, xt_d_to_s, z_d_to_s
>c00a		64 3e 73			    .text _s
.c00d						+
="d-"						    _s := "d-" ? "d-" : str(.d_minus)
>c00d		02 10				    .byte len(_s), UF
>c00f		17 c0 df 9d ff 9d		    .word false ? 0 : +, xt_d_minus, z_d_minus
>c015		64 2d				    .text _s
.c017						+
="d+"						    _s := "d+" ? "d+" : str(.d_plus)
>c017		02 10				    .byte len(_s), UF
>c019		21 c0 00 9e 20 9e		    .word false ? 0 : +, xt_d_plus, z_d_plus
>c01f		64 2b				    .text _s
.c021						+
="erase"					    _s := "" ? "" : str(.erase)
>c021		05 00				    .byte len(_s), 0
>c023		2e c0 bc 87 04 88		    .word false ? 0 : +, xt_erase, z_erase
>c029		65 72 61 73 65			    .text _s
.c02e						+
="blank"					    _s := "" ? "" : str(.blank)
>c02e		05 00				    .byte len(_s), 0
>c030		3b c0 b2 87 04 88		    .word false ? 0 : +, xt_blank, z_blank
>c036		62 6c 61 6e 6b			    .text _s
.c03b						+
="fill"						    _s := "" ? "" : str(.fill)
>c03b		04 10				    .byte len(_s), UF
>c03d		47 c0 c2 87 04 88		    .word false ? 0 : +, xt_fill, z_fill
>c043		66 69 6c 6c			    .text _s
.c047						+
="find-name"					    _s := "find-name" ? "find-name" : str(.find_name)
>c047		09 10				    .byte len(_s), UF
>c049		58 c0 d7 9a 1a 9b		    .word false ? 0 : +, xt_find_name, z_find_name
>c04f		66 69 6e 64 2d 6e 61 6d		    .text _s
>c057		65
.c058						+
="'"						    _s := "'" ? "'" : str(.tick)
>c058		01 00				    .byte len(_s), 0
>c05a		61 c0 3e 92 5d 92		    .word false ? 0 : +, xt_tick, z_tick
>c060		27				    .text _s
.c061						+
="[']"						    _s := "[']" ? "[']" : str(.bracket_tick)
>c061		03 05				    .byte len(_s), CO+IM
>c063		6c c0 14 83 1a 83		    .word false ? 0 : +, xt_bracket_tick, z_bracket_tick
>c069		5b 27 5d			    .text _s
.c06c						+
="name>int"					    _s := "name>int" ? "name>int" : str(.name_to_int)
>c06c		08 10				    .byte len(_s), UF
>c06e		7c c0 15 9c 31 9c		    .word false ? 0 : +, xt_name_to_int, z_name_to_int
>c074		6e 61 6d 65 3e 69 6e 74		    .text _s
.c07c						+
="int>name"					    _s := "int>name" ? "int>name" : str(.int_to_name)
>c07c		08 10				    .byte len(_s), UF
>c07e		8c c0 8f 9b ff 9b		    .word false ? 0 : +, xt_int_to_name, z_int_to_name
>c084		69 6e 74 3e 6e 61 6d 65		    .text _s
.c08c						+
="name>string"					    _s := "name>string" ? "name>string" : str(.name_to_string)
>c08c		0b 10				    .byte len(_s), UF
>c08e		9f c0 32 9c 48 9c		    .word false ? 0 : +, xt_name_to_string, z_name_to_string
>c094		6e 61 6d 65 3e 73 74 72		    .text _s
>c09c		69 6e 67
.c09f						+
=">body"					    _s := ">body" ? ">body" : str(.to_body)
>c09f		05 10				    .byte len(_s), UF
>c0a1		ac c0 9a 92 bc 92		    .word false ? 0 : +, xt_to_body, z_to_body
>c0a7		3e 62 6f 64 79			    .text _s
.c0ac						+
="defer"					    _s := "" ? "" : str(.defer)
>c0ac		05 00				    .byte len(_s), 0
>c0ae		b9 c0 11 85 43 85		    .word false ? 0 : +, xt_defer, z_defer
>c0b4		64 65 66 65 72			    .text _s
.c0b9						+
="latestxt"					    _s := "" ? "" : str(.latestxt)
>c0b9		08 00				    .byte len(_s), 0
>c0bb		c9 c0 0e 9c 14 9c		    .word false ? 0 : +, xt_latestxt, z_latestxt
>c0c1		6c 61 74 65 73 74 78 74		    .text _s
.c0c9						+
="latestnt"					    _s := "" ? "" : str(.latestnt)
>c0c9		08 00				    .byte len(_s), 0
>c0cb		d9 c0 00 9c 0d 9c		    .word false ? 0 : +, xt_latestnt, z_latestnt
>c0d1		6c 61 74 65 73 74 6e 74		    .text _s
.c0d9						+
="parse-name"					    _s := "parse-name" ? "parse-name" : str(.parse_name)
>c0d9		0a 08				    .byte len(_s), NN
>c0db		eb c0 4d 8d 3d 8e		    .word false ? 0 : +, xt_parse_name, z_parse_name
>c0e1		70 61 72 73 65 2d 6e 61		    .text _s
>c0e9		6d 65
.c0eb						+
="parse"					    _s := "" ? "" : str(.parse)
>c0eb		05 10				    .byte len(_s), UF
>c0ed		f8 c0 a8 8d 3d 8e		    .word false ? 0 : +, xt_parse, z_parse
>c0f3		70 61 72 73 65			    .text _s
.c0f8						+
="execute-parsing"				    _s := "execute-parsing" ? "execute-parsing" : str(.execute_parsing)
>c0f8		0f 10				    .byte len(_s), UF
>c0fa		0f c1 b0 9a d6 9a		    .word false ? 0 : +, xt_execute_parsing, z_execute_parsing
>c100		65 78 65 63 75 74 65 2d		    .text _s
>c108		70 61 72 73 69 6e 67
.c10f						+
="source"					    _s := "" ? "" : str(.source)
>c10f		06 00				    .byte len(_s), 0
>c111		1d c1 a7 91 bb 91		    .word false ? 0 : +, xt_source, z_source
>c117		73 6f 75 72 63 65		    .text _s
.c11d						+
="source-id"					    _s := "source-id" ? "source-id" : str(.source_id)
>c11d		09 00				    .byte len(_s), 0
>c11f		2e c1 bc 91 c6 91		    .word false ? 0 : +, xt_source_id, z_source_id
>c125		73 6f 75 72 63 65 2d 69		    .text _s
>c12d		64
.c12e						+
=":"						    _s := ":" ? ":" : str(.colon)
>c12e		01 00				    .byte len(_s), 0
>c130		37 c1 6e 83 b0 83		    .word false ? 0 : +, xt_colon, z_colon
>c136		3a				    .text _s
.c137						+
=";"						    _s := ";" ? ";" : str(.semicolon)
>c137		01 05				    .byte len(_s), CO+IM
>c139		40 c1 ed 90 4b 91		    .word false ? 0 : +, xt_semicolon, z_semicolon
>c13f		3b				    .text _s
.c140						+
=":noname"					    _s := ":noname" ? ":noname" : str(.colon_noname)
>c140		07 00				    .byte len(_s), 0
>c142		4f c1 b1 83 cc 83		    .word false ? 0 : +, xt_colon_noname, z_colon_noname
>c148		3a 6e 6f 6e 61 6d 65		    .text _s
.c14f						+
="compile,"					    _s := "compile," ? "compile," : str(.compile_comma)
>c14f		08 18				    .byte len(_s), UF+NN
>c151		5f c1 c3 96 61 97		    .word false ? 0 : +, xt_compile_comma, z_compile_comma
>c157		63 6f 6d 70 69 6c 65 2c		    .text _s
.c15f						+
="["						    _s := "[" ? "[" : str(.left_bracket)
>c15f		01 05				    .byte len(_s), IM+CO
>c161		68 c1 ca 89 ce 89		    .word false ? 0 : +, xt_left_bracket, z_left_bracket
>c167		5b				    .text _s
.c168						+
="]"						    _s := "]" ? "]" : str(.right_bracket)
>c168		01 04				    .byte len(_s), IM
>c16a		71 c1 86 8f 8c 8f		    .word false ? 0 : +, xt_right_bracket, z_right_bracket
>c170		5d				    .text _s
.c171						+
="literal"					    _s := "literal" ? "literal" : str(.literal)
>c171		07 15				    .byte len(_s), IM+CO+UF
>c173		80 c1 f2 89 2f 8a		    .word false ? 0 : +, xt_literal, z_literal
>c179		6c 69 74 65 72 61 6c		    .text _s
.c180						+
="sliteral"					    _s := "sliteral" ? "sliteral" : str(.sliteral)
>c180		08 15				    .byte len(_s), CO+IM+UF
>c182		90 c1 19 a1 5c a1		    .word false ? 0 : +, xt_sliteral, z_sliteral
>c188		73 6c 69 74 65 72 61 6c		    .text _s
.c190						+
='."'						    _s := '."' ? '."' : str(.dot_quote)
>c190		02 05				    .byte len(_s), CO+IM
>c192		9a c1 61 86 6b 86		    .word false ? 0 : +, xt_dot_quote, z_dot_quote
>c198		2e 22				    .text _s
.c19a						+
='s"'						    _s := 's"' ? 's"' : str(.s_quote)
>c19a		02 0c				    .byte len(_s), IM+NN
>c19c		a4 c1 d6 8f da 90		    .word false ? 0 : +, xt_s_quote, z_s_quote
>c1a2		73 22				    .text _s
.c1a4						+
='s\"'						    _s := 's\"' ? 's\"' : str(.s_backslash_quote)
>c1a4		03 04				    .byte len(_s), IM
>c1a6		af c1 bd 8f c6 8f		    .word false ? 0 : +, xt_s_backslash_quote, z_s_backslash_quote
>c1ac		73 5c 22			    .text _s
.c1af						+
="postpone"					    _s := "postpone" ? "postpone" : str(.postpone)
>c1af		08 05				    .byte len(_s), IM+CO
>c1b1		bf c1 82 8e c0 8e		    .word false ? 0 : +, xt_postpone, z_postpone
>c1b7		70 6f 73 74 70 6f 6e 65		    .text _s
.c1bf						+
="immediate"					    _s := "" ? "" : str(.immediate)
>c1bf		09 00				    .byte len(_s), 0
>c1c1		d0 c1 58 89 63 89		    .word false ? 0 : +, xt_immediate, z_immediate
>c1c7		69 6d 6d 65 64 69 61 74		    .text _s
>c1cf		65
.c1d0						+
="compile-only"					    _s := "compile-only" ? "compile-only" : str(.compile_only)
>c1d0		0c 00				    .byte len(_s), 0
>c1d2		e4 c1 dc 83 e7 83		    .word false ? 0 : +, xt_compile_only, z_compile_only
>c1d8		63 6f 6d 70 69 6c 65 2d		    .text _s
>c1e0		6f 6e 6c 79
.c1e4						+
="never-native"					    _s := "never-native" ? "never-native" : str(.never_native)
>c1e4		0c 00				    .byte len(_s), 0
>c1e6		f8 c1 4e 9c 5b 9c		    .word false ? 0 : +, xt_never_native, z_never_native
>c1ec		6e 65 76 65 72 2d 6e 61		    .text _s
>c1f4		74 69 76 65
.c1f8						+
="always-native"				    _s := "always-native" ? "always-native" : str(.always_native)
>c1f8		0d 00				    .byte len(_s), 0
>c1fa		0d c2 01 9a 0e 9a		    .word false ? 0 : +, xt_always_native, z_always_native
>c200		61 6c 77 61 79 73 2d 6e		    .text _s
>c208		61 74 69 76 65
.c20d						+
="allow-native"					    _s := "allow-native" ? "allow-native" : str(.allow_native)
>c20d		0c 00				    .byte len(_s), 0
>c20f		21 c2 f5 99 00 9a		    .word false ? 0 : +, xt_allow_native, z_allow_native
>c215		61 6c 6c 6f 77 2d 6e 61		    .text _s
>c21d		74 69 76 65
.c221						+
="nc-limit"					    _s := "nc-limit" ? "nc-limit" : str(.nc_limit)
>c221		08 08				    .byte len(_s), NN
>c223		31 c2 49 9c 4e 9c		    .word false ? 0 : +, xt_nc_limit, z_nc_limit
>c229		6e 63 2d 6c 69 6d 69 74		    .text _s
.c231						+
="strip-underflow"				    _s := "strip-underflow" ? "strip-underflow" : str(.strip_underflow)
>c231		0f 08				    .byte len(_s), NN
>c233		48 c2 9e 9d a3 9d		    .word false ? 0 : +, xt_strip_underflow, z_strip_underflow
>c239		73 74 72 69 70 2d 75 6e		    .text _s
>c241		64 65 72 66 6c 6f 77
.c248						+
="abort"					    _s := "" ? "" : str(.abort)
>c248		05 00				    .byte len(_s), 0
>c24a		55 c2 5e 80 af 80		    .word false ? 0 : +, xt_abort, z_abort
>c250		61 62 6f 72 74			    .text _s
.c255						+
='abort"'					    _s := 'abort"' ? 'abort"' : str(.abort_quote)
>c255		06 0d				    .byte len(_s), CO+IM+NN
>c257		63 c2 af 80 b9 80		    .word false ? 0 : +, xt_abort_quote, z_abort_quote
>c25d		61 62 6f 72 74 22		    .text _s
.c263						+
="do"						    _s := "" ? "" : str(.do)
>c263		02 0d				    .byte len(_s), CO+IM+NN
>c265		6d c2 8b 85 a4 85		    .word false ? 0 : +, xt_do, z_do
>c26b		64 6f				    .text _s
.c26d						+
="?do"						    _s := "?do" ? "?do" : str(.question_do)
>c26d		03 0d				    .byte len(_s), CO+IM+NN
>c26f		78 c2 61 85 a4 85		    .word false ? 0 : +, xt_question_do, z_question_do
>c275		3f 64 6f			    .text _s
.c278						+
="i"						    _s := "" ? "" : str(.i)
>c278		01 01				    .byte len(_s), CO
>c27a		81 c2 3f 89 53 89		    .word false ? 0 : +, xt_i, z_i
>c280		69				    .text _s
.c281						+
="j"						    _s := "" ? "" : str(.j)
>c281		01 01				    .byte len(_s), CO
>c283		8a c2 8d 89 a6 89		    .word false ? 0 : +, xt_j, z_j
>c289		6a				    .text _s
.c28a						+
="loop"						    _s := "" ? "" : str(.loop)
>c28a		04 05				    .byte len(_s), CO+IM
>c28c		96 c2 59 8a d1 8a		    .word false ? 0 : +, xt_loop, z_loop
>c292		6c 6f 6f 70			    .text _s
.c296						+
="+loop"					    _s := "+loop" ? "+loop" : str(.plus_loop)
>c296		05 05				    .byte len(_s), CO+IM
>c298		a3 c2 6d 8a d1 8a		    .word false ? 0 : +, xt_plus_loop, z_plus_loop
>c29e		2b 6c 6f 6f 70			    .text _s
.c2a3						+
="exit"						    _s := "" ? "" : str(.exit)
>c2a3		04 03				    .byte len(_s), AN+CO
>c2a5		af c2 19 88 1a 88		    .word false ? 0 : +, xt_exit, z_exit
>c2ab		65 78 69 74			    .text _s
.c2af						+
="unloop"					    _s := "" ? "" : str(.unloop)
>c2af		06 01				    .byte len(_s), CO
>c2b1		bd c2 cd 95 dc 95		    .word false ? 0 : +, xt_unloop, z_unloop
>c2b7		75 6e 6c 6f 6f 70		    .text _s
.c2bd						+
="leave"					    _s := "" ? "" : str(.leave)
>c2bd		05 05				    .byte len(_s), CO+IM
>c2bf		ca c2 b4 89 c9 89		    .word false ? 0 : +, xt_leave, z_leave
>c2c5		6c 65 61 76 65			    .text _s
.c2ca						+
="recurse"					    _s := "" ? "" : str(.recurse)
>c2ca		07 0d				    .byte len(_s), CO+IM+NN
>c2cc		d9 c2 01 8f 3d 8f		    .word false ? 0 : +, xt_recurse, z_recurse
>c2d2		72 65 63 75 72 73 65		    .text _s
.c2d9						+
="quit"						    _s := "" ? "" : str(.quit)
>c2d9		04 00				    .byte len(_s), 0
>c2db		e5 c2 60 80 af 80		    .word false ? 0 : +, xt_quit, z_quit
>c2e1		71 75 69 74			    .text _s
.c2e5						+
="begin"					    _s := "" ? "" : str(.begin)
>c2e5		05 05				    .byte len(_s), CO+IM
>c2e7		f2 c2 1b 89 25 89		    .word false ? 0 : +, xt_begin, z_begin
>c2ed		62 65 67 69 6e			    .text _s
.c2f2						+
="again"					    _s := "" ? "" : str(.again)
>c2f2		05 15				    .byte len(_s), CO+IM+UF
>c2f4		ff c2 1f 82 25 82		    .word false ? 0 : +, xt_again, z_again
>c2fa		61 67 61 69 6e			    .text _s
.c2ff						+
="state"					    _s := "" ? "" : str(.state)
>c2ff		05 00				    .byte len(_s), 0
>c301		0c c3 09 92 13 92		    .word false ? 0 : +, xt_state, z_state
>c307		73 74 61 74 65			    .text _s
.c30c						+
="evaluate"					    _s := "" ? "" : str(.evaluate)
>c30c		08 10				    .byte len(_s), UF
>c30e		1c c3 b2 88 05 89		    .word false ? 0 : +, xt_evaluate, z_evaluate
>c314		65 76 61 6c 75 61 74 65		    .text _s
.c31c						+
="base"						    _s := "" ? "" : str(.base)
>c31c		04 00				    .byte len(_s), 0
>c31e		28 c3 fb 82 03 83		    .word false ? 0 : +, xt_base, z_base
>c324		62 61 73 65			    .text _s
.c328						+
="digit?"					    _s := "digit?" ? "digit?" : str(.digit_question)
>c328		06 10				    .byte len(_s), UF
>c32a		36 c3 7b 9a af 9a		    .word false ? 0 : +, xt_digit_question, z_digit_question
>c330		64 69 67 69 74 3f		    .text _s
.c336						+
="number"					    _s := "" ? "" : str(.number)
>c336		06 10				    .byte len(_s), UF
>c338		44 c3 78 9c 71 9d		    .word false ? 0 : +, xt_number, z_number
>c33e		6e 75 6d 62 65 72		    .text _s
.c344						+
=">number"					    _s := ">number" ? ">number" : str(.to_number)
>c344		07 10				    .byte len(_s), UF
>c346		53 c3 c8 92 67 93		    .word false ? 0 : +, xt_to_number, z_to_number
>c34c		3e 6e 75 6d 62 65 72		    .text _s
.c353						+
="hex"						    _s := "" ? "" : str(.hex)
>c353		03 00				    .byte len(_s), 0
>c355		5e c3 26 89 2c 89		    .word false ? 0 : +, xt_hex, z_hex
>c35b		68 65 78			    .text _s
.c35e						+
="decimal"					    _s := "" ? "" : str(.decimal)
>c35e		07 00				    .byte len(_s), 0
>c360		6d c3 0a 85 10 85		    .word false ? 0 : +, xt_decimal, z_decimal
>c366		64 65 63 69 6d 61 6c		    .text _s
.c36d						+
="count"					    _s := "" ? "" : str(.count)
>c36d		05 10				    .byte len(_s), UF
>c36f		7a c3 26 84 39 84		    .word false ? 0 : +, xt_count, z_count
>c375		63 6f 75 6e 74			    .text _s
.c37a						+
="m*"						    _s := "m*" ? "m*" : str(.m_star)
>c37a		02 10				    .byte len(_s), UF
>c37c		84 c3 21 8b 3b 8b		    .word false ? 0 : +, xt_m_star, z_m_star
>c382		6d 2a				    .text _s
.c384						+
="um*"						    _s := "um*" ? "um*" : str(.um_star)
>c384		03 10				    .byte len(_s), UF
>c386		8f c3 87 95 cc 95		    .word false ? 0 : +, xt_um_star, z_um_star
>c38c		75 6d 2a			    .text _s
.c38f						+
="*"						    _s := "*" ? "*" : str(.star)
>c38f		01 10				    .byte len(_s), UF
>c391		98 c3 e7 91 ef 91		    .word false ? 0 : +, xt_star, z_star
>c397		2a				    .text _s
.c398						+
="um/mod"					    _s := "um/mod" ? "um/mod" : str(.um_slash_mod)
>c398		06 10				    .byte len(_s), UF
>c39a		a6 c3 45 95 86 95		    .word false ? 0 : +, xt_um_slash_mod, z_um_slash_mod
>c3a0		75 6d 2f 6d 6f 64		    .text _s
.c3a6						+
="sm/rem"					    _s := "sm/rem" ? "sm/rem" : str(.sm_slash_rem)
>c3a6		06 10				    .byte len(_s), UF
>c3a8		b4 c3 7e 91 a6 91		    .word false ? 0 : +, xt_sm_slash_rem, z_sm_slash_rem
>c3ae		73 6d 2f 72 65 6d		    .text _s
.c3b4						+
="fm/mod"					    _s := "fm/mod" ? "fm/mod" : str(.fm_slash_mod)
>c3b4		06 10				    .byte len(_s), UF
>c3b6		c2 c3 75 88 ab 88		    .word false ? 0 : +, xt_fm_slash_mod, z_fm_slash_mod
>c3bc		66 6d 2f 6d 6f 64		    .text _s
.c3c2						+
="/"						    _s := "/" ? "/" : str(.slash)
>c3c2		01 10				    .byte len(_s), UF
>c3c4		cb c3 61 91 7d 91		    .word false ? 0 : +, xt_slash, z_slash
>c3ca		2f				    .text _s
.c3cb						+
="/mod"						    _s := "/mod" ? "/mod" : str(.slash_mod)
>c3cb		04 10				    .byte len(_s), UF
>c3cd		d7 c3 66 91 7d 91		    .word false ? 0 : +, xt_slash_mod, z_slash_mod
>c3d3		2f 6d 6f 64			    .text _s
.c3d7						+
="mod"						    _s := "" ? "" : str(.mod)
>c3d7		03 10				    .byte len(_s), UF
>c3d9		e2 c3 f7 8b ff 8b		    .word false ? 0 : +, xt_mod, z_mod
>c3df		6d 6f 64			    .text _s
.c3e2						+
="*/mod"					    _s := "*/mod" ? "*/mod" : str(.star_slash_mod)
>c3e2		05 10				    .byte len(_s), UF
>c3e4		ef c3 f9 91 08 92		    .word false ? 0 : +, xt_star_slash_mod, z_star_slash_mod
>c3ea		2a 2f 6d 6f 64			    .text _s
.c3ef						+
="*/"						    _s := "*/" ? "*/" : str(.star_slash)
>c3ef		02 10				    .byte len(_s), UF
>c3f1		f9 c3 f0 91 f8 91		    .word false ? 0 : +, xt_star_slash, z_star_slash
>c3f7		2a 2f				    .text _s
.c3f9						+
="\"						    _s := "\" ? "\" : str(.backslash)
>c3f9		01 04				    .byte len(_s), IM
>c3fb		02 c4 d0 82 fa 82		    .word false ? 0 : +, xt_backslash, z_backslash
>c401		5c				    .text _s
.c402						+
="move"						    _s := "" ? "" : str(.move)
>c402		04 18				    .byte len(_s), NN+UF
>c404		0e c4 00 8c 1e 8c		    .word false ? 0 : +, xt_move, z_move
>c40a		6d 6f 76 65			    .text _s
.c40e						+
="cmove>"					    _s := "cmove>" ? "cmove>" : str(.cmove_up)
>c40e		06 10				    .byte len(_s), UF
>c410		1c c4 64 9f 9e 9f		    .word false ? 0 : +, xt_cmove_up, z_cmove_up
>c416		63 6d 6f 76 65 3e		    .text _s
.c41c						+
="cmove"					    _s := "" ? "" : str(.cmove)
>c41c		05 10				    .byte len(_s), UF
>c41e		29 c4 29 9f 63 9f		    .word false ? 0 : +, xt_cmove, z_cmove
>c424		63 6d 6f 76 65			    .text _s
.c429						+
="pad"						    _s := "" ? "" : str(.pad)
>c429		03 00				    .byte len(_s), 0
>c42b		34 c4 0f 8d 1e 8d		    .word false ? 0 : +, xt_pad, z_pad
>c431		70 61 64			    .text _s
.c434						+
="cleave"					    _s := "" ? "" : str(.cleave)
>c434		06 10				    .byte len(_s), UF
>c436		42 c4 2e 9a 7a 9a		    .word false ? 0 : +, xt_cleave, z_cleave
>c43c		63 6c 65 61 76 65		    .text _s
.c442						+
="hexstore"					    _s := "" ? "" : str(.hexstore)
>c442		08 10				    .byte len(_s), UF
>c444		52 c4 1b 9b 6d 9b		    .word false ? 0 : +, xt_hexstore, z_hexstore
>c44a		68 65 78 73 74 6f 72 65		    .text _s
.c452						+
="within"					    _s := "" ? "" : str(.within)
>c452		06 10				    .byte len(_s), UF
>c454		60 c4 11 96 26 96		    .word false ? 0 : +, xt_within, z_within
>c45a		77 69 74 68 69 6e		    .text _s
.c460						+
=">in"						    _s := ">in" ? ">in" : str(.to_in)
>c460		03 00				    .byte len(_s), 0
>c462		6b c4 bd 92 c7 92		    .word false ? 0 : +, xt_to_in, z_to_in
>c468		3e 69 6e			    .text _s
.c46b						+
="<#"						    _s := "<#" ? "<#" : str(.less_number_sign)
>c46b		02 00				    .byte len(_s), 0
>c46d		75 c4 cf 89 dc 89		    .word false ? 0 : +, xt_less_number_sign, z_less_number_sign
>c473		3c 23				    .text _s
.c475						+
="#"						    _s := "#" ? "#" : str(.number_sign)
>c475		01 10				    .byte len(_s), UF
>c477		7e c4 5c 8c 8c 8c		    .word false ? 0 : +, xt_number_sign, z_number_sign
>c47d		23				    .text _s
.c47e						+
="#s"						    _s := "#s" ? "#s" : str(.number_sign_s)
>c47e		02 10				    .byte len(_s), UF
>c480		88 c4 af 8c bf 8c		    .word false ? 0 : +, xt_number_sign_s, z_number_sign_s
>c486		23 73				    .text _s
.c488						+
="#>"						    _s := "#>" ? "#>" : str(.number_sign_greater)
>c488		02 10				    .byte len(_s), UF
>c48a		92 c4 8d 8c ae 8c		    .word false ? 0 : +, xt_number_sign_greater, z_number_sign_greater
>c490		23 3e				    .text _s
.c492						+
="hold"						    _s := "" ? "" : str(.hold)
>c492		04 10				    .byte len(_s), UF
>c494		9e c4 2d 89 3e 89		    .word false ? 0 : +, xt_hold, z_hold
>c49a		68 6f 6c 64			    .text _s
.c49e						+
="sign"						    _s := "" ? "" : str(.sign)
>c49e		04 10				    .byte len(_s), UF
>c4a0		aa c4 4c 91 60 91		    .word false ? 0 : +, xt_sign, z_sign
>c4a6		73 69 67 6e			    .text _s
.c4aa						+
="output"					    _s := "" ? "" : str(.output)
>c4aa		06 00				    .byte len(_s), 0
>c4ac		b8 c4 7b 9d 85 9d		    .word false ? 0 : +, xt_output, z_output
>c4b2		6f 75 74 70 75 74		    .text _s
.c4b8						+
="input"					    _s := "" ? "" : str(.input)
>c4b8		05 00				    .byte len(_s), 0
>c4ba		c5 c4 6e 9b 78 9b		    .word false ? 0 : +, xt_input, z_input
>c4c0		69 6e 70 75 74			    .text _s
.c4c5						+
="cr"						    _s := "" ? "" : str(.cr)
>c4c5		02 00				    .byte len(_s), 0
>c4c7		cf c4 3a 84 3f 84		    .word false ? 0 : +, xt_cr, z_cr
>c4cd		63 72				    .text _s
.c4cf						+
="page"						    _s := "" ? "" : str(.page)
>c4cf		04 00				    .byte len(_s), 0
>c4d1		db c4 1f 8d 3c 8d		    .word false ? 0 : +, xt_page, z_page
>c4d7		70 61 67 65			    .text _s
.c4db						+
="at-xy"					    _s := "at-xy" ? "at-xy" : str(.at_xy)
>c4db		05 10				    .byte len(_s), UF
>c4dd		e8 c4 a2 82 cf 82		    .word false ? 0 : +, xt_at_xy, z_at_xy
>c4e3		61 74 2d 78 79			    .text _s
.c4e8						+
="marker"					    _s := "" ? "" : str(.marker)
>c4e8		06 04				    .byte len(_s), IM
>c4ea		f6 c4 3c 8b 76 8b		    .word false ? 0 : +, xt_marker, z_marker
>c4f0		6d 61 72 6b 65 72		    .text _s
.c4f6						+
="words"					    _s := "" ? "" : str(.words)
>c4f6		05 00				    .byte len(_s), 0
>c4f8		03 c5 98 99 f4 99		    .word false ? 0 : +, xt_words, z_words
>c4fe		77 6f 72 64 73			    .text _s
.c503						+
="wordsize"					    _s := "" ? "" : str(.wordsize)
>c503		08 10				    .byte len(_s), UF
>c505		13 c5 b7 9d d7 9d		    .word false ? 0 : +, xt_wordsize, z_wordsize
>c50b		77 6f 72 64 73 69 7a 65		    .text _s
.c513						+
="aligned"					    _s := "" ? "" : str(.aligned)
>c513		07 00				    .byte len(_s), 0
>c515		22 c5 26 82 26 82		    .word false ? 0 : +, xt_aligned, z_aligned
>c51b		61 6c 69 67 6e 65 64		    .text _s
.c522						+
="align"					    _s := "" ? "" : str(.align)
>c522		05 00				    .byte len(_s), 0
>c524		2f c5 26 82 26 82		    .word false ? 0 : +, xt_align, z_align
>c52a		61 6c 69 67 6e			    .text _s
.c52f						+
="bell"						    _s := "" ? "" : str(.bell)
>c52f		04 00				    .byte len(_s), 0
>c531		3b c5 0f 9a 14 9a		    .word false ? 0 : +, xt_bell, z_bell
>c537		62 65 6c 6c			    .text _s
.c53b						+
="dump"						    _s := "" ? "" : str(.dump)
>c53b		04 10				    .byte len(_s), UF
>c53d		47 c5 88 98 ee 98		    .word false ? 0 : +, xt_dump, z_dump
>c543		64 75 6d 70			    .text _s
.c547						+
=".s"						    _s := ".s" ? ".s" : str(.dot_s)
>c547		02 00				    .byte len(_s), 0
>c549		51 c5 44 98 87 98		    .word false ? 0 : +, xt_dot_s, z_dot_s
>c54f		2e 73				    .text _s
.c551						+
="disasm"					    _s := "" ? "" : str(.disasm)
>c551		06 10				    .byte len(_s), UF
>c553		5f c5 85 a1 8b a1		    .word false ? 0 : +, xt_disasm, z_disasm
>c559		64 69 73 61 73 6d		    .text _s
.c55f						+
="compare"					    _s := "" ? "" : str(.compare)
>c55f		07 10				    .byte len(_s), UF
>c561		6e c5 9f 9f 03 a0		    .word false ? 0 : +, xt_compare, z_compare
>c567		63 6f 6d 70 61 72 65		    .text _s
.c56e						+
="search"					    _s := "" ? "" : str(.search)
>c56e		06 18				    .byte len(_s), UF+NN
>c570		7c c5 5a a0 f8 a0		    .word false ? 0 : +, xt_search, z_search
>c576		73 65 61 72 63 68		    .text _s
.c57c						+
="environment?"					    _s := "environment?" ? "environment?" : str(.environment_q)
>c57c		0c 10				    .byte len(_s), UF
>c57e		90 c5 dd 86 59 87		    .word false ? 0 : +, xt_environment_q, z_environment_q
>c584		65 6e 76 69 72 6f 6e 6d		    .text _s
>c58c		65 6e 74 3f
.c590						+
="find"						    _s := "" ? "" : str(.find)
>c590		04 10				    .byte len(_s), UF
>c592		9c c5 2d 88 74 88		    .word false ? 0 : +, xt_find, z_find
>c598		66 69 6e 64			    .text _s
.c59c						+
="word"						    _s := "" ? "" : str(.word)
>c59c		04 10				    .byte len(_s), UF
>c59e		a8 c5 27 96 6a 96		    .word false ? 0 : +, xt_word, z_word
>c5a4		77 6f 72 64			    .text _s
.c5a8						+
="("						    _s := "(" ? "(" : str(.paren)
>c5a8		01 04				    .byte len(_s), IM
>c5aa		b1 c5 3d 8d 4c 8d		    .word false ? 0 : +, xt_paren, z_paren
>c5b0		28				    .text _s
.c5b1						+
=".("						    _s := ".(" ? ".(" : str(.dot_paren)
>c5b1		02 04				    .byte len(_s), IM
>c5b3		bb c5 52 86 60 86		    .word false ? 0 : +, xt_dot_paren, z_dot_paren
>c5b9		2e 28				    .text _s
.c5bb						+
="if"						    _s := "" ? "" : str(.if)
>c5bb		02 0d				    .byte len(_s), IM+CO+NN
>c5bd		c5 c5 54 89 57 89		    .word false ? 0 : +, xt_if, z_if
>c5c3		69 66				    .text _s
.c5c5						+
="then"						    _s := "" ? "" : str(.then)
>c5c5		04 0d				    .byte len(_s), IM+CO+NN
>c5c7		d1 c5 b4 86 bd 86		    .word false ? 0 : +, xt_then, z_then
>c5cd		74 68 65 6e			    .text _s
.c5d1						+
="else"						    _s := "" ? "" : str(.else)
>c5d1		04 0d				    .byte len(_s), IM+CO+NN
>c5d3		dd c5 ae 86 bd 86		    .word false ? 0 : +, xt_else, z_else
>c5d9		65 6c 73 65			    .text _s
.c5dd						+
="repeat"					    _s := "" ? "" : str(.repeat)
>c5dd		06 0d				    .byte len(_s), IM+CO+NN
>c5df		eb c5 80 8f 86 8f		    .word false ? 0 : +, xt_repeat, z_repeat
>c5e5		72 65 70 65 61 74		    .text _s
.c5eb						+
="until"					    _s := "" ? "" : str(.until)
>c5eb		05 0d				    .byte len(_s), IM+CO+NN
>c5ed		f8 c5 dd 95 e0 95		    .word false ? 0 : +, xt_until, z_until
>c5f3		75 6e 74 69 6c			    .text _s
.c5f8						+
="while"					    _s := "" ? "" : str(.while)
>c5f8		05 0d				    .byte len(_s), IM+CO+NN
>c5fa		05 c6 0a 96 10 96		    .word false ? 0 : +, xt_while, z_while
>c600		77 68 69 6c 65			    .text _s
.c605						+
="case"						    _s := "" ? "" : str(.case)
>c605		04 0d				    .byte len(_s), IM+CO+NN
>c607		11 c6 d8 9d de 9d		    .word false ? 0 : +, xt_case, z_case
>c60d		63 61 73 65			    .text _s
.c611						+
="of"						    _s := "" ? "" : str(.of)
>c611		02 0d				    .byte len(_s), IM+CO+NN
>c613		1b c6 c0 8c d8 8c		    .word false ? 0 : +, xt_of, z_of
>c619		6f 66				    .text _s
.c61b						+
="endof"					    _s := "" ? "" : str(.endof)
>c61b		05 0d				    .byte len(_s), IM+CO+NN
>c61d		28 c6 ae 86 bd 86		    .word false ? 0 : +, xt_endof, z_endof
>c623		65 6e 64 6f 66			    .text _s
.c628						+
="endcase"					    _s := "" ? "" : str(.endcase)
>c628		07 0d				    .byte len(_s), IM+CO+NN
>c62a		37 c6 c8 86 dc 86		    .word false ? 0 : +, xt_endcase, z_endcase
>c630		65 6e 64 63 61 73 65		    .text _s
.c637						+
="defer@"					    _s := "defer@" ? "defer@" : str(.defer_fetch)
>c637		06 00				    .byte len(_s), 0
>c639		45 c6 44 85 4a 85		    .word false ? 0 : +, xt_defer_fetch, z_defer_fetch
>c63f		64 65 66 65 72 40		    .text _s
.c645						+
="defer!"					    _s := "defer!" ? "defer!" : str(.defer_store)
>c645		06 00				    .byte len(_s), 0
>c647		53 c6 4b 85 51 85		    .word false ? 0 : +, xt_defer_store, z_defer_store
>c64d		64 65 66 65 72 21		    .text _s
.c653						+
="is"						    _s := "is" ? "is" : str(.is)
>c653		02 04				    .byte len(_s), IM
>c655		5d c6 74 89 8c 89		    .word false ? 0 : +, xt_is, z_is
>c65b		69 73				    .text _s
.c65d						+
="action-of"					    _s := "action-of" ? "action-of" : str(.action_of)
>c65d		09 04				    .byte len(_s), IM
>c65f		6e c6 06 82 1e 82		    .word false ? 0 : +, xt_action_of, z_action_of
>c665		61 63 74 69 6f 6e 2d 6f		    .text _s
>c66d		66
.c66e						+
="useraddr"					    _s := "useraddr" ? "useraddr" : str(.useraddr)
>c66e		08 00				    .byte len(_s), 0
>c670		7e c6 ac 9d b6 9d		    .word false ? 0 : +, xt_useraddr, z_useraddr
>c676		75 73 65 72 61 64 64 72		    .text _s
.c67e						+
="buffer:"					    _s := "buffer:" ? "buffer:" : str(.buffer_colon)
>c67e		07 00				    .byte len(_s), 0
>c680		8d c6 1b 83 21 83		    .word false ? 0 : +, xt_buffer_colon, z_buffer_colon
>c686		62 75 66 66 65 72 3a		    .text _s
.c68d						+
="buffstatus"					    _s := "" ? "" : str(.buffstatus)
>c68d		0a 00				    .byte len(_s), 0
>c68f		9f c6 b4 af b9 af		    .word false ? 0 : +, xt_buffstatus, z_buffstatus
>c695		62 75 66 66 73 74 61 74		    .text _s
>c69d		75 73
.c69f						+
="buffblocknum"					    _s := "" ? "" : str(.buffblocknum)
>c69f		0c 00				    .byte len(_s), 0
>c6a1		b3 c6 7e af 83 af		    .word false ? 0 : +, xt_buffblocknum, z_buffblocknum
>c6a7		62 75 66 66 62 6c 6f 63		    .text _s
>c6af		6b 6e 75 6d
.c6b3						+
="blkbuffer"					    _s := "" ? "" : str(.blkbuffer)
>c6b3		09 00				    .byte len(_s), 0
>c6b5		c4 c6 74 ad 81 ad		    .word false ? 0 : +, xt_blkbuffer, z_blkbuffer
>c6bb		62 6c 6b 62 75 66 66 65		    .text _s
>c6c3		72
.c6c4						+
="scr"						    _s := "" ? "" : str(.scr)
>c6c4		03 08				    .byte len(_s), NN
>c6c6		cf c6 36 b0 3b b0		    .word false ? 0 : +, xt_scr, z_scr
>c6cc		73 63 72			    .text _s
.c6cf						+
="blk"						    _s := "" ? "" : str(.blk)
>c6cf		03 08				    .byte len(_s), NN
>c6d1		da c6 6f ad 74 ad		    .word false ? 0 : +, xt_blk, z_blk
>c6d7		62 6c 6b			    .text _s
.c6da						+
="block-write"					    _s := "block-write" ? "block-write" : str(.block_write)
>c6da		0b 08				    .byte len(_s), NN
>c6dc		ed c6 6b af 79 af		    .word false ? 0 : +, xt_block_write, z_block_write
>c6e2		62 6c 6f 63 6b 2d 77 72		    .text _s
>c6ea		69 74 65
.c6ed						+
="block-write-vector"				    _s := "block-write-vector" ? "block-write-vector" : str(.block_write_vector)
>c6ed		12 08				    .byte len(_s), NN
>c6ef		07 c7 79 af 7e af		    .word false ? 0 : +, xt_block_write_vector, z_block_write_vector
>c6f5		62 6c 6f 63 6b 2d 77 72		    .text _s
>c6fd		69 74 65 2d 76 65 63 74 6f 72
.c707						+
="block-read"					    _s := "block-read" ? "block-read" : str(.block_read)
>c707		0a 28				    .byte len(_s), HC+NN
>c709		19 c7 53 af 61 af		    .word false ? 0 : +, xt_block_read, z_block_read
>c70f		62 6c 6f 63 6b 2d 72 65		    .text _s
>c717		61 64
.c719						+
="block-read-vector"				    _s := "block-read-vector" ? "block-read-vector" : str(.block_read_vector)
>c719		11 28				    .byte len(_s), HC+NN
>c71b		32 c7 61 af 66 af		    .word false ? 0 : +, xt_block_read_vector, z_block_read_vector
>c721		62 6c 6f 63 6b 2d 72 65		    .text _s
>c729		61 64 2d 76 65 63 74 6f 72
.c732						+
="save-buffers"					    _s := "save-buffers" ? "save-buffers" : str(.save_buffers)
>c732		0c 00				    .byte len(_s), 0
>c734		46 c7 1b b0 35 b0		    .word false ? 0 : +, xt_save_buffers, z_save_buffers
>c73a		73 61 76 65 2d 62 75 66		    .text _s
>c742		66 65 72 73
.c746						+
="block"					    _s := "" ? "" : str(.block)
>c746		05 00				    .byte len(_s), 0
>c748		53 c7 82 ad d4 ad		    .word false ? 0 : +, xt_block, z_block
>c74e		62 6c 6f 63 6b			    .text _s
.c753						+
="update"					    _s := "" ? "" : str(.update)
>c753		06 00				    .byte len(_s), 0
>c755		61 c7 80 b0 88 b0		    .word false ? 0 : +, xt_update, z_update
>c75b		75 70 64 61 74 65		    .text _s
.c761						+
="buffer"					    _s := "" ? "" : str(.buffer)
>c761		06 00				    .byte len(_s), 0
>c763		6f c7 83 af b3 af		    .word false ? 0 : +, xt_buffer, z_buffer
>c769		62 75 66 66 65 72		    .text _s
.c76f						+
="empty-buffers"				    _s := "empty-buffers" ? "empty-buffers" : str(.empty_buffers)
>c76f		0d 00				    .byte len(_s), 0
>c771		84 c7 b9 af bf af		    .word false ? 0 : +, xt_empty_buffers, z_empty_buffers
>c777		65 6d 70 74 79 2d 62 75		    .text _s
>c77f		66 66 65 72 73
.c784						+
="flush"					    _s := "" ? "" : str(.flush)
>c784		05 00				    .byte len(_s), 0
>c786		91 c7 c0 af c9 af		    .word false ? 0 : +, xt_flush, z_flush
>c78c		66 6c 75 73 68			    .text _s
.c791						+
="load"						    _s := "" ? "" : str(.load)
>c791		04 10				    .byte len(_s), UF
>c793		9d c7 d7 af 1a b0		    .word false ? 0 : +, xt_load, z_load
>c799		6c 6f 61 64			    .text _s
.c79d						+
="thru"						    _s := "" ? "" : str(.thru)
>c79d		04 10				    .byte len(_s), UF
>c79f		a9 c7 3b b0 7f b0		    .word false ? 0 : +, xt_thru, z_thru
>c7a5		74 68 72 75			    .text _s
.c7a9						+
="list"						    _s := "" ? "" : str(.list)
>c7a9		04 10				    .byte len(_s), UF
>c7ab		b5 c7 ca af d6 af		    .word false ? 0 : +, xt_list, z_list
>c7b1		6c 69 73 74			    .text _s
.c7b5						+
="block-c65-init"				    _s := "block-c65-init" ? "block-c65-init" : str(.block_c65_init)
>c7b5		0e 00				    .byte len(_s), 0
>c7b7		cb c7 d5 ad 0a ae		    .word false ? 0 : +, xt_block_c65_init, z_block_c65_init
>c7bd		62 6c 6f 63 6b 2d 63 36		    .text _s
>c7c5		35 2d 69 6e 69 74
.c7cb						+
="block-ramdrive-init"				    _s := "block-ramdrive-init" ? "block-ramdrive-init" : str(.block_ramdrive_init)
>c7cb		13 10				    .byte len(_s), UF
>c7cd		e6 c7 2d ae 3a ae		    .word false ? 0 : +, xt_block_ramdrive_init, z_block_ramdrive_init
>c7d3		62 6c 6f 63 6b 2d 72 61		    .text _s
>c7db		6d 64 72 69 76 65 2d 69 6e 69 74
.c7e6						+
="definitions"					    _s := "" ? "" : str(.definitions)
>c7e6		0b 00				    .byte len(_s), 0
>c7e8		f9 c7 be b1 c6 b1		    .word false ? 0 : +, xt_definitions, z_definitions
>c7ee		64 65 66 69 6e 69 74 69		    .text _s
>c7f6		6f 6e 73
.c7f9						+
="wordlist"					    _s := "" ? "" : str(.wordlist)
>c7f9		08 00				    .byte len(_s), 0
>c7fb		09 c8 29 b3 3f b3		    .word false ? 0 : +, xt_wordlist, z_wordlist
>c801		77 6f 72 64 6c 69 73 74		    .text _s
.c809						+
="search-wordlist"				    _s := "search-wordlist" ? "search-wordlist" : str(.search_wordlist)
>c809		0f 10				    .byte len(_s), UF
>c80b		20 c8 62 b2 d5 b2		    .word false ? 0 : +, xt_search_wordlist, z_search_wordlist
>c811		73 65 61 72 63 68 2d 77		    .text _s
>c819		6f 72 64 6c 69 73 74
.c820						+
="set-current"					    _s := "set-current" ? "set-current" : str(.set_current)
>c820		0b 10				    .byte len(_s), UF
>c822		33 c8 d6 b2 e1 b2		    .word false ? 0 : +, xt_set_current, z_set_current
>c828		73 65 74 2d 63 75 72 72		    .text _s
>c830		65 6e 74
.c833						+
="get-current"					    _s := "get-current" ? "get-current" : str(.get_current)
>c833		0b 00				    .byte len(_s), 0
>c835		46 c8 ce b1 d8 b1		    .word false ? 0 : +, xt_get_current, z_get_current
>c83b		67 65 74 2d 63 75 72 72		    .text _s
>c843		65 6e 74
.c846						+
="set-order"					    _s := "set-order" ? "set-order" : str(.set_order)
>c846		09 00				    .byte len(_s), 0
>c848		57 c8 e2 b2 15 b3		    .word false ? 0 : +, xt_set_order, z_set_order
>c84e		73 65 74 2d 6f 72 64 65		    .text _s
>c856		72
.c857						+
="get-order"					    _s := "get-order" ? "get-order" : str(.get_order)
>c857		09 00				    .byte len(_s), 0
>c859		68 c8 d9 b1 01 b2		    .word false ? 0 : +, xt_get_order, z_get_order
>c85f		67 65 74 2d 6f 72 64 65		    .text _s
>c867		72
.c868						+
="root-wordlist"				    _s := "root-wordlist" ? "root-wordlist" : str(.root_wordlist)
>c868		0d 00				    .byte len(_s), 0
>c86a		7d c8 59 b2 61 b2		    .word false ? 0 : +, xt_root_wordlist, z_root_wordlist
>c870		72 6f 6f 74 2d 77 6f 72		    .text _s
>c878		64 6c 69 73 74
.c87d						+
="assembler-wordlist"				    _s := "assembler-wordlist" ? "assembler-wordlist" : str(.assembler_wordlist)
>c87d		12 00				    .byte len(_s), 0
>c87f		97 c8 a3 9d ab 9d		    .word false ? 0 : +, xt_assembler_wordlist, z_assembler_wordlist
>c885		61 73 73 65 6d 62 6c 65		    .text _s
>c88d		72 2d 77 6f 72 64 6c 69 73 74
.c897						+
="editor-wordlist"				    _s := "editor-wordlist" ? "editor-wordlist" : str(.editor_wordlist)
>c897		0f 00				    .byte len(_s), 0
>c899		ae c8 72 9d 7a 9d		    .word false ? 0 : +, xt_editor_wordlist, z_editor_wordlist
>c89f		65 64 69 74 6f 72 2d 77		    .text _s
>c8a7		6f 72 64 6c 69 73 74
.c8ae						+
="forth-wordlist"				    _s := "forth-wordlist" ? "forth-wordlist" : str(.forth_wordlist)
>c8ae		0e 00				    .byte len(_s), 0
>c8b0		c4 c8 d8 9d de 9d		    .word false ? 0 : +, xt_forth_wordlist, z_forth_wordlist
>c8b6		66 6f 72 74 68 2d 77 6f		    .text _s
>c8be		72 64 6c 69 73 74
.c8c4						+
="only"						    _s := "" ? "" : str(.only)
>c8c4		04 00				    .byte len(_s), 0
>c8c6		d0 c8 02 b2 08 b2		    .word false ? 0 : +, xt_only, z_only
>c8cc		6f 6e 6c 79			    .text _s
.c8d0						+
="also"						    _s := "" ? "" : str(.also)
>c8d0		04 00				    .byte len(_s), 0
>c8d2		dc c8 ae b1 bd b1		    .word false ? 0 : +, xt_also, z_also
>c8d8		61 6c 73 6f			    .text _s
.c8dc						+
="previous"					    _s := "" ? "" : str(.previous)
>c8dc		08 00				    .byte len(_s), 0
>c8de		ec c8 4c b2 58 b2		    .word false ? 0 : +, xt_previous, z_previous
>c8e4		70 72 65 76 69 6f 75 73		    .text _s
.c8ec						+
=">order"					    _s := ">order" ? ">order" : str(.to_order)
>c8ec		06 00				    .byte len(_s), 0
>c8ee		fa c8 16 b3 28 b3		    .word false ? 0 : +, xt_to_order, z_to_order
>c8f4		3e 6f 72 64 65 72		    .text _s
.c8fa						+
="order"					    _s := "" ? "" : str(.order)
>c8fa		05 00				    .byte len(_s), 0
>c8fc		07 c9 09 b2 33 b2		    .word false ? 0 : +, xt_order, z_order
>c902		6f 72 64 65 72			    .text _s
.c907						+
="forth"					    _s := "" ? "" : str(.forth)
>c907		05 00				    .byte len(_s), 0
>c909		14 c9 c7 b1 cd b1		    .word false ? 0 : +, xt_forth, z_forth
>c90f		66 6f 72 74 68			    .text _s
.c914						+
="see"						    _s := "" ? "" : str(.see)
>c914		03 08				    .byte len(_s), NN
>c916		1f c9 0a 99 97 99		    .word false ? 0 : +, xt_see, z_see
>c91c		73 65 65			    .text _s
.c91f						+
="ed:"						    _s := "ed:" ? "ed:" : str(.ed)
>c91f		03 08				    .byte len(_s), NN
>c921		2a c9 7c a7 7f a7		    .word false ? 0 : +, xt_ed, z_ed
>c927		65 64 3a			    .text _s
.c92a						+
="cold"						    _s := "" ? "" : str(.cold)
>c92a		04 00				    .byte len(_s), 0
>c92c		36 c9 00 80 af 80		    .word false ? 0 : +, xt_cold, z_cold
>c932		63 6f 6c 64			    .text _s
.c936						+
="bye"						    _s := "" ? "" : str(.bye)
>c936		03 00				    .byte len(_s), 0
>c938		00 00 41 98 44 98		    .word true ? 0 : +, xt_bye, z_bye
>c93e		62 79 65			    .text _s
.c941						root_dictionary_start:
="set-order"					    _s := "set-order" ? "set-order" : str(.set_order)
>c941		09 00				    .byte len(_s), 0
>c943		52 c9 e2 b2 15 b3		    .word false ? 0 : +, xt_set_order, z_set_order
>c949		73 65 74 2d 6f 72 64 65		    .text _s
>c951		72
.c952						+
="forth"					    _s := "" ? "" : str(.forth)
>c952		05 00				    .byte len(_s), 0
>c954		5f c9 c7 b1 cd b1		    .word false ? 0 : +, xt_forth, z_forth
>c95a		66 6f 72 74 68			    .text _s
.c95f						+
="forth-wordlist"				    _s := "forth-wordlist" ? "forth-wordlist" : str(.forth_wordlist)
>c95f		0e 00				    .byte len(_s), 0
>c961		75 c9 d8 9d de 9d		    .word false ? 0 : +, xt_forth_wordlist, z_forth_wordlist
>c967		66 6f 72 74 68 2d 77 6f		    .text _s
>c96f		72 64 6c 69 73 74
.c975						+
="words"					    _s := "" ? "" : str(.words)
>c975		05 00				    .byte len(_s), 0
>c977		00 00 98 99 f4 99		    .word true ? 0 : +, xt_words, z_words
>c97d		77 6f 72 64 73			    .text _s
.c982						editor_dictionary_start:
="o"						    _s := "o" ? "o" : str(.editor_o)
>c982		01 00				    .byte len(_s), 0
>c984		8b c9 68 b1 ad b1		    .word false ? 0 : +, xt_editor_o, z_editor_o
>c98a		6f				    .text _s
.c98b						+
="line"						    _s := "line" ? "line" : str(.editor_line)
>c98b		04 10				    .byte len(_s), UF
>c98d		97 c9 4f b1 67 b1		    .word false ? 0 : +, xt_editor_line, z_editor_line
>c993		6c 69 6e 65			    .text _s
.c997						+
="l"						    _s := "l" ? "l" : str(.editor_l)
>c997		01 00				    .byte len(_s), 0
>c999		a0 c9 d5 b0 4e b1		    .word false ? 0 : +, xt_editor_l, z_editor_l
>c99f		6c				    .text _s
.c9a0						+
="el"						    _s := "el" ? "el" : str(.editor_el)
>c9a0		02 00				    .byte len(_s), 0
>c9a2		aa c9 c3 b0 d4 b0		    .word false ? 0 : +, xt_editor_el, z_editor_el
>c9a8		65 6c				    .text _s
.c9aa						+
="erase-screen"					    _s := "erase-screen" ? "erase-screen" : str(.editor_erase_screen)
>c9aa		0c 00				    .byte len(_s), 0
>c9ac		be c9 b1 b0 c2 b0		    .word false ? 0 : +, xt_editor_erase_screen, z_editor_erase_screen
>c9b2		65 72 61 73 65 2d 73 63		    .text _s
>c9ba		72 65 65 6e
.c9be						+
="enter-screen"					    _s := "enter-screen" ? "enter-screen" : str(.editor_enter_screen)
>c9be		0c 00				    .byte len(_s), 0
>c9c0		00 00 95 b0 b0 b0		    .word true ? 0 : +, xt_editor_enter_screen, z_editor_enter_screen
>c9c6		65 6e 74 65 72 2d 73 63		    .text _s
>c9ce		72 65 65 6e
.c9d2						assembler_dictionary_start:
="adc.#"					    _s := "adc.#" ? "adc.#" : str(.asm_adc_h)
>c9d2		05 0c				    .byte len(_s), IM+NN
>c9d4		df c9 c6 a3 cb a3		    .word false ? 0 : +, xt_asm_adc_h, z_asm_adc_h
>c9da		61 64 63 2e 23			    .text _s
.c9df						+
="adc.x"					    _s := "adc.x" ? "adc.x" : str(.asm_adc_x)
>c9df		05 0c				    .byte len(_s), IM+NN
>c9e1		ec c9 cb a3 d0 a3		    .word false ? 0 : +, xt_asm_adc_x, z_asm_adc_x
>c9e7		61 64 63 2e 78			    .text _s
.c9ec						+
="adc.y"					    _s := "adc.y" ? "adc.y" : str(.asm_adc_y)
>c9ec		05 0c				    .byte len(_s), IM+NN
>c9ee		f9 c9 d0 a3 d5 a3		    .word false ? 0 : +, xt_asm_adc_y, z_asm_adc_y
>c9f4		61 64 63 2e 79			    .text _s
.c9f9						+
="adc.z"					    _s := "adc.z" ? "adc.z" : str(.asm_adc_z)
>c9f9		05 0c				    .byte len(_s), IM+NN
>c9fb		06 ca d5 a3 da a3		    .word false ? 0 : +, xt_asm_adc_z, z_asm_adc_z
>ca01		61 64 63 2e 7a			    .text _s
.ca06						+
="adc.zi"					    _s := "adc.zi" ? "adc.zi" : str(.asm_adc_zi)
>ca06		06 0c				    .byte len(_s), IM+NN
>ca08		14 ca da a3 df a3		    .word false ? 0 : +, xt_asm_adc_zi, z_asm_adc_zi
>ca0e		61 64 63 2e 7a 69		    .text _s
.ca14						+
="adc.ziy"					    _s := "adc.ziy" ? "adc.ziy" : str(.asm_adc_ziy)
>ca14		07 0c				    .byte len(_s), IM+NN
>ca16		23 ca df a3 e4 a3		    .word false ? 0 : +, xt_asm_adc_ziy, z_asm_adc_ziy
>ca1c		61 64 63 2e 7a 69 79		    .text _s
.ca23						+
="adc.zx"					    _s := "adc.zx" ? "adc.zx" : str(.asm_adc_zx)
>ca23		06 0c				    .byte len(_s), IM+NN
>ca25		31 ca e4 a3 e9 a3		    .word false ? 0 : +, xt_asm_adc_zx, z_asm_adc_zx
>ca2b		61 64 63 2e 7a 78		    .text _s
.ca31						+
="adc.zxi"					    _s := "adc.zxi" ? "adc.zxi" : str(.asm_adc_zxi)
>ca31		07 0c				    .byte len(_s), IM+NN
>ca33		40 ca e9 a3 ee a3		    .word false ? 0 : +, xt_asm_adc_zxi, z_asm_adc_zxi
>ca39		61 64 63 2e 7a 78 69		    .text _s
.ca40						+
="and."						    _s := "and." ? "and." : str(.asm_and)
>ca40		04 0c				    .byte len(_s), IM+NN
>ca42		4c ca ee a3 f3 a3		    .word false ? 0 : +, xt_asm_and, z_asm_and
>ca48		61 6e 64 2e			    .text _s
.ca4c						+
="and.#"					    _s := "and.#" ? "and.#" : str(.asm_and_h)
>ca4c		05 0c				    .byte len(_s), IM+NN
>ca4e		59 ca f3 a3 f8 a3		    .word false ? 0 : +, xt_asm_and_h, z_asm_and_h
>ca54		61 6e 64 2e 23			    .text _s
.ca59						+
="and.x"					    _s := "and.x" ? "and.x" : str(.asm_and_x)
>ca59		05 0c				    .byte len(_s), IM+NN
>ca5b		66 ca f8 a3 fd a3		    .word false ? 0 : +, xt_asm_and_x, z_asm_and_x
>ca61		61 6e 64 2e 78			    .text _s
.ca66						+
="and.y"					    _s := "and.y" ? "and.y" : str(.asm_and_y)
>ca66		05 0c				    .byte len(_s), IM+NN
>ca68		73 ca fd a3 02 a4		    .word false ? 0 : +, xt_asm_and_y, z_asm_and_y
>ca6e		61 6e 64 2e 79			    .text _s
.ca73						+
="and.z"					    _s := "and.z" ? "and.z" : str(.asm_and_z)
>ca73		05 0c				    .byte len(_s), IM+NN
>ca75		80 ca 02 a4 07 a4		    .word false ? 0 : +, xt_asm_and_z, z_asm_and_z
>ca7b		61 6e 64 2e 7a			    .text _s
.ca80						+
="and.zi"					    _s := "and.zi" ? "and.zi" : str(.asm_and_zi)
>ca80		06 0c				    .byte len(_s), IM+NN
>ca82		8e ca 07 a4 0c a4		    .word false ? 0 : +, xt_asm_and_zi, z_asm_and_zi
>ca88		61 6e 64 2e 7a 69		    .text _s
.ca8e						+
="and.ziy"					    _s := "and.ziy" ? "and.ziy" : str(.asm_and_ziy)
>ca8e		07 0c				    .byte len(_s), IM+NN
>ca90		9d ca 0c a4 11 a4		    .word false ? 0 : +, xt_asm_and_ziy, z_asm_and_ziy
>ca96		61 6e 64 2e 7a 69 79		    .text _s
.ca9d						+
="and.zx"					    _s := "and.zx" ? "and.zx" : str(.asm_and_zx)
>ca9d		06 0c				    .byte len(_s), IM+NN
>ca9f		ab ca 11 a4 16 a4		    .word false ? 0 : +, xt_asm_and_zx, z_asm_and_zx
>caa5		61 6e 64 2e 7a 78		    .text _s
.caab						+
="and.zxi"					    _s := "and.zxi" ? "and.zxi" : str(.asm_and_zxi)
>caab		07 0c				    .byte len(_s), IM+NN
>caad		ba ca 16 a4 1b a4		    .word false ? 0 : +, xt_asm_and_zxi, z_asm_and_zxi
>cab3		61 6e 64 2e 7a 78 69		    .text _s
.caba						+
="asl"						    _s := "asl" ? "asl" : str(.asm_asl)
>caba		03 0c				    .byte len(_s), IM+NN
>cabc		c5 ca 1b a4 20 a4		    .word false ? 0 : +, xt_asm_asl, z_asm_asl
>cac2		61 73 6c			    .text _s
.cac5						+
="asl.a"					    _s := "asl.a" ? "asl.a" : str(.asm_asl_a)
>cac5		05 0c				    .byte len(_s), IM+NN
>cac7		d2 ca 20 a4 25 a4		    .word false ? 0 : +, xt_asm_asl_a, z_asm_asl_a
>cacd		61 73 6c 2e 61			    .text _s
.cad2						+
="asl.x"					    _s := "asl.x" ? "asl.x" : str(.asm_asl_x)
>cad2		05 0c				    .byte len(_s), IM+NN
>cad4		df ca 25 a4 2a a4		    .word false ? 0 : +, xt_asm_asl_x, z_asm_asl_x
>cada		61 73 6c 2e 78			    .text _s
.cadf						+
="asl.z"					    _s := "asl.z" ? "asl.z" : str(.asm_asl_z)
>cadf		05 0c				    .byte len(_s), IM+NN
>cae1		ec ca 2a a4 2f a4		    .word false ? 0 : +, xt_asm_asl_z, z_asm_asl_z
>cae7		61 73 6c 2e 7a			    .text _s
.caec						+
="asl.zx"					    _s := "asl.zx" ? "asl.zx" : str(.asm_asl_zx)
>caec		06 0c				    .byte len(_s), IM+NN
>caee		fa ca 2f a4 34 a4		    .word false ? 0 : +, xt_asm_asl_zx, z_asm_asl_zx
>caf4		61 73 6c 2e 7a 78		    .text _s
.cafa						+
="bcc"						    _s := "bcc" ? "bcc" : str(.asm_bcc)
>cafa		03 0c				    .byte len(_s), IM+NN
>cafc		05 cb 34 a4 39 a4		    .word false ? 0 : +, xt_asm_bcc, z_asm_bcc
>cb02		62 63 63			    .text _s
.cb05						+
="bcs"						    _s := "bcs" ? "bcs" : str(.asm_bcs)
>cb05		03 0c				    .byte len(_s), IM+NN
>cb07		10 cb 39 a4 40 a4		    .word false ? 0 : +, xt_asm_bcs, z_asm_bcs
>cb0d		62 63 73			    .text _s
.cb10						+
="beq"						    _s := "beq" ? "beq" : str(.asm_beq)
>cb10		03 0c				    .byte len(_s), IM+NN
>cb12		1b cb 40 a4 45 a4		    .word false ? 0 : +, xt_asm_beq, z_asm_beq
>cb18		62 65 71			    .text _s
.cb1b						+
="bit"						    _s := "bit" ? "bit" : str(.asm_bit)
>cb1b		03 0c				    .byte len(_s), IM+NN
>cb1d		26 cb 45 a4 4a a4		    .word false ? 0 : +, xt_asm_bit, z_asm_bit
>cb23		62 69 74			    .text _s
.cb26						+
="bit.#"					    _s := "bit.#" ? "bit.#" : str(.asm_bit_h)
>cb26		05 0c				    .byte len(_s), IM+NN
>cb28		33 cb 4a a4 4f a4		    .word false ? 0 : +, xt_asm_bit_h, z_asm_bit_h
>cb2e		62 69 74 2e 23			    .text _s
.cb33						+
="bit.x"					    _s := "bit.x" ? "bit.x" : str(.asm_bit_x)
>cb33		05 0c				    .byte len(_s), IM+NN
>cb35		40 cb 4f a4 54 a4		    .word false ? 0 : +, xt_asm_bit_x, z_asm_bit_x
>cb3b		62 69 74 2e 78			    .text _s
.cb40						+
="bit.z"					    _s := "bit.z" ? "bit.z" : str(.asm_bit_z)
>cb40		05 0c				    .byte len(_s), IM+NN
>cb42		4d cb 54 a4 59 a4		    .word false ? 0 : +, xt_asm_bit_z, z_asm_bit_z
>cb48		62 69 74 2e 7a			    .text _s
.cb4d						+
="bit.zx"					    _s := "bit.zx" ? "bit.zx" : str(.asm_bit_zx)
>cb4d		06 0c				    .byte len(_s), IM+NN
>cb4f		5b cb 59 a4 5e a4		    .word false ? 0 : +, xt_asm_bit_zx, z_asm_bit_zx
>cb55		62 69 74 2e 7a 78		    .text _s
.cb5b						+
="bmi"						    _s := "bmi" ? "bmi" : str(.asm_bmi)
>cb5b		03 0c				    .byte len(_s), IM+NN
>cb5d		66 cb 5e a4 63 a4		    .word false ? 0 : +, xt_asm_bmi, z_asm_bmi
>cb63		62 6d 69			    .text _s
.cb66						+
="bne"						    _s := "bne" ? "bne" : str(.asm_bne)
>cb66		03 0c				    .byte len(_s), IM+NN
>cb68		71 cb 63 a4 68 a4		    .word false ? 0 : +, xt_asm_bne, z_asm_bne
>cb6e		62 6e 65			    .text _s
.cb71						+
="bpl"						    _s := "bpl" ? "bpl" : str(.asm_bpl)
>cb71		03 0c				    .byte len(_s), IM+NN
>cb73		7c cb 68 a4 6d a4		    .word false ? 0 : +, xt_asm_bpl, z_asm_bpl
>cb79		62 70 6c			    .text _s
.cb7c						+
="bra"						    _s := "bra" ? "bra" : str(.asm_bra)
>cb7c		03 0c				    .byte len(_s), IM+NN
>cb7e		87 cb 6d a4 72 a4		    .word false ? 0 : +, xt_asm_bra, z_asm_bra
>cb84		62 72 61			    .text _s
.cb87						+
="brk"						    _s := "brk" ? "brk" : str(.asm_brk)
>cb87		03 0c				    .byte len(_s), IM+NN
>cb89		92 cb 72 a4 77 a4		    .word false ? 0 : +, xt_asm_brk, z_asm_brk
>cb8f		62 72 6b			    .text _s
.cb92						+
="bvc"						    _s := "bvc" ? "bvc" : str(.asm_bvc)
>cb92		03 0c				    .byte len(_s), IM+NN
>cb94		9d cb 77 a4 7c a4		    .word false ? 0 : +, xt_asm_bvc, z_asm_bvc
>cb9a		62 76 63			    .text _s
.cb9d						+
="bvs"						    _s := "bvs" ? "bvs" : str(.asm_bvs)
>cb9d		03 0c				    .byte len(_s), IM+NN
>cb9f		a8 cb 7c a4 81 a4		    .word false ? 0 : +, xt_asm_bvs, z_asm_bvs
>cba5		62 76 73			    .text _s
.cba8						+
="clc"						    _s := "clc" ? "clc" : str(.asm_clc)
>cba8		03 0c				    .byte len(_s), IM+NN
>cbaa		b3 cb 81 a4 86 a4		    .word false ? 0 : +, xt_asm_clc, z_asm_clc
>cbb0		63 6c 63			    .text _s
.cbb3						+
="cld"						    _s := "cld" ? "cld" : str(.asm_cld)
>cbb3		03 0c				    .byte len(_s), IM+NN
>cbb5		be cb 86 a4 8b a4		    .word false ? 0 : +, xt_asm_cld, z_asm_cld
>cbbb		63 6c 64			    .text _s
.cbbe						+
="cli"						    _s := "cli" ? "cli" : str(.asm_cli)
>cbbe		03 0c				    .byte len(_s), IM+NN
>cbc0		c9 cb 8b a4 90 a4		    .word false ? 0 : +, xt_asm_cli, z_asm_cli
>cbc6		63 6c 69			    .text _s
.cbc9						+
="clv"						    _s := "clv" ? "clv" : str(.asm_clv)
>cbc9		03 0c				    .byte len(_s), IM+NN
>cbcb		d4 cb 90 a4 95 a4		    .word false ? 0 : +, xt_asm_clv, z_asm_clv
>cbd1		63 6c 76			    .text _s
.cbd4						+
="cmp"						    _s := "cmp" ? "cmp" : str(.asm_cmp)
>cbd4		03 0c				    .byte len(_s), IM+NN
>cbd6		df cb 95 a4 9a a4		    .word false ? 0 : +, xt_asm_cmp, z_asm_cmp
>cbdc		63 6d 70			    .text _s
.cbdf						+
="cmp.#"					    _s := "cmp.#" ? "cmp.#" : str(.asm_cmp_h)
>cbdf		05 0c				    .byte len(_s), IM+NN
>cbe1		ec cb 9a a4 9f a4		    .word false ? 0 : +, xt_asm_cmp_h, z_asm_cmp_h
>cbe7		63 6d 70 2e 23			    .text _s
.cbec						+
="cmp.x"					    _s := "cmp.x" ? "cmp.x" : str(.asm_cmp_x)
>cbec		05 0c				    .byte len(_s), IM+NN
>cbee		f9 cb 9f a4 a4 a4		    .word false ? 0 : +, xt_asm_cmp_x, z_asm_cmp_x
>cbf4		63 6d 70 2e 78			    .text _s
.cbf9						+
="cmp.y"					    _s := "cmp.y" ? "cmp.y" : str(.asm_cmp_y)
>cbf9		05 0c				    .byte len(_s), IM+NN
>cbfb		06 cc a4 a4 a9 a4		    .word false ? 0 : +, xt_asm_cmp_y, z_asm_cmp_y
>cc01		63 6d 70 2e 79			    .text _s
.cc06						+
="cmp.z"					    _s := "cmp.z" ? "cmp.z" : str(.asm_cmp_z)
>cc06		05 0c				    .byte len(_s), IM+NN
>cc08		13 cc a9 a4 ae a4		    .word false ? 0 : +, xt_asm_cmp_z, z_asm_cmp_z
>cc0e		63 6d 70 2e 7a			    .text _s
.cc13						+
="cmp.zi"					    _s := "cmp.zi" ? "cmp.zi" : str(.asm_cmp_zi)
>cc13		06 0c				    .byte len(_s), IM+NN
>cc15		21 cc ae a4 b3 a4		    .word false ? 0 : +, xt_asm_cmp_zi, z_asm_cmp_zi
>cc1b		63 6d 70 2e 7a 69		    .text _s
.cc21						+
="cmp.ziy"					    _s := "cmp.ziy" ? "cmp.ziy" : str(.asm_cmp_ziy)
>cc21		07 0c				    .byte len(_s), IM+NN
>cc23		30 cc b3 a4 b8 a4		    .word false ? 0 : +, xt_asm_cmp_ziy, z_asm_cmp_ziy
>cc29		63 6d 70 2e 7a 69 79		    .text _s
.cc30						+
="cmp.zx"					    _s := "cmp.zx" ? "cmp.zx" : str(.asm_cmp_zx)
>cc30		06 0c				    .byte len(_s), IM+NN
>cc32		3e cc b8 a4 bd a4		    .word false ? 0 : +, xt_asm_cmp_zx, z_asm_cmp_zx
>cc38		63 6d 70 2e 7a 78		    .text _s
.cc3e						+
="cmp.zxi"					    _s := "cmp.zxi" ? "cmp.zxi" : str(.asm_cmp_zxi)
>cc3e		07 0c				    .byte len(_s), IM+NN
>cc40		4d cc bd a4 c2 a4		    .word false ? 0 : +, xt_asm_cmp_zxi, z_asm_cmp_zxi
>cc46		63 6d 70 2e 7a 78 69		    .text _s
.cc4d						+
="cpx"						    _s := "cpx" ? "cpx" : str(.asm_cpx)
>cc4d		03 0c				    .byte len(_s), IM+NN
>cc4f		58 cc c2 a4 c7 a4		    .word false ? 0 : +, xt_asm_cpx, z_asm_cpx
>cc55		63 70 78			    .text _s
.cc58						+
="cpx.#"					    _s := "cpx.#" ? "cpx.#" : str(.asm_cpx_h)
>cc58		05 0c				    .byte len(_s), IM+NN
>cc5a		65 cc c7 a4 cc a4		    .word false ? 0 : +, xt_asm_cpx_h, z_asm_cpx_h
>cc60		63 70 78 2e 23			    .text _s
.cc65						+
="cpx.z"					    _s := "cpx.z" ? "cpx.z" : str(.asm_cpx_z)
>cc65		05 0c				    .byte len(_s), IM+NN
>cc67		72 cc cc a4 d1 a4		    .word false ? 0 : +, xt_asm_cpx_z, z_asm_cpx_z
>cc6d		63 70 78 2e 7a			    .text _s
.cc72						+
="cpy"						    _s := "cpy" ? "cpy" : str(.asm_cpy)
>cc72		03 0c				    .byte len(_s), IM+NN
>cc74		7d cc d1 a4 d8 a4		    .word false ? 0 : +, xt_asm_cpy, z_asm_cpy
>cc7a		63 70 79			    .text _s
.cc7d						+
="cpy.#"					    _s := "cpy.#" ? "cpy.#" : str(.asm_cpy_h)
>cc7d		05 0c				    .byte len(_s), IM+NN
>cc7f		8a cc d8 a4 dd a4		    .word false ? 0 : +, xt_asm_cpy_h, z_asm_cpy_h
>cc85		63 70 79 2e 23			    .text _s
.cc8a						+
="cpy.z"					    _s := "cpy.z" ? "cpy.z" : str(.asm_cpy_z)
>cc8a		05 0c				    .byte len(_s), IM+NN
>cc8c		97 cc dd a4 e2 a4		    .word false ? 0 : +, xt_asm_cpy_z, z_asm_cpy_z
>cc92		63 70 79 2e 7a			    .text _s
.cc97						+
="dec"						    _s := "dec" ? "dec" : str(.asm_dec)
>cc97		03 0c				    .byte len(_s), IM+NN
>cc99		a2 cc e2 a4 e7 a4		    .word false ? 0 : +, xt_asm_dec, z_asm_dec
>cc9f		64 65 63			    .text _s
.cca2						+
="dec.a"					    _s := "dec.a" ? "dec.a" : str(.asm_dec_a)
>cca2		05 0c				    .byte len(_s), IM+NN
>cca4		af cc e7 a4 ec a4		    .word false ? 0 : +, xt_asm_dec_a, z_asm_dec_a
>ccaa		64 65 63 2e 61			    .text _s
.ccaf						+
="dec.x"					    _s := "dec.x" ? "dec.x" : str(.asm_dec_x)
>ccaf		05 0c				    .byte len(_s), IM+NN
>ccb1		bc cc ec a4 f1 a4		    .word false ? 0 : +, xt_asm_dec_x, z_asm_dec_x
>ccb7		64 65 63 2e 78			    .text _s
.ccbc						+
="dec.z"					    _s := "dec.z" ? "dec.z" : str(.asm_dec_z)
>ccbc		05 0c				    .byte len(_s), IM+NN
>ccbe		c9 cc f1 a4 f6 a4		    .word false ? 0 : +, xt_asm_dec_z, z_asm_dec_z
>ccc4		64 65 63 2e 7a			    .text _s
.ccc9						+
="dec.zx"					    _s := "dec.zx" ? "dec.zx" : str(.asm_dec_zx)
>ccc9		06 0c				    .byte len(_s), IM+NN
>cccb		d7 cc f6 a4 fb a4		    .word false ? 0 : +, xt_asm_dec_zx, z_asm_dec_zx
>ccd1		64 65 63 2e 7a 78		    .text _s
.ccd7						+
="dex"						    _s := "dex" ? "dex" : str(.asm_dex)
>ccd7		03 0c				    .byte len(_s), IM+NN
>ccd9		e2 cc fb a4 00 a5		    .word false ? 0 : +, xt_asm_dex, z_asm_dex
>ccdf		64 65 78			    .text _s
.cce2						+
="dey"						    _s := "dey" ? "dey" : str(.asm_dey)
>cce2		03 0c				    .byte len(_s), IM+NN
>cce4		ed cc 00 a5 05 a5		    .word false ? 0 : +, xt_asm_dey, z_asm_dey
>ccea		64 65 79			    .text _s
.cced						+
="eor"						    _s := "eor" ? "eor" : str(.asm_eor)
>cced		03 0c				    .byte len(_s), IM+NN
>ccef		f8 cc 05 a5 0a a5		    .word false ? 0 : +, xt_asm_eor, z_asm_eor
>ccf5		65 6f 72			    .text _s
.ccf8						+
="eor.#"					    _s := "eor.#" ? "eor.#" : str(.asm_eor_h)
>ccf8		05 0c				    .byte len(_s), IM+NN
>ccfa		05 cd 0a a5 0f a5		    .word false ? 0 : +, xt_asm_eor_h, z_asm_eor_h
>cd00		65 6f 72 2e 23			    .text _s
.cd05						+
="eor.x"					    _s := "eor.x" ? "eor.x" : str(.asm_eor_x)
>cd05		05 0c				    .byte len(_s), IM+NN
>cd07		12 cd 0f a5 14 a5		    .word false ? 0 : +, xt_asm_eor_x, z_asm_eor_x
>cd0d		65 6f 72 2e 78			    .text _s
.cd12						+
="eor.y"					    _s := "eor.y" ? "eor.y" : str(.asm_eor_y)
>cd12		05 0c				    .byte len(_s), IM+NN
>cd14		1f cd 14 a5 19 a5		    .word false ? 0 : +, xt_asm_eor_y, z_asm_eor_y
>cd1a		65 6f 72 2e 79			    .text _s
.cd1f						+
="eor.z"					    _s := "eor.z" ? "eor.z" : str(.asm_eor_z)
>cd1f		05 0c				    .byte len(_s), IM+NN
>cd21		2c cd 19 a5 1e a5		    .word false ? 0 : +, xt_asm_eor_z, z_asm_eor_z
>cd27		65 6f 72 2e 7a			    .text _s
.cd2c						+
="eor.zi"					    _s := "eor.zi" ? "eor.zi" : str(.asm_eor_zi)
>cd2c		06 0c				    .byte len(_s), IM+NN
>cd2e		3a cd 1e a5 23 a5		    .word false ? 0 : +, xt_asm_eor_zi, z_asm_eor_zi
>cd34		65 6f 72 2e 7a 69		    .text _s
.cd3a						+
="eor.ziy"					    _s := "eor.ziy" ? "eor.ziy" : str(.asm_eor_ziy)
>cd3a		07 0c				    .byte len(_s), IM+NN
>cd3c		49 cd 23 a5 28 a5		    .word false ? 0 : +, xt_asm_eor_ziy, z_asm_eor_ziy
>cd42		65 6f 72 2e 7a 69 79		    .text _s
.cd49						+
="eor.zx"					    _s := "eor.zx" ? "eor.zx" : str(.asm_eor_zx)
>cd49		06 0c				    .byte len(_s), IM+NN
>cd4b		57 cd 28 a5 2d a5		    .word false ? 0 : +, xt_asm_eor_zx, z_asm_eor_zx
>cd51		65 6f 72 2e 7a 78		    .text _s
.cd57						+
="eor.zxi"					    _s := "eor.zxi" ? "eor.zxi" : str(.asm_eor_zxi)
>cd57		07 0c				    .byte len(_s), IM+NN
>cd59		66 cd 2d a5 32 a5		    .word false ? 0 : +, xt_asm_eor_zxi, z_asm_eor_zxi
>cd5f		65 6f 72 2e 7a 78 69		    .text _s
.cd66						+
="inc"						    _s := "inc" ? "inc" : str(.asm_inc)
>cd66		03 0c				    .byte len(_s), IM+NN
>cd68		71 cd 32 a5 37 a5		    .word false ? 0 : +, xt_asm_inc, z_asm_inc
>cd6e		69 6e 63			    .text _s
.cd71						+
="inc.a"					    _s := "inc.a" ? "inc.a" : str(.asm_inc_a)
>cd71		05 0c				    .byte len(_s), IM+NN
>cd73		7e cd 37 a5 3c a5		    .word false ? 0 : +, xt_asm_inc_a, z_asm_inc_a
>cd79		69 6e 63 2e 61			    .text _s
.cd7e						+
="inc.x"					    _s := "inc.x" ? "inc.x" : str(.asm_inc_x)
>cd7e		05 0c				    .byte len(_s), IM+NN
>cd80		8b cd 3c a5 41 a5		    .word false ? 0 : +, xt_asm_inc_x, z_asm_inc_x
>cd86		69 6e 63 2e 78			    .text _s
.cd8b						+
="inc.z"					    _s := "inc.z" ? "inc.z" : str(.asm_inc_z)
>cd8b		05 0c				    .byte len(_s), IM+NN
>cd8d		98 cd 41 a5 46 a5		    .word false ? 0 : +, xt_asm_inc_z, z_asm_inc_z
>cd93		69 6e 63 2e 7a			    .text _s
.cd98						+
="inc.zx"					    _s := "inc.zx" ? "inc.zx" : str(.asm_inc_zx)
>cd98		06 0c				    .byte len(_s), IM+NN
>cd9a		a6 cd 46 a5 4b a5		    .word false ? 0 : +, xt_asm_inc_zx, z_asm_inc_zx
>cda0		69 6e 63 2e 7a 78		    .text _s
.cda6						+
="inx"						    _s := "inx" ? "inx" : str(.asm_inx)
>cda6		03 0c				    .byte len(_s), IM+NN
>cda8		b1 cd 4b a5 50 a5		    .word false ? 0 : +, xt_asm_inx, z_asm_inx
>cdae		69 6e 78			    .text _s
.cdb1						+
="iny"						    _s := "iny" ? "iny" : str(.asm_iny)
>cdb1		03 0c				    .byte len(_s), IM+NN
>cdb3		bc cd 50 a5 55 a5		    .word false ? 0 : +, xt_asm_iny, z_asm_iny
>cdb9		69 6e 79			    .text _s
.cdbc						+
="jmp"						    _s := "jmp" ? "jmp" : str(.asm_jmp)
>cdbc		03 0c				    .byte len(_s), IM+NN
>cdbe		c7 cd 55 a5 5a a5		    .word false ? 0 : +, xt_asm_jmp, z_asm_jmp
>cdc4		6a 6d 70			    .text _s
.cdc7						+
="jmp.i"					    _s := "jmp.i" ? "jmp.i" : str(.asm_jmp_i)
>cdc7		05 0c				    .byte len(_s), IM+NN
>cdc9		d4 cd 5a a5 5f a5		    .word false ? 0 : +, xt_asm_jmp_i, z_asm_jmp_i
>cdcf		6a 6d 70 2e 69			    .text _s
.cdd4						+
="jmp.xi"					    _s := "jmp.xi" ? "jmp.xi" : str(.asm_jmp_xi)
>cdd4		06 0c				    .byte len(_s), IM+NN
>cdd6		e2 cd 5f a5 64 a5		    .word false ? 0 : +, xt_asm_jmp_xi, z_asm_jmp_xi
>cddc		6a 6d 70 2e 78 69		    .text _s
.cde2						+
="jsr"						    _s := "jsr" ? "jsr" : str(.asm_jsr)
>cde2		03 0c				    .byte len(_s), IM+NN
>cde4		ed cd 64 a5 69 a5		    .word false ? 0 : +, xt_asm_jsr, z_asm_jsr
>cdea		6a 73 72			    .text _s
.cded						+
="lda"						    _s := "lda" ? "lda" : str(.asm_lda)
>cded		03 0c				    .byte len(_s), IM+NN
>cdef		f8 cd 69 a5 6e a5		    .word false ? 0 : +, xt_asm_lda, z_asm_lda
>cdf5		6c 64 61			    .text _s
.cdf8						+
="lda.#"					    _s := "lda.#" ? "lda.#" : str(.asm_lda_h)
>cdf8		05 0c				    .byte len(_s), IM+NN
>cdfa		05 ce 6e a5 73 a5		    .word false ? 0 : +, xt_asm_lda_h, z_asm_lda_h
>ce00		6c 64 61 2e 23			    .text _s
.ce05						+
="lda.x"					    _s := "lda.x" ? "lda.x" : str(.asm_lda_x)
>ce05		05 0c				    .byte len(_s), IM+NN
>ce07		12 ce 73 a5 78 a5		    .word false ? 0 : +, xt_asm_lda_x, z_asm_lda_x
>ce0d		6c 64 61 2e 78			    .text _s
.ce12						+
="lda.y"					    _s := "lda.y" ? "lda.y" : str(.asm_lda_y)
>ce12		05 0c				    .byte len(_s), IM+NN
>ce14		1f ce 78 a5 7d a5		    .word false ? 0 : +, xt_asm_lda_y, z_asm_lda_y
>ce1a		6c 64 61 2e 79			    .text _s
.ce1f						+
="lda.z"					    _s := "lda.z" ? "lda.z" : str(.asm_lda_z)
>ce1f		05 0c				    .byte len(_s), IM+NN
>ce21		2c ce 7d a5 82 a5		    .word false ? 0 : +, xt_asm_lda_z, z_asm_lda_z
>ce27		6c 64 61 2e 7a			    .text _s
.ce2c						+
="lda.zi"					    _s := "lda.zi" ? "lda.zi" : str(.asm_lda_zi)
>ce2c		06 0c				    .byte len(_s), IM+NN
>ce2e		3a ce 82 a5 87 a5		    .word false ? 0 : +, xt_asm_lda_zi, z_asm_lda_zi
>ce34		6c 64 61 2e 7a 69		    .text _s
.ce3a						+
="lda.ziy"					    _s := "lda.ziy" ? "lda.ziy" : str(.asm_lda_ziy)
>ce3a		07 0c				    .byte len(_s), IM+NN
>ce3c		49 ce 87 a5 8c a5		    .word false ? 0 : +, xt_asm_lda_ziy, z_asm_lda_ziy
>ce42		6c 64 61 2e 7a 69 79		    .text _s
.ce49						+
="lda.zx"					    _s := "lda.zx" ? "lda.zx" : str(.asm_lda_zx)
>ce49		06 0c				    .byte len(_s), IM+NN
>ce4b		57 ce 8c a5 91 a5		    .word false ? 0 : +, xt_asm_lda_zx, z_asm_lda_zx
>ce51		6c 64 61 2e 7a 78		    .text _s
.ce57						+
="lda.zxi"					    _s := "lda.zxi" ? "lda.zxi" : str(.asm_lda_zxi)
>ce57		07 0c				    .byte len(_s), IM+NN
>ce59		66 ce 91 a5 96 a5		    .word false ? 0 : +, xt_asm_lda_zxi, z_asm_lda_zxi
>ce5f		6c 64 61 2e 7a 78 69		    .text _s
.ce66						+
="ldx"						    _s := "ldx" ? "ldx" : str(.asm_ldx)
>ce66		03 0c				    .byte len(_s), IM+NN
>ce68		71 ce 96 a5 9b a5		    .word false ? 0 : +, xt_asm_ldx, z_asm_ldx
>ce6e		6c 64 78			    .text _s
.ce71						+
="ldx.#"					    _s := "ldx.#" ? "ldx.#" : str(.asm_ldx_h)
>ce71		05 0c				    .byte len(_s), IM+NN
>ce73		7e ce 9b a5 a0 a5		    .word false ? 0 : +, xt_asm_ldx_h, z_asm_ldx_h
>ce79		6c 64 78 2e 23			    .text _s
.ce7e						+
="ldx.y"					    _s := "ldx.y" ? "ldx.y" : str(.asm_ldx_y)
>ce7e		05 0c				    .byte len(_s), IM+NN
>ce80		8b ce a0 a5 a5 a5		    .word false ? 0 : +, xt_asm_ldx_y, z_asm_ldx_y
>ce86		6c 64 78 2e 79			    .text _s
.ce8b						+
="ldx.z"					    _s := "ldx.z" ? "ldx.z" : str(.asm_ldx_z)
>ce8b		05 0c				    .byte len(_s), IM+NN
>ce8d		98 ce a5 a5 aa a5		    .word false ? 0 : +, xt_asm_ldx_z, z_asm_ldx_z
>ce93		6c 64 78 2e 7a			    .text _s
.ce98						+
="ldx.zy"					    _s := "ldx.zy" ? "ldx.zy" : str(.asm_ldx_zy)
>ce98		06 0c				    .byte len(_s), IM+NN
>ce9a		a6 ce aa a5 af a5		    .word false ? 0 : +, xt_asm_ldx_zy, z_asm_ldx_zy
>cea0		6c 64 78 2e 7a 79		    .text _s
.cea6						+
="ldy"						    _s := "ldy" ? "ldy" : str(.asm_ldy)
>cea6		03 0c				    .byte len(_s), IM+NN
>cea8		b1 ce af a5 b4 a5		    .word false ? 0 : +, xt_asm_ldy, z_asm_ldy
>ceae		6c 64 79			    .text _s
.ceb1						+
="ldy.#"					    _s := "ldy.#" ? "ldy.#" : str(.asm_ldy_h)
>ceb1		05 0c				    .byte len(_s), IM+NN
>ceb3		be ce b4 a5 b9 a5		    .word false ? 0 : +, xt_asm_ldy_h, z_asm_ldy_h
>ceb9		6c 64 79 2e 23			    .text _s
.cebe						+
="ldy.x"					    _s := "ldy.x" ? "ldy.x" : str(.asm_ldy_x)
>cebe		05 0c				    .byte len(_s), IM+NN
>cec0		cb ce b9 a5 be a5		    .word false ? 0 : +, xt_asm_ldy_x, z_asm_ldy_x
>cec6		6c 64 79 2e 78			    .text _s
.cecb						+
="ldy.z"					    _s := "ldy.z" ? "ldy.z" : str(.asm_ldy_z)
>cecb		05 0c				    .byte len(_s), IM+NN
>cecd		d8 ce be a5 c3 a5		    .word false ? 0 : +, xt_asm_ldy_z, z_asm_ldy_z
>ced3		6c 64 79 2e 7a			    .text _s
.ced8						+
="ldy.zx"					    _s := "ldy.zx" ? "ldy.zx" : str(.asm_ldy_zx)
>ced8		06 0c				    .byte len(_s), IM+NN
>ceda		e6 ce c3 a5 c8 a5		    .word false ? 0 : +, xt_asm_ldy_zx, z_asm_ldy_zx
>cee0		6c 64 79 2e 7a 78		    .text _s
.cee6						+
="lsr"						    _s := "lsr" ? "lsr" : str(.asm_lsr)
>cee6		03 0c				    .byte len(_s), IM+NN
>cee8		f1 ce c8 a5 cd a5		    .word false ? 0 : +, xt_asm_lsr, z_asm_lsr
>ceee		6c 73 72			    .text _s
.cef1						+
="lsr.a"					    _s := "lsr.a" ? "lsr.a" : str(.asm_lsr_a)
>cef1		05 0c				    .byte len(_s), IM+NN
>cef3		fe ce cd a5 d2 a5		    .word false ? 0 : +, xt_asm_lsr_a, z_asm_lsr_a
>cef9		6c 73 72 2e 61			    .text _s
.cefe						+
="lsr.x"					    _s := "lsr.x" ? "lsr.x" : str(.asm_lsr_x)
>cefe		05 0c				    .byte len(_s), IM+NN
>cf00		0b cf d2 a5 d7 a5		    .word false ? 0 : +, xt_asm_lsr_x, z_asm_lsr_x
>cf06		6c 73 72 2e 78			    .text _s
.cf0b						+
="lsr.z"					    _s := "lsr.z" ? "lsr.z" : str(.asm_lsr_z)
>cf0b		05 0c				    .byte len(_s), IM+NN
>cf0d		18 cf d7 a5 dc a5		    .word false ? 0 : +, xt_asm_lsr_z, z_asm_lsr_z
>cf13		6c 73 72 2e 7a			    .text _s
.cf18						+
="lsr.zx"					    _s := "lsr.zx" ? "lsr.zx" : str(.asm_lsr_zx)
>cf18		06 0c				    .byte len(_s), IM+NN
>cf1a		26 cf dc a5 e1 a5		    .word false ? 0 : +, xt_asm_lsr_zx, z_asm_lsr_zx
>cf20		6c 73 72 2e 7a 78		    .text _s
.cf26						+
="nop"						    _s := "nop" ? "nop" : str(.asm_nop)
>cf26		03 0c				    .byte len(_s), IM+NN
>cf28		31 cf e1 a5 e6 a5		    .word false ? 0 : +, xt_asm_nop, z_asm_nop
>cf2e		6e 6f 70			    .text _s
.cf31						+
="ora"						    _s := "ora" ? "ora" : str(.asm_ora)
>cf31		03 0c				    .byte len(_s), IM+NN
>cf33		3c cf e6 a5 eb a5		    .word false ? 0 : +, xt_asm_ora, z_asm_ora
>cf39		6f 72 61			    .text _s
.cf3c						+
="ora.#"					    _s := "ora.#" ? "ora.#" : str(.asm_ora_h)
>cf3c		05 0c				    .byte len(_s), IM+NN
>cf3e		49 cf eb a5 f0 a5		    .word false ? 0 : +, xt_asm_ora_h, z_asm_ora_h
>cf44		6f 72 61 2e 23			    .text _s
.cf49						+
="ora.x"					    _s := "ora.x" ? "ora.x" : str(.asm_ora_x)
>cf49		05 0c				    .byte len(_s), IM+NN
>cf4b		56 cf f0 a5 f5 a5		    .word false ? 0 : +, xt_asm_ora_x, z_asm_ora_x
>cf51		6f 72 61 2e 78			    .text _s
.cf56						+
="ora.y"					    _s := "ora.y" ? "ora.y" : str(.asm_ora_y)
>cf56		05 0c				    .byte len(_s), IM+NN
>cf58		63 cf f5 a5 fa a5		    .word false ? 0 : +, xt_asm_ora_y, z_asm_ora_y
>cf5e		6f 72 61 2e 79			    .text _s
.cf63						+
="ora.z"					    _s := "ora.z" ? "ora.z" : str(.asm_ora_z)
>cf63		05 0c				    .byte len(_s), IM+NN
>cf65		70 cf fa a5 ff a5		    .word false ? 0 : +, xt_asm_ora_z, z_asm_ora_z
>cf6b		6f 72 61 2e 7a			    .text _s
.cf70						+
="ora.zi"					    _s := "ora.zi" ? "ora.zi" : str(.asm_ora_zi)
>cf70		06 0c				    .byte len(_s), IM+NN
>cf72		7e cf ff a5 06 a6		    .word false ? 0 : +, xt_asm_ora_zi, z_asm_ora_zi
>cf78		6f 72 61 2e 7a 69		    .text _s
.cf7e						+
="ora.ziy"					    _s := "ora.ziy" ? "ora.ziy" : str(.asm_ora_ziy)
>cf7e		07 0c				    .byte len(_s), IM+NN
>cf80		8d cf 06 a6 0b a6		    .word false ? 0 : +, xt_asm_ora_ziy, z_asm_ora_ziy
>cf86		6f 72 61 2e 7a 69 79		    .text _s
.cf8d						+
="ora.zx"					    _s := "ora.zx" ? "ora.zx" : str(.asm_ora_zx)
>cf8d		06 0c				    .byte len(_s), IM+NN
>cf8f		9b cf 0b a6 10 a6		    .word false ? 0 : +, xt_asm_ora_zx, z_asm_ora_zx
>cf95		6f 72 61 2e 7a 78		    .text _s
.cf9b						+
="ora.zxi"					    _s := "ora.zxi" ? "ora.zxi" : str(.asm_ora_zxi)
>cf9b		07 0c				    .byte len(_s), IM+NN
>cf9d		aa cf 10 a6 15 a6		    .word false ? 0 : +, xt_asm_ora_zxi, z_asm_ora_zxi
>cfa3		6f 72 61 2e 7a 78 69		    .text _s
.cfaa						+
="pha"						    _s := "pha" ? "pha" : str(.asm_pha)
>cfaa		03 0c				    .byte len(_s), IM+NN
>cfac		b5 cf 15 a6 1a a6		    .word false ? 0 : +, xt_asm_pha, z_asm_pha
>cfb2		70 68 61			    .text _s
.cfb5						+
="php"						    _s := "php" ? "php" : str(.asm_php)
>cfb5		03 0c				    .byte len(_s), IM+NN
>cfb7		c0 cf 1a a6 1f a6		    .word false ? 0 : +, xt_asm_php, z_asm_php
>cfbd		70 68 70			    .text _s
.cfc0						+
="phx"						    _s := "phx" ? "phx" : str(.asm_phx)
>cfc0		03 0c				    .byte len(_s), IM+NN
>cfc2		cb cf 1f a6 24 a6		    .word false ? 0 : +, xt_asm_phx, z_asm_phx
>cfc8		70 68 78			    .text _s
.cfcb						+
="phy"						    _s := "phy" ? "phy" : str(.asm_phy)
>cfcb		03 0c				    .byte len(_s), IM+NN
>cfcd		d6 cf 24 a6 29 a6		    .word false ? 0 : +, xt_asm_phy, z_asm_phy
>cfd3		70 68 79			    .text _s
.cfd6						+
="pla"						    _s := "pla" ? "pla" : str(.asm_pla)
>cfd6		03 0c				    .byte len(_s), IM+NN
>cfd8		e1 cf 29 a6 2e a6		    .word false ? 0 : +, xt_asm_pla, z_asm_pla
>cfde		70 6c 61			    .text _s
.cfe1						+
="plp"						    _s := "plp" ? "plp" : str(.asm_plp)
>cfe1		03 0c				    .byte len(_s), IM+NN
>cfe3		ec cf 2e a6 33 a6		    .word false ? 0 : +, xt_asm_plp, z_asm_plp
>cfe9		70 6c 70			    .text _s
.cfec						+
="plx"						    _s := "plx" ? "plx" : str(.asm_plx)
>cfec		03 0c				    .byte len(_s), IM+NN
>cfee		f7 cf 33 a6 38 a6		    .word false ? 0 : +, xt_asm_plx, z_asm_plx
>cff4		70 6c 78			    .text _s
.cff7						+
="ply"						    _s := "ply" ? "ply" : str(.asm_ply)
>cff7		03 0c				    .byte len(_s), IM+NN
>cff9		02 d0 38 a6 3d a6		    .word false ? 0 : +, xt_asm_ply, z_asm_ply
>cfff		70 6c 79			    .text _s
.d002						+
="rol"						    _s := "rol" ? "rol" : str(.asm_rol)
>d002		03 0c				    .byte len(_s), IM+NN
>d004		0d d0 3d a6 42 a6		    .word false ? 0 : +, xt_asm_rol, z_asm_rol
>d00a		72 6f 6c			    .text _s
.d00d						+
="rol.a"					    _s := "rol.a" ? "rol.a" : str(.asm_rol_a)
>d00d		05 0c				    .byte len(_s), IM+NN
>d00f		1a d0 42 a6 47 a6		    .word false ? 0 : +, xt_asm_rol_a, z_asm_rol_a
>d015		72 6f 6c 2e 61			    .text _s
.d01a						+
="rol.x"					    _s := "rol.x" ? "rol.x" : str(.asm_rol_x)
>d01a		05 0c				    .byte len(_s), IM+NN
>d01c		27 d0 47 a6 4c a6		    .word false ? 0 : +, xt_asm_rol_x, z_asm_rol_x
>d022		72 6f 6c 2e 78			    .text _s
.d027						+
="rol.z"					    _s := "rol.z" ? "rol.z" : str(.asm_rol_z)
>d027		05 0c				    .byte len(_s), IM+NN
>d029		34 d0 4c a6 51 a6		    .word false ? 0 : +, xt_asm_rol_z, z_asm_rol_z
>d02f		72 6f 6c 2e 7a			    .text _s
.d034						+
="rol.zx"					    _s := "rol.zx" ? "rol.zx" : str(.asm_rol_zx)
>d034		06 0c				    .byte len(_s), IM+NN
>d036		42 d0 51 a6 56 a6		    .word false ? 0 : +, xt_asm_rol_zx, z_asm_rol_zx
>d03c		72 6f 6c 2e 7a 78		    .text _s
.d042						+
="ror"						    _s := "ror" ? "ror" : str(.asm_ror)
>d042		03 0c				    .byte len(_s), IM+NN
>d044		4d d0 56 a6 5b a6		    .word false ? 0 : +, xt_asm_ror, z_asm_ror
>d04a		72 6f 72			    .text _s
.d04d						+
="ror.a"					    _s := "ror.a" ? "ror.a" : str(.asm_ror_a)
>d04d		05 0c				    .byte len(_s), IM+NN
>d04f		5a d0 5b a6 60 a6		    .word false ? 0 : +, xt_asm_ror_a, z_asm_ror_a
>d055		72 6f 72 2e 61			    .text _s
.d05a						+
="ror.x"					    _s := "ror.x" ? "ror.x" : str(.asm_ror_x)
>d05a		05 0c				    .byte len(_s), IM+NN
>d05c		67 d0 60 a6 65 a6		    .word false ? 0 : +, xt_asm_ror_x, z_asm_ror_x
>d062		72 6f 72 2e 78			    .text _s
.d067						+
="ror.z"					    _s := "ror.z" ? "ror.z" : str(.asm_ror_z)
>d067		05 0c				    .byte len(_s), IM+NN
>d069		74 d0 65 a6 6a a6		    .word false ? 0 : +, xt_asm_ror_z, z_asm_ror_z
>d06f		72 6f 72 2e 7a			    .text _s
.d074						+
="ror.zx"					    _s := "ror.zx" ? "ror.zx" : str(.asm_ror_zx)
>d074		06 0c				    .byte len(_s), IM+NN
>d076		82 d0 6a a6 6f a6		    .word false ? 0 : +, xt_asm_ror_zx, z_asm_ror_zx
>d07c		72 6f 72 2e 7a 78		    .text _s
.d082						+
="rti"						    _s := "rti" ? "rti" : str(.asm_rti)
>d082		03 0c				    .byte len(_s), IM+NN
>d084		8d d0 6f a6 74 a6		    .word false ? 0 : +, xt_asm_rti, z_asm_rti
>d08a		72 74 69			    .text _s
.d08d						+
="rts"						    _s := "rts" ? "rts" : str(.asm_rts)
>d08d		03 0c				    .byte len(_s), IM+NN
>d08f		98 d0 74 a6 79 a6		    .word false ? 0 : +, xt_asm_rts, z_asm_rts
>d095		72 74 73			    .text _s
.d098						+
="sbc"						    _s := "sbc" ? "sbc" : str(.asm_sbc)
>d098		03 0c				    .byte len(_s), IM+NN
>d09a		a3 d0 79 a6 7e a6		    .word false ? 0 : +, xt_asm_sbc, z_asm_sbc
>d0a0		73 62 63			    .text _s
.d0a3						+
="sbc.#"					    _s := "sbc.#" ? "sbc.#" : str(.asm_sbc_h)
>d0a3		05 0c				    .byte len(_s), IM+NN
>d0a5		b0 d0 7e a6 83 a6		    .word false ? 0 : +, xt_asm_sbc_h, z_asm_sbc_h
>d0ab		73 62 63 2e 23			    .text _s
.d0b0						+
="sbc.x"					    _s := "sbc.x" ? "sbc.x" : str(.asm_sbc_x)
>d0b0		05 0c				    .byte len(_s), IM+NN
>d0b2		bd d0 83 a6 88 a6		    .word false ? 0 : +, xt_asm_sbc_x, z_asm_sbc_x
>d0b8		73 62 63 2e 78			    .text _s
.d0bd						+
="sbc.y"					    _s := "sbc.y" ? "sbc.y" : str(.asm_sbc_y)
>d0bd		05 0c				    .byte len(_s), IM+NN
>d0bf		ca d0 88 a6 8d a6		    .word false ? 0 : +, xt_asm_sbc_y, z_asm_sbc_y
>d0c5		73 62 63 2e 79			    .text _s
.d0ca						+
="sbc.z"					    _s := "sbc.z" ? "sbc.z" : str(.asm_sbc_z)
>d0ca		05 0c				    .byte len(_s), IM+NN
>d0cc		d7 d0 8d a6 92 a6		    .word false ? 0 : +, xt_asm_sbc_z, z_asm_sbc_z
>d0d2		73 62 63 2e 7a			    .text _s
.d0d7						+
="sbc.zi"					    _s := "sbc.zi" ? "sbc.zi" : str(.asm_sbc_zi)
>d0d7		06 0c				    .byte len(_s), IM+NN
>d0d9		e5 d0 92 a6 97 a6		    .word false ? 0 : +, xt_asm_sbc_zi, z_asm_sbc_zi
>d0df		73 62 63 2e 7a 69		    .text _s
.d0e5						+
="sbc.ziy"					    _s := "sbc.ziy" ? "sbc.ziy" : str(.asm_sbc_ziy)
>d0e5		07 0c				    .byte len(_s), IM+NN
>d0e7		f4 d0 97 a6 9c a6		    .word false ? 0 : +, xt_asm_sbc_ziy, z_asm_sbc_ziy
>d0ed		73 62 63 2e 7a 69 79		    .text _s
.d0f4						+
="sbc.zx"					    _s := "sbc.zx" ? "sbc.zx" : str(.asm_sbc_zx)
>d0f4		06 0c				    .byte len(_s), IM+NN
>d0f6		02 d1 9c a6 a1 a6		    .word false ? 0 : +, xt_asm_sbc_zx, z_asm_sbc_zx
>d0fc		73 62 63 2e 7a 78		    .text _s
.d102						+
="sbc.zxi"					    _s := "sbc.zxi" ? "sbc.zxi" : str(.asm_sbc_zxi)
>d102		07 0c				    .byte len(_s), IM+NN
>d104		11 d1 a1 a6 a5 a6		    .word false ? 0 : +, xt_asm_sbc_zxi, z_asm_sbc_zxi
>d10a		73 62 63 2e 7a 78 69		    .text _s
.d111						+
="sec"						    _s := "sec" ? "sec" : str(.asm_sec)
>d111		03 0c				    .byte len(_s), IM+NN
>d113		1c d1 a5 a6 a9 a6		    .word false ? 0 : +, xt_asm_sec, z_asm_sec
>d119		73 65 63			    .text _s
.d11c						+
="sed"						    _s := "sed" ? "sed" : str(.asm_sed)
>d11c		03 0c				    .byte len(_s), IM+NN
>d11e		27 d1 a9 a6 ad a6		    .word false ? 0 : +, xt_asm_sed, z_asm_sed
>d124		73 65 64			    .text _s
.d127						+
="sei"						    _s := "sei" ? "sei" : str(.asm_sei)
>d127		03 0c				    .byte len(_s), IM+NN
>d129		32 d1 ad a6 b1 a6		    .word false ? 0 : +, xt_asm_sei, z_asm_sei
>d12f		73 65 69			    .text _s
.d132						+
="sta"						    _s := "sta" ? "sta" : str(.asm_sta)
>d132		03 0c				    .byte len(_s), IM+NN
>d134		3d d1 b1 a6 b5 a6		    .word false ? 0 : +, xt_asm_sta, z_asm_sta
>d13a		73 74 61			    .text _s
.d13d						+
="sta.x"					    _s := "sta.x" ? "sta.x" : str(.asm_sta_x)
>d13d		05 0c				    .byte len(_s), IM+NN
>d13f		4a d1 b5 a6 b9 a6		    .word false ? 0 : +, xt_asm_sta_x, z_asm_sta_x
>d145		73 74 61 2e 78			    .text _s
.d14a						+
="sta.y"					    _s := "sta.y" ? "sta.y" : str(.asm_sta_y)
>d14a		05 0c				    .byte len(_s), IM+NN
>d14c		57 d1 b9 a6 bd a6		    .word false ? 0 : +, xt_asm_sta_y, z_asm_sta_y
>d152		73 74 61 2e 79			    .text _s
.d157						+
="sta.z"					    _s := "sta.z" ? "sta.z" : str(.asm_sta_z)
>d157		05 0c				    .byte len(_s), IM+NN
>d159		64 d1 bd a6 c1 a6		    .word false ? 0 : +, xt_asm_sta_z, z_asm_sta_z
>d15f		73 74 61 2e 7a			    .text _s
.d164						+
="sta.zi"					    _s := "sta.zi" ? "sta.zi" : str(.asm_sta_zi)
>d164		06 0c				    .byte len(_s), IM+NN
>d166		72 d1 c1 a6 c5 a6		    .word false ? 0 : +, xt_asm_sta_zi, z_asm_sta_zi
>d16c		73 74 61 2e 7a 69		    .text _s
.d172						+
="sta.ziy"					    _s := "sta.ziy" ? "sta.ziy" : str(.asm_sta_ziy)
>d172		07 0c				    .byte len(_s), IM+NN
>d174		81 d1 c5 a6 c9 a6		    .word false ? 0 : +, xt_asm_sta_ziy, z_asm_sta_ziy
>d17a		73 74 61 2e 7a 69 79		    .text _s
.d181						+
="sta.zx"					    _s := "sta.zx" ? "sta.zx" : str(.asm_sta_zx)
>d181		06 0c				    .byte len(_s), IM+NN
>d183		8f d1 c9 a6 cd a6		    .word false ? 0 : +, xt_asm_sta_zx, z_asm_sta_zx
>d189		73 74 61 2e 7a 78		    .text _s
.d18f						+
="sta.zxi"					    _s := "sta.zxi" ? "sta.zxi" : str(.asm_sta_zxi)
>d18f		07 0c				    .byte len(_s), IM+NN
>d191		9e d1 cd a6 d1 a6		    .word false ? 0 : +, xt_asm_sta_zxi, z_asm_sta_zxi
>d197		73 74 61 2e 7a 78 69		    .text _s
.d19e						+
="stx"						    _s := "stx" ? "stx" : str(.asm_stx)
>d19e		03 0c				    .byte len(_s), IM+NN
>d1a0		a9 d1 d1 a6 d5 a6		    .word false ? 0 : +, xt_asm_stx, z_asm_stx
>d1a6		73 74 78			    .text _s
.d1a9						+
="stx.z"					    _s := "stx.z" ? "stx.z" : str(.asm_stx_z)
>d1a9		05 0c				    .byte len(_s), IM+NN
>d1ab		b6 d1 d5 a6 d9 a6		    .word false ? 0 : +, xt_asm_stx_z, z_asm_stx_z
>d1b1		73 74 78 2e 7a			    .text _s
.d1b6						+
="stx.zy"					    _s := "stx.zy" ? "stx.zy" : str(.asm_stx_zy)
>d1b6		06 0c				    .byte len(_s), IM+NN
>d1b8		c4 d1 d9 a6 dd a6		    .word false ? 0 : +, xt_asm_stx_zy, z_asm_stx_zy
>d1be		73 74 78 2e 7a 79		    .text _s
.d1c4						+
="sty"						    _s := "sty" ? "sty" : str(.asm_sty)
>d1c4		03 0c				    .byte len(_s), IM+NN
>d1c6		cf d1 dd a6 e1 a6		    .word false ? 0 : +, xt_asm_sty, z_asm_sty
>d1cc		73 74 79			    .text _s
.d1cf						+
="sty.z"					    _s := "sty.z" ? "sty.z" : str(.asm_sty_z)
>d1cf		05 0c				    .byte len(_s), IM+NN
>d1d1		dc d1 e1 a6 e5 a6		    .word false ? 0 : +, xt_asm_sty_z, z_asm_sty_z
>d1d7		73 74 79 2e 7a			    .text _s
.d1dc						+
="sty.zx"					    _s := "sty.zx" ? "sty.zx" : str(.asm_sty_zx)
>d1dc		06 0c				    .byte len(_s), IM+NN
>d1de		ea d1 e5 a6 e9 a6		    .word false ? 0 : +, xt_asm_sty_zx, z_asm_sty_zx
>d1e4		73 74 79 2e 7a 78		    .text _s
.d1ea						+
="stz"						    _s := "stz" ? "stz" : str(.asm_stz)
>d1ea		03 0c				    .byte len(_s), IM+NN
>d1ec		f5 d1 e9 a6 ed a6		    .word false ? 0 : +, xt_asm_stz, z_asm_stz
>d1f2		73 74 7a			    .text _s
.d1f5						+
="stz.x"					    _s := "stz.x" ? "stz.x" : str(.asm_stz_x)
>d1f5		05 0c				    .byte len(_s), IM+NN
>d1f7		02 d2 ed a6 f1 a6		    .word false ? 0 : +, xt_asm_stz_x, z_asm_stz_x
>d1fd		73 74 7a 2e 78			    .text _s
.d202						+
="stz.z"					    _s := "stz.z" ? "stz.z" : str(.asm_stz_z)
>d202		05 0c				    .byte len(_s), IM+NN
>d204		0f d2 f1 a6 f5 a6		    .word false ? 0 : +, xt_asm_stz_z, z_asm_stz_z
>d20a		73 74 7a 2e 7a			    .text _s
.d20f						+
="stz.zx"					    _s := "stz.zx" ? "stz.zx" : str(.asm_stz_zx)
>d20f		06 0c				    .byte len(_s), IM+NN
>d211		1d d2 f5 a6 f9 a6		    .word false ? 0 : +, xt_asm_stz_zx, z_asm_stz_zx
>d217		73 74 7a 2e 7a 78		    .text _s
.d21d						+
="tax"						    _s := "tax" ? "tax" : str(.asm_tax)
>d21d		03 0c				    .byte len(_s), IM+NN
>d21f		28 d2 f9 a6 fd a6		    .word false ? 0 : +, xt_asm_tax, z_asm_tax
>d225		74 61 78			    .text _s
.d228						+
="tay"						    _s := "tay" ? "tay" : str(.asm_tay)
>d228		03 0c				    .byte len(_s), IM+NN
>d22a		33 d2 fd a6 01 a7		    .word false ? 0 : +, xt_asm_tay, z_asm_tay
>d230		74 61 79			    .text _s
.d233						+
="trb"						    _s := "trb" ? "trb" : str(.asm_trb)
>d233		03 0c				    .byte len(_s), IM+NN
>d235		3e d2 01 a7 05 a7		    .word false ? 0 : +, xt_asm_trb, z_asm_trb
>d23b		74 72 62			    .text _s
.d23e						+
="trb.z"					    _s := "trb.z" ? "trb.z" : str(.asm_trb_z)
>d23e		05 0c				    .byte len(_s), IM+NN
>d240		4b d2 05 a7 09 a7		    .word false ? 0 : +, xt_asm_trb_z, z_asm_trb_z
>d246		74 72 62 2e 7a			    .text _s
.d24b						+
="tsb"						    _s := "tsb" ? "tsb" : str(.asm_tsb)
>d24b		03 0c				    .byte len(_s), IM+NN
>d24d		56 d2 09 a7 0d a7		    .word false ? 0 : +, xt_asm_tsb, z_asm_tsb
>d253		74 73 62			    .text _s
.d256						+
="tsb.z"					    _s := "tsb.z" ? "tsb.z" : str(.asm_tsb_z)
>d256		05 0c				    .byte len(_s), IM+NN
>d258		63 d2 0d a7 11 a7		    .word false ? 0 : +, xt_asm_tsb_z, z_asm_tsb_z
>d25e		74 73 62 2e 7a			    .text _s
.d263						+
="tsx"						    _s := "tsx" ? "tsx" : str(.asm_tsx)
>d263		03 0c				    .byte len(_s), IM+NN
>d265		6e d2 11 a7 15 a7		    .word false ? 0 : +, xt_asm_tsx, z_asm_tsx
>d26b		74 73 78			    .text _s
.d26e						+
="txa"						    _s := "txa" ? "txa" : str(.asm_txa)
>d26e		03 0c				    .byte len(_s), IM+NN
>d270		79 d2 15 a7 19 a7		    .word false ? 0 : +, xt_asm_txa, z_asm_txa
>d276		74 78 61			    .text _s
.d279						+
="txs"						    _s := "txs" ? "txs" : str(.asm_txs)
>d279		03 0c				    .byte len(_s), IM+NN
>d27b		84 d2 19 a7 1d a7		    .word false ? 0 : +, xt_asm_txs, z_asm_txs
>d281		74 78 73			    .text _s
.d284						+
="tya"						    _s := "tya" ? "tya" : str(.asm_tya)
>d284		03 0c				    .byte len(_s), IM+NN
>d286		8f d2 1d a7 21 a7		    .word false ? 0 : +, xt_asm_tya, z_asm_tya
>d28c		74 79 61			    .text _s
.d28f						+
="-->"						    _s := "-->" ? "-->" : str(.asm_arrow)
>d28f		03 04				    .byte len(_s), IM
>d291		9a d2 1b 89 25 89		    .word false ? 0 : +, xt_asm_arrow, z_asm_arrow
>d297		2d 2d 3e			    .text _s
.d29a						+
="<j"						    _s := "<j" ? "<j" : str(.asm_back_jump)
>d29a		02 04				    .byte len(_s), IM
>d29c		a4 d2 72 a7 72 a7		    .word false ? 0 : +, xt_asm_back_jump, z_asm_back_jump
>d2a2		3c 6a				    .text _s
.d2a4						+
="<b"						    _s := "<b" ? "<b" : str(.asm_back_branch)
>d2a4		02 04				    .byte len(_s), IM
>d2a6		ae d2 73 a7 7b a7		    .word false ? 0 : +, xt_asm_back_branch, z_asm_back_branch
>d2ac		3c 62				    .text _s
.d2ae						+
="push-a"					    _s := "push-a" ? "push-a" : str(.asm_push_a)
>d2ae		06 0c				    .byte len(_s), IM+NN
>d2b0		00 00 5b a7 6a a7		    .word true ? 0 : +, xt_asm_push_a, z_asm_push_a
>d2b6		70 75 73 68 2d 61		    .text _s

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix         ; unused?
=1						ix += 1
=1						str_compile        = ix         ; unused?
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix         ; unused?
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_sdc     = ix
=13						ix += 1
=13						str_disasm_lit     = ix
=14						ix += 1
=14						str_disasm_0bra    = ix
=15						ix += 1
=15						str_disasm_loop    = ix
=16						ix += 1
=16						str_disasm_do      = ix
=17						ix += 1
.d2bc						string_table:
>d2bc		de d2 e2 d2 ec d2 f7 d2		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d2c4		2e d3 26 d3 1b d3 35 d3		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d2cc		3b d3 57 d3 5c d3 61 d3		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d2d4		72 d3 85 d3 8e d3 97 d3		        .word s_disasm_sdc, s_disasm_lit, s_disasm_0bra, s_disasm_loop, s_disasm_do ; 12-16
>d2dc		9d d3
>d2de		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d2e2		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d2ea		64 00
>d2ec		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d2f4		64 20 00
>d2f7		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d2ff		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d30f		4f 50 51 52 53 54 55 56 57 58 59 5a
>d31b		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d323		72 20 00
>d326		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d32e		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d335		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d33b		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d343		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d353		29 3a 20 00
>d357		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d35c		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d361		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d369		63 69 6d 61 6c 29 3a 20 00
>d372		20 53 54 41 43 4b 20 44		s_disasm_sdc: .text " STACK DEPTH CHECK", 0
>d37a		45 50 54 48 20 43 48 45 43 4b 00
>d385		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d38d		00
>d38e		30 42 52 41 4e 43 48 20		s_disasm_0bra: .text "0BRANCH ",0
>d396		00
>d397		4c 4f 4f 50 20 00		s_disasm_loop: .text "LOOP ",0
>d39d		44 4f 20 00			s_disasm_do: .text "DO ",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d3a1						error_table:
>d3a1		bd d3 de d3 fe d3 1f d4		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d3a9		3c d4 4d d4 5d d4 8b d4		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d3b1		a3 d4 c4 d4 d9 d4 f5 d4		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d3b9		0c d5 4b d5			        .word es_blockwords, es_returnstack                     ; 12-13
>d3bd		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d3c5		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d3d5		65 20 6d 65 6d 6f 72 79 00
>d3de		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d3e6		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d3f6		20 52 45 46 49 4c 4c 00
>d3fe		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d406		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d416		6e 6c 79 20 77 6f 72 64 00
>d41f		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d427		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d437		20 79 65 74 00
>d43c		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d444		20 62 79 20 7a 65 72 6f 00
>d44d		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d455		66 61 69 6c 75 72 65 00
>d45d		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d465		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d475		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d485		64 20 2d 31 29 00
>d48b		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d493		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d4a3		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d4ab		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d4bb		64 20 6e 75 6d 62 65 72 00
>d4c4		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d4cc		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d4d9		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d4e1		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d4f1		4c 4f 54 00
>d4f5		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d4fd		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d50c		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d514		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d524		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d534		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d544		56 45 43 54 4f 52 00
>d54b		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d553		74 61 63 6b 3a 00
>d559		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d561		44 2d 53 54 52 49 4e 47
>d569		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d56f		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d574		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d57c		2d 55 4e 49 54 2d 42 49 54 53
>d586		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d58e		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d596		52
>d597		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d59d		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d5a3		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d5ab		53 54 41 43 4b 2d 43 45 4c 4c 53
>d5b6		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d5be		45 4c 4c 53
>d5c2		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d5ca		54 53
>d5cc		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d5d2		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d5d9						doconst:
.d5d9		ca		dex		                dex             ; make room for constant
.d5da		ca		dex		                dex
.d5db		68		pla		                pla             ; LSB of return address
.d5dc		85 25		sta $25		                sta tmp1
.d5de		68		pla		                pla             ; MSB of return address
.d5df		85 26		sta $26		                sta tmp1+1
.d5e1		a0 01		ldy #$01	                ldy #1
.d5e3		b1 25		lda ($25),y	                lda (tmp1),y
.d5e5		95 00		sta $00,x	                sta 0,x
.d5e7		c8		iny		                iny
.d5e8		b1 25		lda ($25),y	                lda (tmp1),y
.d5ea		95 01		sta $01,x	                sta 1,x
.d5ec		60		rts		                rts
.d5ed						dodefer:
.d5ed		68		pla		                pla             ; LSB
.d5ee		85 25		sta $25		                sta tmp1
.d5f0		68		pla		                pla             ; MSB
.d5f1		85 26		sta $26		                sta tmp1+1
.d5f3		a0 01		ldy #$01	                ldy #1
.d5f5		b1 25		lda ($25),y	                lda (tmp1),y
.d5f7		85 27		sta $27		                sta tmp2
.d5f9		c8		iny		                iny
.d5fa		b1 25		lda ($25),y	                lda (tmp1),y
.d5fc		85 28		sta $28		                sta tmp2+1
.d5fe		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d601						defer_error:
.d601		a9 03		lda #$03	                lda #err_defer
.d603		4c 87 d7	jmp $d787	                jmp error
.d606						dodoes:
.d606		7a		ply		                ply             ; LSB
.d607		68		pla		                pla             ; MSB
.d608		c8		iny		                iny
.d609		d0 01		bne $d60c	                bne +
.d60b		1a		inc a		                ina
.d60c						+
.d60c		84 27		sty $27		                sty tmp2
.d60e		85 28		sta $28		                sta tmp2+1
.d610		ca		dex		                dex
.d611		ca		dex		                dex
.d612		7a		ply		                ply
.d613		68		pla		                pla
.d614		c8		iny		                iny
.d615		d0 01		bne $d618	                bne +
.d617		1a		inc a		                ina
.d618						+
.d618		94 00		sty $00,x	                sty 0,x         ; LSB
.d61a		95 01		sta $01,x	                sta 1,x         ; MSB
.d61c		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d61f						dovar:
.d61f		7a		ply		                ply             ; LSB
.d620		68		pla		                pla             ; MSB
.d621		c8		iny		                iny
.d622		d0 01		bne $d625	                bne +
.d624		1a		inc a		                ina
.d625						+
.d625		ca		dex		                dex
.d626		ca		dex		                dex
.d627		95 01		sta $01,x	                sta 1,x
.d629		98		tya		                tya
.d62a		95 00		sta $00,x	                sta 0,x
.d62c		60		rts		                rts
.d62d						push_upvar_tos:
.d62d		ca		dex		                dex
.d62e		ca		dex		                dex
.d62f		18		clc		                clc
.d630		65 08		adc $08		                adc up
.d632		95 00		sta $00,x	                sta 0,x
.d634		a5 09		lda $09		                lda up+1
.d636		90 01		bcc $d639	                bcc +
.d638		1a		inc a		                ina
.d639						+
.d639		95 01		sta $01,x	                sta 1,x
.d63b		60		rts		                rts
.d63c						byte_to_ascii:
.d63c		48		pha		                pha
.d63d		4a		lsr a		                lsr             ; convert high nibble first
.d63e		4a		lsr a		                lsr
.d63f		4a		lsr a		                lsr
.d640		4a		lsr a		                lsr
.d641		20 45 d6	jsr $d645	                jsr _nibble_to_ascii
.d644		68		pla		                pla
.d645						_nibble_to_ascii:
.d645		29 0f		and #$0f	                and #$F
.d647		09 30		ora #$30	                ora #'0'
.d649		c9 3a		cmp #$3a	                cmp #'9'+1
.d64b		90 02		bcc $d64f	                bcc +
.d64d		69 06		adc #$06	                adc #6
.d64f		4c c5 86	jmp $86c5	+               jmp emit_a
.d652		60		rts		                rts
.d653						find_header_name:
.d653		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d655		85 27		sta $27		                sta tmp2
.d657		b5 03		lda $03,x	                lda 3,x
.d659		85 28		sta $28		                sta tmp2+1
.d65b						_loop:
.d65b		b2 25		lda ($25)	                lda (tmp1)
.d65d		d5 00		cmp $00,x	                cmp 0,x
.d65f		d0 3a		bne $d69b	                bne _next_entry
.d661		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d663		a0 08		ldy #$08	                ldy #8
.d665		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d667		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d669		d0 30		bne $d69b	                bne _next_entry ; definitely not equal if any bits differ
.d66b		a5 25		lda $25		                lda tmp1
.d66d		48		pha		                pha             ; Save original address on the stack
.d66e		18		clc		                clc
.d66f		69 08		adc #$08	                adc #8
.d671		85 25		sta $25		                sta tmp1
.d673		a5 26		lda $26		                lda tmp1+1
.d675		48		pha		                pha
.d676		90 03		bcc $d67b	                bcc +
.d678		1a		inc a		                ina
.d679		85 26		sta $26		                sta tmp1+1
.d67b						+
.d67b		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d67d		88		dey		                dey
.d67e						_next_char:
.d67e		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d680		c9 5b		cmp #$5b	                cmp #'Z'+1
.d682		b0 06		bcs $d68a	                bcs _check_char
.d684		c9 41		cmp #$41	                cmp #'A'
.d686		90 02		bcc $d68a	                bcc _check_char
.d688		09 20		ora #$20	                ora #$20
.d68a						_check_char:
.d68a		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d68c		d0 03		bne $d691	                bne _reset_tmp1
.d68e		88		dey		                dey
.d68f		10 ed		bpl $d67e	                bpl _next_char
.d691						_reset_tmp1:
.d691		68		pla		                pla
.d692		85 26		sta $26		                sta tmp1+1
.d694		68		pla		                pla
.d695		85 25		sta $25		                sta tmp1
.d697		98		tya		                tya             ; leave A = $FF on success
.d698		c8		iny		                iny             ; if Y was $FF, we succeeded
.d699		f0 11		beq $d6ac	                beq _done
.d69b						_next_entry:
.d69b		a0 02		ldy #$02	                ldy #2
.d69d		b1 25		lda ($25),y	                lda (tmp1),y
.d69f		48		pha		                pha
.d6a0		c8		iny		                iny
.d6a1		b1 25		lda ($25),y	                lda (tmp1),y
.d6a3		85 26		sta $26		                sta tmp1+1
.d6a5		68		pla		                pla
.d6a6		85 25		sta $25		                sta tmp1
.d6a8		05 26		ora $26		                ora tmp1+1
.d6aa		d0 af		bne $d65b	                bne _loop
.d6ac		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d6ae		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d6af						compare_16bit:
.d6af		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d6b1		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d6b3		f0 08		beq $d6bd	                beq _equal
.d6b5		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6b7		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6b9		70 08		bvs $d6c3	                bvs _overflow
.d6bb		80 08		bra $d6c5	                bra _not_equal
.d6bd						_equal:
.d6bd		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6bf		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6c1		50 04		bvc $d6c7	                bvc _done
.d6c3						_overflow:
.d6c3		49 80		eor #$80	                eor #$80                ; complement negative flag
.d6c5						_not_equal:
.d6c5		09 01		ora #$01	                ora #1                  ; set Z=0 since we're not equal
.d6c7						_done:
.d6c7		60		rts		                rts
.d6c8						current_to_dp:
.d6c8		a0 08		ldy #$08	                ldy #current_offset
.d6ca		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d6cc		0a		asl a		                asl             ; turn it into an offset (in cells)
.d6cd		18		clc		                clc
.d6ce		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d6d0		a8		tay		                tay
.d6d1		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d6d3		85 02		sta $02		                sta dp
.d6d5		c8		iny		                iny
.d6d6		b1 08		lda ($08),y	                lda (up),y
.d6d8		85 03		sta $03		                sta dp+1
.d6da		60		rts		                rts
.d6db						dp_to_current:
.d6db		a0 08		ldy #$08	                ldy #current_offset
.d6dd		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d6df		0a		asl a		                asl             ; turn it into an offset (in cells)
.d6e0		18		clc		                clc
.d6e1		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d6e3		a8		tay		                tay
.d6e4		a5 02		lda $02		                lda dp
.d6e6		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d6e8		c8		iny		                iny
.d6e9		a5 03		lda $03		                lda dp+1
.d6eb		91 08		sta ($08),y	                sta (up),y
.d6ed		60		rts		                rts
.d6ee						interpret:
.d6ee						_loop:
.d6ee		20 4d 8d	jsr $8d4d	                jsr xt_parse_name       ; ( "string" -- addr u )
.d6f1		b5 00		lda $00,x	                lda 0,x
.d6f3		15 01		ora $01,x	                ora 1,x
.d6f5		f0 5b		beq $d752	                beq _line_done
.d6f7		20 ab 93	jsr $93ab	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d6fa		20 d7 9a	jsr $9ad7	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d6fd		b5 00		lda $00,x	                lda 0,x
.d6ff		15 01		ora $01,x	                ora 1,x
.d701		d0 19		bne $d71c	                bne _got_name_token
.d703		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d704		e8		inx		                inx
.d705		20 78 9c	jsr $9c78	                jsr xt_number           ; ( addr u -- u|d )
.d708		a5 1a		lda $1a		                lda state
.d70a		f0 e2		beq $d6ee	                beq _loop
.d70c		a9 20		lda #$20	                lda #%00100000
.d70e		24 1c		bit $1c		                bit status
.d710		d0 05		bne $d717	                bne _double_number
.d712		20 f2 89	jsr $89f2	                jsr xt_literal
.d715		80 d7		bra $d6ee	                bra _loop
.d717						_double_number:
.d717		20 d0 9e	jsr $9ed0	                jsr xt_two_literal
.d71a		80 d2		bra $d6ee	                bra _loop
.d71c						_got_name_token:
.d71c		b5 00		lda $00,x	                lda 0,x
.d71e		95 04		sta $04,x	                sta 4,x
.d720		b5 01		lda $01,x	                lda 1,x
.d722		95 05		sta $05,x	                sta 5,x
.d724		e8		inx		                inx
.d725		e8		inx		                inx
.d726		e8		inx		                inx
.d727		e8		inx		                inx                     ; ( nt )
.d728		20 e5 8c	jsr $8ce5	                jsr xt_one_plus
.d72b		a1 00		lda ($00,x)	                lda (0,x)
.d72d		48		pha		                pha
.d72e		20 d9 8c	jsr $8cd9	                jsr xt_one_minus
.d731		20 15 9c	jsr $9c15	                jsr xt_name_to_int      ; ( nt - xt )
.d734		a5 1a		lda $1a		                lda state
.d736		d0 10		bne $d748	                bne _compile
.d738		68		pla		                pla
.d739		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d73b		f0 05		beq $d742	                beq _interpret
.d73d		a9 02		lda #$02	                lda #err_compileonly
.d73f		4c 87 d7	jmp $d787	                jmp error
.d742						_interpret:
.d742		20 05 88	jsr $8805	                jsr xt_execute
.d745		4c ee d6	jmp $d6ee	                jmp _loop
.d748						_compile:
.d748		68		pla		                pla
.d749		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d74b		d0 f5		bne $d742	                bne _interpret          ; IMMEDIATE word, execute right now
.d74d		20 c3 96	jsr $96c3	                jsr xt_compile_comma
.d750		80 9c		bra $d6ee	                bra _loop
.d752						_line_done:
.d752		e8		inx		                inx
.d753		e8		inx		                inx
.d754		e8		inx		                inx
.d755		e8		inx		                inx
.d756		60		rts		                rts
.d757						is_printable:
.d757		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d759		90 08		bcc $d763	                bcc _done
.d75b		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d75d		b0 03		bcs $d762	                bcs _failed
.d75f		38		sec		                sec
.d760		80 01		bra $d763	                bra _done
.d762						_failed:
.d762		18		clc		                clc
.d763						_done:
.d763		60		rts		                rts
.d764						is_whitespace:
.d764		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d766		90 08		bcc $d770	                bcc _done
.d768		c9 21		cmp #$21	                cmp #AscSP+1
.d76a		b0 03		bcs $d76f	                bcs _failed
.d76c		38		sec		                sec
.d76d		80 01		bra $d770	                bra _done
.d76f						_failed:
.d76f		18		clc		                clc
.d770						_done:
.d770		60		rts		                rts
.d771						underflow_1:
.d771		e0 77		cpx #$77	                cpx #dsp0-1
.d773		10 10		bpl $d785	                bpl underflow_error
.d775		60		rts		                rts
.d776						underflow_2:
.d776		e0 75		cpx #$75	                cpx #dsp0-3
.d778		10 0b		bpl $d785	                bpl underflow_error
.d77a		60		rts		                rts
.d77b						underflow_3:
.d77b		e0 73		cpx #$73	                cpx #dsp0-5
.d77d		10 06		bpl $d785	                bpl underflow_error
.d77f		60		rts		                rts
.d780						underflow_4:
.d780		e0 71		cpx #$71	                cpx #dsp0-7
.d782		10 01		bpl $d785	                bpl underflow_error
.d784		60		rts		                rts
.d785						underflow_error:
.d785		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d787						error:
.d787		48		pha		                pha                     ; save error
.d788		20 c7 d7	jsr $d7c7	                jsr print_error
.d78b		20 3a 84	jsr $843a	                jsr xt_cr
.d78e		68		pla		                pla
.d78f		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d791		d0 17		bne $d7aa	                bne _no_underflow
.d793		a9 0d		lda #$0d	                lda #err_returnstack
.d795		20 c7 d7	jsr $d7c7	                jsr print_error
.d798		ba		tsx		                tsx
.d799						-
.d799		e8		inx		                inx
.d79a		f0 0b		beq $d7a7	                beq +
.d79c		20 c7 91	jsr $91c7	                jsr xt_space
.d79f		bd 00 01	lda $0100,x	                lda $100,x
.d7a2		20 3c d6	jsr $d63c	                jsr byte_to_ascii
.d7a5		80 f2		bra $d799	                bra -
.d7a7						+
.d7a7		20 3a 84	jsr $843a	                jsr xt_cr
.d7aa						_no_underflow:
.d7aa		4c 5e 80	jmp $805e	                jmp xt_abort            ; no jsr, as we clobber return stack
.d7ad						print_string_no_lf:
.d7ad		0a		asl a		                asl
.d7ae		a8		tay		                tay
.d7af		b9 bc d2	lda $d2bc,y	                lda string_table,y
.d7b2		85 29		sta $29		                sta tmp3                ; LSB
.d7b4		c8		iny		                iny
.d7b5		b9 bc d2	lda $d2bc,y	                lda string_table,y
.d7b8		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d7ba						print_common:
.d7ba		a0 00		ldy #$00	                ldy #0
.d7bc						_loop:
.d7bc		b1 29		lda ($29),y	                lda (tmp3),y
.d7be		f0 06		beq $d7c6	                beq _done               ; strings are zero-terminated
.d7c0		20 c5 86	jsr $86c5	                jsr emit_a              ; allows vectoring via output
.d7c3		c8		iny		                iny
.d7c4		80 f6		bra $d7bc	                bra _loop
.d7c6						_done:
.d7c6		60		rts		                rts
.d7c7						print_error:
.d7c7		0a		asl a		                asl
.d7c8		a8		tay		                tay
.d7c9		b9 a1 d3	lda $d3a1,y	                lda error_table,y
.d7cc		85 29		sta $29		                sta tmp3                ; LSB
.d7ce		c8		iny		                iny
.d7cf		b9 a1 d3	lda $d3a1,y	                lda error_table,y
.d7d2		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d7d4		20 ba d7	jsr $d7ba	                jsr print_common
.d7d7		60		rts		                rts
.d7d8						print_string:
.d7d8		20 ad d7	jsr $d7ad	                jsr print_string_no_lf
.d7db		4c 3a 84	jmp $843a	                jmp xt_cr               ; JSR/RTS because never compiled
.d7de						print_u:
.d7de		20 d8 9d	jsr $9dd8	                jsr xt_zero                     ; 0
.d7e1		20 cf 89	jsr $89cf	                jsr xt_less_number_sign         ; <#
.d7e4		20 af 8c	jsr $8caf	                jsr xt_number_sign_s            ; #S
.d7e7		20 8d 8c	jsr $8c8d	                jsr xt_number_sign_greater      ; #>
.d7ea		4c c0 94	jmp $94c0	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm


;******  Processing file: platform/simulator.asm

=$f000						io_start = $f000
>f000						                .byte ?
>f001						io_putc:        .byte ?     ; $f001     write byte to stdout
>f002						                .word ?
>f004						io_getc:        .byte ?     ; $f004     read byte from stdin
>f005						io_peekc:       .byte ?     ; $f005     non-blocking input
>f006						io_clk_start:   .byte ?     ; $f006     *read* to start cycle counter
>f007						io_clk_stop:    .byte ?     ; $f007     *read* to stop the cycle counter
>f008						io_clk_cycles:  .word ?,?   ; $f008-b   32-bit cycle count in NUXI order
>f00c						                .word ?,?
>f010						io_blk_action:  .byte ?     ; $f010     Write to act (status=0 read=1 write=2)
>f011						io_blk_status:  .byte ?     ; $f011     Read action result (OK=0)
>f012						io_blk_number:  .word ?     ; $f012     Little endian block number 0-ffff
>f014						io_blk_buffer:  .word ?     ; $f014     Little endian memory address
.f016						io_end:
.f016						kernel_init:
.f016		78		sei		                sei             ; Disable interrupts
.f017		a2 00		ldx #$00	                ldx #0
.f019		bd 32 f0	lda $f032,x	-               lda s_kernel_id,x
.f01c		f0 06		beq $f024	                beq _done
.f01e		20 2d f0	jsr $f02d	                jsr kernel_putc
.f021		e8		inx		                inx
.f022		80 f5		bra $f019	                bra -
.f024						_done:
.f024		4c 00 80	jmp $8000	                jmp forth
.f027						kernel_getc:
.f027						_loop:
.f027		ad 04 f0	lda $f004	                lda io_getc
.f02a		f0 fb		beq $f027	                beq _loop
.f02c		60		rts		                rts
.f02d						kernel_putc:
.f02d		8d 01 f0	sta $f001	                sta io_putc
.f030		60		rts		                rts
.f031						kernel_bye:
.f031		00		brk #		                brk

;******  Return to file: platform/platform-py65mon.asm

.f032						s_kernel_id:
>f032		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f03a		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f04a		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f05a		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		16 f0				v_nmi   .word kernel_init
>fffc		16 f0				v_reset .word kernel_init
>fffe		16 f0				v_irq   .word kernel_init

;******  End of listing
